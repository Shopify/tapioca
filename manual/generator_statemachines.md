## StateMachines

`Tapioca::Compilers::Dsl::StateMachines` generates RBI files for classes that setup a
[`state_machine`](https://github.com/state-machines/state_machines). The generator also
processes the extra methods generated by
[StateMachines Active Record](https://github.com/state-machines/state_machines-activerecord)
and [StateMachines ActiveModel](https://github.com/state-machines/state_machines-activemodel)
integrations.

For example, with the following `Vehicle` class:

~~~rb
class Vehicle
  state_machine :alarm_state, initial: :active, namespace: :'alarm' do
    event :enable do
      transition all => :active
    end

    event :disable do
      transition all => :off
    end

    state :active, :value => 1
    state :off, :value => 0
  end
end
~~~

this generator will produce the RBI file `vehicle.rbi` with the following content:

~~~rbi
# vehicle.rbi
# typed: true
class Vehicle
  include Vehicle::StateMachineInstanceHelperModule
  extend Vehicle::StateMachineClassHelperModule
end

module Vehicle::StateMachineClassHelperModule
  sig { params(event: T.any(String, Symbol)).returns(String) }
  def human_alarm_state_event_name(event); end

  sig { params(state: T.any(String, Symbol)).returns(String) }
  def human_alarm_state_name(state); end
end

module Vehicle::StateMachineInstanceHelperModule
  sig { returns(T::Boolean) }
  def alarm_active?; end

  sig { returns(T::Boolean) }
  def alarm_off?; end

  sig { returns(Integer) }
  def alarm_state; end

  sig { params(value: Integer).returns(Integer) }
  def alarm_state=(value); end

  sig { params(state: T.any(String, Symbol)).returns(T::Boolean) }
  def alarm_state?(state); end

  sig { params(args: T.untyped).returns(T::Array[T.any(String, Symbol)]) }
  def alarm_state_events(*args); end

  sig { returns(T.any(String, Symbol)) }
  def alarm_state_name; end

  sig { params(args: T.untyped).returns(T::Array[::StateMachines::Transition]) }
  def alarm_state_paths(*args); end

  sig { params(args: T.untyped).returns(T::Array[::StateMachines::Transition]) }
  def alarm_state_transitions(*args); end

  sig { returns(T::Boolean) }
  def can_disable_alarm?; end

  sig { returns(T::Boolean) }
  def can_enable_alarm?; end

  sig { params(args: T.untyped).returns(T::Boolean) }
  def disable_alarm(*args); end

  sig { params(args: T.untyped).returns(T::Boolean) }
  def disable_alarm!(*args); end

  sig { params(args: T.untyped).returns(T.nilable(::StateMachines::Transition)) }
  def disable_alarm_transition(*args); end

  sig { params(args: T.untyped).returns(T::Boolean) }
  def enable_alarm(*args); end

  sig { params(args: T.untyped).returns(T::Boolean) }
  def enable_alarm!(*args); end

  sig { params(args: T.untyped).returns(T.nilable(::StateMachines::Transition)) }
  def enable_alarm_transition(*args); end

  sig { params(event: T.any(String, Symbol), args: T.untyped).returns(T::Boolean) }
  def fire_alarm_state_event(event, *args); end

  sig { returns(String) }
  def human_alarm_state_name; end
end
~~~
