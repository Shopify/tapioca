# typed: strict
# frozen_string_literal: true

module Tapioca
  module Generators
    class Base
      extend(T::Sig)
      extend(T::Helpers)

      abstract!

      sig { returns(Pathname) }
      attr_reader :outpath

      sig { params(outpath: Pathname).void }
      def initialize(outpath:)
        @outpath = outpath
      end

      sig { abstract.void }
      def generate; end

      sig { abstract.params(error: String).void }
      def error_handler(error); end

      sig do
        params(
          command: String,
          file_header: T::Boolean,
          reason: T.nilable(String),
          strictness: T.nilable(String)
        ).returns(String)
      end
      def rbi_header(command, file_header: true, reason: nil, strictness: nil)
        statement = <<~HEAD
          # DO NOT EDIT MANUALLY
          # This is an autogenerated file for #{reason}.
          # Please instead update this file by running `#{command}`.
        HEAD

        sigil = <<~SIGIL if strictness
          # typed: #{strictness}
        SIGIL

        if file_header
          [statement, sigil].compact.join("\n").strip.concat("\n\n")
        elsif sigil
          sigil.strip.concat("\n\n")
        else
          ""
        end
      end

      sig { params(constant_name: String).returns(Pathname) }
      def dsl_rbi_filename(constant_name)
        outpath / "#{underscore(constant_name)}.rbi"
      end

      sig { params(constant_names: T::Array[String]).returns(T::Array[Module]) }
      def constantize(constant_names)
        constant_map = constant_names.map do |name|
          [name, Object.const_get(name)]
        rescue NameError
          [name, nil]
        end.to_h

        unprocessable_constants = constant_map.select { |_, v| v.nil? }
        unless unprocessable_constants.empty?
          unprocessable_constants.each do |name, _|
            remove(dsl_rbi_filename(name))
          end
        end

        constant_map.values
      end

      sig { params(requested_constants: T::Array[String], path: Pathname).returns(T::Set[Pathname]) }
      def existing_rbi_filenames(requested_constants, path: outpath)
        filenames = if requested_constants.empty?
          Pathname.glob(path / "**/*.rbi")
        else
          requested_constants.map do |constant_name|
            dsl_rbi_filename(constant_name)
          end
        end

        filenames.to_set
      end

      sig { params(filename: Pathname).void }
      def remove(filename)
        return unless filename.exist?
        filename.unlink
      end

      sig { params(class_name: String).returns(String) }
      def underscore(class_name)
        return class_name unless /[A-Z-]|::/.match?(class_name)

        word = class_name.to_s.gsub("::", "/")
        word.gsub!(/([A-Z\d]+)([A-Z][a-z])/, '\1_\2')
        word.gsub!(/([a-z\d])([A-Z])/, '\1_\2')
        word.tr!("-", "_")
        word.downcase!
        word
      end
    end
  end
end
