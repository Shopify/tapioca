# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activeresource` gem.
# Please instead update this file by running `bin/tapioca gem activeresource`.

# typed: true

module ActiveResource
  extend ::ActiveSupport::Autoload
end

module ActiveResource::Associations
  # Specifies a one-to-one association with another class. This class should only be used
  # if this class contains the foreign key.
  #
  # Methods will be added for retrieval and query for a single associated object, for which
  # this object holds an id:
  #
  # [association(force_reload = false)]
  # Returns the associated object. +nil+ is returned if the foreign key is +nil+.
  # Throws a ActiveResource::ResourceNotFound exception if the foreign key is not +nil+
  # and the resource is not found.
  #
  # (+association+ is replaced with the symbol passed as the first argument, so
  # <tt>belongs_to :post</tt> would add among others <tt>post.nil?</tt>.
  #
  # === Example
  #
  # A Comment class declares <tt>belongs_to :post</tt>, which will add:
  # * <tt>Comment#post</tt> (similar to <tt>Post.find(post_id)</tt>)
  # The declaration can also include an options hash to specialize the behavior of the association.
  #
  # === Options
  # [:class_name]
  # Specify the class name for the association. Use it only if that name can't be inferred from association name.
  # So <tt>belongs_to :post</tt> will by default be linked to the Post class, but if the real class name is Article,
  # you'll have to specify it with this option.
  # [:foreign_key]
  # Specify the foreign key used for the association. By default this is guessed to be the name
  # of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :post</tt>
  # association will use "post_id" as the default <tt>:foreign_key</tt>. Similarly,
  # <tt>belongs_to :article, :class_name => "Post"</tt> will use a foreign key
  # of "article_id".
  #
  # Option examples:
  # <tt>belongs_to :customer, :class_name => 'User'</tt>
  # Creates a belongs_to association called customer which is represented through the <tt>User</tt> class.
  #
  # <tt>belongs_to :customer, :foreign_key => 'user_id'</tt>
  # Creates a belongs_to association called customer which would be resolved by the foreign_key <tt>user_id</tt> instead of <tt>customer_id</tt>
  def belongs_to(name, options = T.unsafe(nil)); end

  # Defines the belongs_to association finder method
  def defines_belongs_to_finder_method(reflection); end

  def defines_has_many_finder_method(reflection); end

  # Defines the has_one association
  def defines_has_one_finder_method(reflection); end

  # Specifies a one-to-many association.
  #
  # === Options
  # [:class_name]
  # Specify the class name of the association. This class name would
  # be used for resolving the association class.
  #
  # ==== Example for [:class_name] - option
  # GET /posts/123.json delivers following response body:
  # {
  # title: "ActiveResource now has associations",
  # body: "Lorem Ipsum"
  # comments: [
  # {
  # content: "..."
  # },
  # {
  # content: "..."
  # }
  # ]
  # }
  # ====
  #
  # <tt>has_many :comments, :class_name => 'myblog/comment'</tt>
  # Would resolve those comments into the <tt>Myblog::Comment</tt> class.
  #
  # If the response body does not contain an attribute matching the association name
  # a request sent to the index action under the current resource.
  # For the example above, if the comments are not present the requested path would be:
  # GET /posts/123/comments.xml
  def has_many(name, options = T.unsafe(nil)); end

  # Specifies a one-to-one association.
  #
  # === Options
  # [:class_name]
  # Specify the class name of the association. This class name would
  # be used for resolving the association class.
  #
  # ==== Example for [:class_name] - option
  # GET /posts/1.json delivers following response body:
  # {
  # title: "ActiveResource now has associations",
  # body: "Lorem Ipsum",
  # author: {
  # name: "Gabby Blogger",
  # }
  # }
  # ====
  #
  # <tt>has_one :author, :class_name => 'myblog/author'</tt>
  # Would resolve this author into the <tt>Myblog::Author</tt> class.
  #
  # If the response body does not contain an attribute matching the association name
  # a request is sent to a singleton path under the current resource.
  # For example, if a Product class <tt>has_one :inventory</tt> calling <tt>Product#inventory</tt>
  # will generate a request on /products/:product_id/inventory.json.
  def has_one(name, options = T.unsafe(nil)); end
end

module ActiveResource::Associations::Builder; end

class ActiveResource::Associations::Builder::Association
  def initialize(model, name, options); end

  def build; end

  # Returns the value of attribute klass.
  def klass; end

  def macro; end
  def macro=(_arg0); end
  def macro?; end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute options.
  def options; end

  def valid_options; end
  def valid_options=(_arg0); end
  def valid_options?; end

  private

  def validate_options; end

  class << self
    def build(model, name, options); end
    def macro; end
    def macro=(value); end
    def macro?; end
    def valid_options; end
    def valid_options=(value); end
    def valid_options?; end
  end
end

class ActiveResource::Associations::Builder::BelongsTo < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
    def valid_options; end
  end
end

class ActiveResource::Associations::Builder::HasMany < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
  end
end

class ActiveResource::Associations::Builder::HasOne < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
  end
end

# 400 Bad Request
class ActiveResource::BadRequest < ::ActiveResource::ClientError; end

# ActiveResource::Base is the main class for mapping RESTful resources as models in a Rails application.
#
# For an outline of what Active Resource is capable of, see its {README}[link:files/activeresource/README_rdoc.html].
#
# == Automated mapping
#
# Active Resource objects represent your RESTful resources as manipulatable Ruby objects. To map resources
# to Ruby objects, Active Resource only needs a class name that corresponds to the resource name (e.g., the class
# Person maps to the resources people, very similarly to Active Record) and a +site+ value, which holds the
# URI of the resources.
#
# class Person < ActiveResource::Base
# self.site = "https://api.people.com"
# end
#
# Now the Person class is mapped to RESTful resources located at <tt>https://api.people.com/people/</tt>, and
# you can now use Active Resource's life cycle methods to manipulate resources. In the case where you already have
# an existing model with the same name as the desired RESTful resource you can set the +element_name+ value.
#
# class PersonResource < ActiveResource::Base
# self.site = "https://api.people.com"
# self.element_name = "person"
# end
#
# If your Active Resource object is required to use an HTTP proxy you can set the +proxy+ value which holds a URI.
#
# class PersonResource < ActiveResource::Base
# self.site = "https://api.people.com"
# self.proxy = "https://user:password@proxy.people.com:8080"
# end
#
#
# == Life cycle methods
#
# Active Resource exposes methods for creating, finding, updating, and deleting resources
# from REST web services.
#
# ryan = Person.new(:first => 'Ryan', :last => 'Daigle')
# ryan.save                # => true
# ryan.id                  # => 2
# Person.exists?(ryan.id)  # => true
# ryan.exists?             # => true
#
# ryan = Person.find(1)
# # Resource holding our newly created Person object
#
# ryan.first = 'Rizzle'
# ryan.save                # => true
#
# ryan.destroy             # => true
#
# As you can see, these are very similar to Active Record's life cycle methods for database records.
# You can read more about each of these methods in their respective documentation.
#
# === Custom REST methods
#
# Since simple CRUD/life cycle methods can't accomplish every task, Active Resource also supports
# defining your own custom REST methods. To invoke them, Active Resource provides the <tt>get</tt>,
# <tt>post</tt>, <tt>put</tt> and <tt>delete</tt> methods where you can specify a custom REST method
# name to invoke.
#
# # POST to the custom 'register' REST method, i.e. POST /people/new/register.json.
# Person.new(:name => 'Ryan').post(:register)
# # => { :id => 1, :name => 'Ryan', :position => 'Clerk' }
#
# # PUT an update by invoking the 'promote' REST method, i.e. PUT /people/1/promote.json?position=Manager.
# Person.find(1).put(:promote, :position => 'Manager')
# # => { :id => 1, :name => 'Ryan', :position => 'Manager' }
#
# # GET all the positions available, i.e. GET /people/positions.json.
# Person.get(:positions)
# # => [{:name => 'Manager'}, {:name => 'Clerk'}]
#
# # DELETE to 'fire' a person, i.e. DELETE /people/1/fire.json.
# Person.find(1).delete(:fire)
#
# For more information on using custom REST methods, see the
# ActiveResource::CustomMethods documentation.
#
# == Validations
#
# You can validate resources client side by overriding validation methods in the base class.
#
# class Person < ActiveResource::Base
# self.site = "https://api.people.com"
# protected
# def validate
# errors.add("last", "has invalid characters") unless last =~ /[a-zA-Z]*/
# end
# end
#
# See the ActiveResource::Validations documentation for more information.
#
# == Authentication
#
# Many REST APIs require authentication. The HTTP spec describes two ways to
# make requests with a username and password (see RFC 2617).
#
# Basic authentication simply sends a username and password along with HTTP
# requests. These sensitive credentials are sent unencrypted, visible to
# any onlooker, so this scheme should only be used with SSL.
#
# Digest authentication sends a crytographic hash of the username, password,
# HTTP method, URI, and a single-use secret key provided by the server.
# Sensitive credentials aren't visible to onlookers, so digest authentication
# doesn't require SSL. However, this doesn't mean the connection is secure!
# Just the username and password.
#
# (You really, really want to use SSL. There's little reason not to.)
#
# === Picking an authentication scheme
#
# Basic authentication is the default. To switch to digest authentication,
# set +auth_type+ to +:digest+:
#
# class Person < ActiveResource::Base
# self.auth_type = :digest
# end
#
# === Setting the username and password
#
# Set +user+ and +password+ on the class, or include them in the +site+ URL.
#
# class Person < ActiveResource::Base
# # Set user and password directly:
# self.user = "ryan"
# self.password = "password"
#
# # Or include them in the site:
# self.site = "https://ryan:password@api.people.com"
# end
#
# === Certificate Authentication
#
# You can also authenticate using an X509 certificate. <tt>See ssl_options=</tt> for all options.
#
# class Person < ActiveResource::Base
# self.site = "https://secure.api.people.com/"
#
# File.open(pem_file_path, 'rb') do |pem_file|
# self.ssl_options = {
# cert:        OpenSSL::X509::Certificate.new(pem_file),
# key:         OpenSSL::PKey::RSA.new(pem_file),
# ca_path:     "/path/to/OpenSSL/formatted/CA_Certs",
# verify_mode: OpenSSL::SSL::VERIFY_PEER }
# end
# end
#
#
# == Errors & Validation
#
# Error handling and validation is handled in much the same manner as you're used to seeing in
# Active Record. Both the response code in the HTTP response and the body of the response are used to
# indicate that an error occurred.
#
# === Resource errors
#
# When a GET is requested for a resource that does not exist, the HTTP <tt>404</tt> (Resource Not Found)
# response code will be returned from the server which will raise an ActiveResource::ResourceNotFound
# exception.
#
# # GET https://api.people.com/people/999.json
# ryan = Person.find(999) # 404, raises ActiveResource::ResourceNotFound
#
#
# <tt>404</tt> is just one of the HTTP error response codes that Active Resource will handle with its own exception. The
# following HTTP response codes will also result in these exceptions:
#
# * 200..399 - Valid response. No exceptions, other than these redirects:
# * 301, 302, 303, 307 - ActiveResource::Redirection
# * 400 - ActiveResource::BadRequest
# * 401 - ActiveResource::UnauthorizedAccess
# * 403 - ActiveResource::ForbiddenAccess
# * 404 - ActiveResource::ResourceNotFound
# * 405 - ActiveResource::MethodNotAllowed
# * 409 - ActiveResource::ResourceConflict
# * 410 - ActiveResource::ResourceGone
# * 422 - ActiveResource::ResourceInvalid (rescued by save as validation errors)
# * 401..499 - ActiveResource::ClientError
# * 500..599 - ActiveResource::ServerError
# * Other - ActiveResource::ConnectionError
#
# These custom exceptions allow you to deal with resource errors more naturally and with more precision
# rather than returning a general HTTP error. For example:
#
# begin
# ryan = Person.find(my_id)
# rescue ActiveResource::ResourceNotFound
# redirect_to :action => 'not_found'
# rescue ActiveResource::ResourceConflict, ActiveResource::ResourceInvalid
# redirect_to :action => 'new'
# end
#
# When a GET is requested for a nested resource and you don't provide the prefix_param
# an ActiveResource::MissingPrefixParam will be raised.
#
# class Comment < ActiveResource::Base
# self.site = "https://someip.com/posts/:post_id"
# end
#
# Comment.find(1)
# # => ActiveResource::MissingPrefixParam: post_id prefix_option is missing
#
# === Validation errors
#
# Active Resource supports validations on resources and will return errors if any of these validations fail
# (e.g., "First name can not be blank" and so on). These types of errors are denoted in the response by
# a response code of <tt>422</tt> and an JSON or XML representation of the validation errors. The save operation will
# then fail (with a <tt>false</tt> return value) and the validation errors can be accessed on the resource in question.
#
# ryan = Person.find(1)
# ryan.first # => ''
# ryan.save  # => false
#
# # When
# # PUT https://api.people.com/people/1.xml
# # or
# # PUT https://api.people.com/people/1.json
# # is requested with invalid values, the response is:
# #
# # Response (422):
# # <errors><error>First cannot be empty</error></errors>
# # or
# # {"errors":{"first":["cannot be empty"]}}
# #
#
# ryan.errors.invalid?(:first)  # => true
# ryan.errors.full_messages     # => ['First cannot be empty']
#
# For backwards-compatibility with older endpoints, the following formats are also supported in JSON responses:
#
# # {"errors":['First cannot be empty']}
# #   This was the required format for previous versions of ActiveResource
# # {"first":["cannot be empty"]}
# #   This was the default format produced by respond_with in ActionController <3.2.1
#
# Parsing either of these formats will result in a deprecation warning.
#
# Learn more about Active Resource's validation features in the ActiveResource::Validations documentation.
#
# === Timeouts
#
# Active Resource relies on HTTP to access RESTful APIs and as such is inherently susceptible to slow or
# unresponsive servers. In such cases, your Active Resource method calls could \timeout. You can control the
# amount of time before Active Resource times out with the +timeout+ variable.
#
# class Person < ActiveResource::Base
# self.site = "https://api.people.com"
# self.timeout = 5
# end
#
# This sets the +timeout+ to 5 seconds. You can adjust the +timeout+ to a value suitable for the RESTful API
# you are accessing. It is recommended to set this to a reasonably low value to allow your Active Resource
# clients (especially if you are using Active Resource in a Rails application) to fail-fast (see
# http://en.wikipedia.org/wiki/Fail-fast) rather than cause cascading failures that could incapacitate your
# server.
#
# When a \timeout occurs, an ActiveResource::TimeoutError is raised. You should rescue from
# ActiveResource::TimeoutError in your Active Resource method calls.
#
# Internally, Active Resource relies on Ruby's Net::HTTP library to make HTTP requests. Setting +timeout+
# sets the <tt>read_timeout</tt> of the internal Net::HTTP instance to the same value. The default
# <tt>read_timeout</tt> is 60 seconds on most Ruby implementations.
#
# Active Resource also supports distinct +open_timeout+ (time to connect) and +read_timeout+ (how long to
# wait for an upstream response). This is inline with supported +Net::HTTP+ timeout configuration and allows
# for finer control of client timeouts depending on context.
#
# class Person < ActiveResource::Base
# self.site = "https://api.people.com"
# self.open_timeout = 2
# self.read_timeout = 10
# end
class ActiveResource::Base
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveResource::Validations
  include ::ActiveResource::CustomMethods
  include ::ActiveResource::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::Conversion
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serializers::Xml
  include ::ActiveResource::Reflection
  extend ::ThreadsafeAttributes
  extend ::ActiveModel::Naming
  extend ::ActiveResource::Associations
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveResource::CustomMethods::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveResource::Reflection::ClassMethods

  # Constructor method for \new resources; the optional +attributes+ parameter takes a \hash
  # of attributes for the \new resource.
  #
  # ==== Examples
  # my_course = Course.new
  # my_course.name = "Western Civilization"
  # my_course.lecturer = "Don Trotter"
  # my_course.save
  #
  # my_other_course = Course.new(:name => "Philosophy: Reason and Being", :lecturer => "Ralph Cling")
  # my_other_course.save
  def initialize(attributes = T.unsafe(nil), persisted = T.unsafe(nil)); end

  # Test for equality. Resource are equal if and only if +other+ is the same object or
  # is an instance of the same class, is not <tt>new?</tt>, and has the same +id+.
  #
  # ==== Examples
  # ryan = Person.create(:name => 'Ryan')
  # jamie = Person.create(:name => 'Jamie')
  #
  # ryan == jamie
  # # => false (Different name attribute and id)
  #
  # ryan_again = Person.new(:name => 'Ryan')
  # ryan == ryan_again
  # # => false (ryan_again is new?)
  #
  # ryans_clone = Person.create(:name => 'Ryan')
  # ryan == ryans_clone
  # # => false (Different id attributes)
  #
  # ryans_twin = Person.find(ryan.id)
  # ryan == ryans_twin
  # # => true
  def ==(other); end

  def __callbacks; end
  def __callbacks?; end
  def _collection_parser; end
  def _collection_parser=(_arg0); end
  def _collection_parser?; end
  def _create_callbacks; end
  def _destroy_callbacks; end
  def _format; end
  def _format=(_arg0); end
  def _format?; end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _update_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def attributes; end
  def attributes=(_arg0); end

  # Returns a \clone of the resource that hasn't been assigned an +id+ yet and
  # is treated as a \new resource.
  #
  # ryan = Person.find(1)
  # not_ryan = ryan.clone
  # not_ryan.new?  # => true
  #
  # Any active resource member attributes will NOT be cloned, though all other
  # attributes are. This is to prevent the conflict between any +prefix_options+
  # that refer to the original parent resource and the newly cloned parent
  # resource that does not exist.
  #
  # ryan = Person.find(1)
  # ryan.address = StreetAddress.find(1, :person_id => ryan.id)
  # ryan.hash = {:not => "an ARes instance"}
  #
  # not_ryan = ryan.clone
  # not_ryan.new?            # => true
  # not_ryan.address         # => NoMethodError
  # not_ryan.hash            # => {:not => "an ARes instance"}
  def clone; end

  def connection_class; end
  def connection_class=(_arg0); end
  def connection_class?; end

  # Deletes the resource from the remote service.
  #
  # ==== Examples
  # my_id = 3
  # my_person = Person.find(my_id)
  # my_person.destroy
  # Person.find(my_id) # 404 (Resource Not Found)
  #
  # new_person = Person.create(:name => 'James')
  # new_id = new_person.id # => 7
  # new_person.destroy
  # Person.find(new_id) # 404 (Resource Not Found)
  def destroy; end

  # Duplicates the current resource without saving it.
  #
  # ==== Examples
  # my_invoice = Invoice.create(:customer => 'That Company')
  # next_invoice = my_invoice.dup
  # next_invoice.new? # => true
  #
  # next_invoice.save
  # next_invoice == my_invoice # => false (different id attributes)
  #
  # my_invoice.customer   # => That Company
  # next_invoice.customer # => That Company
  def dup; end

  # Returns the serialized string representation of the resource in the configured
  # serialization format specified in ActiveResource::Base.format. The options
  # applicable depend on the configured encoding format.
  def encode(options = T.unsafe(nil)); end

  # Tests for equality (delegates to ==).
  def eql?(other); end

  # Evaluates to <tt>true</tt> if this resource is not <tt>new?</tt> and is
  # found on the remote service. Using this method, you can check for
  # resources that may have been deleted between the object's instantiation
  # and actions on it.
  #
  # ==== Examples
  # Person.create(:name => 'Theodore Roosevelt')
  # that_guy = Person.find(:first)
  # that_guy.exists? # => true
  #
  # that_lady = Person.new(:name => 'Paul Bean')
  # that_lady.exists? # => false
  #
  # guys_id = that_guy.id
  # Person.delete(guys_id)
  # that_guy.exists? # => false
  def exists?; end

  # Delegates to id in order to allow two resources of the same type and \id to work with something like:
  # [(a = Person.find 1), (b = Person.find 2)] & [(c = Person.find 1), (d = Person.find 4)] # => [a]
  def hash; end

  # Gets the <tt>\id</tt> attribute of the resource.
  def id; end

  # Sets the <tt>\id</tt> attribute of the resource.
  def id=(id); end

  def include_format_in_path; end
  def include_format_in_path=(_arg0); end
  def include_format_in_path?; end
  def include_root_in_json; end
  def include_root_in_json?; end

  # This is a list of known attributes for this resource. Either
  # gathered from the provided <tt>schema</tt>, or from the attributes
  # set on this instance after it has been fetched from the remote system.
  def known_attributes; end

  # A method to manually load attributes from a \hash. Recursively loads collections of
  # resources. This method is called in +initialize+ and +create+ when a \hash of attributes
  # is provided.
  #
  # ==== Examples
  # my_attrs = {:name => 'J&J Textiles', :industry => 'Cloth and textiles'}
  # my_attrs = {:name => 'Marty', :colors => ["red", "green", "blue"]}
  #
  # the_supplier = Supplier.find(:first)
  # the_supplier.name # => 'J&M Textiles'
  # the_supplier.load(my_attrs)
  # the_supplier.name('J&J Textiles')
  #
  # # These two calls are the same as Supplier.new(my_attrs)
  # my_supplier = Supplier.new
  # my_supplier.load(my_attrs)
  #
  # # These three calls are the same as Supplier.create(my_attrs)
  # your_supplier = Supplier.new
  # your_supplier.load(my_attrs)
  # your_supplier.save
  def load(attributes, remove_root = T.unsafe(nil), persisted = T.unsafe(nil)); end

  # :singleton-method:
  # The logger for diagnosing and tracing Active Resource calls.
  def logger; end

  def model_name(*_arg0, &_arg1); end

  # Returns +true+ if this object hasn't yet been saved, otherwise, returns +false+.
  #
  # ==== Examples
  # not_new = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  # not_new.new? # => false
  #
  # is_new = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  # is_new.new? # => true
  #
  # is_new.save
  # is_new.new? # => false
  def new?; end

  # Returns +true+ if this object hasn't yet been saved, otherwise, returns +false+.
  #
  # ==== Examples
  # not_new = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  # not_new.new? # => false
  #
  # is_new = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  # is_new.new? # => true
  #
  # is_new.save
  # is_new.new? # => false
  def new_record?; end

  # Returns +true+ if this object has been saved, otherwise returns +false+.
  #
  # ==== Examples
  # persisted = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  # persisted.persisted? # => true
  #
  # not_persisted = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  # not_persisted.persisted? # => false
  #
  # not_persisted.save
  # not_persisted.persisted? # => true
  def persisted?; end

  def prefix_options; end
  def prefix_options=(_arg0); end
  def read_attribute_for_serialization(n); end
  def reflections; end
  def reflections=(_arg0); end
  def reflections?; end

  # A method to \reload the attributes of this object from the remote web service.
  #
  # ==== Examples
  # my_branch = Branch.find(:first)
  # my_branch.name # => "Wislon Raod"
  #
  # # Another client fixes the typo...
  #
  # my_branch.name # => "Wislon Raod"
  # my_branch.reload
  # my_branch.name # => "Wilson Road"
  def reload; end

  # For checking <tt>respond_to?</tt> without searching the attributes (which is faster).
  def respond_to_without_attributes?(*_arg0); end

  # Saves (+POST+) or \updates (+PUT+) a resource. Delegates to +create+ if the object is \new,
  # +update+ if it exists. If the response to the \save includes a body, it will be assumed that this body
  # is Json for the final object as it looked after the \save (which would include attributes like +created_at+
  # that weren't part of the original submit).
  #
  # ==== Examples
  # my_company = Company.new(:name => 'RoleModel Software', :owner => 'Ken Auer', :size => 2)
  # my_company.new? # => true
  # my_company.save # sends POST /companies/ (create)
  #
  # my_company.new? # => false
  # my_company.size = 10
  # my_company.save # sends PUT /companies/1 (update)
  def save(options = T.unsafe(nil)); end

  # Saves the resource.
  #
  # If the resource is new, it is created via +POST+, otherwise the
  # existing resource is updated via +PUT+.
  #
  # With <tt>save!</tt> validations always run. If any of them fail
  # ActiveResource::ResourceInvalid gets raised, and nothing is POSTed to
  # the remote system.
  # See ActiveResource::Validations for more information.
  #
  # There's a series of callbacks associated with <tt>save!</tt>. If any
  # of the <tt>before_*</tt> callbacks return +false+ the action is
  # cancelled and <tt>save!</tt> raises ActiveResource::ResourceInvalid.
  def save!; end

  def save_without_validation; end

  # If no schema has been defined for the class (see
  # <tt>ActiveResource::schema=</tt>), the default automatic schema is
  # generated from the current instance's attributes
  def schema; end

  def to_json(options = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end

  # Updates a single attribute and then saves the object.
  #
  # Note: <tt>Unlike ActiveRecord::Base.update_attribute</tt>, this method <b>is</b>
  # subject to normal validation routines as an update sends the whole body
  # of the resource in the request. (See Validations).
  #
  # As such, this method is equivalent to calling update_attributes with a single attribute/value pair.
  #
  # If the saving fails because of a connection or remote service error, an
  # exception will be raised. If saving fails because the resource is
  # invalid then <tt>false</tt> will be returned.
  def update_attribute(name, value); end

  # Updates this resource with all the attributes from the passed-in Hash
  # and requests that the record be saved.
  #
  # If the saving fails because of a connection or remote service error, an
  # exception will be raised. If saving fails because the resource is
  # invalid then <tt>false</tt> will be returned.
  #
  # Note: Though this request can be made with a partial set of the
  # resource's attributes, the full body of the request will still be sent
  # in the save request to the remote service.
  def update_attributes(attributes); end

  def validation_context; end

  protected

  def collection_path(options = T.unsafe(nil)); end
  def connection(refresh = T.unsafe(nil)); end

  # Create (i.e., \save to the remote service) the \new resource.
  def create; end

  def element_path(options = T.unsafe(nil)); end
  def element_url(options = T.unsafe(nil)); end

  # Takes a response from a typical create post and pulls the ID out
  def id_from_response(response); end

  def load_attributes_from_response(response); end
  def new_element_path; end

  # Update the resource on the remote service.
  def update; end

  private

  def const_valid?(*const_args); end

  # Create and return a class definition for a resource inside the current resource
  def create_resource_for(resource_name); end

  # Tries to find a resource for a given name; if it fails, then the resource is created
  def find_or_create_resource_for(name); end

  # Tries to find a resource for a given collection name; if it fails, then the resource is created
  def find_or_create_resource_for_collection(name); end

  # Tries to find a resource in a non empty list of nested modules
  # if it fails, then the resource is created
  def find_or_create_resource_in_modules(resource_name, module_names); end

  def method_missing(method_symbol, *arguments); end

  # A method to determine if an object responds to a message (e.g., a method call). In Active Resource, a Person object with a
  # +name+ attribute can answer <tt>true</tt> to <tt>my_person.respond_to?(:name)</tt>, <tt>my_person.respond_to?(:name=)</tt>, and
  # <tt>my_person.respond_to?(:name?)</tt>.
  def respond_to_missing?(method, include_priv = T.unsafe(nil)); end

  # Determine whether the response is allowed to have a body per HTTP 1.1 spec section 4.4.1
  def response_code_allows_body?(c); end

  def split_options(options = T.unsafe(nil)); end
  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _collection_parser; end
    def _collection_parser=(value); end
    def _collection_parser?; end
    def _connection; end
    def _connection=(value); end
    def _connection_defined?; end
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _format; end
    def _format=(value); end
    def _format?; end
    def _headers; end
    def _headers=(value); end
    def _headers_defined?; end
    def _password; end
    def _password=(value); end
    def _password_defined?; end
    def _proxy; end
    def _proxy=(value); end
    def _proxy_defined?; end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _site; end
    def _site=(value); end
    def _site_defined?; end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _user; end
    def _user=(value); end
    def _user_defined?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def after_create(*args, **options, &block); end
    def after_destroy(*args, **options, &block); end
    def after_save(*args, **options, &block); end
    def after_update(*args, **options, &block); end

    # This is an alias for find(:all). You can pass in all the same
    # arguments to this method as you can to <tt>find(:all)</tt>
    def all(*args); end

    def around_create(*args, **options, &block); end
    def around_destroy(*args, **options, &block); end
    def around_save(*args, **options, &block); end
    def around_update(*args, **options, &block); end
    def auth_type; end
    def auth_type=(auth_type); end
    def before_create(*args, **options, &block); end
    def before_destroy(*args, **options, &block); end
    def before_save(*args, **options, &block); end
    def before_update(*args, **options, &block); end

    # Builds a new, unsaved record using the default values from the remote server so
    # that it can be used with RESTful forms.
    #
    # ==== Options
    # * +attributes+ - A hash that overrides the default values from the server.
    #
    # Returns the new resource instance.
    def build(attributes = T.unsafe(nil)); end

    def collection_name; end

    # Sets the attribute collection_name
    def collection_name=(_arg0); end

    def collection_parser; end

    # Sets the parser to use when a collection is returned.  The parser must be Enumerable.
    def collection_parser=(parser_instance); end

    # Gets the collection path for the REST resources. If the +query_options+ parameter is omitted, Rails
    # will split from the +prefix_options+.
    #
    # ==== Options
    # * +prefix_options+ - A hash to add a prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>/accounts/19/purchases.json</tt>).
    # * +query_options+ - A hash to add items to the query string for the request.
    #
    # ==== Examples
    # Post.collection_path
    # # => /posts.json
    #
    # Comment.collection_path(:post_id => 5)
    # # => /posts/5/comments.json
    #
    # Comment.collection_path(:post_id => 5, :active => 1)
    # # => /posts/5/comments.json?active=1
    #
    # Comment.collection_path({:post_id => 5}, {:active => 1})
    # # => /posts/5/comments.json?active=1
    def collection_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # An instance of ActiveResource::Connection that is the base \connection to the remote service.
    # The +refresh+ parameter toggles whether or not the \connection is refreshed at every request
    # or not (defaults to <tt>false</tt>).
    def connection(refresh = T.unsafe(nil)); end

    def connection_class; end
    def connection_class=(value); end
    def connection_class?; end

    # Creates a new resource instance and makes a request to the remote service
    # that it be saved, making it equivalent to the following simultaneous calls:
    #
    # ryan = Person.new(:first => 'ryan')
    # ryan.save
    #
    # Returns the newly created resource. If a failure has occurred an
    # exception will be raised (see <tt>save</tt>). If the resource is invalid and
    # has not been saved then <tt>valid?</tt> will return <tt>false</tt>,
    # while <tt>new?</tt> will still return <tt>true</tt>.
    #
    # ==== Examples
    # Person.create(:name => 'Jeremy', :email => 'myname@nospam.com', :enabled => true)
    # my_person = Person.find(:first)
    # my_person.email # => myname@nospam.com
    #
    # dhh = Person.create(:name => 'David', :email => 'dhh@nospam.com', :enabled => true)
    # dhh.valid? # => true
    # dhh.new?   # => false
    #
    # # We'll assume that there's a validation that requires the name attribute
    # that_guy = Person.create(:name => '', :email => 'thatguy@nospam.com', :enabled => true)
    # that_guy.valid? # => false
    # that_guy.new?   # => true
    def create(attributes = T.unsafe(nil)); end

    # Creates a new resource (just like <tt>create</tt>) and makes a request to the
    # remote service that it be saved, but runs validations and raises
    # <tt>ActiveResource::ResourceInvalid</tt>, making it equivalent to the following
    # simultaneous calls:
    #
    # ryan = Person.new(:first => 'ryan')
    # ryan.save!
    def create!(attributes = T.unsafe(nil)); end

    # Deletes the resources with the ID in the +id+ parameter.
    #
    # ==== Options
    # All options specify \prefix and query parameters.
    #
    # ==== Examples
    # Event.delete(2) # sends DELETE /events/2
    #
    # Event.create(:name => 'Free Concert', :location => 'Community Center')
    # my_event = Event.find(:first) # let's assume this is event with ID 7
    # Event.delete(my_event.id) # sends DELETE /events/7
    #
    # # Let's assume a request to events/5/cancel.json
    # Event.delete(params[:id]) # sends DELETE /events/5
    def delete(custom_method_name, options = T.unsafe(nil)); end

    def element_name; end

    # Sets the attribute element_name
    def element_name=(_arg0); end

    # Gets the element path for the given ID in +id+. If the +query_options+ parameter is omitted, Rails
    # will split from the \prefix options.
    #
    # ==== Options
    # +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>/accounts/19/purchases.json</tt>).
    #
    # +query_options+ - A \hash to add items to the query string for the request.
    #
    # ==== Examples
    # Post.element_path(1)
    # # => /posts/1.json
    #
    # class Comment < ActiveResource::Base
    # self.site = "https://37s.sunrise.com/posts/:post_id"
    # end
    #
    # Comment.element_path(1, :post_id => 5)
    # # => /posts/5/comments/1.json
    #
    # Comment.element_path(1, :post_id => 5, :active => 1)
    # # => /posts/5/comments/1.json?active=1
    #
    # Comment.element_path(1, {:post_id => 5}, {:active => 1})
    # # => /posts/5/comments/1.json?active=1
    def element_path(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # Gets the element url for the given ID in +id+. If the +query_options+ parameter is omitted, Rails
    # will split from the \prefix options.
    #
    # ==== Options
    # +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>https://37s.sunrise.com/accounts/19/purchases.json</tt>).
    #
    # +query_options+ - A \hash to add items to the query string for the request.
    #
    # ==== Examples
    # Post.element_url(1)
    # # => https://37s.sunrise.com/posts/1.json
    #
    # class Comment < ActiveResource::Base
    # self.site = "https://37s.sunrise.com/posts/:post_id"
    # end
    #
    # Comment.element_url(1, :post_id => 5)
    # # => https://37s.sunrise.com/posts/5/comments/1.json
    #
    # Comment.element_url(1, :post_id => 5, :active => 1)
    # # => https://37s.sunrise.com/posts/5/comments/1.json?active=1
    #
    # Comment.element_url(1, {:post_id => 5}, {:active => 1})
    # # => https://37s.sunrise.com/posts/5/comments/1.json?active=1
    def element_url(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # Asserts the existence of a resource, returning <tt>true</tt> if the resource is found.
    #
    # ==== Examples
    # Note.create(:title => 'Hello, world.', :body => 'Nothing more for now...')
    # Note.exists?(1) # => true
    #
    # Note.exists(1349) # => false
    def exists?(id, options = T.unsafe(nil)); end

    # Core method for finding resources. Used similarly to Active Record's +find+ method.
    #
    # ==== Arguments
    # The first argument is considered to be the scope of the query. That is, how many
    # resources are returned from the request. It can be one of the following.
    #
    # * <tt>:one</tt> - Returns a single resource.
    # * <tt>:first</tt> - Returns the first resource found.
    # * <tt>:last</tt> - Returns the last resource found.
    # * <tt>:all</tt> - Returns every resource that matches the request.
    #
    # ==== Options
    #
    # * <tt>:from</tt> - Sets the path or custom method that resources will be fetched from.
    # * <tt>:params</tt> - Sets query and \prefix (nested URL) parameters.
    #
    # ==== Examples
    # Person.find(1)
    # # => GET /people/1.json
    #
    # Person.find(:all)
    # # => GET /people.json
    #
    # Person.find(:all, :params => { :title => "CEO" })
    # # => GET /people.json?title=CEO
    #
    # Person.find(:first, :from => :managers)
    # # => GET /people/managers.json
    #
    # Person.find(:last, :from => :managers)
    # # => GET /people/managers.json
    #
    # Person.find(:all, :from => "/companies/1/people.json")
    # # => GET /companies/1/people.json
    #
    # Person.find(:one, :from => :leader)
    # # => GET /people/leader.json
    #
    # Person.find(:all, :from => :developers, :params => { :language => 'ruby' })
    # # => GET /people/developers.json?language=ruby
    #
    # Person.find(:one, :from => "/companies/1/manager.json")
    # # => GET /companies/1/manager.json
    #
    # StreetAddress.find(1, :params => { :person_id => 1 })
    # # => GET /people/1/street_addresses/1.json
    #
    # == Failure or missing data
    # A failure to find the requested object raises a ResourceNotFound
    # exception if the find was called with an id.
    # With any other scope, find returns nil when no data is returned.
    #
    # Person.find(1)
    # # => raises ResourceNotFound
    #
    # Person.find(:all)
    # Person.find(:first)
    # Person.find(:last)
    # # => nil
    def find(*arguments); end

    # A convenience wrapper for <tt>find(:first, *args)</tt>. You can pass
    # in all the same arguments to this method as you can to
    # <tt>find(:first)</tt>.
    def first(*args); end

    # Returns the current format, default is ActiveResource::Formats::JsonFormat.
    def format; end

    # Sets the format that attributes are sent and received in from a mime type reference:
    #
    # Person.format = :json
    # Person.find(1) # => GET /people/1.json
    #
    # Person.format = ActiveResource::Formats::XmlFormat
    # Person.find(1) # => GET /people/1.xml
    #
    # Default format is <tt>:json</tt>.
    def format=(mime_type_reference_or_format); end

    def format_extension; end
    def get(custom_method_name, options = T.unsafe(nil)); end
    def headers; end
    def include_format_in_path; end
    def include_format_in_path=(value); end
    def include_format_in_path?; end
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end

    # Returns the list of known attributes for this resource, gathered
    # from the provided <tt>schema</tt>
    # Attributes that are known will cause your resource to return 'true'
    # when <tt>respond_to?</tt> is called on them. A known attribute will
    # return nil if not set (rather than <tt>MethodNotFound</tt>); thus
    # known attributes can be used with <tt>validates_presence_of</tt>
    # without a getter-method.
    def known_attributes; end

    # A convenience wrapper for <tt>find(:last, *args)</tt>. You can pass
    # in all the same arguments to this method as you can to
    # <tt>find(:last)</tt>.
    def last(*args); end

    def logger; end
    def logger=(logger); end

    # Gets the new element path for REST resources.
    #
    # ==== Options
    # * +prefix_options+ - A hash to add a prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>/accounts/19/purchases/new.json</tt>).
    #
    # ==== Examples
    # Post.new_element_path
    # # => /posts/new.json
    #
    # class Comment < ActiveResource::Base
    # self.site = "https://37s.sunrise.com/posts/:post_id"
    # end
    #
    # Comment.collection_path(:post_id => 5)
    # # => /posts/5/comments/new.json
    def new_element_path(prefix_options = T.unsafe(nil)); end

    # Gets the number of seconds after which connection attempts to the REST API should time out.
    def open_timeout; end

    # Sets the number of seconds after which connection attempts to the REST API should time out.
    def open_timeout=(timeout); end

    def orig_delete(id, options = T.unsafe(nil)); end

    # Gets the \password for REST HTTP authentication.
    def password; end

    # Sets the \password for REST HTTP authentication.
    def password=(password); end

    def patch(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
    def post(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

    # Gets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>)
    # This method is regenerated at runtime based on what the \prefix is set to.
    def prefix(options = T.unsafe(nil)); end

    # Sets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>).
    # Default value is <tt>site.path</tt>.
    def prefix=(value = T.unsafe(nil)); end

    # An attribute reader for the source string for the resource path \prefix. This
    # method is regenerated at runtime based on what the \prefix is set to.
    def prefix_source; end

    def primary_key; end

    # Sets the attribute primary_key
    def primary_key=(_arg0); end

    # Gets the \proxy variable if a proxy is required
    def proxy; end

    # Sets the URI of the http proxy to the value in the +proxy+ argument.
    def proxy=(proxy); end

    def put(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

    # Gets the number of seconds after which reads to the REST API should time out.
    def read_timeout; end

    # Sets the number of seconds after which reads to the REST API should time out.
    def read_timeout=(timeout); end

    def reflections; end
    def reflections=(value); end
    def reflections?; end

    # Creates a schema for this resource - setting the attributes that are
    # known prior to fetching an instance from the remote system.
    #
    # The schema helps define the set of <tt>known_attributes</tt> of the
    # current resource.
    #
    # There is no need to specify a schema for your Active Resource. If
    # you do not, the <tt>known_attributes</tt> will be guessed from the
    # instance attributes returned when an instance is fetched from the
    # remote system.
    #
    # example:
    # class Person < ActiveResource::Base
    # schema do
    # # define each attribute separately
    # attribute 'name', :string
    #
    # # or use the convenience methods and pass >=1 attribute names
    # string  'eye_color', 'hair_color'
    # integer 'age'
    # float   'height', 'weight'
    #
    # # unsupported types should be left as strings
    # # overload the accessor methods if you need to convert them
    # attribute 'created_at', 'string'
    # end
    # end
    #
    # p = Person.new
    # p.respond_to? :name   # => true
    # p.respond_to? :age    # => true
    # p.name                # => nil
    # p.age                 # => nil
    #
    # j = Person.find_by_name('John')
    # <person><name>John</name><age>34</age><num_children>3</num_children></person>
    # j.respond_to? :name   # => true
    # j.respond_to? :age    # => true
    # j.name                # => 'John'
    # j.age                 # => '34'  # note this is a string!
    # j.num_children        # => '3'  # note this is a string!
    #
    # p.num_children        # => NoMethodError
    #
    # Attribute-types must be one of: <tt>string, text, integer, float, decimal, datetime, timestamp, time, date, binary, boolean</tt>
    #
    # Note: at present the attribute-type doesn't do anything, but stay
    # tuned...
    # Shortly it will also *cast* the value of the returned attribute.
    # ie:
    # j.age                 # => 34   # cast to an integer
    # j.weight              # => '65' # still a string!
    def schema(&block); end

    # Alternative, direct way to specify a <tt>schema</tt> for this
    # Resource. <tt>schema</tt> is more flexible, but this is quick
    # for a very simple schema.
    #
    # Pass the schema as a hash with the keys being the attribute-names
    # and the value being one of the accepted attribute types (as defined
    # in <tt>schema</tt>)
    #
    # example:
    #
    # class Person < ActiveResource::Base
    # schema = {'name' => :string, 'age' => :integer }
    # end
    #
    # The keys/values can be strings or symbols. They will be converted to
    # strings.
    def schema=(the_schema); end

    # Sets the attribute collection_name
    def set_collection_name(_arg0); end

    # Sets the attribute element_name
    def set_element_name(_arg0); end

    # Sets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>).
    # Default value is <tt>site.path</tt>.
    def set_prefix(value = T.unsafe(nil)); end

    # Sets the attribute primary_key
    def set_primary_key(_arg0); end

    # Gets the URI of the REST resources to map for this class. The site variable is required for
    # Active Resource's mapping to work.
    def site; end

    # Sets the URI of the REST resources to map for this class to the value in the +site+ argument.
    # The site variable is required for Active Resource's mapping to work.
    def site=(site); end

    # Returns the SSL options hash.
    def ssl_options; end

    # Options that will get applied to an SSL connection.
    #
    # * <tt>:key</tt> - An OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
    # * <tt>:cert</tt> - An OpenSSL::X509::Certificate object as client certificate
    # * <tt>:ca_file</tt> - Path to a CA certification file in PEM format. The file can contain several CA certificates.
    # * <tt>:ca_path</tt> - Path of a CA certification directory containing certifications in PEM format.
    # * <tt>:verify_mode</tt> - Flags for server the certification verification at beginning of SSL/TLS session. (OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER is acceptable)
    # * <tt>:verify_callback</tt> - The verify callback for the server certification verification.
    # * <tt>:verify_depth</tt> - The maximum depth for the certificate chain verification.
    # * <tt>:cert_store</tt> - OpenSSL::X509::Store to verify peer certificate.
    # * <tt>:ssl_timeout</tt> -The SSL timeout in seconds.
    def ssl_options=(options); end

    # Gets the number of seconds after which requests to the REST API should time out.
    def timeout; end

    # Sets the number of seconds after which requests to the REST API should time out.
    def timeout=(timeout); end

    # Gets the \user for REST HTTP authentication.
    def user; end

    # Sets the \user for REST HTTP authentication.
    def user=(user); end

    def where(clauses = T.unsafe(nil)); end

    private

    def check_prefix_options(prefix_options); end

    # Accepts a URI and creates the proxy URI from that.
    def create_proxy_uri_from(proxy); end

    # Accepts a URI and creates the site URI from that.
    def create_site_uri_from(site); end

    # Find every resource
    def find_every(options); end

    # Find a single resource from a one-off URL
    def find_one(options); end

    # Find a single resource from the default URL
    def find_single(scope, options); end

    def instantiate_collection(collection, original_params = T.unsafe(nil), prefix_options = T.unsafe(nil)); end
    def instantiate_record(record, prefix_options = T.unsafe(nil)); end

    # contains a set of the current prefix parameters.
    def prefix_parameters; end

    # Builds the query string for the request.
    def query_string(options); end

    # split an option hash into two hashes, one containing the prefix options,
    # and the other containing the leftovers.
    def split_options(options = T.unsafe(nil)); end
  end
end

module ActiveResource::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

ActiveResource::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

# 4xx Client Error
class ActiveResource::ClientError < ::ActiveResource::ConnectionError; end

class ActiveResource::Collection
  include ::Enumerable

  # ActiveResource::Collection is a wrapper to handle parsing index responses that
  # do not directly map to Rails conventions.
  #
  # You can define a custom class that inherets from ActiveResource::Collection
  # in order to to set the elements instance.
  #
  # GET /posts.json delivers following response body:
  # {
  # posts: [
  # {
  # title: "ActiveResource now has associations",
  # body: "Lorem Ipsum"
  # },
  # {...}
  # ],
  # next_page: "/posts.json?page=2"
  # }
  #
  # A Post class can be setup to handle it with:
  #
  # class Post < ActiveResource::Base
  # self.site = "http://example.com"
  # self.collection_parser = PostCollection
  # end
  #
  # And the collection parser:
  #
  # class PostCollection < ActiveResource::Collection
  # attr_accessor :next_page
  # def initialize(parsed = {})
  # @elements = parsed['posts']
  # @next_page = parsed['next_page']
  # end
  # end
  #
  # The result from a find method that returns multiple entries will now be a
  # PostParser instance.  ActiveResource::Collection includes Enumerable and
  # instances can be iterated over just like an array.
  # @posts = Post.find(:all) # => PostCollection:xxx
  # @posts.next_page         # => "/posts.json?page=2"
  # @posts.map(&:id)         # =>[1, 3, 5 ...]
  #
  # The initialize method will receive the ActiveResource::Formats parsed result
  # and should set @elements.
  def initialize(elements = T.unsafe(nil)); end

  def &(*_arg0, &_arg1); end
  def *(*_arg0, &_arg1); end
  def +(*_arg0, &_arg1); end
  def -(*_arg0, &_arg1); end
  def <<(*_arg0, &_arg1); end
  def <=>(*_arg0, &_arg1); end
  def ==(arg); end
  def [](*_arg0, &_arg1); end
  def []=(*_arg0, &_arg1); end
  def all?(*_arg0, &_arg1); end
  def any?(*_arg0, &_arg1); end
  def append(*_arg0, &_arg1); end
  def as_json(*_arg0, &_arg1); end
  def assoc(*_arg0, &_arg1); end
  def at(*_arg0, &_arg1); end
  def blank?(*_arg0, &_arg1); end
  def bsearch(*_arg0, &_arg1); end
  def bsearch_index(*_arg0, &_arg1); end
  def clear(*_arg0, &_arg1); end
  def collect(*_arg0, &_arg1); end
  def collect!; end
  def combination(*_arg0, &_arg1); end
  def compact(*_arg0, &_arg1); end
  def compact!(*_arg0, &_arg1); end
  def compact_blank!(*_arg0, &_arg1); end
  def concat(*_arg0, &_arg1); end
  def count(*_arg0, &_arg1); end
  def cycle(*_arg0, &_arg1); end
  def deconstruct(*_arg0, &_arg1); end
  def deep_dup(*_arg0, &_arg1); end
  def delete(*_arg0, &_arg1); end
  def delete_at(*_arg0, &_arg1); end
  def delete_if(*_arg0, &_arg1); end
  def difference(*_arg0, &_arg1); end
  def dig(*_arg0, &_arg1); end
  def drop(*_arg0, &_arg1); end
  def drop_while(*_arg0, &_arg1); end
  def each(*_arg0, &_arg1); end
  def each_index(*_arg0, &_arg1); end

  # The array of actual elements returned by index actions
  def elements; end

  # The array of actual elements returned by index actions
  def elements=(_arg0); end

  def empty?(*_arg0, &_arg1); end
  def eql?(*_arg0, &_arg1); end
  def excluding(*_arg0, &_arg1); end
  def extract!(*_arg0, &_arg1); end
  def extract_options!(*_arg0, &_arg1); end
  def fetch(*_arg0, &_arg1); end
  def fifth(*_arg0, &_arg1); end
  def fill(*_arg0, &_arg1); end
  def filter(*_arg0, &_arg1); end
  def filter!(*_arg0, &_arg1); end
  def find_index(*_arg0, &_arg1); end
  def first(*_arg0, &_arg1); end
  def first_or_create(attributes = T.unsafe(nil)); end
  def first_or_initialize(attributes = T.unsafe(nil)); end
  def flatten(*_arg0, &_arg1); end
  def flatten!(*_arg0, &_arg1); end
  def forty_two(*_arg0, &_arg1); end
  def fourth(*_arg0, &_arg1); end
  def from(*_arg0, &_arg1); end
  def hash(*_arg0, &_arg1); end
  def include?(*_arg0, &_arg1); end
  def including(*_arg0, &_arg1); end
  def index(*_arg0, &_arg1); end
  def insert(*_arg0, &_arg1); end
  def inspect(*_arg0, &_arg1); end
  def intersection(*_arg0, &_arg1); end
  def join(*_arg0, &_arg1); end
  def keep_if(*_arg0, &_arg1); end
  def last(*_arg0, &_arg1); end
  def length(*_arg0, &_arg1); end
  def map(*_arg0, &_arg1); end
  def map!; end
  def max(*_arg0, &_arg1); end
  def min(*_arg0, &_arg1); end
  def minmax(*_arg0, &_arg1); end
  def none?(*_arg0, &_arg1); end
  def one?(*_arg0, &_arg1); end

  # The array of actual elements returned by index actions
  def original_params; end

  # The array of actual elements returned by index actions
  def original_params=(_arg0); end

  def pack(*_arg0, &_arg1); end
  def permutation(*_arg0, &_arg1); end
  def place(*_arg0, &_arg1); end
  def pop(*_arg0, &_arg1); end
  def prepend(*_arg0, &_arg1); end
  def pretty_print(*_arg0, &_arg1); end
  def pretty_print_cycle(*_arg0, &_arg1); end
  def product(*_arg0, &_arg1); end
  def push(*_arg0, &_arg1); end
  def rassoc(*_arg0, &_arg1); end
  def reject(*_arg0, &_arg1); end
  def reject!(*_arg0, &_arg1); end
  def repeated_combination(*_arg0, &_arg1); end
  def repeated_permutation(*_arg0, &_arg1); end
  def replace(*_arg0, &_arg1); end

  # The array of actual elements returned by index actions
  def resource_class; end

  # The array of actual elements returned by index actions
  def resource_class=(_arg0); end

  def reverse(*_arg0, &_arg1); end
  def reverse!(*_arg0, &_arg1); end
  def reverse_each(*_arg0, &_arg1); end
  def rindex(*_arg0, &_arg1); end
  def rotate(*_arg0, &_arg1); end
  def rotate!(*_arg0, &_arg1); end
  def sample(*_arg0, &_arg1); end
  def second(*_arg0, &_arg1); end
  def second_to_last(*_arg0, &_arg1); end
  def select(*_arg0, &_arg1); end
  def select!(*_arg0, &_arg1); end
  def shelljoin(*_arg0, &_arg1); end
  def shift(*_arg0, &_arg1); end
  def shuffle(*_arg0, &_arg1); end
  def shuffle!(*_arg0, &_arg1); end
  def size(*_arg0, &_arg1); end
  def slice(*_arg0, &_arg1); end
  def slice!(*_arg0, &_arg1); end
  def sort(*_arg0, &_arg1); end
  def sort!(*_arg0, &_arg1); end
  def sort_by!(*_arg0, &_arg1); end
  def sum(*_arg0, &_arg1); end
  def take(*_arg0, &_arg1); end
  def take_while(*_arg0, &_arg1); end
  def third(*_arg0, &_arg1); end
  def third_to_last(*_arg0, &_arg1); end
  def to(*_arg0, &_arg1); end
  def to_a; end
  def to_ary(*_arg0, &_arg1); end
  def to_default_s(*_arg0, &_arg1); end
  def to_formatted_s(*_arg0, &_arg1); end
  def to_h(*_arg0, &_arg1); end
  def to_param(*_arg0, &_arg1); end
  def to_query(*_arg0, &_arg1); end
  def to_s(*_arg0, &_arg1); end
  def to_sentence(*_arg0, &_arg1); end
  def to_xml(*_arg0, &_arg1); end
  def to_yaml(*_arg0, &_arg1); end
  def transpose(*_arg0, &_arg1); end
  def union(*_arg0, &_arg1); end
  def uniq(*_arg0, &_arg1); end
  def uniq!(*_arg0, &_arg1); end
  def unshift(*_arg0, &_arg1); end
  def values_at(*_arg0, &_arg1); end
  def where(clauses = T.unsafe(nil)); end
  def without(*_arg0, &_arg1); end
  def zip(*_arg0, &_arg1); end
  def |(*_arg0, &_arg1); end
end

ActiveResource::Collection::SELF_DEFINE_METHODS = T.let(T.unsafe(nil), Array)

# Class to handle connections to remote web services.
# This class is used by ActiveResource::Base to interface with REST
# services.
class ActiveResource::Connection
  # The +site+ parameter is required and will set the +site+
  # attribute to the URI for the remote resource service.
  def initialize(site, format = T.unsafe(nil), logger: T.unsafe(nil)); end

  # Returns the value of attribute auth_type.
  def auth_type; end

  # Sets the auth type for remote service.
  def auth_type=(auth_type); end

  # Returns the value of attribute bearer_token.
  def bearer_token; end

  # Sets the bearer token for remote service.
  def bearer_token=(_arg0); end

  # Executes a DELETE request (see HTTP protocol documentation if unfamiliar).
  # Used to delete resources.
  def delete(path, headers = T.unsafe(nil)); end

  # Returns the value of attribute format.
  def format; end

  # Sets the attribute format
  def format=(_arg0); end

  # Executes a GET request.
  # Used to get (find) resources.
  def get(path, headers = T.unsafe(nil)); end

  # Executes a HEAD request.
  # Used to obtain meta-information about resources, such as whether they exist and their size (via response headers).
  def head(path, headers = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  def logger=(_arg0); end

  # Returns the value of attribute open_timeout.
  def open_timeout; end

  # Sets the number of seconds after which HTTP connects to the remote service should time out.
  def open_timeout=(_arg0); end

  # Returns the value of attribute password.
  def password; end

  # Sets the password for remote service.
  def password=(_arg0); end

  # Executes a PATCH request (see HTTP protocol documentation if unfamiliar).
  # Used to update resources.
  def patch(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Executes a POST request.
  # Used to create new resources.
  def post(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns the value of attribute proxy.
  def proxy; end

  # Set the proxy for remote service.
  def proxy=(proxy); end

  # Executes a PUT request (see HTTP protocol documentation if unfamiliar).
  # Used to update resources.
  def put(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns the value of attribute read_timeout.
  def read_timeout; end

  # Sets the number of seconds after which HTTP read requests to the remote service should time out.
  def read_timeout=(_arg0); end

  # Returns the value of attribute site.
  def site; end

  # Set URI for remote service.
  def site=(site); end

  # Returns the value of attribute ssl_options.
  def ssl_options; end

  # Hash of options applied to Net::HTTP instance when +site+ protocol is 'https'.
  def ssl_options=(_arg0); end

  # Returns the value of attribute timeout.
  def timeout; end

  # Sets the number of seconds after which HTTP requests to the remote service should time out.
  def timeout=(_arg0); end

  # Returns the value of attribute user.
  def user; end

  # Sets the user for remote service.
  def user=(_arg0); end

  private

  def apply_ssl_options(http); end
  def auth_attributes_for(uri, request_digest, params); end
  def authorization_header(http_method, uri); end

  # Builds headers for request to remote service.
  def build_request_headers(headers, http_method, uri); end

  def client_nonce; end
  def configure_http(http); end
  def default_header; end
  def digest_auth_header(http_method, uri); end
  def extract_params_from_response; end

  # Handles response and error codes from the remote service.
  def handle_response(response); end

  # Creates new Net::HTTP instance for communication with the
  # remote service and resources.
  def http; end

  def http_format_header(http_method); end
  def legitimize_auth_type(auth_type); end
  def new_http; end

  # Makes a request to the remote service.
  def request(method, path, *arguments); end

  def response_auth_header; end
  def with_auth; end

  class << self
    def requests; end
  end
end

ActiveResource::Connection::HTTP_FORMAT_HEADER_NAMES = T.let(T.unsafe(nil), Hash)

class ActiveResource::ConnectionError < ::StandardError
  def initialize(response, message = T.unsafe(nil)); end

  # Returns the value of attribute response.
  def response; end

  def to_s; end
end

# A module to support custom REST methods and sub-resources, allowing you to break out
# of the "default" REST methods with your own custom resource requests. For example,
# say you use Rails to expose a REST service and configure your routes with:
#
# map.resources :people, :new => { :register => :post },
# :member => { :promote => :put, :deactivate => :delete }
# :collection => { :active => :get }
#
# This route set creates routes for the following HTTP requests:
#
# POST      /people/new/register.json # PeopleController.register
# PATCH/PUT /people/1/promote.json    # PeopleController.promote with :id => 1
# DELETE    /people/1/deactivate.json # PeopleController.deactivate with :id => 1
# GET       /people/active.json       # PeopleController.active
#
# Using this module, Active Resource can use these custom REST methods just like the
# standard methods.
#
# class Person < ActiveResource::Base
# self.site = "https://37s.sunrise.com"
# end
#
# Person.new(:name => 'Ryan').post(:register)  # POST /people/new/register.json
# # => { :id => 1, :name => 'Ryan' }
#
# Person.find(1).put(:promote, :position => 'Manager') # PUT /people/1/promote.json
# Person.find(1).delete(:deactivate) # DELETE /people/1/deactivate.json
#
# Person.get(:active)  # GET /people/active.json
# # => [{:id => 1, :name => 'Ryan'}, {:id => 2, :name => 'Joe'}]
module ActiveResource::CustomMethods
  extend ::ActiveSupport::Concern

  def delete(method_name, options = T.unsafe(nil)); end
  def get(method_name, options = T.unsafe(nil)); end
  def patch(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
  def post(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
  def put(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

  private

  def custom_method_element_url(method_name, options = T.unsafe(nil)); end
  def custom_method_new_element_url(method_name, options = T.unsafe(nil)); end
end

module ActiveResource::CustomMethods::ClassMethods
  def custom_method_collection_url(method_name, options = T.unsafe(nil)); end
end

# Active Resource validation is reported to and from this object, which is used by Base#save
# to determine whether the object in a valid state to be saved. See usage example in Validations.
class ActiveResource::Errors < ::ActiveModel::Errors
  # Grabs errors from an array of messages (like ActiveRecord::Validations).
  # The second parameter directs the errors cache to be cleared (default)
  # or not (by passing true).
  def from_array(messages, save_cache = T.unsafe(nil)); end

  # Grabs errors from a hash of attribute => array of errors elements
  # The second parameter directs the errors cache to be cleared (default)
  # or not (by passing true)
  #
  # Unrecognized attribute names will be humanized and added to the record's
  # base errors.
  def from_hash(messages, save_cache = T.unsafe(nil)); end

  # Grabs errors from a json response.
  def from_json(json, save_cache = T.unsafe(nil)); end

  # Grabs errors from an XML response.
  def from_xml(xml, save_cache = T.unsafe(nil)); end
end

# 403 Forbidden
class ActiveResource::ForbiddenAccess < ::ActiveResource::ClientError; end

module ActiveResource::Formats
  class << self
    # Lookup the format class from a mime type reference symbol. Example:
    #
    # ActiveResource::Formats[:xml]  # => ActiveResource::Formats::XmlFormat
    # ActiveResource::Formats[:json] # => ActiveResource::Formats::JsonFormat
    def [](mime_type_reference); end

    def remove_root(data); end
  end
end

module ActiveResource::Formats::JsonFormat
  extend ::ActiveResource::Formats::JsonFormat

  def decode(json); end
  def encode(hash, options = T.unsafe(nil)); end
  def extension; end
  def mime_type; end
end

module ActiveResource::Formats::XmlFormat
  extend ::ActiveResource::Formats::XmlFormat

  def decode(xml); end
  def encode(hash, options = T.unsafe(nil)); end
  def extension; end
  def mime_type; end
end

# One thing that has always been a pain with remote web services is testing. The HttpMock
# class makes it easy to test your Active Resource models by creating a set of mock responses to specific
# requests.
#
# To test your Active Resource model, you simply call the ActiveResource::HttpMock.respond_to
# method with an attached block. The block declares a set of URIs with expected input, and the output
# each request should return. The passed in block has any number of entries in the following generalized
# format:
#
# mock.http_method(path, request_headers = {}, body = nil, status = 200, response_headers = {})
#
# * <tt>http_method</tt> - The HTTP method to listen for. This can be +get+, +post+, +patch+, +put+, +delete+ or
# +head+.
# * <tt>path</tt> - A string, starting with a "/", defining the URI that is expected to be
# called.
# * <tt>request_headers</tt> - Headers that are expected along with the request. This argument uses a
# hash format, such as <tt>{ "Content-Type" => "application/json" }</tt>. This mock will only trigger
# if your tests sends a request with identical headers.
# * <tt>body</tt> - The data to be returned. This should be a string of Active Resource parseable content,
# such as Json.
# * <tt>status</tt> - The HTTP response code, as an integer, to return with the response.
# * <tt>response_headers</tt> - Headers to be returned with the response. Uses the same hash format as
# <tt>request_headers</tt> listed above.
#
# In order for a mock to deliver its content, the incoming request must match by the <tt>http_method</tt>,
# +path+ and <tt>request_headers</tt>. If no match is found an +InvalidRequestError+ exception
# will be raised showing you what request it could not find a response for and also what requests and response
# pairs have been recorded so you can create a new mock for that request.
#
# ==== Example
# def setup
# @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
# ActiveResource::HttpMock.respond_to do |mock|
# mock.post   "/people.json",   {}, @matz, 201, "Location" => "/people/1.json"
# mock.get    "/people/1.json", {}, @matz
# mock.put    "/people/1.json", {}, nil, 204
# mock.delete "/people/1.json", {}, nil, 200
# end
# end
#
# def test_get_matz
# person = Person.find(1)
# assert_equal "Matz", person.name
# end
class ActiveResource::HttpMock
  def initialize(site); end

  def delete(path, headers); end
  def get(path, headers); end
  def head(path, headers); end
  def inspect_responses; end
  def patch(path, body, headers); end
  def post(path, body, headers); end
  def put(path, body, headers); end

  class << self
    def delete_responses_to_replace(new_responses); end

    # Sets all ActiveResource::Connection to use HttpMock instances.
    def disable_net_connection!; end

    # Enables all ActiveResource::Connection instances to use real
    # Net::HTTP instance instead of a mock.
    def enable_net_connection!; end

    def net_connection_disabled?; end

    # Checks if real requests can be used instead of the default mock used in tests.
    def net_connection_enabled?; end

    # Returns an array of all request objects that have been sent to the mock. You can use this to check
    # if your model actually sent an HTTP request.
    #
    # ==== Example
    # def setup
    # @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    # ActiveResource::HttpMock.respond_to do |mock|
    # mock.get "/people/1.json", {}, @matz
    # end
    # end
    #
    # def test_should_request_remote_service
    # person = Person.find(1)  # Call the remote service
    #
    # # This request object has the same HTTP method and path as declared by the mock
    # expected_request = ActiveResource::Request.new(:get, "/people/1.json")
    #
    # # Assert that the mock received, and responded to, the expected request from the model
    # assert ActiveResource::HttpMock.requests.include?(expected_request)
    # end
    def requests; end

    # Deletes all logged requests and responses.
    def reset!; end

    # Accepts a block which declares a set of requests and responses for the HttpMock to respond to in
    # the following format:
    #
    # mock.http_method(path, request_headers = {}, body = nil, status = 200, response_headers = {})
    #
    # === Example
    #
    # @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    # ActiveResource::HttpMock.respond_to do |mock|
    # mock.post   "/people.json",   {}, @matz, 201, "Location" => "/people/1.json"
    # mock.get    "/people/1.json", {}, @matz
    # mock.put    "/people/1.json", {}, nil, 204
    # mock.delete "/people/1.json", {}, nil, 200
    # end
    #
    # Alternatively, accepts a hash of <tt>{Request => Response}</tt> pairs allowing you to generate
    # these the following format:
    #
    # ActiveResource::Request.new(method, path, body, request_headers)
    # ActiveResource::Response.new(body, status, response_headers)
    #
    # === Example
    #
    # Request.new(method, path, nil, request_headers)
    #
    # @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    #
    # create_matz      = ActiveResource::Request.new(:post, '/people.json', @matz, {})
    # created_response = ActiveResource::Response.new("", 201, {"Location" => "/people/1.json"})
    # get_matz         = ActiveResource::Request.new(:get, '/people/1.json', nil)
    # ok_response      = ActiveResource::Response.new("", 200, {})
    #
    # pairs = {create_matz => created_response, get_matz => ok_response}
    #
    # ActiveResource::HttpMock.respond_to(pairs)
    #
    # Note, by default, every time you call +respond_to+, any previous request and response pairs stored
    # in HttpMock will be deleted giving you a clean slate to work on.
    #
    # If you want to override this behavior, pass in +false+ as the last argument to +respond_to+
    #
    # === Example
    #
    # ActiveResource::HttpMock.respond_to do |mock|
    # mock.send(:get, "/people/1", {}, "JSON1")
    # end
    # ActiveResource::HttpMock.responses.length #=> 1
    #
    # ActiveResource::HttpMock.respond_to(false) do |mock|
    # mock.send(:get, "/people/2", {}, "JSON2")
    # end
    # ActiveResource::HttpMock.responses.length #=> 2
    #
    # This also works with passing in generated pairs of requests and responses, again, just pass in false
    # as the last argument:
    #
    # === Example
    #
    # ActiveResource::HttpMock.respond_to do |mock|
    # mock.send(:get, "/people/1", {}, "JSON1")
    # end
    # ActiveResource::HttpMock.responses.length #=> 1
    #
    # get_matz         = ActiveResource::Request.new(:get, '/people/1.json', nil)
    # ok_response      = ActiveResource::Response.new("", 200, {})
    #
    # pairs = {get_matz => ok_response}
    #
    # ActiveResource::HttpMock.respond_to(pairs, false)
    # ActiveResource::HttpMock.responses.length #=> 2
    #
    # # If you add a response with an existing request, it will be replaced
    #
    # fail_response      = ActiveResource::Response.new("", 404, {})
    # pairs = {get_matz => fail_response}
    #
    # ActiveResource::HttpMock.respond_to(pairs, false)
    # ActiveResource::HttpMock.responses.length #=> 2
    def respond_to(*args); end

    # Returns the list of requests and their mocked responses. Look up a
    # response for a request using <tt>responses.assoc(request)</tt>.
    def responses; end
  end
end

class ActiveResource::HttpMock::Responder
  def initialize(responses); end

  def delete(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def get(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def head(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def patch(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def post(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def put(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  private

  def delete_duplicate_responses(request); end
end

class ActiveResource::InvalidRequestError < ::StandardError; end

class ActiveResource::LogSubscriber < ::ActiveSupport::LogSubscriber
  def logger; end
  def request(event); end
end

# 405 Method Not Allowed
class ActiveResource::MethodNotAllowed < ::ActiveResource::ClientError
  def allowed_methods; end
end

class ActiveResource::MissingPrefixParam < ::ArgumentError; end
class ActiveResource::Railtie < ::Rails::Railtie; end

# 3xx Redirection
class ActiveResource::Redirection < ::ActiveResource::ConnectionError
  def to_s; end
end

# = Active Resource reflection
#
# Associations in ActiveResource would be used to resolve nested attributes
# in a response with correct classes.
# Now they could be specified over Associations with the options :class_name
module ActiveResource::Reflection
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveResource::Reflection::ClassMethods

  module GeneratedClassMethods
    def reflections; end
    def reflections=(value); end
    def reflections?; end
  end

  module GeneratedInstanceMethods
    def reflections; end
    def reflections=(value); end
    def reflections?; end
  end
end

class ActiveResource::Reflection::AssociationReflection
  def initialize(macro, name, options); end

  # Returns the class name for the macro.
  #
  # <tt>has_many :clients</tt> returns <tt>'Client'</tt>
  def class_name; end

  # Returns the foreign_key for the macro.
  def foreign_key; end

  # Returns the class for the macro.
  #
  # <tt>has_many :clients</tt> returns the Client class
  def klass; end

  # Returns the macro type.
  #
  # <tt>has_many :clients</tt> returns <tt>:has_many</tt>
  def macro; end

  # Returns the name of the macro.
  #
  # <tt>has_many :clients</tt> returns <tt>:clients</tt>
  def name; end

  # Returns the hash of options used for the macro.
  #
  # <tt>has_many :clients</tt> returns +{}+
  def options; end

  private

  def derive_class_name; end
  def derive_foreign_key; end
end

module ActiveResource::Reflection::ClassMethods
  def create_reflection(macro, name, options); end
end

class ActiveResource::Request
  def initialize(method, path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  def ==(req); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  def body=(_arg0); end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  def headers=(_arg0); end

  # Returns the value of attribute method.
  def method; end

  # Sets the attribute method
  def method=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  def path=(_arg0); end

  def to_s; end

  private

  def headers_match?(req); end
end

# 409 Conflict
class ActiveResource::ResourceConflict < ::ActiveResource::ClientError; end

# 410 Gone
class ActiveResource::ResourceGone < ::ActiveResource::ClientError; end

class ActiveResource::ResourceInvalid < ::ActiveResource::ClientError; end

# 404 Not Found
class ActiveResource::ResourceNotFound < ::ActiveResource::ClientError; end

class ActiveResource::Response
  def initialize(body, message = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns true if the other is a Response with an equal body, equal message
  # and equal headers. Otherwise it returns false.
  def ==(other); end

  def [](key); end
  def []=(key, value); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  def body=(_arg0); end

  # Returns the value of attribute code.
  def code; end

  # Sets the attribute code
  def code=(_arg0); end

  # Returns the value of attribute headers.
  def headers; end

  # Sets the attribute headers
  def headers=(_arg0); end

  # Returns the value of attribute message.
  def message; end

  # Sets the attribute message
  def message=(_arg0); end

  # Returns true if code is 2xx,
  # false otherwise.
  def success?; end
end

# Raised when a OpenSSL::SSL::SSLError occurs.
class ActiveResource::SSLError < ::ActiveResource::ConnectionError
  def initialize(message); end

  def to_s; end
end

class ActiveResource::Schema
  # The internals of an Active Resource Schema are very simple -
  # unlike an Active Record TableDefinition (on which it is based).
  # It provides a set of convenience methods for people to define their
  # schema using the syntax:
  # schema do
  # string :foo
  # integer :bar
  # end
  #
  # The schema stores the name and type of each attribute. That is then
  # read out by the schema method to populate the schema of the actual
  # resource.
  def initialize; end

  def attribute(name, type, options = T.unsafe(nil)); end

  # An array of attribute definitions, representing the attributes that
  # have been defined.
  def attrs; end

  # An array of attribute definitions, representing the attributes that
  # have been defined.
  def attrs=(_arg0); end

  def binary(*args); end
  def boolean(*args); end
  def date(*args); end
  def datetime(*args); end
  def decimal(*args); end
  def float(*args); end
  def integer(*args); end
  def string(*args); end
  def text(*args); end
  def time(*args); end
  def timestamp(*args); end
end

# attributes can be known to be one of these types. They are easy to
# cast to/from.
ActiveResource::Schema::KNOWN_ATTRIBUTE_TYPES = T.let(T.unsafe(nil), Array)

# 5xx Server Error
class ActiveResource::ServerError < ::ActiveResource::ConnectionError; end

module ActiveResource::Singleton
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveResource::Singleton::ClassMethods

  # Deletes the resource from the remote service.
  #
  # ==== Examples
  # weather = Weather.find
  # weather.destroy
  # Weather.find # 404 (Resource Not Found)
  def destroy; end

  protected

  # Create (i.e. \save to the remote service) the \new resource.
  def create; end

  # Update the resource on the remote service
  def update; end

  private

  def singleton_path(options = T.unsafe(nil)); end
end

module ActiveResource::Singleton::ClassMethods
  # Core method for finding singleton resources.
  #
  # ==== Arguments
  # Takes a single argument of options
  #
  # ==== Options
  # * <tt>:params</tt> - Sets the query and \prefix (nested URL) parameters.
  #
  # ==== Examples
  # Weather.find
  # # => GET /weather.json
  #
  # Weather.find(:params => {:degrees => 'fahrenheit'})
  # # => GET /weather.json?degrees=fahrenheit
  #
  # == Failure or missing data
  # A failure to find the requested object raises a ResourceNotFound exception.
  #
  # Inventory.find
  # # => raises ResourceNotFound
  def find(options = T.unsafe(nil)); end

  def singleton_name; end

  # Sets the attribute singleton_name
  def singleton_name=(_arg0); end

  # Gets the singleton path for the object.  If the +query_options+ parameter is omitted, Rails
  # will split from the \prefix options.
  #
  # ==== Options
  # * +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
  # would yield a URL like <tt>/accounts/19/purchases.json</tt>).
  #
  # * +query_options+ - A \hash to add items to the query string for the request.
  #
  # ==== Examples
  # Weather.singleton_path
  # # => /weather.json
  #
  # class Inventory < ActiveResource::Base
  # self.site =   "https://37s.sunrise.com"
  # self.prefix = "/products/:product_id/"
  # end
  #
  # Inventory.singleton_path(:product_id => 5)
  # # => /products/5/inventory.json
  #
  # Inventory.singleton_path({:product_id => 5}, {:sold => true})
  # # => /products/5/inventory.json?sold=true
  def singleton_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

  private

  # Find singleton resource
  def find_singleton(options); end
end

# Raised when a Timeout::Error occurs.
class ActiveResource::TimeoutError < ::ActiveResource::ConnectionError
  def initialize(message); end

  def to_s; end
end

# 401 Unauthorized
class ActiveResource::UnauthorizedAccess < ::ActiveResource::ClientError; end

module ActiveResource::VERSION; end
ActiveResource::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
ActiveResource::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
ActiveResource::VERSION::STRING = T.let(T.unsafe(nil), String)
ActiveResource::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# Module to support validation and errors with Active Resource objects. The module overrides
# Base#save to rescue ActiveResource::ResourceInvalid exceptions and parse the errors returned
# in the web service response. The module also adds an +errors+ collection that mimics the interface
# of the errors provided by ActiveModel::Errors.
#
# ==== Example
#
# Consider a Person resource on the server requiring both a +first_name+ and a +last_name+ with a
# <tt>validates_presence_of :first_name, :last_name</tt> declaration in the model:
#
# person = Person.new(:first_name => "Jim", :last_name => "")
# person.save                   # => false (server returns an HTTP 422 status code and errors)
# person.valid?                 # => false
# person.errors.empty?          # => false
# person.errors.count           # => 1
# person.errors.full_messages   # => ["Last name can't be empty"]
# person.errors[:last_name]  # => ["can't be empty"]
# person.last_name = "Halpert"
# person.save                   # => true (and person is now saved to the remote service)
module ActiveResource::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations

  mixes_in_class_methods GeneratedClassMethods

  # Returns the Errors object that holds all information about attribute error messages.
  def errors; end

  # Loads the set of remote errors into the object's Errors based on the
  # content-type of the error-block received.
  def load_remote_errors(remote_errors, save_cache = T.unsafe(nil)); end

  # Validate a resource and save (POST) it to the remote web service.
  # If any local validations fail - the save (POST) will not be attempted.
  def save_with_validation(options = T.unsafe(nil)); end

  # Checks for errors on an object (i.e., is resource.errors empty?).
  #
  # Runs all the specified local validations and returns true if no errors
  # were added, otherwise false.
  # Runs local validations (eg those on your Active Resource model), and
  # also any errors returned from the remote system the last time we
  # saved.
  # Remote errors can only be cleared by trying to re-save the resource.
  #
  # ==== Examples
  # my_person = Person.create(params[:person])
  # my_person.valid?
  # # => true
  #
  # my_person.errors.add('login', 'can not be empty') if my_person.login == ''
  # my_person.valid?
  # # => false
  def valid?; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

module ThreadsafeAttributes
  mixes_in_class_methods ::ThreadsafeAttributes::ClassMethods

  private

  def get_threadsafe_attribute(name, main_thread); end
  def get_threadsafe_attribute_by_thread(name, thread); end
  def set_threadsafe_attribute(name, value, main_thread); end
  def set_threadsafe_attribute_by_thread(name, value, thread); end
  def threadsafe_attribute_defined?(name, main_thread); end
  def threadsafe_attribute_defined_by_thread?(name, thread); end

  class << self
    def included(klass); end
  end
end

module ThreadsafeAttributes::ClassMethods
  def threadsafe_attribute(*attrs); end
end
