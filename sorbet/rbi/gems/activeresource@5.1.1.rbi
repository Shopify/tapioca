# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activeresource` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

module ActiveResource
  extend(::ActiveSupport::Autoload)
end

class ActiveResource::BadRequest < ::ActiveResource::ClientError
end

class ActiveResource::Base
  include(::ActiveModel::Validations)
  include(::ActiveSupport::Callbacks)
  include(::ActiveModel::Validations::HelperMethods)
  include(::ActiveResource::Validations)
  include(::ActiveResource::CustomMethods)
  include(::ActiveResource::Callbacks)
  include(::ActiveModel::Validations::Callbacks)
  include(::ActiveModel::Conversion)
  include(::ActiveModel::Serialization)
  include(::ActiveModel::Serializers::JSON)
  include(::ActiveModel::Serializers::Xml)
  include(::ActiveResource::Reflection)
  extend(::ThreadsafeAttributes)
  extend(::ActiveModel::Naming)
  extend(::ActiveResource::Associations)
  extend(::ActiveModel::Validations::ClassMethods)
  extend(::ActiveModel::Callbacks)
  extend(::ActiveSupport::Callbacks::ClassMethods)
  extend(::ActiveSupport::DescendantsTracker)
  extend(::ActiveModel::Translation)
  extend(::ActiveModel::Validations::HelperMethods)
  extend(::ActiveResource::CustomMethods::ClassMethods)
  extend(::ActiveModel::Validations::Callbacks::ClassMethods)
  extend(::ActiveModel::Conversion::ClassMethods)
  extend(::ActiveResource::Reflection::ClassMethods)

  def initialize(attributes = T.unsafe(nil), persisted = T.unsafe(nil)); end

  def ==(other); end
  def __callbacks; end
  def __callbacks?; end
  def _collection_parser; end
  def _collection_parser=(val); end
  def _collection_parser?; end
  def _create_callbacks; end
  def _destroy_callbacks; end
  def _format; end
  def _format=(val); end
  def _format?; end
  def _run_create_callbacks(&block); end
  def _run_destroy_callbacks(&block); end
  def _run_save_callbacks(&block); end
  def _run_update_callbacks(&block); end
  def _run_validate_callbacks(&block); end
  def _run_validation_callbacks(&block); end
  def _save_callbacks; end
  def _update_callbacks; end
  def _validate_callbacks; end
  def _validation_callbacks; end
  def _validators; end
  def _validators?; end
  def attributes; end
  def attributes=(_); end
  def clone; end
  def connection_class; end
  def connection_class=(val); end
  def connection_class?; end
  def destroy; end
  def dup; end
  def encode(options = T.unsafe(nil)); end
  def eql?(other); end
  def exists?; end
  def hash; end
  def id; end
  def id=(id); end
  def include_format_in_path; end
  def include_format_in_path=(val); end
  def include_format_in_path?; end
  def include_root_in_json; end
  def include_root_in_json?; end
  def known_attributes; end
  def load(attributes, remove_root = T.unsafe(nil), persisted = T.unsafe(nil)); end
  def logger; end
  def model_name(*args, &block); end
  def new?; end
  def new_record?; end
  def persisted?; end
  def prefix_options; end
  def prefix_options=(_); end
  def read_attribute_for_serialization(n); end
  def reflections; end
  def reflections=(val); end
  def reflections?; end
  def reload; end
  def respond_to_without_attributes?(*_); end
  def save(options = T.unsafe(nil)); end
  def save!; end
  def save_without_validation; end
  def schema; end
  def to_json(options = T.unsafe(nil)); end
  def to_xml(options = T.unsafe(nil)); end
  def update_attribute(name, value); end
  def update_attributes(attributes); end
  def validation_context; end

  protected

  def collection_path(options = T.unsafe(nil)); end
  def connection(refresh = T.unsafe(nil)); end
  def create; end
  def element_path(options = T.unsafe(nil)); end
  def element_url(options = T.unsafe(nil)); end
  def id_from_response(response); end
  def load_attributes_from_response(response); end
  def new_element_path; end
  def update; end

  private

  def const_valid?(*const_args); end
  def create_resource_for(resource_name); end
  def find_or_create_resource_for(name); end
  def find_or_create_resource_for_collection(name); end
  def find_or_create_resource_in_modules(resource_name, module_names); end
  def method_missing(method_symbol, *arguments); end
  def respond_to_missing?(method, include_priv = T.unsafe(nil)); end
  def response_code_allows_body?(c); end
  def split_options(options = T.unsafe(nil)); end
  def validation_context=(_); end

  class << self
    def __callbacks; end
    def __callbacks=(val); end
    def __callbacks?; end
    def _collection_parser; end
    def _collection_parser=(val); end
    def _collection_parser?; end
    def _connection; end
    def _connection=(value); end
    def _connection_defined?; end
    def _create_callbacks; end
    def _create_callbacks=(value); end
    def _destroy_callbacks; end
    def _destroy_callbacks=(value); end
    def _format; end
    def _format=(val); end
    def _format?; end
    def _headers; end
    def _headers=(value); end
    def _headers_defined?; end
    def _password; end
    def _password=(value); end
    def _password_defined?; end
    def _proxy; end
    def _proxy=(value); end
    def _proxy_defined?; end
    def _save_callbacks; end
    def _save_callbacks=(value); end
    def _site; end
    def _site=(value); end
    def _site_defined?; end
    def _update_callbacks; end
    def _update_callbacks=(value); end
    def _user; end
    def _user=(value); end
    def _user_defined?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validation_callbacks; end
    def _validation_callbacks=(value); end
    def _validators; end
    def _validators=(val); end
    def _validators?; end
    def after_create(*args, &block); end
    def after_destroy(*args, &block); end
    def after_save(*args, &block); end
    def after_update(*args, &block); end
    def all(*args); end
    def around_create(*args, &block); end
    def around_destroy(*args, &block); end
    def around_save(*args, &block); end
    def around_update(*args, &block); end
    def auth_type; end
    def auth_type=(auth_type); end
    def before_create(*args, &block); end
    def before_destroy(*args, &block); end
    def before_save(*args, &block); end
    def before_update(*args, &block); end
    def build(attributes = T.unsafe(nil)); end
    def collection_name; end
    def collection_name=(_); end
    def collection_parser; end
    def collection_parser=(parser_instance); end
    def collection_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end
    def connection(refresh = T.unsafe(nil)); end
    def connection_class; end
    def connection_class=(val); end
    def connection_class?; end
    def create(attributes = T.unsafe(nil)); end
    def create!(attributes = T.unsafe(nil)); end
    def delete(custom_method_name, options = T.unsafe(nil)); end
    def element_name; end
    def element_name=(_); end
    def element_path(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end
    def element_url(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end
    def exists?(id, options = T.unsafe(nil)); end
    def find(*arguments); end
    def first(*args); end
    def format; end
    def format=(mime_type_reference_or_format); end
    def format_extension; end
    def get(custom_method_name, options = T.unsafe(nil)); end
    def headers; end
    def include_format_in_path; end
    def include_format_in_path=(val); end
    def include_format_in_path?; end
    def include_root_in_json; end
    def include_root_in_json=(val); end
    def include_root_in_json?; end
    def known_attributes; end
    def last(*args); end
    def logger; end
    def logger=(logger); end
    def new_element_path(prefix_options = T.unsafe(nil)); end
    def open_timeout; end
    def open_timeout=(timeout); end
    def orig_delete(id, options = T.unsafe(nil)); end
    def password; end
    def password=(password); end
    def patch(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
    def post(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
    def prefix(options = T.unsafe(nil)); end
    def prefix=(value = T.unsafe(nil)); end
    def prefix_source; end
    def primary_key; end
    def primary_key=(_); end
    def proxy; end
    def proxy=(proxy); end
    def put(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
    def read_timeout; end
    def read_timeout=(timeout); end
    def reflections; end
    def reflections=(val); end
    def reflections?; end
    def schema(&block); end
    def schema=(the_schema); end
    def set_collection_name(_); end
    def set_element_name(_); end
    def set_prefix(value = T.unsafe(nil)); end
    def set_primary_key(_); end
    def site; end
    def site=(site); end
    def ssl_options; end
    def ssl_options=(options); end
    def timeout; end
    def timeout=(timeout); end
    def user; end
    def user=(user); end
    def where(clauses = T.unsafe(nil)); end

    private

    def check_prefix_options(prefix_options); end
    def create_proxy_uri_from(proxy); end
    def create_site_uri_from(site); end
    def find_every(options); end
    def find_one(options); end
    def find_single(scope, options); end
    def instantiate_collection(collection, original_params = T.unsafe(nil), prefix_options = T.unsafe(nil)); end
    def instantiate_record(record, prefix_options = T.unsafe(nil)); end
    def prefix_parameters; end
    def query_string(options); end
    def split_options(options = T.unsafe(nil)); end
  end
end

module ActiveResource::Callbacks
  extend(::ActiveSupport::Concern)

  include(::ActiveSupport::Callbacks)
  include(::ActiveModel::Validations::Callbacks)

  mixes_in_class_methods(::ActiveSupport::DescendantsTracker)
end

ActiveResource::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

class ActiveResource::ClientError < ::ActiveResource::ConnectionError
end

class ActiveResource::Collection
  include(::Enumerable)

  def initialize(elements = T.unsafe(nil)); end

  def &(*args, &block); end
  def *(*args, &block); end
  def +(*args, &block); end
  def -(*args, &block); end
  def <<(*args, &block); end
  def <=>(*args, &block); end
  def ==(arg); end
  def [](*args, &block); end
  def []=(*args, &block); end
  def all?(*args, &block); end
  def any?(*args, &block); end
  def append(*args, &block); end
  def as_json(*args, &block); end
  def assoc(*args, &block); end
  def at(*args, &block); end
  def blank?(*args, &block); end
  def bsearch(*args, &block); end
  def bsearch_index(*args, &block); end
  def clear(*args, &block); end
  def collect(*args, &block); end
  def collect!; end
  def combination(*args, &block); end
  def compact(*args, &block); end
  def compact!(*args, &block); end
  def concat(*args, &block); end
  def count(*args, &block); end
  def cycle(*args, &block); end
  def deconstruct(*args, &block); end
  def deep_dup(*args, &block); end
  def delete(*args, &block); end
  def delete_at(*args, &block); end
  def delete_if(*args, &block); end
  def difference(*args, &block); end
  def dig(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def each(*args, &block); end
  def each_index(*args, &block); end
  def elements; end
  def elements=(_); end
  def empty?(*args, &block); end
  def eql?(*args, &block); end
  def extract_options!(*args, &block); end
  def fetch(*args, &block); end
  def fifth(*args, &block); end
  def fill(*args, &block); end
  def filter(*args, &block); end
  def filter!(*args, &block); end
  def find_index(*args, &block); end
  def first(*args, &block); end
  def first_or_create(attributes = T.unsafe(nil)); end
  def first_or_initialize(attributes = T.unsafe(nil)); end
  def flatten(*args, &block); end
  def flatten!(*args, &block); end
  def forty_two(*args, &block); end
  def fourth(*args, &block); end
  def from(*args, &block); end
  def hash(*args, &block); end
  def in_groups(*args, &block); end
  def in_groups_of(*args, &block); end
  def include?(*args, &block); end
  def index(*args, &block); end
  def inquiry(*args, &block); end
  def insert(*args, &block); end
  def inspect(*args, &block); end
  def intersection(*args, &block); end
  def join(*args, &block); end
  def keep_if(*args, &block); end
  def last(*args, &block); end
  def length(*args, &block); end
  def map(*args, &block); end
  def map!; end
  def max(*args, &block); end
  def min(*args, &block); end
  def minmax(*args, &block); end
  def none?(*args, &block); end
  def one?(*args, &block); end
  def original_params; end
  def original_params=(_); end
  def pack(*args, &block); end
  def permutation(*args, &block); end
  def pop(*args, &block); end
  def prepend(*args, &block); end
  def pretty_print(*args, &block); end
  def pretty_print_cycle(*args, &block); end
  def product(*args, &block); end
  def push(*args, &block); end
  def rassoc(*args, &block); end
  def reject(*args, &block); end
  def reject!(*args, &block); end
  def repeated_combination(*args, &block); end
  def repeated_permutation(*args, &block); end
  def replace(*args, &block); end
  def resource_class; end
  def resource_class=(_); end
  def reverse(*args, &block); end
  def reverse!(*args, &block); end
  def reverse_each(*args, &block); end
  def rindex(*args, &block); end
  def rotate(*args, &block); end
  def rotate!(*args, &block); end
  def sample(*args, &block); end
  def second(*args, &block); end
  def second_to_last(*args, &block); end
  def select(*args, &block); end
  def select!(*args, &block); end
  def shelljoin(*args, &block); end
  def shift(*args, &block); end
  def shuffle(*args, &block); end
  def shuffle!(*args, &block); end
  def size(*args, &block); end
  def slice(*args, &block); end
  def slice!(*args, &block); end
  def sort(*args, &block); end
  def sort!(*args, &block); end
  def sort_by!(*args, &block); end
  def split(*args, &block); end
  def sum(*args, &block); end
  def take(*args, &block); end
  def take_while(*args, &block); end
  def third(*args, &block); end
  def third_to_last(*args, &block); end
  def to(*args, &block); end
  def to_a; end
  def to_ary(*args, &block); end
  def to_default_s(*args, &block); end
  def to_formatted_s(*args, &block); end
  def to_h(*args, &block); end
  def to_param(*args, &block); end
  def to_query(*args, &block); end
  def to_s(*args, &block); end
  def to_sentence(*args, &block); end
  def to_xml(*args, &block); end
  def to_yaml(*args, &block); end
  def transpose(*args, &block); end
  def union(*args, &block); end
  def uniq(*args, &block); end
  def uniq!(*args, &block); end
  def unshift(*args, &block); end
  def values_at(*args, &block); end
  def where(clauses = T.unsafe(nil)); end
  def without(*args, &block); end
  def zip(*args, &block); end
  def |(*args, &block); end
end

ActiveResource::Collection::SELF_DEFINE_METHODS = T.let(T.unsafe(nil), Array)

class ActiveResource::Connection
  def initialize(site, format = T.unsafe(nil), logger: T.unsafe(nil)); end

  def auth_type; end
  def auth_type=(auth_type); end
  def bearer_token; end
  def bearer_token=(_); end
  def delete(path, headers = T.unsafe(nil)); end
  def format; end
  def format=(_); end
  def get(path, headers = T.unsafe(nil)); end
  def head(path, headers = T.unsafe(nil)); end
  def logger; end
  def logger=(_); end
  def open_timeout; end
  def open_timeout=(_); end
  def password; end
  def password=(_); end
  def patch(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def post(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def proxy; end
  def proxy=(proxy); end
  def put(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end
  def read_timeout; end
  def read_timeout=(_); end
  def site; end
  def site=(site); end
  def ssl_options; end
  def ssl_options=(_); end
  def timeout; end
  def timeout=(_); end
  def user; end
  def user=(_); end

  private

  def apply_ssl_options(http); end
  def auth_attributes_for(uri, request_digest, params); end
  def authorization_header(http_method, uri); end
  def build_request_headers(headers, http_method, uri); end
  def client_nonce; end
  def configure_http(http); end
  def default_header; end
  def digest_auth_header(http_method, uri); end
  def extract_params_from_response; end
  def handle_response(response); end
  def http; end
  def http_format_header(http_method); end
  def legitimize_auth_type(auth_type); end
  def new_http; end
  def request(method, path, *arguments); end
  def response_auth_header; end
  def with_auth; end

  class << self
    def requests; end
  end
end

ActiveResource::Connection::HTTP_FORMAT_HEADER_NAMES = T.let(T.unsafe(nil), Hash)

class ActiveResource::ConnectionError < ::StandardError
  def initialize(response, message = T.unsafe(nil)); end

  def response; end
  def to_s; end
end

module ActiveResource::CustomMethods
  extend(::ActiveSupport::Concern)

  def delete(method_name, options = T.unsafe(nil)); end
  def get(method_name, options = T.unsafe(nil)); end
  def patch(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
  def post(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end
  def put(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

  private

  def custom_method_element_url(method_name, options = T.unsafe(nil)); end
  def custom_method_new_element_url(method_name, options = T.unsafe(nil)); end
end

module ActiveResource::CustomMethods::ClassMethods
  def custom_method_collection_url(method_name, options = T.unsafe(nil)); end
end

class ActiveResource::ForbiddenAccess < ::ActiveResource::ClientError
end

module ActiveResource::Formats
  class << self
    def [](mime_type_reference); end
    def remove_root(data); end
  end
end

module ActiveResource::Formats::JsonFormat
  extend(::ActiveResource::Formats::JsonFormat)

  def decode(json); end
  def encode(hash, options = T.unsafe(nil)); end
  def extension; end
  def mime_type; end
end

module ActiveResource::Formats::XmlFormat
  extend(::ActiveResource::Formats::XmlFormat)

  def decode(xml); end
  def encode(hash, options = T.unsafe(nil)); end
  def extension; end
  def mime_type; end
end

class ActiveResource::HttpMock
  def initialize(site); end

  def delete(path, headers); end
  def get(path, headers); end
  def head(path, headers); end
  def inspect_responses; end
  def patch(path, body, headers); end
  def post(path, body, headers); end
  def put(path, body, headers); end

  class << self
    def delete_responses_to_replace(new_responses); end
    def disable_net_connection!; end
    def enable_net_connection!; end
    def net_connection_disabled?; end
    def net_connection_enabled?; end
    def requests; end
    def reset!; end
    def respond_to(*args); end
    def responses; end
  end
end

class ActiveResource::HttpMock::Responder
  def initialize(responses); end

  def delete(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def get(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def head(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def patch(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def post(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end
  def put(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  private

  def delete_duplicate_responses(request); end
end

class ActiveResource::MethodNotAllowed < ::ActiveResource::ClientError
  def allowed_methods; end
end

class ActiveResource::MissingPrefixParam < ::ArgumentError
end

class ActiveResource::Railtie < ::Rails::Railtie
end

class ActiveResource::Redirection < ::ActiveResource::ConnectionError
  def to_s; end
end

class ActiveResource::ResourceConflict < ::ActiveResource::ClientError
end

class ActiveResource::ResourceGone < ::ActiveResource::ClientError
end

class ActiveResource::ResourceNotFound < ::ActiveResource::ClientError
end

class ActiveResource::SSLError < ::ActiveResource::ConnectionError
  def initialize(message); end

  def to_s; end
end

class ActiveResource::Schema
  def initialize; end

  def attribute(name, type, options = T.unsafe(nil)); end
  def attrs; end
  def attrs=(_); end
  def binary(*args); end
  def boolean(*args); end
  def date(*args); end
  def datetime(*args); end
  def decimal(*args); end
  def float(*args); end
  def integer(*args); end
  def string(*args); end
  def text(*args); end
  def time(*args); end
  def timestamp(*args); end
end

ActiveResource::Schema::KNOWN_ATTRIBUTE_TYPES = T.let(T.unsafe(nil), Array)

class ActiveResource::ServerError < ::ActiveResource::ConnectionError
end

module ActiveResource::Singleton
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActiveResource::Singleton::ClassMethods)

  def destroy; end

  protected

  def create; end
  def update; end

  private

  def singleton_path(options = T.unsafe(nil)); end
end

module ActiveResource::Singleton::ClassMethods
  def find(options = T.unsafe(nil)); end
  def singleton_name; end
  def singleton_name=(_); end
  def singleton_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

  private

  def find_singleton(options); end
end

class ActiveResource::TimeoutError < ::ActiveResource::ConnectionError
  def initialize(message); end

  def to_s; end
end

class ActiveResource::UnauthorizedAccess < ::ActiveResource::ClientError
end

module ActiveResource::VERSION
end

ActiveResource::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

ActiveResource::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

ActiveResource::VERSION::STRING = T.let(T.unsafe(nil), String)

ActiveResource::VERSION::TINY = T.let(T.unsafe(nil), Integer)

module ActiveResource::Validations
  extend(::ActiveSupport::Concern)

  def errors; end
  def load_remote_errors(remote_errors, save_cache = T.unsafe(nil)); end
  def save_with_validation(options = T.unsafe(nil)); end
  def valid?; end
end

module ActiveResource::Associations
  def belongs_to(name, options = T.unsafe(nil)); end
  def defines_belongs_to_finder_method(reflection); end
  def defines_has_many_finder_method(reflection); end
  def defines_has_one_finder_method(reflection); end
  def has_many(name, options = T.unsafe(nil)); end
  def has_one(name, options = T.unsafe(nil)); end
end

module ActiveResource::Associations::Builder
end

class ActiveResource::Associations::Builder::Association
  def initialize(model, name, options); end

  def build; end
  def klass; end
  def macro; end
  def macro=(val); end
  def macro?; end
  def model; end
  def name; end
  def options; end
  def valid_options; end
  def valid_options=(val); end
  def valid_options?; end

  private

  def validate_options; end

  class << self
    def build(model, name, options); end
    def macro; end
    def macro=(val); end
    def macro?; end
    def valid_options; end
    def valid_options=(val); end
    def valid_options?; end
  end
end

class ActiveResource::Associations::Builder::BelongsTo < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
    def valid_options; end
  end
end

class ActiveResource::Associations::Builder::HasMany < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
  end
end

class ActiveResource::Associations::Builder::HasOne < ::ActiveResource::Associations::Builder::Association
  def build; end

  class << self
    def macro; end
  end
end

class ActiveResource::Errors < ::ActiveModel::Errors
  def from_array(messages, save_cache = T.unsafe(nil)); end
  def from_hash(messages, save_cache = T.unsafe(nil)); end
  def from_json(json, save_cache = T.unsafe(nil)); end
  def from_xml(xml, save_cache = T.unsafe(nil)); end
end

class ActiveResource::InvalidRequestError < ::StandardError
end

class ActiveResource::LogSubscriber < ::ActiveSupport::LogSubscriber
  def logger; end
  def request(event); end
end

module ActiveResource::Reflection
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActiveResource::Reflection::ClassMethods)
end

class ActiveResource::Reflection::AssociationReflection
  def initialize(macro, name, options); end

  def class_name; end
  def foreign_key; end
  def klass; end
  def macro; end
  def name; end
  def options; end

  private

  def derive_class_name; end
  def derive_foreign_key; end
end

module ActiveResource::Reflection::ClassMethods
  def create_reflection(macro, name, options); end
end

class ActiveResource::Request
  def initialize(method, path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  def ==(req); end
  def body; end
  def body=(_); end
  def headers; end
  def headers=(_); end
  def method; end
  def method=(_); end
  def path; end
  def path=(_); end
  def to_s; end

  private

  def headers_match?(req); end
end

class ActiveResource::ResourceInvalid < ::ActiveResource::ClientError
end

class ActiveResource::Response
  def initialize(body, message = T.unsafe(nil), headers = T.unsafe(nil)); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def body; end
  def body=(_); end
  def code; end
  def code=(_); end
  def headers; end
  def headers=(_); end
  def message; end
  def message=(_); end
  def success?; end
end

module ThreadsafeAttributes
  mixes_in_class_methods(::ThreadsafeAttributes::ClassMethods)


  private

  def get_threadsafe_attribute(name, main_thread); end
  def get_threadsafe_attribute_by_thread(name, thread); end
  def set_threadsafe_attribute(name, value, main_thread); end
  def set_threadsafe_attribute_by_thread(name, value, thread); end
  def threadsafe_attribute_defined?(name, main_thread); end
  def threadsafe_attribute_defined_by_thread?(name, thread); end

  class << self
    def included(klass); end
  end
end

module ThreadsafeAttributes::ClassMethods
  def threadsafe_attribute(*attrs); end
end
