# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `bin/tapioca gem identity_cache`.


# pkg:gem/identity_cache#lib/identity_cache/version.rb:3
module IdentityCache
  extend ::ActiveSupport::Concern
  extend ::IdentityCache::CacheHash
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex
  include ::IdentityCache::WithPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # pkg:gem/identity_cache#lib/identity_cache.rb:75
  def cache_namespace; end

  # pkg:gem/identity_cache#lib/identity_cache.rb:75
  def cache_namespace=(val); end

  class << self
    # @raise [AlreadyIncludedError]
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:90
    def append_features(base); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:110
    def cache; end

    # Sets the cache adaptor IdentityCache will be using
    #
    # == Parameters
    #
    # +cache_adaptor+ - A ActiveSupport::Cache::Store
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:102
    def cache_backend=(cache_adaptor); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:75
    def cache_namespace; end

    # pkg:gem/identity_cache#lib/identity_cache.rb:75
    def cache_namespace=(val); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:319
    def deprecator; end

    # pkg:gem/identity_cache#lib/identity_cache.rb:315
    def eager_load!; end

    # Cache retrieval and miss resolver primitive; given a key it will try to
    # retrieve the associated value from the cache otherwise it will return the
    # value of the execution of the block.
    #
    # == Parameters
    # +key+ A cache key string
    # +cache_fetcher_options+ A hash of options to pass to the cache backend
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:163
    def fetch(key, cache_fetcher_options = T.unsafe(nil)); end

    # Same as +fetch+, except that it will try a collection of keys, using the
    # multiget operation of the cache adaptor.
    #
    # == Parameters
    # +keys+ A collection or array of key strings
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:186
    def fetch_multi(*keys); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:308
    def fetch_read_only_records; end

    # Sets the attribute fetch_read_only_records
    #
    # @param value the value to set the attribute fetch_read_only_records to.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:86
    def fetch_read_only_records=(_arg0); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:114
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:88
    def logger=(_arg0); end

    # pkg:gem/identity_cache#lib/identity_cache.rb:173
    def map_cached_nil_for(value); end

    # Returns the value of attribute readonly.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:87
    def readonly; end

    # Sets the attribute readonly
    #
    # @param value the value to set the attribute readonly to.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:87
    def readonly=(_arg0); end

    # @return [Boolean]
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:118
    def should_fill_cache?; end

    # pkg:gem/identity_cache#lib/identity_cache.rb:140
    def should_use_cache?; end

    # pkg:gem/identity_cache#lib/identity_cache.rb:177
    def unmap_cached_nil_for(value); end

    # Executes a block with deferred cache expiration, ensuring that the records' (parent,
    # children and attributes) cache expiration is deferred until the block completes. When
    # the block completes, it issues delete_multi calls for all the records and attributes
    # that were marked for expiration.
    #
    # == Parameters:
    # No parameters.
    #
    # == Raises:
    # NestedDeferredCacheExpirationBlockError if a deferred cache expiration block is already active.
    #
    # == Yield:
    # Runs the provided block with deferred cache expiration.
    #
    # == Returns:
    # The result of executing the provided block.
    #
    # == Ensures:
    # Cleans up thread-local variables related to deferred cache expiration regardless
    # of whether the block raises an exception.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:269
    def with_deferred_expiration; end

    # Executes a block with deferred parent expiration, ensuring that the parent
    # records' cache expiration is deferred until the block completes. When the block
    # completes, it triggers expiration of the primary index for the parent records.
    # Raises a NestedDeferredParentBlockError if a deferred parent expiration block
    # is already active on the current thread.
    #
    # == Parameters:
    # No parameters.
    #
    # == Raises:
    # NestedDeferredParentBlockError if a deferred parent expiration block is already active.
    #
    # == Yield:
    # Runs the provided block with deferred parent expiration.
    #
    # == Returns:
    # The result of executing the provided block.
    #
    # == Ensures:
    # Cleans up thread-local variables related to deferred parent expiration regardless
    # of whether the block raises an exception.
    #
    # pkg:gem/identity_cache#lib/identity_cache.rb:228
    def with_deferred_parent_expiration; end

    # pkg:gem/identity_cache#lib/identity_cache.rb:300
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    # pkg:gem/identity_cache#lib/identity_cache.rb:325
    def fetch_in_batches(keys, &block); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:57
class IdentityCache::AlreadyIncludedError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache.rb:59
class IdentityCache::AssociationError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache.rb:53
IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# pkg:gem/identity_cache#lib/identity_cache/belongs_to_caching.rb:4
module IdentityCache::BelongsToCaching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods

  module GeneratedClassMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end

  module GeneratedInstanceMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/belongs_to_caching.rb:12
module IdentityCache::BelongsToCaching::ClassMethods
  # pkg:gem/identity_cache#lib/identity_cache/belongs_to_caching.rb:13
  def cache_belongs_to(association); end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:52
IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)

# pkg:gem/identity_cache#lib/identity_cache/version.rb:5
IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

# pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:6
class IdentityCache::CacheFetcher
  # @return [CacheFetcher] a new instance of CacheFetcher
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:51
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:7
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:7
  def cache_backend=(_arg0); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:68
  def clear; end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:59
  def delete(key); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:63
  def delete_multi(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:82
  def fetch(key, fill_lock_duration: T.unsafe(nil), lock_wait_tries: T.unsafe(nil), &block); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:72
  def fetch_multi(keys, &block); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:55
  def write(key, value); end

  private

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:316
  def add(key, value, expiration_options = T.unsafe(nil)); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:310
  def add_multi(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:281
  def cas_multi(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:277
  def client_id; end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:262
  def fallback_key_expiration_options(fill_lock_duration); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:204
  def fetch_or_take_lock(key, old_lock:, **expiration_options); end

  # @raise [ArgumentError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:108
  def fetch_with_fill_lock(key, fill_lock_duration, lock_wait_tries, &block); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:92
  def fetch_without_fill_lock(key); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:242
  def fill_with_lock(key, data, my_lock, expiration_options); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:258
  def lock_fill_fallback_key(key, lock); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:179
  def mark_fill_failure_on_lock(key, expiration_options); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:191
  def upsert(key, expiration_options = T.unsafe(nil)); end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:9
IdentityCache::CacheFetcher::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:11
class IdentityCache::CacheFetcher::FillLock
  # @return [FillLock] a new instance of FillLock
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:29
  def initialize(client_id:, data_version:); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:46
  def ==(other); end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:34
  def cache_value; end

  # Returns the value of attribute client_id.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:27
  def client_id; end

  # Returns the value of attribute data_version.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:27
  def data_version; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:42
  def fill_failed?; end

  # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:38
  def mark_failed; end

  class << self
    # @return [Boolean]
    #
    # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:22
    def cache_value?(cache_value); end

    # @raise [ArgumentError]
    #
    # pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:16
    def from_cache(marker, client_id, data_version); end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:13
IdentityCache::CacheFetcher::FillLock::FAILED_CLIENT_ID = T.let(T.unsafe(nil), String)

# pkg:gem/identity_cache#lib/identity_cache/cache_fetcher.rb:12
IdentityCache::CacheFetcher::FillLock::FILL_LOCKED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/identity_cache#lib/identity_cache/cache_hash.rb:23
module IdentityCache::CacheHash
  # pkg:gem/identity_cache#lib/identity_cache/cache_hash.rb:26
  def memcache_hash(key); end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_invalidation.rb:4
module IdentityCache::CacheInvalidation
  # pkg:gem/identity_cache#lib/identity_cache/cache_invalidation.rb:7
  def reload(*_arg0); end

  private

  # pkg:gem/identity_cache#lib/identity_cache/cache_invalidation.rb:14
  def clear_cached_associations; end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_invalidation.rb:5
IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

# pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:4
module IdentityCache::CacheKeyGeneration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods

  class << self
    # pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:30
    def denormalized_schema_hash(klass); end

    # pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:13
    def denormalized_schema_string(klass); end

    # pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:9
    def schema_to_string(columns); end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:36
module IdentityCache::CacheKeyGeneration::ClassMethods
  # pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:37
  def rails_cache_key_namespace; end
end

# pkg:gem/identity_cache#lib/identity_cache/cache_key_generation.rb:6
IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

# A generic cache key loader that supports different types of
# cache fetchers, each of which can use their own cache key
# format and have their own cache miss resolvers.
#
# Here is the interface of a cache fetcher in the
# [ruby-signature](https://github.com/ruby/ruby-signature)'s
# format.
#
# ```
# interface _CacheFetcher[DbKey, DbValue, CacheableValue]
#   def cache_key: (DbKey) -> String
#   def cache_encode: (DbValue) -> CacheableValue
#   def cache_decode: (CacheableValue) -> DbValue
#   def load_one_from_db: (DbKey) -> DbValue
#   def load_multi_from_db: (Array[DbKey]) -> Hash[DbKey, DbValue]
# end
# ```
#
# pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:21
module IdentityCache::CacheKeyLoader
  class << self
    # Load a single key for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key Reference to what to load from the database.
    # @return The database value corresponding to the database key.
    #
    # pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:28
    def load(cache_fetcher, db_key, cache_fetcher_options = T.unsafe(nil)); end

    # Load multiple keys for multiple cache fetchers
    #
    # pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:51
    def load_batch(cache_fetcher_to_db_keys_hash); end

    # Load multiple keys for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key [Array] Reference to what to load from the database.
    # @return [Hash] A hash mapping each database key to its corresponding value
    #
    # pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:46
    def load_multi(cache_fetcher, db_keys); end

    private

    # pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:99
    def cache_fetch_multi(cache_keys); end

    # pkg:gem/identity_cache#lib/identity_cache/cache_key_loader.rb:106
    def resolve_multi_on_miss(cache_fetcher, unresolved_cache_keys, cache_key_to_db_key_hash, resolve_miss_result, db_keys_buffer: T.unsafe(nil)); end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/cached.rb:4
module IdentityCache::Cached; end

# pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:5
class IdentityCache::Cached::Association
  include ::IdentityCache::Cached::EmbeddedFetching

  # @return [Association] a new instance of Association
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:8
  def initialize(name, reflection:); end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:17
  def build; end

  # Returns the value of attribute cached_accessor_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:15
  def cached_accessor_name; end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:29
  def clear(_record); end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:41
  def embedded?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:45
  def embedded_by_reference?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:49
  def embedded_recursively?; end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:33
  def fetch(_records); end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:37
  def fetch_async(_load_strategy, _records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:53
  def inverse_name; end

  # Returns the value of attribute name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:15
  def name; end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:21
  def read(_record); end

  # Returns the value of attribute records_variable_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:15
  def records_variable_name; end

  # Returns the value of attribute reflection.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:15
  def reflection; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:57
  def validate; end

  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/association.rb:25
  def write(_record, _value); end
end

# @abstract
#
# pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:6
class IdentityCache::Cached::Attribute
  # @return [Attribute] a new instance of Attribute
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:9
  def initialize(model, attribute_or_proc, alias_name, key_fields, unique); end

  # Returns the value of attribute alias_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:7
  def alias_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:21
  def attribute; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:118
  def cache_decode(db_value); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:115
  def cache_encode(db_value); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:66
  def cache_key(index_key); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:37
  def expire(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:25
  def fetch(db_key); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:78
  def fetch_multi(keys); end

  # Returns the value of attribute key_fields.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:7
  def key_fields; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:94
  def load_multi_from_db(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:71
  def load_one_from_db(key); end

  # Returns the value of attribute model.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:7
  def model; end

  # Returns the value of attribute unique.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:7
  def unique; end

  private

  # @abstract
  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:143
  def cache_key_from_key_values(_key_values); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:151
  def cache_key_prefix; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:123
  def cast_db_key(_index_key); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:181
  def fetch_method_suffix; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:147
  def field_types; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:133
  def load_from_db_where_conditions(_index_key_or_keys); end

  # @abstract
  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:138
  def load_multi_rows(_index_keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:161
  def new_cache_key(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:166
  def old_cache_key(record); end

  # @abstract
  # @raise [NotImplementedError]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute.rb:128
  def unhashed_values_cache_key_string(_index_key); end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:5
class IdentityCache::Cached::AttributeByMulti < ::IdentityCache::Cached::Attribute
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:6
  def build; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:53
  def cache_key_from_key_values(index_key); end

  private

  # Attribute method overrides
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:24
  def cast_db_key(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:35
  def load_from_db_where_conditions(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:39
  def load_multi_rows(keys); end

  # Helper methods
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:57
  def load_multi_rows_query(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:31
  def unhashed_values_cache_key_string(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_multi.rb:117
  def unsorted_model; end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:5
class IdentityCache::Cached::AttributeByOne < ::IdentityCache::Cached::Attribute
  # @return [AttributeByOne] a new instance of AttributeByOne
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:8
  def initialize(*_arg0); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:13
  def build; end

  # Returns the value of attribute key_field.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:6
  def key_field; end

  private

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:47
  def cache_key_from_key_values(key_values); end

  # Attribute method overrides
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:31
  def cast_db_key(key); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:39
  def load_from_db_where_conditions(key_values); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:43
  def load_multi_rows(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/attribute_by_one.rb:35
  def unhashed_values_cache_key_string(key); end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:5
class IdentityCache::Cached::BelongsTo < ::IdentityCache::Cached::Association
  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:8
  def build; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:25
  def clear(record); end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:102
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:98
  def embedded_recursively?; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:35
  def fetch(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:39
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute records_variable_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:6
  def records_variable_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/belongs_to.rb:31
  def write(owner_record, associated_record); end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/embedded_fetching.rb:5
module IdentityCache::Cached::EmbeddedFetching
  private

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/embedded_fetching.rb:36
  def embedded_fetched?(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/embedded_fetching.rb:8
  def fetch_embedded(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/embedded_fetching.rb:12
  def fetch_embedded_async(load_strategy, records); end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/prefetcher.rb:5
module IdentityCache::Cached::Prefetcher
  class << self
    # pkg:gem/identity_cache#lib/identity_cache/cached/prefetcher.rb:9
    def prefetch(klass, associations, records, load_strategy: T.unsafe(nil)); end

    private

    # pkg:gem/identity_cache#lib/identity_cache/cached/prefetcher.rb:39
    def fetch_association(load_strategy, klass, association, records, &block); end

    # pkg:gem/identity_cache#lib/identity_cache/cached/prefetcher.rb:54
    def preload_records(records, association); end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/prefetcher.rb:6
IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

# pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:5
class IdentityCache::Cached::PrimaryIndex
  # @return [PrimaryIndex] a new instance of PrimaryIndex
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:8
  def initialize(model); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:81
  def cache_decode(cache_value); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:77
  def cache_encode(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:55
  def cache_key(id); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:46
  def expire(id); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:12
  def fetch(id, cache_fetcher_options); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:34
  def fetch_multi(ids); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:68
  def load_multi_from_db(ids); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:59
  def load_one_from_db(id); end

  # Returns the value of attribute model.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:6
  def model; end

  private

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:95
  def build_query(id_or_ids); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:99
  def cache_key_prefix; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:87
  def cast_id(id); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/primary_index.rb:91
  def id_column; end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:5
module IdentityCache::Cached::Recursive; end

# pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:6
class IdentityCache::Cached::Recursive::Association < ::IdentityCache::Cached::Association
  # @return [Association] a new instance of Association
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:7
  def initialize(name, reflection:); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:14
  def build; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:53
  def clear(record); end

  # Returns the value of attribute dehydrated_variable_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:12
  def dehydrated_variable_name; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:69
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:73
  def embedded_recursively?; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:59
  def fetch(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:63
  def fetch_async(load_strategy, records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:25
  def read(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:48
  def set_with_inverse(record, association_target); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:44
  def write(record, association_target); end

  private

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:104
  def embedded_fetched?(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:95
  def hydrate_association_target(associated_class, dehydrated_value); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/recursive/association.rb:79
  def set_inverse(record, association_target); end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/recursive/has_many.rb:6
class IdentityCache::Cached::Recursive::HasMany < ::IdentityCache::Cached::Recursive::Association; end

# pkg:gem/identity_cache#lib/identity_cache/cached/recursive/has_one.rb:6
class IdentityCache::Cached::Recursive::HasOne < ::IdentityCache::Cached::Recursive::Association; end

# pkg:gem/identity_cache#lib/identity_cache/cached/reference/association.rb:5
module IdentityCache::Cached::Reference; end

# pkg:gem/identity_cache#lib/identity_cache/cached/reference/association.rb:6
class IdentityCache::Cached::Reference::Association < ::IdentityCache::Cached::Association
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/association.rb:7
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/association.rb:11
  def embedded_recursively?; end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:6
class IdentityCache::Cached::Reference::HasMany < ::IdentityCache::Cached::Reference::Association
  # @return [HasMany] a new instance of HasMany
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:7
  def initialize(name, reflection:); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:15
  def build; end

  # Returns the value of attribute cached_ids_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:13
  def cached_ids_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:44
  def clear(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:52
  def fetch(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:56
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute ids_variable_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:13
  def ids_variable_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:36
  def read(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:40
  def write(record, ids); end

  private

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:87
  def embedded_fetched?(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:100
  def ids_cached_reader_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:96
  def ids_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_many.rb:92
  def singular_name; end
end

# pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:6
class IdentityCache::Cached::Reference::HasOne < ::IdentityCache::Cached::Reference::Association
  # @return [HasOne] a new instance of HasOne
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:7
  def initialize(name, reflection:); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:15
  def build; end

  # Returns the value of attribute cached_id_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:13
  def cached_id_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:45
  def clear(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:53
  def fetch(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:57
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute id_variable_name.
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:13
  def id_variable_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:37
  def read(record); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:41
  def write(record, id); end

  private

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:86
  def embedded_fetched?(records); end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:95
  def id_cached_reader_name; end

  # pkg:gem/identity_cache#lib/identity_cache/cached/reference/has_one.rb:91
  def id_name; end
end

# pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:4
module IdentityCache::ConfigurationDSL
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:17
module IdentityCache::ConfigurationDSL::ClassMethods
  # Will cache a single attribute on its own blob, it will add a
  # fetch_attribute_by_id (or the value of the by option).
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     cache_attribute :quantity, by: :name
  #     cache_attribute :quantity, by: [:name, :vendor]
  #   end
  #
  # == Parameters
  # +attribute+ Symbol with the name of the attribute being cached
  #
  # == Options
  #
  # * by: Other attribute or attributes in the model to keep values indexed. Default is :id
  # * unique: if the index would only have unique values. Default is true
  #
  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:119
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # The embed option, if set, will make IdentityCache keep the association
  # values in the same cache entry as the parent.
  #
  # Embedded associations are more effective in offloading database work,
  # however they will increase the size of the cache entries and make the
  # whole entry expire when any of the embedded members change.
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     has_many :options
  #     has_many :orders
  #     cache_has_many :options, embed: :ids
  #     cache_has_many :orders
  #   end
  #
  # == Parameters
  # +association+ Name of the association being cached as a symbol
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated records
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:ids` (the default), it will only embed the ids for the associated
  #   records.
  #
  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:45
  def cache_has_many(association, embed: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # IdentityCache will keep the association values in the same cache entry
  # as the parent.
  #
  # == Example:
  #   class Product
  #     cache_has_one :store, embed: true
  #     cache_has_one :vendor, embed: :id
  #   end
  #
  # == Parameters
  # +association+ Symbol with the name of the association being cached
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated record
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:id`, it will only embed the id for the associated record.
  #
  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:83
  def cache_has_one(association, embed:); end

  private

  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:125
  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end

  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:144
  def check_association_for_caching(association); end

  # pkg:gem/identity_cache#lib/identity_cache/configuration_dsl.rb:135
  def ensure_base_model; end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:54
IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/identity_cache#lib/identity_cache.rb:55
IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)

# pkg:gem/identity_cache#lib/identity_cache.rb:71
class IdentityCache::DerivedModelError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache/encoder.rb:4
module IdentityCache::Encoder
  class << self
    # pkg:gem/identity_cache#lib/identity_cache/encoder.rb:17
    def decode(coder, klass); end

    # pkg:gem/identity_cache#lib/identity_cache/encoder.rb:9
    def encode(record); end

    private

    # pkg:gem/identity_cache#lib/identity_cache/encoder.rb:27
    def coder_from_record(record, klass); end

    # pkg:gem/identity_cache#lib/identity_cache/encoder.rb:58
    def embedded_coder(record, _association, cached_association); end

    # pkg:gem/identity_cache#lib/identity_cache/encoder.rb:70
    def record_from_coder(coder, klass); end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/encoder.rb:5
IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)

# pkg:gem/identity_cache#lib/identity_cache/encoder.rb:6
IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)

# pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:4
class IdentityCache::ExpiryHook
  # @return [ExpiryHook] a new instance of ExpiryHook
  #
  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:5
  def initialize(cached_association); end

  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:9
  def install; end

  private

  # Returns the value of attribute cached_association.
  #
  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:17
  def cached_association; end

  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:31
  def child_class; end

  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:23
  def inverse_name; end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:19
  def only_on_foreign_key_change?; end

  # pkg:gem/identity_cache#lib/identity_cache/expiry_hook.rb:27
  def parent_class; end
end

# pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:4
class IdentityCache::FallbackFetcher
  # @return [FallbackFetcher] a new instance of FallbackFetcher
  #
  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:7
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:5
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:5
  def cache_backend=(_arg0); end

  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:19
  def clear; end

  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:15
  def delete(key); end

  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:40
  def fetch(key, **cache_fetcher_options); end

  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:23
  def fetch_multi(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/fallback_fetcher.rb:11
  def write(key, value); end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:61
class IdentityCache::InverseAssociationError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache/load_strategy/load_request.rb:4
module IdentityCache::LoadStrategy; end

# pkg:gem/identity_cache#lib/identity_cache/load_strategy/eager.rb:5
module IdentityCache::LoadStrategy::Eager
  extend ::IdentityCache::LoadStrategy::Eager

  # @yield [lazy_loader]
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/eager.rb:20
  def lazy_load; end

  # @yield [CacheKeyLoader.load(cache_fetcher, db_key)]
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/eager.rb:8
  def load(cache_fetcher, db_key); end

  # @yield [CacheKeyLoader.load_batch(db_keys_by_cache_fetcher)]
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/eager.rb:16
  def load_batch(db_keys_by_cache_fetcher); end

  # @yield [CacheKeyLoader.load_multi(cache_fetcher, db_keys)]
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/eager.rb:12
  def load_multi(cache_fetcher, db_keys); end
end

# pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:5
class IdentityCache::LoadStrategy::Lazy
  # @return [Lazy] a new instance of Lazy
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:6
  def initialize; end

  # @yield [_self]
  # @yieldparam _self [IdentityCache::LoadStrategy::Lazy] the object that the method was called on
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:45
  def lazy_load; end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:10
  def load(cache_fetcher, db_key); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:32
  def load_batch(db_keys_by_cache_fetcher); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:17
  def load_multi(cache_fetcher, db_keys, &callback); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:50
  def load_now; end

  private

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/lazy.rb:60
  def load_pending(pending_loads); end
end

# pkg:gem/identity_cache#lib/identity_cache/load_strategy/load_request.rb:5
class IdentityCache::LoadStrategy::LoadRequest
  # @return [LoadRequest] a new instance of LoadRequest
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/load_request.rb:8
  def initialize(db_keys, callback); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/load_request.rb:13
  def after_load(results); end

  # Returns the value of attribute db_keys.
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/load_request.rb:6
  def db_keys; end
end

# pkg:gem/identity_cache#lib/identity_cache/load_strategy/multi_load_request.rb:5
class IdentityCache::LoadStrategy::MultiLoadRequest
  # @return [MultiLoadRequest] a new instance of MultiLoadRequest
  #
  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/multi_load_request.rb:6
  def initialize(load_requests); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/multi_load_request.rb:14
  def after_load(all_results); end

  # pkg:gem/identity_cache#lib/identity_cache/load_strategy/multi_load_request.rb:10
  def db_keys; end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:73
class IdentityCache::LockWaitTimeout < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:7
class IdentityCache::MemoizedCacheProxy
  # @return [MemoizedCacheProxy] a new instance of MemoizedCacheProxy
  #
  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:10
  def initialize(cache_adaptor = T.unsafe(nil)); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:15
  def cache_backend=(cache_adaptor); end

  # Returns the value of attribute cache_fetcher.
  #
  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:8
  def cache_fetcher; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:143
  def clear; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:60
  def delete(key); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:73
  def delete_multi(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:83
  def fetch(key, cache_fetcher_options = T.unsafe(nil), &block); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:112
  def fetch_multi(*keys); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:40
  def memoized_key_values; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:44
  def with_memoization; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:52
  def write(key, value); end

  private

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:199
  def clear_memoization; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:162
  def fetch_memoized(key); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:171
  def fetch_multi_memoized(keys); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:191
  def instrument_duration(payload, key); end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:207
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:203
  def memoizing?; end

  # pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:155
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

# pkg:gem/identity_cache#lib/identity_cache/memoized_cache_proxy.rb:152
IdentityCache::MemoizedCacheProxy::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# pkg:gem/identity_cache#lib/identity_cache.rb:65
class IdentityCache::NestedDeferredCacheExpirationBlockError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache.rb:63
class IdentityCache::NestedDeferredParentBlockError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:4
module IdentityCache::ParentModelExpiration
  include ::ArTransactionChanges
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:58
  def add_parents_to_cache_expiry_set(parents_to_expire); end

  # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:65
  def add_record_to_cache_expiry_set(parents_to_expire, record); end

  # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:45
  def expire_parent_caches; end

  # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:71
  def parents_to_expire_on_changes(parents_to_expire, association_name, cached_associations); end

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:105
  def should_expire_identity_cache_parent?(foreign_key, only_on_foreign_key_change); end

  class << self
    # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:9
    def add_parent_expiry_hook(cached_association); end

    # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:14
    def install_all_pending_parent_expiry_hooks; end

    # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:24
    def install_pending_parent_expiry_hooks(model); end

    private

    # pkg:gem/identity_cache#lib/identity_cache/parent_model_expiration.rb:35
    def lazy_hooks; end
  end

  module GeneratedClassMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/query_api.rb:4
module IdentityCache::QueryAPI
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods

  # Override the method that is used to call after_commit callbacks so that we can
  # expire the caches before other after_commit callbacks. This way we can avoid stale
  # cache reads that happen from the ordering of callbacks. For example, if an after_commit
  # callback enqueues a background job, then we don't want it to be possible for the
  # background job to run and load data from the cache before it is invalidated.
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:168
  def _run_commit_callbacks; end

  # Invalidate the cache data associated with the record. Returns `true` on success,
  # `false` otherwise.
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:177
  def expire_cache; end

  # @api private
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:185
  def was_new_record?; end

  private

  # Even if we have problems with some attributes, carry over the results and expire
  # all possible attributes without array allocation.
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:194
  def expire_attribute_indexes; end
end

# pkg:gem/identity_cache#lib/identity_cache/query_api.rb:7
module IdentityCache::QueryAPI::ClassMethods
  # @api private
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:19
  def all_cached_associations; end

  # @api private
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:14
  def cached_association(name); end

  # Prefetches cached associations on a collection of records
  #
  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:9
  def prefetch_associations(includes, records); end

  private

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:139
  def cache_fetch_includes; end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:32
  def check_association_scope(association_name); end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:122
  def each_id_embedded_association; end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:135
  def embedded_associations; end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:43
  def preload_id_embedded_association(records, cached_association); end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:25
  def raise_if_scoped; end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:114
  def readonly_copy(record_or_records); end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:108
  def readonly_record_copy(record); end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:131
  def recursively_embedded_associations; end

  # pkg:gem/identity_cache#lib/identity_cache/query_api.rb:69
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

# pkg:gem/identity_cache#lib/identity_cache/railtie.rb:4
class IdentityCache::Railtie < ::Rails::Railtie; end

# pkg:gem/identity_cache#lib/identity_cache/record_not_found.rb:4
class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound; end

# pkg:gem/identity_cache#lib/identity_cache/should_use_cache.rb:4
module IdentityCache::ShouldUseCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods

  private

  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/should_use_cache.rb:19
  def loaded_by_idc?; end

  # pkg:gem/identity_cache#lib/identity_cache/should_use_cache.rb:15
  def mark_as_loaded_by_idc; end
end

# pkg:gem/identity_cache#lib/identity_cache/should_use_cache.rb:7
module IdentityCache::ShouldUseCache::ClassMethods
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/should_use_cache.rb:8
  def should_use_cache?; end
end

# pkg:gem/identity_cache#lib/identity_cache.rb:69
class IdentityCache::UnsupportedAssociationError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache.rb:67
class IdentityCache::UnsupportedScopeError < ::StandardError; end

# pkg:gem/identity_cache#lib/identity_cache/version.rb:4
IdentityCache::VERSION = T.let(T.unsafe(nil), String)

# pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:4
module IdentityCache::WithPrimaryIndex
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:9
  def expire_cache; end

  # @api private
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:16
  def expire_primary_index; end

  # @api private
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:21
  def primary_cache_index_key; end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:25
module IdentityCache::WithPrimaryIndex::ClassMethods
  # Declares a new index in the cache for the class where IdentityCache was
  # included.
  #
  # IdentityCache will add a fetch_by_field1_and_field2_and_...field and
  # fetch_multi_by_field1_and_field2_and_...field for every index.
  #
  # == Example:
  #
  #  class Product
  #    include IdentityCache
  #    cache_index :name, :vendor
  #  end
  #
  # Will add:
  #
  #   Product.fetch_by_name_and_vendor
  #   Product.fetch_multi_by_name_and_vendor
  #
  # == Parameters
  #
  # +fields+ Array of symbols or strings representing the fields in the index
  #
  # == Options
  # * unique: if the index would only have unique values. Default is false
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:60
  def cache_index(*fields, unique: T.unsafe(nil)); end

  # @api private
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:27
  def cached_primary_index; end

  # Similar to ActiveRecord::Base#exists? will return true if the id can be
  # found in the cache or in the DB.
  #
  # @return [Boolean]
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:99
  def exists_with_identity_cache?(id); end

  # Invalidates the primary cache index for the associated record. Will not invalidate cached attributes.
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:162
  def expire_primary_key_cache_index(id); end

  # Fetch the record by its primary key from the cache or read from
  # the database and fill the cache on a cache miss. This behaves like
  # `readonly.find(id)` being called on the model.
  #
  # @param fill_lock_duration [Float] If provided, take a fill lock around cache fills
  #   and wait for this duration for cache to be filled when reading a lock provided
  #   by another client. Defaults to not setting the fill lock and trying to fill the
  #   cache from the database regardless of the presence of another client's fill lock.
  #   Set this to just above the typical amount of time it takes to do a cache fill.
  # @param id Primary key value for the record to fetch.
  # @param includes [Hash|Array|Symbol] Cached associations to prefetch from
  #   the cache on the returned record
  # @param lock_wait_tries [Integer] Only applicable if fill_lock_duration is provided,
  #   in which case it specifies the number of times to do a lock wait. After the first
  #   lock wait it will try to take the lock, so will only do following lock waits due
  #   to another client taking the lock first. If another lock wait would be needed after
  #   reaching the limit, then a `LockWaitTimeout` exception is raised. Default is 2. Use
  #   this to control the maximum total lock wait duration
  #   (`lock_wait_tries * fill_lock_duration`).
  # @raise [ActiveRecord::RecordNotFound] if the record isn't found
  # @raise [LockWaitTimeout] Timeout after waiting `lock_wait_tries * fill_lock_duration`
  #   seconds for `lock_wait_tries` other clients to fill the cache.
  # @return [self] An instance of this model for the record with the specified id
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:142
  def fetch(id, **options); end

  # Fetch the record by its primary key from the cache or read from
  # the database and fill the cache on a cache miss. This behaves like
  # `where(id: id).readonly.first` being called on the model.
  #
  # @param fill_lock_duration [Float] If provided, take a fill lock around cache fills
  #   and wait for this duration for cache to be filled when reading a lock provided
  #   by another client. Defaults to not setting the fill lock and trying to fill the
  #   cache from the database regardless of the presence of another client's fill lock.
  #   Set this to just above the typical amount of time it takes to do a cache fill.
  # @param id Primary key value for the record to fetch.
  # @param includes [Hash|Array|Symbol] Cached associations to prefetch from
  #   the cache on the returned record
  # @param lock_wait_tries [Integer] Only applicable if fill_lock_duration is provided,
  #   in which case it specifies the number of times to do a lock wait. After the first
  #   lock wait it will try to take the lock, so will only do following lock waits due
  #   to another client taking the lock first. If another lock wait would be needed after
  #   reaching the limit, then a `LockWaitTimeout` exception is raised. Default is 2. Use
  #   this to control the maximum total lock wait duration
  #   (`lock_wait_tries * fill_lock_duration`).
  # @raise [LockWaitTimeout] Timeout after waiting `lock_wait_tries * fill_lock_duration`
  #   seconds for `lock_wait_tries` other clients to fill the cache.
  # @return [self|nil] An instance of this model for the record with the specified id or
  #   `nil` if no record with this `id` exists in the database
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:126
  def fetch_by_id(id, includes: T.unsafe(nil), **cache_fetcher_options); end

  # Default fetcher added to the model on inclusion, if behaves like
  # ActiveRecord::Base.find_all_by_id
  #
  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:150
  def fetch_multi(*ids, includes: T.unsafe(nil)); end

  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:31
  def primary_cache_index_enabled; end

  private

  # pkg:gem/identity_cache#lib/identity_cache/with_primary_index.rb:168
  def inherited(subclass); end
end

# pkg:gem/identity_cache#lib/identity_cache/without_primary_index.rb:4
module IdentityCache::WithoutPrimaryIndex
  include ::ArTransactionChanges
  include ::IdentityCache::CacheInvalidation
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods

  class << self
    # @raise [AlreadyIncludedError]
    #
    # pkg:gem/identity_cache#lib/identity_cache/without_primary_index.rb:17
    def append_features(base); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# pkg:gem/identity_cache#lib/identity_cache/without_primary_index.rb:29
module IdentityCache::WithoutPrimaryIndex::ClassMethods
  # pkg:gem/identity_cache#lib/identity_cache/without_primary_index.rb:30
  def primary_cache_index_enabled; end
end
