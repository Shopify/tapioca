# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ruby-lsp` gem.
# Please instead update this file by running `bin/tapioca gem ruby-lsp`.

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#4
module RubyIndexer
  class << self
    # source://ruby-lsp//lib/ruby_indexer/ruby_indexer.rb#21
    sig { returns(::RubyIndexer::Configuration) }
    def configuration; end
  end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#5
class RubyIndexer::Collector
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#11
  sig { params(index: ::RubyIndexer::Index, parse_result: ::Prism::ParseResult, file_path: ::String).void }
  def initialize(index, parse_result, file_path); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#27
  sig { params(node: ::Prism::Node).void }
  def collect(node); end

  private

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#287
  sig { params(node: ::Prism::ClassNode).void }
  def add_class_entry(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#226
  sig do
    params(
      node: T.any(::Prism::ConstantAndWriteNode, ::Prism::ConstantOperatorWriteNode, ::Prism::ConstantOrWriteNode, ::Prism::ConstantPathAndWriteNode, ::Prism::ConstantPathOperatorWriteNode, ::Prism::ConstantPathOrWriteNode, ::Prism::ConstantPathTargetNode, ::Prism::ConstantPathWriteNode, ::Prism::ConstantTargetNode, ::Prism::ConstantWriteNode),
      name: ::String,
      value: T.nilable(::Prism::Node)
    ).void
  end
  def add_constant(node, name, value = T.unsafe(nil)); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#272
  sig { params(node: ::Prism::ModuleNode).void }
  def add_module_entry(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#316
  sig { params(node: ::Prism::Node).returns(T::Array[::String]) }
  def collect_comments(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#338
  sig { returns(T.nilable(::RubyIndexer::Entry::Namespace)) }
  def current_namespace; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#348
  sig { params(name: ::String).returns(::String) }
  def fully_qualify_name(name); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#357
  sig { params(node: ::Prism::CallNode, reader: T::Boolean, writer: T::Boolean).void }
  def handle_attribute(node, reader:, writer:); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#142
  sig { params(node: ::Prism::CallNode).void }
  def handle_call_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#126
  sig { params(node: ::Prism::ConstantPathAndWriteNode).void }
  def handle_constant_path_and_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#116
  sig { params(node: ::Prism::ConstantPathOperatorWriteNode).void }
  def handle_constant_path_operator_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#106
  sig { params(node: ::Prism::ConstantPathOrWriteNode).void }
  def handle_constant_path_or_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#96
  sig { params(node: ::Prism::ConstantPathWriteNode).void }
  def handle_constant_path_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#136
  sig { params(node: ::Prism::ConstantWriteNode).void }
  def handle_constant_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#158
  sig { params(node: ::Prism::DefNode).void }
  def handle_def_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#76
  sig { params(node: ::Prism::MultiWriteNode).void }
  def handle_multi_write_node(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#184
  sig { params(node: ::Prism::CallNode).void }
  def handle_private_constant(node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#343
  sig { params(namespace: ::RubyIndexer::Entry::Namespace).void }
  def push_namespace(namespace); end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/collector.rb#8
RubyIndexer::Collector::LEAVE_EVENT = T.let(T.unsafe(nil), Object)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#5
class RubyIndexer::Configuration
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#20
  sig { void }
  def initialize; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#61
  sig { returns(T::Array[::RubyIndexer::IndexablePath]) }
  def indexables; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#47
  sig { void }
  def load_config; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#157
  sig { returns(::Regexp) }
  def magic_comment_regex; end

  private

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#179
  sig { params(config: T::Hash[::String, T.untyped]).void }
  def apply_config(config); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#188
  sig { returns(T::Array[::String]) }
  def initial_excluded_gems; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#164
  sig { params(config: T::Hash[::String, T.untyped]).void }
  def validate_config!(config); end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/configuration.rb#8
RubyIndexer::Configuration::CONFIGURATION_SCHEMA = T.let(T.unsafe(nil), Hash)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#5
class RubyIndexer::Entry
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#24
  sig { params(name: ::String, file_path: ::String, location: ::Prism::Location, comments: T::Array[::String]).void }
  def initialize(name, file_path, location, comments); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#18
  sig { returns(T::Array[::String]) }
  def comments; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#33
  sig { returns(::String) }
  def file_name; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#12
  sig { returns(::String) }
  def file_path; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#15
  sig { returns(::Prism::Location) }
  def location; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#9
  sig { returns(::String) }
  def name; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#21
  sig { returns(::Symbol) }
  def visibility; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#21
  def visibility=(_arg0); end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#178
class RubyIndexer::Entry::Accessor < ::RubyIndexer::Entry::Member
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#182
  sig { override.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end
end

# Alias represents a resolved alias, which points to an existing constant target
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#345
class RubyIndexer::Entry::Alias < ::RubyIndexer::Entry
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#352
  sig { params(target: ::String, unresolved_alias: ::RubyIndexer::Entry::UnresolvedAlias).void }
  def initialize(target, unresolved_alias); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#349
  sig { returns(::String) }
  def target; end
end

# A block method parameter, e.g. `def foo(&block)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#142
class RubyIndexer::Entry::BlockParameter < ::RubyIndexer::Entry::Parameter
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#146
  sig { override.returns(::Symbol) }
  def decorated_name; end
end

# A block method parameter, e.g. `def foo(&block)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#143
RubyIndexer::Entry::BlockParameter::DEFAULT_NAME = T.let(T.unsafe(nil), Symbol)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#52
class RubyIndexer::Entry::Class < ::RubyIndexer::Entry::Namespace
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#69
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      parent_class: T.nilable(::String)
    ).void
  end
  def initialize(name, file_path, location, comments, parent_class); end

  # The unresolved name of the parent class. This may return `nil`, which indicates the lack of an explicit parent
  # and therefore ::Object is the correct parent class
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#58
  sig { returns(T.nilable(::String)) }
  def parent_class; end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#75
class RubyIndexer::Entry::Constant < ::RubyIndexer::Entry; end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#304
class RubyIndexer::Entry::InstanceMethod < ::RubyIndexer::Entry::Method; end

# An required keyword method parameter, e.g. `def foo(a:)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#106
class RubyIndexer::Entry::KeywordParameter < ::RubyIndexer::Entry::Parameter
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#108
  sig { override.returns(::Symbol) }
  def decorated_name; end
end

# A keyword rest method parameter, e.g. `def foo(**a)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#132
class RubyIndexer::Entry::KeywordRestParameter < ::RubyIndexer::Entry::Parameter
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#136
  sig { override.returns(::Symbol) }
  def decorated_name; end
end

# A keyword rest method parameter, e.g. `def foo(**a)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#133
RubyIndexer::Entry::KeywordRestParameter::DEFAULT_NAME = T.let(T.unsafe(nil), Symbol)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#151
class RubyIndexer::Entry::Member < ::RubyIndexer::Entry
  abstract!

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#169
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      owner: T.nilable(::RubyIndexer::Entry::Namespace)
    ).void
  end
  def initialize(name, file_path, location, comments, owner); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#158
  sig { returns(T.nilable(::RubyIndexer::Entry::Namespace)) }
  def owner; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#175
  sig { abstract.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#189
class RubyIndexer::Entry::Method < ::RubyIndexer::Entry::Member
  abstract!

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#208
  sig do
    params(
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String],
      parameters_node: T.nilable(::Prism::ParametersNode),
      owner: T.nilable(::RubyIndexer::Entry::Namespace)
    ).void
  end
  def initialize(name, file_path, location, comments, parameters_node, owner); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#196
  sig { override.returns(T::Array[::RubyIndexer::Entry::Parameter]) }
  def parameters; end

  private

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#217
  sig do
    params(
      parameters_node: T.nilable(::Prism::ParametersNode)
    ).returns(T::Array[::RubyIndexer::Entry::Parameter])
  end
  def list_params(parameters_node); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#276
  sig { params(node: T.nilable(::Prism::Node)).returns(T.nilable(::Symbol)) }
  def parameter_name(node); end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#49
class RubyIndexer::Entry::Module < ::RubyIndexer::Entry::Namespace; end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#37
class RubyIndexer::Entry::Namespace < ::RubyIndexer::Entry
  abstract!

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#44
  sig { returns(::String) }
  def short_name; end
end

# An optional keyword method parameter, e.g. `def foo(a: 123)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#114
class RubyIndexer::Entry::OptionalKeywordParameter < ::RubyIndexer::Entry::Parameter
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#116
  sig { override.returns(::Symbol) }
  def decorated_name; end
end

# An optional method parameter, e.g. `def foo(a = 123)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#102
class RubyIndexer::Entry::OptionalParameter < ::RubyIndexer::Entry::Parameter; end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#78
class RubyIndexer::Entry::Parameter
  abstract!

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#92
  sig { params(name: ::Symbol).void }
  def initialize(name:); end

  # source://sorbet-runtime/0.5.11155/lib/types/private/methods/_methods.rb#254
  def decorated_name(*args, **_arg1, &blk); end

  # Name includes just the name of the parameter, excluding symbols like splats
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#86
  sig { returns(::Symbol) }
  def name; end
end

# A required method parameter, e.g. `def foo(a)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#98
class RubyIndexer::Entry::RequiredParameter < ::RubyIndexer::Entry::Parameter; end

# A rest method parameter, e.g. `def foo(*a)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#122
class RubyIndexer::Entry::RestParameter < ::RubyIndexer::Entry::Parameter
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#126
  sig { override.returns(::Symbol) }
  def decorated_name; end
end

# A rest method parameter, e.g. `def foo(*a)`
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#123
RubyIndexer::Entry::RestParameter::DEFAULT_NAME = T.let(T.unsafe(nil), Symbol)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#301
class RubyIndexer::Entry::SingletonMethod < ::RubyIndexer::Entry::Method; end

# An UnresolvedAlias points to a constant alias with a right hand side that has not yet been resolved. For
# example, if we find
#
# ```ruby
#   CONST = Foo
# ```
# Before we have discovered `Foo`, there's no way to eagerly resolve this alias to the correct target constant.
# All aliases are inserted as UnresolvedAlias in the index first and then we lazily resolve them to the correct
# possible to resolve the alias and it will remain an UnresolvedAlias until the right hand side constant exists
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#317
class RubyIndexer::Entry::UnresolvedAlias < ::RubyIndexer::Entry
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#336
  sig do
    params(
      target: ::String,
      namespace: T.nilable(::RubyIndexer::Entry::Namespace),
      name: ::String,
      file_path: ::String,
      location: ::Prism::Location,
      comments: T::Array[::String]
    ).void
  end
  def initialize(target, namespace, name, file_path, location, comments); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#324
  sig { returns(T.nilable(::RubyIndexer::Entry::Namespace)) }
  def namespace; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/entry.rb#321
  sig { returns(::String) }
  def target; end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#5
class RubyIndexer::Index
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#14
  sig { void }
  def initialize; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#65
  sig { params(entry: ::RubyIndexer::Entry).void }
  def <<(entry); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#74
  sig { params(fully_qualified_name: ::String).returns(T.nilable(T::Array[::RubyIndexer::Entry])) }
  def [](fully_qualified_name); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#37
  sig { params(indexable: ::RubyIndexer::IndexablePath).void }
  def delete(indexable); end

  # Follows aliases in a namespace. The algorithm keeps checking if the name is an alias and then recursively follows
  # it. The idea is that we test the name in parts starting from the complete name to the first namespace. For
  # `Foo::Bar::Baz`, we would test:
  # 1. Is `Foo::Bar::Baz` an alias? Get the target and recursively follow its target
  # 2. Is `Foo::Bar` an alias? Get the target and recursively follow its target
  # 3. Is `Foo` an alias? Get the target and recursively follow its target
  #
  # If we find an alias, then we want to follow its target. In the same example, if `Foo::Bar` is an alias to
  # `Something::Else`, then we first discover `Something::Else::Baz`. But `Something::Else::Baz` might contain other
  # aliases, so we have to invoke `follow_aliased_namespace` again to check until we only return a real name
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#209
  sig { params(name: ::String).returns(::String) }
  def follow_aliased_namespace(name); end

  # Fuzzy searches index entries based on Jaro-Winkler similarity. If no query is provided, all entries are returned
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#116
  sig { params(query: T.nilable(::String)).returns(T::Array[::RubyIndexer::Entry]) }
  def fuzzy_search(query); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#171
  sig do
    params(
      indexable_paths: T::Array[::RubyIndexer::IndexablePath],
      block: T.nilable(T.proc.params(progress: ::Integer).returns(T::Boolean))
    ).void
  end
  def index_all(indexable_paths: T.unsafe(nil), &block); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#186
  sig { params(indexable_path: ::RubyIndexer::IndexablePath, source: T.nilable(::String)).void }
  def index_single(indexable_path, source = T.unsafe(nil)); end

  # Searches entries in the index based on an exact prefix, intended for providing autocomplete. All possible matches
  # to the prefix are returned. The return is an array of arrays, where each entry is the array of entries for a given
  # name match. For example:
  # ```ruby
  # index.prefix_search("Foo::B")
  # [
  # ]
  # ```
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#97
  sig do
    params(
      query: ::String,
      nesting: T.nilable(T::Array[::String])
    ).returns(T::Array[T::Array[::RubyIndexer::Entry]])
  end
  def prefix_search(query, nesting = T.unsafe(nil)); end

  # Try to find the entry based on the nesting from the most specific to the least specific. For example, if we have
  # the nesting as ["Foo", "Bar"] and the name as "Baz", we will try to find it in this order:
  # 1. Foo::Bar::Baz
  # 2. Foo::Baz
  # 3. Baz
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#135
  sig { params(name: ::String, nesting: T::Array[::String]).returns(T.nilable(T::Array[::RubyIndexer::Entry])) }
  def resolve(name, nesting); end

  # Attempts to find a given method for a resolved fully qualified receiver name. Returns `nil` if the method does not
  # exist on that receiver
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#243
  sig { params(method_name: ::String, receiver_name: ::String).returns(T.nilable(::RubyIndexer::Entry::Method)) }
  def resolve_method(method_name, receiver_name); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#79
  sig { params(query: ::String).returns(T::Array[::RubyIndexer::IndexablePath]) }
  def search_require_paths(query); end

  private

  # Attempts to resolve an UnresolvedAlias into a resolved Alias. If the unresolved alias is pointing to a constant
  # that doesn't exist, then we return the same UnresolvedAlias
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#257
  sig do
    params(
      entry: ::RubyIndexer::Entry::UnresolvedAlias
    ).returns(T.any(::RubyIndexer::Entry::Alias, ::RubyIndexer::Entry::UnresolvedAlias))
  end
  def resolve_alias(entry); end
end

# The minimum Jaro-Winkler similarity score for an entry to be considered a match for a given fuzzy search query
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#11
RubyIndexer::Index::ENTRY_SIMILARITY_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/index.rb#8
class RubyIndexer::Index::UnresolvableAliasError < ::StandardError; end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#5
class RubyIndexer::IndexablePath
  # An IndexablePath is instantiated with a load_path_entry and a full_path. The load_path_entry is where the file can
  # be found in the $LOAD_PATH, which we use to determine the require_path. The load_path_entry may be `nil` if the
  # indexer is configured to go through files that do not belong in the $LOAD_PATH. For example,
  # `sorbet/tapioca/require.rb` ends up being a part of the paths to be indexed because it's a Ruby file inside the
  # project, but the `sorbet` folder is not a part of the $LOAD_PATH. That means that both its load_path_entry and
  # require_path will be `nil`, since it cannot be required by the project
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#21
  sig { params(load_path_entry: T.nilable(::String), full_path: ::String).void }
  def initialize(load_path_entry, full_path); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#12
  sig { returns(::String) }
  def full_path; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/indexable_path.rb#9
  sig { returns(T.nilable(::String)) }
  def require_path; end
end

# A PrefixTree is a data structure that allows searching for partial strings fast. The tree is similar to a nested
# hash structure, where the keys are the characters of the inserted strings.
#
# ```ruby
# tree = PrefixTree[String].new
# tree.insert("bar", "bar")
# tree.insert("baz", "baz")
# ```
#
# A PrefixTree is useful for autocomplete, since we always want to find all alternatives while the developer hasn't
# finished typing yet. This PrefixTree implementation allows for string keys and any arbitrary value using the generic
# `Value` type.
#
# See https://en.wikipedia.org/wiki/Trie for more information
#
# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#35
class RubyIndexer::PrefixTree
  extend T::Generic

  Value = type_member

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#42
  sig { void }
  def initialize; end

  # Deletes the entry identified by `key` from the tree. Notice that a partial match will still delete all entries
  # that match it. For example, if the tree contains `foo` and we ask to delete `fo`, then `foo` will be deleted
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#77
  sig { params(key: ::String).void }
  def delete(key); end

  # Inserts a `value` using the given `key`
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#60
  sig { params(key: ::String, value: Value).void }
  def insert(key, value); end

  # Search the PrefixTree based on a given `prefix`. If `foo` is an entry in the tree, then searching for `fo` will
  # return it as a result. The result is always an array of the type of value attribute to the generic `Value` type.
  # Notice that if the `Value` is an array, this method will return an array of arrays, where each entry is the array
  # of values for a given match
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#51
  sig { params(prefix: ::String).returns(T::Array[Value]) }
  def search(prefix); end

  private

  # Find a node that matches the given `key`
  #
  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#97
  sig { params(key: ::String).returns(T.nilable(RubyIndexer::PrefixTree::Node[Value])) }
  def find_node(key); end
end

# source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#110
class RubyIndexer::PrefixTree::Node
  extend T::Generic

  Value = type_member

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#132
  sig { params(key: ::String, value: Value, parent: T.nilable(RubyIndexer::PrefixTree::Node[Value])).void }
  def initialize(key, value, parent = T.unsafe(nil)); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#117
  sig { returns(T::Hash[::String, RubyIndexer::PrefixTree::Node[Value]]) }
  def children; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#141
  sig { returns(T::Array[Value]) }
  def collect; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#120
  sig { returns(::String) }
  def key; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#126
  sig { returns(T::Boolean) }
  def leaf; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#126
  def leaf=(_arg0); end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#129
  sig { returns(T.nilable(RubyIndexer::PrefixTree::Node[Value])) }
  def parent; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#123
  sig { returns(Value) }
  def value; end

  # source://ruby-lsp//lib/ruby_indexer/lib/ruby_indexer/prefix_tree.rb#123
  def value=(_arg0); end
end

# source://ruby-lsp//lib/ruby-lsp.rb#4
module RubyLsp; end

# source://ruby-lsp//lib/ruby-lsp.rb#5
RubyLsp::VERSION = T.let(T.unsafe(nil), String)
