# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `timeout` gem.
# Please instead update this file by running `bin/tapioca gem timeout`.


# pkg:gem/timeout#lib/timeout.rb:21
module Timeout
  private

  # pkg:gem/timeout#lib/timeout.rb:308
  def timeout(*args, &block); end

  class << self
    # Perform an operation in a block, raising an exception if it takes longer than
    # +sec+ seconds to complete.
    #
    # +sec+:: Number of seconds to wait for the block to terminate. Any non-negative number
    #         or nil may be used, including Floats to specify fractional seconds. A
    #         value of 0 or +nil+ will execute the block without any timeout.
    #         Any negative number will raise an ArgumentError.
    # +klass+:: Exception Class to raise if the block fails to terminate
    #           in +sec+ seconds.  Omitting will use the default, Timeout::Error
    # +message+:: Error message to raise with Exception Class.
    #             Omitting will use the default, "execution expired"
    #
    # Returns the result of the block *if* the block completed before
    # +sec+ seconds, otherwise raises an exception, based on the value of +klass+.
    #
    # The exception raised to terminate the given block is the given +klass+, or
    # Timeout::ExitException if +klass+ is not given. The reason for that behavior
    # is that Timeout::Error inherits from RuntimeError and might be caught unexpectedly by `rescue`.
    # Timeout::ExitException inherits from Exception so it will only be rescued by `rescue Exception`.
    # Note that the Timeout::ExitException is translated to a Timeout::Error once it reaches the Timeout.timeout call,
    # so outside that call it will be a Timeout::Error.
    #
    # In general, be aware that the code block may rescue the exception, and in such a case not respect the timeout.
    # Also, the block can use +ensure+ to prevent the handling of the exception.
    # For those reasons, this method cannot be relied on to enforce timeouts for untrusted blocks.
    #
    # If a scheduler is defined, it will be used to handle the timeout by invoking
    # Scheduler#timeout_after.
    #
    # Note that this is both a method of module Timeout, so you can <tt>include
    # Timeout</tt> into your classes so they have a #timeout method, as well as
    # a module method, so you can call it directly as Timeout.timeout().
    #
    # ==== Ensuring the exception does not fire inside ensure blocks
    #
    # When using Timeout.timeout it can be desirable to ensure the timeout exception does not fire inside an +ensure+ block.
    # The simplest and best way to do so it to put the Timeout.timeout call inside the body of the begin/ensure/end:
    #
    #     begin
    #       Timeout.timeout(sec) { some_long_operation }
    #     ensure
    #       cleanup # safe, cannot be interrupt by timeout
    #     end
    #
    # If that is not feasible, e.g. if there are +ensure+ blocks inside +some_long_operation+,
    # they need to not be interrupted by timeout, and it's not possible to move these ensure blocks outside,
    # one can use Thread.handle_interrupt to delay the timeout exception like so:
    #
    #     Thread.handle_interrupt(Timeout::Error => :never) {
    #       Timeout.timeout(sec, Timeout::Error) do
    #         setup # timeout cannot happen here, no matter how long it takes
    #         Thread.handle_interrupt(Timeout::Error => :immediate) {
    #           some_long_operation # timeout can happen here
    #         }
    #       ensure
    #         cleanup # timeout cannot happen here, no matter how long it takes
    #       end
    #     }
    #
    # An important thing to note is the need to pass an exception klass to Timeout.timeout,
    # otherwise it does not work. Specifically, using +Thread.handle_interrupt(Timeout::ExitException => ...)+
    # is unsupported and causes subtle errors like raising the wrong exception outside the block, do not use that.
    #
    # Note that Thread.handle_interrupt is somewhat dangerous because if setup or cleanup hangs
    # then the current thread will hang too and the timeout will never fire.
    # Also note the block might run for longer than +sec+ seconds:
    # e.g. some_long_operation executes for +sec+ seconds + whatever time cleanup takes.
    #
    # If you want the timeout to only happen on blocking operations one can use :on_blocking
    # instead of :immediate. However, that means if the block uses no blocking operations after +sec+ seconds,
    # the block will not be interrupted.
    #
    # @raise [ArgumentError]
    #
    # pkg:gem/timeout#lib/timeout.rb:278
    def timeout(sec, klass = T.unsafe(nil), message = T.unsafe(nil), &block); end
  end
end

# Raised by Timeout.timeout when the block times out.
#
# pkg:gem/timeout#lib/timeout.rb:33
class Timeout::Error < ::RuntimeError
  class << self
    # pkg:gem/timeout#lib/timeout.rb:34
    def handle_timeout(message); end
  end
end

# Internal exception raised to when a timeout is triggered.
#
# pkg:gem/timeout#lib/timeout.rb:26
class Timeout::ExitException < ::Exception
  # pkg:gem/timeout#lib/timeout.rb:27
  def exception(*_arg0); end
end

# We keep a private reference so that time mocking libraries won't break Timeout.
#
# pkg:gem/timeout#lib/timeout.rb:49
Timeout::GET_TIME = T.let(T.unsafe(nil), Method)

# pkg:gem/timeout#lib/timeout.rb:143
class Timeout::Request
  # @return [Request] a new instance of Request
  #
  # pkg:gem/timeout#lib/timeout.rb:146
  def initialize(thread, timeout, exception_class, message); end

  # Returns the value of attribute deadline.
  #
  # pkg:gem/timeout#lib/timeout.rb:144
  def deadline; end

  # Only called by the timeout thread, so does not need Sync.synchronize
  #
  # @return [Boolean]
  #
  # pkg:gem/timeout#lib/timeout.rb:157
  def done?; end

  # @return [Boolean]
  #
  # pkg:gem/timeout#lib/timeout.rb:163
  def expired?(now); end

  # pkg:gem/timeout#lib/timeout.rb:177
  def finished; end

  # Only called by the timeout thread, so does not need Sync.synchronize
  #
  # pkg:gem/timeout#lib/timeout.rb:168
  def interrupt; end
end

# pkg:gem/timeout#lib/timeout.rb:56
class Timeout::State
  # @return [State] a new instance of State
  #
  # pkg:gem/timeout#lib/timeout.rb:57
  def initialize; end

  # pkg:gem/timeout#lib/timeout.rb:134
  def add_request(request); end

  # pkg:gem/timeout#lib/timeout.rb:83
  def create_timeout_thread; end

  # pkg:gem/timeout#lib/timeout.rb:120
  def ensure_timeout_thread_created; end

  class << self
    # Ractor support if
    # 1. Ractor.store_if_absent is available
    # 2. Method object can be shareable (4.0~)
    #
    # pkg:gem/timeout#lib/timeout.rb:70
    def instance; end
  end
end

# pkg:gem/timeout#lib/timeout.rb:185
module Timeout::Sync
  class << self
    # Calls mutex.synchronize(&block) but if that fails on CRuby due to being in a trap handler,
    # run mutex.synchronize(&block) in a separate Thread instead.
    #
    # pkg:gem/timeout#lib/timeout.rb:188
    def synchronize(mutex, &block); end
  end
end

# The version
#
# pkg:gem/timeout#lib/timeout.rb:23
Timeout::VERSION = T.let(T.unsafe(nil), String)
