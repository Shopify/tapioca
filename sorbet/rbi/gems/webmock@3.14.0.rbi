# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `webmock` gem.
# Please instead update this file by running `bin/tapioca gem webmock`.

module Net::WebMockHTTPResponse
  def read_body(dest = T.unsafe(nil), &block); end
end

class Net::WebMockNetBufferedIO < ::Net::BufferedIO
  # @return [WebMockNetBufferedIO] a new instance of WebMockNetBufferedIO
  def initialize(io, *args, **kwargs); end

  # https://github.com/ruby/ruby/blob/7d02441f0d6e5c9d0a73a024519eba4f69e36dce/lib/net/protocol.rb#L208
  # Modified version of method from ruby, so that nil is always passed into orig_read_nonblock to avoid timeout
  def rbuf_fill; end
end

# patch for StringIO behavior in Ruby 2.2.3
# https://github.com/bblimke/webmock/issues/558
class PatchedStringIO < ::StringIO
  def orig_read_nonblock(*_arg0); end
  def read_nonblock(size, *args, **kwargs); end
end

class StubSocket
  # @return [StubSocket] a new instance of StubSocket
  def initialize(*args); end

  def close; end

  # @return [Boolean]
  def closed?; end

  # Returns the value of attribute continue_timeout.
  def continue_timeout; end

  # Sets the attribute continue_timeout
  #
  # @param value the value to set the attribute continue_timeout to.
  def continue_timeout=(_arg0); end

  def io; end

  # Returns the value of attribute read_timeout.
  def read_timeout; end

  # Sets the attribute read_timeout
  #
  # @param value the value to set the attribute read_timeout to.
  def read_timeout=(_arg0); end

  def readuntil(*args); end

  # Returns the value of attribute write_timeout.
  def write_timeout; end

  # Sets the attribute write_timeout
  #
  # @param value the value to set the attribute write_timeout to.
  def write_timeout=(_arg0); end
end

class StubSocket::StubIO
  def setsockopt(*args); end
end

module WebMock
  include ::WebMock::API
  extend ::WebMock::API

  def after_request(*args, &block); end
  def allow_net_connect!(*args, &block); end
  def disable_net_connect!(*args, &block); end
  def net_connect_allowed?(*args, &block); end
  def registered_request?(*args, &block); end
  def reset_callbacks(*args, &block); end
  def reset_webmock(*args, &block); end

  class << self
    def after_request(options = T.unsafe(nil), &block); end
    def allow_net_connect!(options = T.unsafe(nil)); end
    def disable!(options = T.unsafe(nil)); end
    def disable_net_connect!(options = T.unsafe(nil)); end
    def disallow_net_connect!(options = T.unsafe(nil)); end
    def enable!(options = T.unsafe(nil)); end
    def enable_net_connect!(options = T.unsafe(nil)); end
    def globally_stub_request(order = T.unsafe(nil), &block); end
    def hide_body_diff!; end
    def hide_stubbing_instructions!; end

    # @private
    def included(clazz); end

    # @return [Boolean]
    def net_connect_allowed?(uri = T.unsafe(nil)); end

    # @return [Boolean]
    def net_connect_explicit_allowed?(allowed, uri = T.unsafe(nil)); end

    def print_executed_requests; end

    # @return [Boolean]
    def registered_request?(request_signature); end

    def request(method, uri); end
    def reset!; end
    def reset_callbacks; end
    def reset_webmock; end
    def show_body_diff!; end

    # @return [Boolean]
    def show_body_diff?; end

    def show_stubbing_instructions!; end

    # @return [Boolean]
    def show_stubbing_instructions?; end

    def version; end
  end
end

module WebMock::API
  extend ::WebMock::API

  def a_request(method, uri); end
  def assert_not_requested(*args, &block); end
  def assert_requested(*args, &block); end
  def hash_excluding(*args); end

  # Similar to RSpec::Mocks::ArgumentMatchers#hash_including()
  #
  # Matches a hash that includes the specified key(s) or key/value pairs.
  # Ignores any additional keys.
  #
  # @example
  #
  #   object.should_receive(:message).with(hash_including(:key => val))
  #   object.should_receive(:message).with(hash_including(:key))
  #   object.should_receive(:message).with(hash_including(:key, :key2 => val2))
  def hash_including(*args); end

  def refute_requested(*args, &block); end
  def remove_request_stub(stub); end
  def reset_executed_requests!; end
  def stub_http_request(method, uri); end
  def stub_request(method, uri); end

  private

  # this is a based on RSpec::Mocks::ArgumentMatchers#anythingize_lonely_keys
  def anythingize_lonely_keys(*args); end

  def assert_request_not_requested(request, options = T.unsafe(nil)); end
  def assert_request_requested(request, options = T.unsafe(nil)); end
  def convert_uri_method_and_options_to_request_and_options(method, uri, options, &block); end

  class << self
    def request(method, uri); end
  end
end

class WebMock::AssertionFailure
  class << self
    # Returns the value of attribute error_class.
    def error_class; end

    # Sets the attribute error_class
    #
    # @param value the value to set the attribute error_class to.
    def error_class=(_arg0); end

    # @raise [@error_class]
    def failure(message); end
  end
end

class WebMock::BodyPattern
  include ::WebMock::RSpecMatcherDetector

  # @return [BodyPattern] a new instance of BodyPattern
  def initialize(pattern); end

  # @return [Boolean]
  def matches?(body, content_type = T.unsafe(nil)); end

  # Returns the value of attribute pattern.
  def pattern; end

  def to_s; end

  private

  def assert_non_multipart_body(content_type); end
  def body_as_hash(body, content_type); end
  def body_format(content_type); end

  # @return [Boolean]
  def empty_string?(string); end

  # Compare two hashes for equality
  #
  # For two hashes to match they must have the same length and all
  # values must match when compared using `#===`.
  #
  # The following hashes are examples of matches:
  #
  #     {a: /\d+/} and {a: '123'}
  #
  #     {a: '123'} and {a: '123'}
  #
  #     {a: {b: /\d+/}} and {a: {b: '123'}}
  #
  #     {a: {b: 'wow'}} and {a: {b: 'wow'}}
  #
  # @param query_parameters [Hash] typically the result of parsing
  #   JSON, XML or URL encoded parameters.
  # @param pattern [Hash] which contains keys with a string, hash or
  #   regular expression value to use for comparison.
  # @return [Boolean] true if the paramaters match the comparison
  #   hash, false if not.
  def matching_body_hashes?(query_parameters, pattern, content_type); end

  def normalize_hash(hash); end

  # @return [Boolean]
  def url_encoded_body?(content_type); end
end

WebMock::BodyPattern::BODY_FORMATS = T.let(T.unsafe(nil), Hash)

class WebMock::CallbackRegistry
  class << self
    def add_callback(options, block); end

    # @return [Boolean]
    def any_callbacks?; end

    def callbacks; end
    def invoke_callbacks(options, request_signature, response); end
    def reset; end
  end
end

class WebMock::Config
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Config] a new instance of Config
  def initialize; end

  # Returns the value of attribute allow.
  def allow; end

  # Sets the attribute allow
  #
  # @param value the value to set the attribute allow to.
  def allow=(_arg0); end

  # Returns the value of attribute allow_localhost.
  def allow_localhost; end

  # Sets the attribute allow_localhost
  #
  # @param value the value to set the attribute allow_localhost to.
  def allow_localhost=(_arg0); end

  # Returns the value of attribute allow_net_connect.
  def allow_net_connect; end

  # Sets the attribute allow_net_connect
  #
  # @param value the value to set the attribute allow_net_connect to.
  def allow_net_connect=(_arg0); end

  # Returns the value of attribute net_http_connect_on_start.
  def net_http_connect_on_start; end

  # Sets the attribute net_http_connect_on_start
  #
  # @param value the value to set the attribute net_http_connect_on_start to.
  def net_http_connect_on_start=(_arg0); end

  # Returns the value of attribute query_values_notation.
  def query_values_notation; end

  # Sets the attribute query_values_notation
  #
  # @param value the value to set the attribute query_values_notation to.
  def query_values_notation=(_arg0); end

  # Returns the value of attribute show_body_diff.
  def show_body_diff; end

  # Sets the attribute show_body_diff
  #
  # @param value the value to set the attribute show_body_diff to.
  def show_body_diff=(_arg0); end

  # Returns the value of attribute show_stubbing_instructions.
  def show_stubbing_instructions; end

  # Sets the attribute show_stubbing_instructions
  #
  # @param value the value to set the attribute show_stubbing_instructions to.
  def show_stubbing_instructions=(_arg0); end
end

class WebMock::Deprecation
  class << self
    def warning(message); end
  end
end

class WebMock::DynamicResponse < ::WebMock::Response
  # @return [DynamicResponse] a new instance of DynamicResponse
  def initialize(responder); end

  def evaluate(request_signature); end

  # Returns the value of attribute responder.
  def responder; end

  # Sets the attribute responder
  #
  # @param value the value to set the attribute responder to.
  def responder=(_arg0); end
end

class WebMock::HashValidator
  # @return [HashValidator] a new instance of HashValidator
  def initialize(hash); end

  # This code is based on https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/hash/keys.rb
  def validate_keys(*valid_keys); end
end

class WebMock::HeadersPattern
  # @return [HeadersPattern] a new instance of HeadersPattern
  def initialize(pattern); end

  # @return [Boolean]
  def matches?(headers); end

  def pp_to_s; end
  def to_s; end

  private

  # @return [Boolean]
  def empty_headers?(headers); end
end

class WebMock::HttpLibAdapter
  class << self
    def adapter_for(lib); end
  end
end

class WebMock::HttpLibAdapterRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [HttpLibAdapterRegistry] a new instance of HttpLibAdapterRegistry
  def initialize; end

  def each_adapter(&block); end

  # Returns the value of attribute http_lib_adapters.
  def http_lib_adapters; end

  # Sets the attribute http_lib_adapters
  #
  # @param value the value to set the attribute http_lib_adapters to.
  def http_lib_adapters=(_arg0); end

  def register(lib, adapter); end
end

module WebMock::HttpLibAdapters; end

class WebMock::HttpLibAdapters::NetHttpAdapter < ::WebMock::HttpLibAdapter
  class << self
    def disable!; end
    def enable!; end
  end
end

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetBufferedIO = Net::BufferedIO
WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP
module WebMock::Matchers; end

# this is a based on RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
class WebMock::Matchers::AnyArgMatcher
  # @return [AnyArgMatcher] a new instance of AnyArgMatcher
  def initialize(ignore); end

  def ==(other); end
end

# Base class for Hash matchers
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
class WebMock::Matchers::HashArgumentMatcher
  # @return [HashArgumentMatcher] a new instance of HashArgumentMatcher
  def initialize(expected); end

  def ==(_actual, &block); end

  class << self
    def from_rspec_matcher(matcher); end
  end
end

# this is a based on RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
class WebMock::Matchers::HashExcludingMatcher < ::WebMock::Matchers::HashArgumentMatcher
  def ==(actual); end
  def inspect; end
end

# this is a based on RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
# https://github.com/rspec/rspec-mocks/blob/master/lib/rspec/mocks/argument_matchers.rb
class WebMock::Matchers::HashIncludingMatcher < ::WebMock::Matchers::HashArgumentMatcher
  def ==(actual); end
  def inspect; end
end

class WebMock::MethodPattern
  # @return [MethodPattern] a new instance of MethodPattern
  def initialize(pattern); end

  # @return [Boolean]
  def matches?(method); end

  def to_s; end
end

class WebMock::NetConnectNotAllowedError < ::Exception
  # @return [NetConnectNotAllowedError] a new instance of NetConnectNotAllowedError
  def initialize(request_signature); end
end

module WebMock::NetHTTPUtility
  class << self
    def check_right_http_connection; end
    def get_uri(net_http, path); end
    def puts_warning_for_right_http_if_needed; end
    def request_signature_from_request(net_http, request, body = T.unsafe(nil)); end
    def validate_headers(headers); end
  end
end

module WebMock::RSpecMatcherDetector
  # @return [Boolean]
  def rSpecHashExcludingMatcher?(matcher); end

  # @return [Boolean]
  def rSpecHashIncludingMatcher?(matcher); end
end

class WebMock::RackResponse < ::WebMock::Response
  # @return [RackResponse] a new instance of RackResponse
  def initialize(app); end

  def body_from_rack_response(response); end
  def build_rack_env(request); end
  def evaluate(request); end
  def session; end
  def session_options; end
end

class WebMock::RequestBodyDiff
  # @return [RequestBodyDiff] a new instance of RequestBodyDiff
  def initialize(request_signature, request_stub); end

  def body_diff; end

  private

  # @return [Boolean]
  def parseable_json?(body_pattern); end

  # Returns the value of attribute request_signature.
  def request_signature; end

  def request_signature_body_hash; end

  # @return [Boolean]
  def request_signature_diffable?; end

  # @return [Boolean]
  def request_signature_parseable_json?; end

  # Returns the value of attribute request_stub.
  def request_stub; end

  def request_stub_body; end
  def request_stub_body_hash; end

  # @return [Boolean]
  def request_stub_diffable?; end

  # @return [Boolean]
  def request_stub_parseable_json?; end
end

class WebMock::RequestExecutionVerifier
  # @return [RequestExecutionVerifier] a new instance of RequestExecutionVerifier
  def initialize(request_pattern = T.unsafe(nil), expected_times_executed = T.unsafe(nil), at_least_times_executed = T.unsafe(nil), at_most_times_executed = T.unsafe(nil)); end

  # Returns the value of attribute at_least_times_executed.
  def at_least_times_executed; end

  # Sets the attribute at_least_times_executed
  #
  # @param value the value to set the attribute at_least_times_executed to.
  def at_least_times_executed=(_arg0); end

  # Returns the value of attribute at_most_times_executed.
  def at_most_times_executed; end

  # Sets the attribute at_most_times_executed
  #
  # @param value the value to set the attribute at_most_times_executed to.
  def at_most_times_executed=(_arg0); end

  def description; end

  # @return [Boolean]
  def does_not_match?; end

  # Returns the value of attribute expected_times_executed.
  def expected_times_executed; end

  # Sets the attribute expected_times_executed
  #
  # @param value the value to set the attribute expected_times_executed to.
  def expected_times_executed=(_arg0); end

  def failure_message; end
  def failure_message_when_negated; end

  # @return [Boolean]
  def matches?; end

  # Returns the value of attribute request_pattern.
  def request_pattern; end

  # Sets the attribute request_pattern
  #
  # @param value the value to set the attribute request_pattern to.
  def request_pattern=(_arg0); end

  # Returns the value of attribute times_executed.
  def times_executed; end

  # Sets the attribute times_executed
  #
  # @param value the value to set the attribute times_executed to.
  def times_executed=(_arg0); end

  private

  def failure_message_phrase(is_negated = T.unsafe(nil)); end
  def quantity_phrase(is_negated = T.unsafe(nil)); end
  def times(times); end

  class << self
    def executed_requests_message; end
  end
end

class WebMock::RequestPattern
  # @return [RequestPattern] a new instance of RequestPattern
  def initialize(method, uri, options = T.unsafe(nil)); end

  # Returns the value of attribute body_pattern.
  def body_pattern; end

  # Returns the value of attribute headers_pattern.
  def headers_pattern; end

  # @return [Boolean]
  def matches?(request_signature); end

  # Returns the value of attribute method_pattern.
  def method_pattern; end

  def to_s; end

  # Returns the value of attribute uri_pattern.
  def uri_pattern; end

  # @raise [ArgumentError]
  def with(options = T.unsafe(nil), &block); end

  private

  def assign_options(options); end
  def create_uri_pattern(uri); end
  def set_basic_auth_as_headers!(options); end
  def validate_basic_auth!(basic_auth); end
end

class WebMock::RequestRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [RequestRegistry] a new instance of RequestRegistry
  def initialize; end

  # Returns the value of attribute requested_signatures.
  def requested_signatures; end

  # Sets the attribute requested_signatures
  #
  # @param value the value to set the attribute requested_signatures to.
  def requested_signatures=(_arg0); end

  def reset!; end
  def times_executed(request_pattern); end
  def to_s; end
end

class WebMock::RequestSignature
  # @return [RequestSignature] a new instance of RequestSignature
  def initialize(method, uri, options = T.unsafe(nil)); end

  # @return [Boolean]
  def ==(other); end

  # Returns the value of attribute body.
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  def body=(_arg0); end

  # @return [Boolean]
  def eql?(other); end

  def hash; end

  # Returns the value of attribute headers.
  def headers; end

  def headers=(headers); end

  # @return [Boolean]
  def json_headers?; end

  # Returns the value of attribute method.
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  def method=(_arg0); end

  def to_s; end

  # Returns the value of attribute uri.
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  def uri=(_arg0); end

  # @return [Boolean]
  def url_encoded?; end

  private

  def assign_options(options); end
end

class WebMock::RequestSignatureSnippet
  # @return [RequestSignatureSnippet] a new instance of RequestSignatureSnippet
  def initialize(request_signature); end

  # Returns the value of attribute request_signature.
  def request_signature; end

  # Returns the value of attribute request_stub.
  def request_stub; end

  def request_stubs; end
  def stubbing_instructions; end

  private

  def add_body_diff(stub, text); end
  def pretty_print_to_string(string_to_print); end
  def request_params; end
  def signature_stub_body_diff(stub); end
end

class WebMock::RequestStub
  # @return [RequestStub] a new instance of RequestStub
  def initialize(method, uri); end

  def and_raise(*exceptions); end
  def and_return(*response_hashes, &block); end
  def and_timeout; end

  # @return [Boolean]
  def has_responses?; end

  # @return [Boolean]
  def matches?(request_signature); end

  # Returns the value of attribute request_pattern.
  def request_pattern; end

  # Sets the attribute request_pattern
  #
  # @param value the value to set the attribute request_pattern to.
  def request_pattern=(_arg0); end

  def response; end
  def then; end
  def times(number); end
  def to_rack(app, options = T.unsafe(nil)); end
  def to_raise(*exceptions); end
  def to_return(*response_hashes, &block); end
  def to_s; end
  def to_timeout; end
  def with(params = T.unsafe(nil), &block); end

  class << self
    def from_request_signature(signature); end
  end
end

class WebMock::Response
  # @return [Response] a new instance of Response
  def initialize(options = T.unsafe(nil)); end

  def ==(other); end
  def body; end
  def body=(body); end
  def evaluate(request_signature); end
  def exception; end
  def exception=(exception); end
  def headers; end
  def headers=(headers); end
  def options=(options); end

  # @raise [@exception]
  def raise_error_if_any; end

  def should_timeout; end
  def status; end
  def status=(status); end

  private

  def assert_valid_body!; end
  def read_raw_response(raw_response); end
  def stringify_body!; end
end

class WebMock::Response::InvalidBody < ::StandardError; end

class WebMock::ResponseFactory
  class << self
    def response_for(options); end
  end
end

class WebMock::ResponsesSequence
  # @return [ResponsesSequence] a new instance of ResponsesSequence
  def initialize(responses); end

  # @return [Boolean]
  def end?; end

  def next_response; end

  # Returns the value of attribute times_to_repeat.
  def times_to_repeat; end

  # Sets the attribute times_to_repeat
  #
  # @param value the value to set the attribute times_to_repeat to.
  def times_to_repeat=(_arg0); end

  private

  def increase_position; end
end

class WebMock::StubRegistry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [StubRegistry] a new instance of StubRegistry
  def initialize; end

  def global_stubs; end
  def register_global_stub(order = T.unsafe(nil), &block); end
  def register_request_stub(stub); end

  # @return [Boolean]
  def registered_request?(request_signature); end

  def remove_request_stub(stub); end

  # Returns the value of attribute request_stubs.
  def request_stubs; end

  # Sets the attribute request_stubs
  #
  # @param value the value to set the attribute request_stubs to.
  def request_stubs=(_arg0); end

  def reset!; end
  def response_for_request(request_signature); end

  private

  def evaluate_response_for_request(response, request_signature); end
  def request_stub_for(request_signature); end
end

class WebMock::StubRequestSnippet
  # @return [StubRequestSnippet] a new instance of StubRequestSnippet
  def initialize(request_stub); end

  def body_pattern; end
  def to_s(with_response = T.unsafe(nil)); end
end

class WebMock::URIAddressablePattern < ::WebMock::URIPattern
  def add_query_params(query_params); end

  private

  # @return [Boolean]
  def matches_with_variations?(uri); end

  def pattern_inspect; end

  # @return [Boolean]
  def pattern_matches?(uri); end

  # @return [Boolean]
  def template_matches_uri?(template, uri); end
end

class WebMock::URICallablePattern < ::WebMock::URIPattern
  private

  # @return [Boolean]
  def pattern_matches?(uri); end
end

class WebMock::URIPattern
  include ::WebMock::RSpecMatcherDetector

  # @return [URIPattern] a new instance of URIPattern
  def initialize(pattern); end

  def add_query_params(query_params); end

  # @return [Boolean]
  def matches?(uri); end

  def to_s; end

  private

  def pattern_inspect; end

  # @return [Boolean]
  def query_params_matches?(uri); end
end

class WebMock::URIRegexpPattern < ::WebMock::URIPattern
  private

  # @return [Boolean]
  def pattern_matches?(uri); end
end

class WebMock::URIStringPattern < ::WebMock::URIPattern
  def add_query_params(query_params); end

  private

  def pattern_inspect; end

  # @return [Boolean]
  def pattern_matches?(uri); end
end

module WebMock::Util; end

class WebMock::Util::HashCounter
  # @return [HashCounter] a new instance of HashCounter
  def initialize; end

  def each(&block); end
  def get(key); end

  # Returns the value of attribute hash.
  def hash; end

  # Sets the attribute hash
  #
  # @param value the value to set the attribute hash to.
  def hash=(_arg0); end

  def put(key, num = T.unsafe(nil)); end
  def select(&block); end
end

class WebMock::Util::HashKeysStringifier
  class << self
    def stringify_keys!(arg, options = T.unsafe(nil)); end
  end
end

class WebMock::Util::Headers
  class << self
    def basic_auth_header(*credentials); end
    def decode_userinfo_from_header(header); end
    def normalize_headers(headers); end
    def pp_headers_string(headers); end
    def sorted_headers_string(headers); end
  end
end

class WebMock::Util::JSON
  class << self
    # Ensure that ":" and "," are always followed by a space
    def convert_json_to_yaml(json); end

    def parse(json); end
    def unescape(str); end
  end
end

class WebMock::Util::JSON::ParseError < ::StandardError; end

class WebMock::Util::QueryMapper
  class << self
    def collect_query_hash(query_array, empty_accumulator, options); end
    def collect_query_parts(query); end
    def dehash(hash); end
    def fill_accumulator_for_dot(accumulator, key, value); end
    def fill_accumulator_for_flat(accumulator, key, value); end
    def fill_accumulator_for_flat_array(accumulator, key, value); end
    def fill_accumulator_for_subscript(accumulator, key, value); end
    def normalize_query_hash(query_hash, empty_accumulator, options); end

    # Converts the query component to a Hash value.
    #
    # @example
    #   WebMock::Util::QueryMapper.query_to_values("?one=1&two=2&three=3")
    #   #=> {"one" => "1", "two" => "2", "three" => "3"}
    #   WebMock::Util::QueryMapper("?one[two][three]=four").query_values
    #   #=> {"one" => {"two" => {"three" => "four"}}}
    #   WebMock::Util::QueryMapper.query_to_values("?one.two.three=four",
    #   :notation => :dot
    #   )
    #   #=> {"one" => {"two" => {"three" => "four"}}}
    #   WebMock::Util::QueryMapper.query_to_values("?one[two][three]=four",
    #   :notation => :flat
    #   )
    #   #=> {"one[two][three]" => "four"}
    #   WebMock::Util::QueryMapper.query_to_values("?one.two.three=four",
    #   :notation => :flat
    #   )
    #   #=> {"one.two.three" => "four"}
    #   WebMock::Util::QueryMapper(
    #   "?one[two][three][]=four&one[two][three][]=five"
    #   )
    #   #=> {"one" => {"two" => {"three" => ["four", "five"]}}}
    #   WebMock::Util::QueryMapper.query_to_values(
    #   "?one=two&one=three").query_values(:notation => :flat_array)
    #   #=> [['one', 'two'], ['one', 'three']]
    # @option [Symbol]
    # @param [Symbol] [Hash] a customizable set of options
    # @return [Hash, Array] The query string parsed as a Hash or Array object.
    def query_to_values(query, options = T.unsafe(nil)); end

    # new_query_values have form [['key1', 'value1'], ['key2', 'value2']]
    def to_query(parent, value, options = T.unsafe(nil)); end

    # Sets the query component for this URI from a Hash object.
    # This method produces a query string using the :subscript notation.
    # An empty Hash will result in a nil query.
    #
    # @param new_query_values [Hash, #to_hash, Array] The new query values.
    def values_to_query(new_query_values, options = T.unsafe(nil)); end
  end
end

class WebMock::Util::URI
  class << self
    def encode_unsafe_chars_in_userinfo(userinfo); end
    def heuristic_parse(uri); end

    # @return [Boolean]
    def is_uri_localhost?(uri); end

    def normalize_uri(uri); end
    def sort_query_values(query_values); end
    def strip_default_port_from_uri_string(uri_string); end
    def uris_encoded_and_unencoded(uris); end
    def uris_with_inferred_port_and_without(uris); end
    def uris_with_scheme_and_without(uris); end
    def uris_with_trailing_slash_and_without(uris); end
    def variations_of_uri_as_strings(uri_object, only_with_scheme: T.unsafe(nil)); end
  end
end

WebMock::Util::URI::ADDRESSABLE_URIS = T.let(T.unsafe(nil), Hash)
module WebMock::Util::URI::CharacterClasses; end
WebMock::Util::URI::CharacterClasses::USERINFO = T.let(T.unsafe(nil), String)
WebMock::Util::URI::NORMALIZED_URIS = T.let(T.unsafe(nil), Hash)

class WebMock::Util::ValuesStringifier
  class << self
    def stringify_values(value); end
  end
end

WebMock::VERSION = T.let(T.unsafe(nil), String)

class WebMock::VersionChecker
  # @return [VersionChecker] a new instance of VersionChecker
  def initialize(library_name, library_version, min_patch_level, max_minor_version = T.unsafe(nil), unsupported_versions = T.unsafe(nil)); end

  def check_version!; end

  private

  def colorize(text, color_code); end
  def compare_version; end
  def parse_version(version); end

  # @return [Boolean]
  def too_high?; end

  # @return [Boolean]
  def too_low?; end

  # @return [Boolean]
  def unsupported_version?; end

  def version_requirement; end
  def warn_about_too_high; end
  def warn_about_too_low; end
  def warn_about_unsupported_version; end
  def warn_in_red(text); end
end
