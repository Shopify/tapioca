# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `actiontext` gem.
# Please instead update this file by running `bin/tapioca gem actiontext`.

module ActionText
  extend ::ActiveSupport::Autoload

  class << self
    def railtie_helpers_paths; end
    def railtie_namespace; end
    def railtie_routes_url_helpers(include_path_helpers = T.unsafe(nil)); end
    def table_name_prefix; end
    def use_relative_model_naming?; end
  end
end

module ActionText::Attachable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Attachable::ClassMethods

  def as_json(*_arg0); end
  def attachable_content_type; end
  def attachable_filename; end
  def attachable_filesize; end
  def attachable_metadata; end
  def attachable_sgid; end

  # @return [Boolean]
  def previewable_attachable?; end

  def to_attachable_partial_path; end
  def to_rich_text_attributes(attributes = T.unsafe(nil)); end
  def to_trix_content_attachment_partial_path; end

  class << self
    def from_attachable_sgid(sgid, options = T.unsafe(nil)); end
    def from_node(node); end

    private

    def attachable_from_sgid(sgid); end
  end
end

module ActionText::Attachable::ClassMethods
  def from_attachable_sgid(sgid); end
end

ActionText::Attachable::LOCATOR_NAME = T.let(T.unsafe(nil), String)

module ActionText::Attachables
  extend ::ActiveSupport::Autoload
end

class ActionText::Attachables::ContentAttachment
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  def __callbacks; end
  def __callbacks?; end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def _validators; end
  def _validators?; end
  def attachable_plain_text_representation(caption); end
  def model_name(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  def to_partial_path; end
  def to_trix_content_attachment_partial_path; end
  def validation_context; end

  private

  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def from_node(node); end
  end
end

module ActionText::Attachables::MissingAttachable
  extend ::ActiveModel::Naming

  def model_name(*_arg0, **_arg1, &_arg2); end

  class << self
    def to_partial_path; end
  end
end

class ActionText::Attachables::RemoteImage
  extend ::ActiveModel::Naming

  # @return [RemoteImage] a new instance of RemoteImage
  def initialize(attributes = T.unsafe(nil)); end

  def attachable_plain_text_representation(caption); end

  # Returns the value of attribute content_type.
  def content_type; end

  # Returns the value of attribute height.
  def height; end

  def model_name(*_arg0, **_arg1, &_arg2); end
  def to_partial_path; end

  # Returns the value of attribute url.
  def url; end

  # Returns the value of attribute width.
  def width; end

  class << self
    def from_node(node); end

    private

    def attributes_from_node(node); end

    # @return [Boolean]
    def content_type_is_image?(content_type); end
  end
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  include ::ActionText::Attachments::TrixConversion
  extend ::ActionText::Attachments::Minification::ClassMethods
  extend ::ActionText::Attachments::TrixConversion::ClassMethods

  # @return [Attachment] a new instance of Attachment
  def initialize(node, attachable); end

  # Returns the value of attribute attachable.
  def attachable; end

  def caption; end
  def full_attributes; end
  def inspect; end
  def method_missing(method, *args, **_arg2, &block); end

  # Returns the value of attribute node.
  def node; end

  def tag_name; end
  def tag_name=(val); end
  def to_html; end
  def to_param(*_arg0, **_arg1, &_arg2); end
  def to_plain_text; end
  def to_s; end
  def with_full_attributes; end

  private

  def attachable_attributes; end
  def node_attributes; end
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
  def sgid_attributes; end

  class << self
    def fragment_by_canonicalizing_attachments(content); end
    def from_attachable(attachable, attributes = T.unsafe(nil)); end
    def from_attachables(attachables); end
    def from_attributes(attributes, attachable = T.unsafe(nil)); end
    def from_node(node, attachable = T.unsafe(nil)); end
    def tag_name; end
    def tag_name=(val); end

    private

    def node_from_attributes(attributes); end
    def process_attributes(attributes); end
  end
end

ActionText::Attachment::ATTRIBUTES = T.let(T.unsafe(nil), Array)

class ActionText::AttachmentGallery
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Conversion
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::API
  include ::ActiveModel::Model
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Naming
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveModel::Conversion::ClassMethods

  # @return [AttachmentGallery] a new instance of AttachmentGallery
  def initialize(node); end

  def __callbacks; end
  def __callbacks?; end
  def _run_validate_callbacks(&block); end
  def _validate_callbacks; end
  def _validators; end
  def _validators?; end
  def attachments; end
  def inspect; end
  def model_name(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute node.
  def node; end

  def size; end
  def validation_context; end

  private

  def validation_context=(_arg0); end

  class << self
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validate_callbacks; end
    def _validate_callbacks=(value); end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
    def attachment_selector; end
    def find_attachment_gallery_nodes(content); end
    def fragment_by_canonicalizing_attachment_galleries(content); end
    def fragment_by_replacing_attachment_gallery_nodes(content); end
    def from_node(node); end
    def selector; end
  end
end

ActionText::AttachmentGallery::TAG_NAME = T.let(T.unsafe(nil), String)

module ActionText::Attachments
  extend ::ActiveSupport::Autoload
end

module ActionText::Attachments::Caching
  def cache_key(*args); end

  private

  def cache_digest; end
end

module ActionText::Attachments::Minification
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Attachments::Minification::ClassMethods
end

module ActionText::Attachments::Minification::ClassMethods
  def fragment_by_minifying_attachments(content); end
end

module ActionText::Attachments::TrixConversion
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Attachments::TrixConversion::ClassMethods

  def to_trix_attachment(content = T.unsafe(nil)); end

  private

  def trix_attachment_content; end
end

module ActionText::Attachments::TrixConversion::ClassMethods
  def fragment_by_converting_trix_attachments(content); end
  def from_trix_attachment(trix_attachment); end
end

module ActionText::Attribute
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Attribute::ClassMethods
end

module ActionText::Attribute::ClassMethods
  def has_rich_text(name, encrypted: T.unsafe(nil)); end
  def rich_text_association_names; end
  def with_all_rich_text; end
end

class ActionText::Content
  include ::ActionText::Serialization
  include ::ActionText::Rendering
  extend ::ActionText::Serialization::ClassMethods
  extend ::ActionText::Rendering::ClassMethods

  # @return [Content] a new instance of Content
  def initialize(content = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def append_attachables(attachables); end
  def as_json(*_arg0); end
  def attachables; end
  def attachment_galleries; end
  def attachments; end
  def blank?(*_arg0, **_arg1, &_arg2); end
  def empty?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute fragment.
  def fragment; end

  def gallery_attachments; end
  def html_safe(*_arg0, **_arg1, &_arg2); end
  def inspect; end
  def links; end
  def present?(*_arg0, **_arg1, &_arg2); end
  def render(*_arg0, **_arg1, &_arg2); end
  def render_attachment_galleries(&block); end
  def render_attachments(**options, &block); end
  def to_html; end
  def to_partial_path; end
  def to_plain_text; end
  def to_rendered_html_with_layout; end
  def to_s; end
  def to_trix_html; end

  private

  def attachment_for_node(node, with_full_attributes: T.unsafe(nil)); end
  def attachment_gallery_for_node(node); end
  def attachment_gallery_nodes; end
  def attachment_nodes; end

  class << self
    def default_renderer; end
    def default_renderer=(val); end
    def fragment_by_canonicalizing_content(content); end
    def renderer; end
    def renderer=(obj); end
  end
end

module ActionText::ContentHelper
  def allowed_attributes; end
  def allowed_attributes=(val); end
  def allowed_tags; end
  def allowed_tags=(val); end
  def render_action_text_attachment(attachment, locals: T.unsafe(nil)); end
  def render_action_text_attachments(content); end
  def render_action_text_content(content); end
  def sanitize_action_text_content(content); end
  def sanitizer; end
  def sanitizer=(val); end
  def scrubber; end
  def scrubber=(val); end

  class << self
    def allowed_attributes; end
    def allowed_attributes=(val); end
    def allowed_tags; end
    def allowed_tags=(val); end
    def sanitizer; end
    def sanitizer=(val); end
    def scrubber; end
    def scrubber=(val); end
  end
end

class ActionText::EncryptedRichText < ::ActionText::RichText
  include ::ActionText::EncryptedRichText::GeneratedAttributeMethods
  include ::ActionText::EncryptedRichText::GeneratedAssociationMethods

  class << self
    def __callbacks; end
    def _validators; end
    def attributes_to_define_after_schema_loads; end
    def defined_enums; end
    def encrypted_attributes; end
  end
end

module ActionText::EncryptedRichText::GeneratedAssociationMethods; end
module ActionText::EncryptedRichText::GeneratedAttributeMethods; end

module ActionText::Encryption
  def decrypt; end
  def encrypt; end

  private

  def decrypt_rich_texts; end
  def encrypt_rich_texts; end
  def encryptable_rich_texts; end

  # @return [Boolean]
  def has_encrypted_rich_texts?; end
end

class ActionText::Engine < ::Rails::Engine; end

# Fixtures are a way of organizing data that you want to test against; in
# short, sample data.
#
# To learn more about fixtures, read the
# {ActiveRecord::FixtureSet}[rdoc-ref:ActiveRecord::FixtureSet] documentation.
#
# === YAML
#
# Like other Active Record-backed models, ActionText::RichText records inherit
# from ActiveRecord::Base instances and can therefore be populated by
# fixtures.
#
# Consider an <tt>Article</tt> class:
#
#   class Article < ApplicationRecord
#     has_rich_text :content
#   end
#
# To declare fixture data for the related <tt>content</tt>, first declare fixture
# data for <tt>Article</tt> instances in <tt>test/fixtures/articles.yml</tt>:
#
#   first:
#     title: An Article
#
# Then declare the ActionText::RichText fixture data in
# <tt>test/fixtures/action_text/rich_texts.yml</tt>, making sure to declare
# each entry's <tt>record:</tt> key as a polymorphic relationship:
#
#   first:
#     record: first (Article)
#     name: content
#     body: <div>Hello, world.</div>
#
# When processed, Active Record will insert database records for each fixture
# entry and will ensure the Action Text relationship is intact.
class ActionText::FixtureSet
  class << self
    # Fixtures support Action Text attachments as part of their <tt>body</tt>
    # HTML.
    #
    # === Examples
    #
    # For example, consider a second <tt>Article</tt> fixture declared in
    # <tt>test/fixtures/articles.yml</tt>:
    #
    #   second:
    #     title: Another Article
    #
    # You can attach a mention of <tt>articles(:first)</tt> to <tt>second</tt>'s
    # <tt>content</tt> by embedding a call to <tt>ActionText::FixtureSet.attachment</tt>
    # in the <tt>body:</tt> value in <tt>test/fixtures/action_text/rich_texts.yml</tt>:
    #
    #   second:
    #     record: second (Article)
    #     name: content
    #     body: <div>Hello, <%= ActionText::FixtureSet.attachment("articles", :first) %></div>
    def attachment(fixture_set_name, label, column_type: T.unsafe(nil)); end
  end
end

class ActionText::Fragment
  # @return [Fragment] a new instance of Fragment
  def initialize(source); end

  def find_all(selector); end
  def replace(selector); end

  # Returns the value of attribute source.
  def source; end

  def to_html; end
  def to_plain_text; end
  def to_s; end

  # @yield [source = self.source.clone]
  def update; end

  class << self
    def from_html(html); end
    def wrap(fragment_or_html); end
  end
end

module ActionText::HtmlConversion
  extend ::ActionText::HtmlConversion

  def create_element(tag_name, attributes = T.unsafe(nil)); end
  def fragment_for_html(html); end
  def node_to_html(node); end

  private

  def document; end
end

module ActionText::PlainTextConversion
  extend ::ActionText::PlainTextConversion

  def node_to_plain_text(node); end

  private

  def break_if_nested_list(node, text); end
  def bullet_for_li_node(node, index); end
  def indentation_for_li_node(node); end
  def list_node_depth_for_node(node); end
  def list_node_name_for_li_node(node); end
  def plain_text_for_block(node, index = T.unsafe(nil)); end
  def plain_text_for_blockquote_node(node, index); end
  def plain_text_for_br_node(node, index); end
  def plain_text_for_div_node(node, index); end
  def plain_text_for_figcaption_node(node, index); end
  def plain_text_for_h1_node(node, index = T.unsafe(nil)); end
  def plain_text_for_li_node(node, index); end
  def plain_text_for_list(node, index); end
  def plain_text_for_node(node, index = T.unsafe(nil)); end
  def plain_text_for_node_children(node); end
  def plain_text_for_ol_node(node, index); end
  def plain_text_for_p_node(node, index = T.unsafe(nil)); end
  def plain_text_for_text_node(node, index); end
  def plain_text_for_ul_node(node, index); end
  def plain_text_method_for_node(node); end
  def remove_trailing_newlines(text); end
end

class ActionText::Record < ::ActiveRecord::Base
  include ::ActionText::Record::GeneratedAttributeMethods
  include ::ActionText::Record::GeneratedAssociationMethods

  class << self
    def _validators; end
    def defined_enums; end
  end
end

module ActionText::Record::GeneratedAssociationMethods; end
module ActionText::Record::GeneratedAttributeMethods; end

module ActionText::Rendering
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Rendering::ClassMethods
end

module ActionText::Rendering::ClassMethods
  def render(*args, &block); end
  def with_renderer(renderer); end
end

class ActionText::RichText < ::ActionText::Record
  include ::ActionText::RichText::GeneratedAttributeMethods
  include ::ActionText::RichText::GeneratedAssociationMethods

  def autosave_associated_records_for_record(*args); end
  def nil?(*_arg0, **_arg1, &_arg2); end
  def to_s(*_arg0, **_arg1, &_arg2); end

  class << self
    def __callbacks; end
    def _reflections; end
    def _validators; end
    def attributes_to_define_after_schema_loads; end
    def defined_enums; end
  end
end

module ActionText::RichText::GeneratedAssociationMethods
  def record; end
  def record=(value); end
  def record_changed?; end
  def record_previously_changed?; end
  def reload_record; end
end

module ActionText::RichText::GeneratedAttributeMethods; end

module ActionText::Serialization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActionText::Serialization::ClassMethods

  def _dump(*_arg0); end
end

module ActionText::Serialization::ClassMethods
  def _load(content); end
  def dump(content); end
  def load(content); end
end

module ActionText::TagHelper
  def rich_text_area_tag(name, value = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    def id; end
    def id=(val); end
  end
end

class ActionText::TrixAttachment
  # @return [TrixAttachment] a new instance of TrixAttachment
  def initialize(node); end

  def attributes; end

  # Returns the value of attribute node.
  def node; end

  def to_html; end
  def to_s; end

  private

  def attachment_attributes; end
  def composed_attributes; end
  def read_json_attribute(name); end
  def read_json_object_attribute(name); end

  class << self
    def from_attributes(attributes); end

    private

    def process_attributes(attributes); end
    def transform_attribute_keys(attributes); end
    def typecast_attribute_values(attributes); end
  end
end

ActionText::TrixAttachment::ATTRIBUTES = T.let(T.unsafe(nil), Array)
ActionText::TrixAttachment::ATTRIBUTE_TYPES = T.let(T.unsafe(nil), Hash)
ActionText::TrixAttachment::COMPOSED_ATTRIBUTES = T.let(T.unsafe(nil), Array)
ActionText::TrixAttachment::SELECTOR = T.let(T.unsafe(nil), String)
ActionText::TrixAttachment::TAG_NAME = T.let(T.unsafe(nil), String)
