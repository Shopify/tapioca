# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca sync

# typed: true

class Hash
  include(::Enumerable)
  include(::JSON::Ext::Generator::GeneratorMethods::Hash)

  def assert_exclusive_keys(*exclusive_keys); end
  def assert_valid_keys(*valid_keys); end
end

module StateMachines
end

class StateMachines::AllMatcher < ::StateMachines::Matcher
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def -(blacklist); end
  def description; end
  def filter(values); end
  def matches?(value, context = _); end

  def self.instance; end
end

class StateMachines::AttributeTransitionCollection < ::StateMachines::TransitionCollection
  def initialize(transitions = _, options = _); end


  private

  def persist; end
  def reset; end
  def rollback; end
  def run_callbacks(index = _); end
end

class StateMachines::BlacklistMatcher < ::StateMachines::Matcher
  def description; end
  def filter(values); end
  def matches?(value, context = _); end
end

class StateMachines::Branch
  include(::StateMachines::EvalHelpers)

  def initialize(options = _); end

  def draw(graph, event, valid_states); end
  def event_requirement; end
  def if_condition; end
  def known_states; end
  def match(object, query = _); end
  def matches?(object, query = _); end
  def state_requirements; end
  def unless_condition; end

  protected

  def build_matcher(options, whitelist_option, blacklist_option); end
  def match_event(query); end
  def match_query(query); end
  def match_states(query); end
  def matches_conditions?(object, query); end
  def matches_requirement?(query, option, requirement); end
end

class StateMachines::Callback
  include(::StateMachines::EvalHelpers)

  def initialize(type, *args, &block); end

  def branch; end
  def call(object, context = _, *args, &block); end
  def known_states; end
  def terminator; end
  def type; end
  def type=(_); end

  private

  def bound_method(block); end
  def run_methods(object, context = _, index = _, *args, &block); end

  def self.bind_to_object; end
  def self.bind_to_object=(_); end
  def self.terminator; end
  def self.terminator=(_); end
end

module StateMachines::ClassMethods
  def state_machines; end

  def self.extended(base); end
end

class StateMachines::Error < ::StandardError
  def initialize(object, message = _); end

  def object; end
end

module StateMachines::EvalHelpers
  def evaluate_method(object, method, *args, &block); end
end

class StateMachines::Event
  include(::StateMachines::MatcherHelpers)

  def initialize(machine, name, options = _); end

  def branches; end
  def can_fire?(object, requirements = _); end
  def context(&block); end
  def draw(graph, options = _); end
  def fire(object, *args); end
  def human_name(klass = _); end
  def human_name=(_); end
  def inspect; end
  def known_states; end
  def machine; end
  def machine=(_); end
  def name; end
  def on_failure(object); end
  def qualified_name; end
  def reset; end
  def transition(options); end
  def transition_for(object, requirements = _); end

  protected

  def add_actions; end

  private

  def initialize_copy(orig); end
end

class StateMachines::EventCollection < ::StateMachines::NodeCollection
  def initialize(machine); end

  def attribute_transition_for(object, invalidate = _); end
  def transitions_for(object, requirements = _); end
  def valid_for(object, requirements = _); end

  private

  def match(requirements); end
end

class StateMachines::HelperModule < ::Module
  def initialize(machine, kind); end

  def to_s; end
end

module StateMachines::InstanceMethods
  def fire_events(*events); end
  def fire_events!(*events); end

  protected

  def initialize_state_machines(options = _, &block); end
end

class StateMachines::IntegrationError < ::StandardError
end

class StateMachines::IntegrationNotFound < ::StateMachines::Error
  def initialize(name); end

  def error_message; end
  def no_integrations; end
  def valid_integrations; end
  def valid_integrations_name; end
end

module StateMachines::Integrations
  def self.find_by_name(name); end
  def self.integrations; end
  def self.list; end
  def self.match(klass); end
  def self.match_ancestors(ancestors); end
  def self.register(name_or_module); end
  def self.reset; end
end

module StateMachines::Integrations::Base
  mixes_in_class_methods(::StateMachines::Integrations::Base::ClassMethods)

  def self.included(base); end
end

module StateMachines::Integrations::Base::ClassMethods
  def defaults; end
  def integration_name; end
  def matches?(klass); end
  def matches_ancestors?(ancestors); end
  def matching_ancestors; end
end

class StateMachines::InvalidContext < ::StateMachines::Error
end

class StateMachines::InvalidEvent < ::StateMachines::Error
  def initialize(object, event_name); end

  def event; end
end

class StateMachines::InvalidParallelTransition < ::StateMachines::Error
  def initialize(object, events); end

  def events; end
end

class StateMachines::InvalidTransition < ::StateMachines::Error
  def initialize(object, machine, event); end

  def event; end
  def from; end
  def from_name; end
  def machine; end
  def qualified_event; end
  def qualified_from_name; end
end

class StateMachines::LoopbackMatcher < ::StateMachines::Matcher
  include(::Singleton)
  extend(::Singleton::SingletonClassMethods)

  def description; end
  def matches?(value, context); end

  def self.instance; end
end

class StateMachines::Machine
  include(::StateMachines::EvalHelpers)
  include(::StateMachines::MatcherHelpers)

  def initialize(owner_class, *args, &block); end

  def action; end
  def action_hook?(self_only = _); end
  def after_failure(*args, &block); end
  def after_transition(*args, &block); end
  def around_transition(*args, &block); end
  def attribute(name = _); end
  def before_transition(*args, &block); end
  def callbacks; end
  def define_helper(scope, method, *args, &block); end
  def draw(*_); end
  def dynamic_initial_state?; end
  def errors_for(_object); end
  def event(*names, &block); end
  def events; end
  def generate_message(name, values = _); end
  def initial_state(object); end
  def initial_state=(new_initial_state); end
  def initialize_state(object, options = _); end
  def invalidate(_object, _attribute, _message, _values = _); end
  def name; end
  def namespace; end
  def on(*names, &block); end
  def other_states(*names, &block); end
  def owner_class; end
  def owner_class=(klass); end
  def paths_for(object, requirements = _); end
  def read(object, attribute, ivar = _); end
  def reset(_object); end
  def state(*names, &block); end
  def states; end
  def transition(options); end
  def use_transactions; end
  def within_transaction(object); end
  def write(object, attribute, value, ivar = _); end

  protected

  def action_hook; end
  def add_callback(type, options, &block); end
  def add_events(new_events); end
  def add_sibling_machine_configs; end
  def add_states(new_states); end
  def after_initialize; end
  def create_with_scope(name); end
  def create_without_scope(name); end
  def define_action_helpers; end
  def define_action_helpers?; end
  def define_action_hook; end
  def define_event_helpers; end
  def define_helpers; end
  def define_name_helpers; end
  def define_path_helpers; end
  def define_scopes(custom_plural = _); end
  def define_state_accessor; end
  def define_state_initializer; end
  def define_state_predicate; end
  def initialize_state?(object); end
  def owner_class_ancestor_has_method?(scope, method); end
  def owner_class_attribute_default; end
  def owner_class_attribute_default_matches?(state); end
  def owner_class_has_method?(scope, method); end
  def pluralize(word); end
  def run_scope(scope, machine, klass, states); end
  def sibling_machines; end
  def transaction(object); end

  private

  def initialize_copy(orig); end

  def self.default_messages; end
  def self.default_messages=(_); end
  def self.draw(*_); end
  def self.find_or_create(owner_class, *args, &block); end
  def self.ignore_method_conflicts; end
  def self.ignore_method_conflicts=(_); end
end

class StateMachines::MachineCollection < ::Hash
  def fire_events(object, *events); end
  def initialize_states(object, options = _, attributes = _); end
  def transitions(object, action, options = _); end

  protected

  def resolve_use_transactions; end
end

module StateMachines::MacroMethods
  def state_machine(*args, &block); end
end

class StateMachines::Matcher
  def initialize(values = _); end

  def filter(values); end
  def values; end
end

module StateMachines::MatcherHelpers
  def all; end
  def any; end
  def same; end
end

class StateMachines::NodeCollection
  include(::Enumerable)

  def initialize(machine, options = _); end

  def <<(node); end
  def [](key, index_name = _); end
  def at(index); end
  def concat(nodes); end
  def context(nodes, &block); end
  def each; end
  def fetch(key, index_name = _); end
  def keys(index_name = _); end
  def length; end
  def machine; end
  def machine=(new_machine); end
  def update(node); end

  protected

  def add_to_index(name, key, node); end
  def eval_context(context, node); end
  def index(name); end
  def remove_from_index(name, key); end
  def to_sym?(value); end
  def update_index(name, node); end
  def value(node, attribute); end

  private

  def initialize_copy(orig); end
end

class StateMachines::Path < ::Array
  def initialize(object, machine, options = _); end

  def complete?; end
  def events; end
  def from_name; end
  def from_states; end
  def machine; end
  def object; end
  def to_name; end
  def to_states; end
  def walk; end

  private

  def can_walk_to?(transition); end
  def initialize_copy(orig); end
  def recently_walked?(transition); end
  def times_walked_to(state); end
  def transitions; end
end

class StateMachines::PathCollection < ::Array
  def initialize(object, machine, options = _); end

  def events; end
  def from_name; end
  def from_states; end
  def machine; end
  def object; end
  def to_name; end
  def to_states; end

  private

  def initial_paths; end
  def walk(path); end
end

class StateMachines::State
  def initialize(machine, name, options = _); end

  def cache; end
  def cache=(_); end
  def call(object, method, *args, &block); end
  def context(&block); end
  def context_methods; end
  def description(options = _); end
  def draw(graph, options = _); end
  def final?; end
  def human_name(klass = _); end
  def human_name=(_); end
  def initial; end
  def initial=(_); end
  def initial?; end
  def inspect; end
  def machine; end
  def machine=(machine); end
  def matcher; end
  def matcher=(_); end
  def matches?(other_value); end
  def name; end
  def qualified_name; end
  def value(eval = _); end
  def value=(_); end

  private

  def add_predicate; end
  def cache_value?; end
  def context_name_for(method); end
  def initialize_copy(orig); end
end

class StateMachines::StateCollection < ::StateMachines::NodeCollection
  def initialize(machine); end

  def by_priority; end
  def match(object); end
  def match!(object); end
  def matches?(object, name); end

  private

  def value(node, attribute); end
end

class StateMachines::StateContext < ::Module
  include(::StateMachines::EvalHelpers)

  def initialize(state); end

  def machine; end
  def method_missing(*args, &block); end
  def state; end
  def transition(options); end
end

class StateMachines::Transition
  def initialize(object, machine, event, from_name, to_name, read_state = _); end

  def ==(other); end
  def action; end
  def args; end
  def args=(_); end
  def attribute; end
  def attributes; end
  def event; end
  def from; end
  def from_name; end
  def human_event; end
  def human_from_name; end
  def human_to_name; end
  def inspect; end
  def loopback?; end
  def machine; end
  def object; end
  def perform(*args); end
  def persist; end
  def qualified_event; end
  def qualified_from_name; end
  def qualified_to_name; end
  def reset; end
  def result; end
  def rollback; end
  def run_callbacks(options = _, &block); end
  def to; end
  def to_name; end
  def transient=(_); end
  def transient?; end
  def within_transaction; end

  private

  def after; end
  def before(complete = _, index = _, &block); end
  def context; end
  def pausable; end
  def pause; end
  def resume; end

  def self.pause_supported?; end
end

class StateMachines::TransitionCollection < ::Array
  def initialize(transitions = _, options = _); end

  def perform(&block); end
  def skip_actions; end
  def skip_after; end
  def use_transactions; end

  protected

  def results; end

  private

  def actions; end
  def catch_exceptions; end
  def object; end
  def persist; end
  def reset; end
  def rollback; end
  def run_actions; end
  def run_callbacks(index = _, &block); end
  def success?; end
  def use_event_attributes?; end
  def valid?; end
  def within_transaction; end
end

StateMachines::VERSION = T.let(T.unsafe(nil), String)

class StateMachines::WhitelistMatcher < ::StateMachines::Matcher
  def description; end
  def matches?(value, context = _); end
end
