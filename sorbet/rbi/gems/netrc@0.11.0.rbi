# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `netrc` gem.
# Please instead update this file by running `bin/tapioca gem netrc`.


# pkg:gem/netrc#lib/netrc.rb:3
class Netrc
  # pkg:gem/netrc#lib/netrc.rb:166
  def initialize(path, data); end

  # pkg:gem/netrc#lib/netrc.rb:180
  def [](k); end

  # pkg:gem/netrc#lib/netrc.rb:188
  def []=(k, info); end

  # pkg:gem/netrc#lib/netrc.rb:200
  def delete(key); end

  # pkg:gem/netrc#lib/netrc.rb:211
  def each(&block); end

  # pkg:gem/netrc#lib/netrc.rb:196
  def length; end

  # pkg:gem/netrc#lib/netrc.rb:215
  def new_item(m, l, p); end

  # pkg:gem/netrc#lib/netrc.rb:178
  def new_item_prefix; end

  # pkg:gem/netrc#lib/netrc.rb:178
  def new_item_prefix=(_arg0); end

  # pkg:gem/netrc#lib/netrc.rb:219
  def save; end

  # pkg:gem/netrc#lib/netrc.rb:233
  def unparse; end

  class << self
    # pkg:gem/netrc#lib/netrc.rb:42
    def check_permissions(path); end

    # pkg:gem/netrc#lib/netrc.rb:33
    def config; end

    # pkg:gem/netrc#lib/netrc.rb:37
    def configure; end

    # pkg:gem/netrc#lib/netrc.rb:10
    def default_path; end

    # pkg:gem/netrc#lib/netrc.rb:14
    def home_path; end

    # pkg:gem/netrc#lib/netrc.rb:85
    def lex(lines); end

    # pkg:gem/netrc#lib/netrc.rb:29
    def netrc_filename; end

    # Returns two values, a header and a list of items.
    # Each item is a tuple, containing some or all of:
    # - machine keyword (including trailing whitespace+comments)
    # - machine name
    # - login keyword (including surrounding whitespace+comments)
    # - login
    # - password keyword (including surrounding whitespace+comments)
    # - password
    # - trailing chars
    # This lets us change individual fields, then write out the file
    # with all its original formatting.
    #
    # pkg:gem/netrc#lib/netrc.rb:129
    def parse(ts); end

    # Reads path and parses it as a .netrc file. If path doesn't
    # exist, returns an empty object. Decrypt paths ending in .gpg.
    #
    # pkg:gem/netrc#lib/netrc.rb:51
    def read(path = T.unsafe(nil)); end

    # pkg:gem/netrc#lib/netrc.rb:112
    def skip?(s); end
  end
end

# pkg:gem/netrc#lib/netrc.rb:8
Netrc::CYGWIN = T.let(T.unsafe(nil), T.untyped)

# pkg:gem/netrc#lib/netrc.rb:244
class Netrc::Entry < ::Struct
  # pkg:gem/netrc#lib/netrc.rb:244
  def login; end

  # pkg:gem/netrc#lib/netrc.rb:244
  def login=(_); end

  # pkg:gem/netrc#lib/netrc.rb:244
  def password; end

  # pkg:gem/netrc#lib/netrc.rb:244
  def password=(_); end

  # pkg:gem/netrc#lib/netrc.rb:245
  def to_ary; end

  class << self
    # pkg:gem/netrc#lib/netrc.rb:244
    def [](*_arg0); end

    # pkg:gem/netrc#lib/netrc.rb:244
    def inspect; end

    # pkg:gem/netrc#lib/netrc.rb:244
    def keyword_init?; end

    # pkg:gem/netrc#lib/netrc.rb:244
    def members; end

    # pkg:gem/netrc#lib/netrc.rb:244
    def new(*_arg0); end
  end
end

# pkg:gem/netrc#lib/netrc.rb:250
class Netrc::Error < ::StandardError; end

# pkg:gem/netrc#lib/netrc.rb:68
class Netrc::TokenArray < ::Array
  # pkg:gem/netrc#lib/netrc.rb:76
  def readto; end

  # pkg:gem/netrc#lib/netrc.rb:69
  def take; end
end

# pkg:gem/netrc#lib/netrc.rb:4
Netrc::VERSION = T.let(T.unsafe(nil), String)

# see http://stackoverflow.com/questions/4871309/what-is-the-correct-way-to-detect-if-ruby-is-running-on-windows
#
# pkg:gem/netrc#lib/netrc.rb:7
Netrc::WINDOWS = T.let(T.unsafe(nil), T.untyped)
