# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `state_machines` gem.
# Please instead update this file by running `bin/tapioca gem state_machines`.


class Class < ::Module
  include ::StateMachines::MacroMethods
end

# A state machine is a model of behavior composed of states, events, and
# transitions.  This helper adds support for defining this type of
# functionality on any Ruby class.
#
# source://state_machines//lib/state_machines/version.rb#3
module StateMachines; end

# Matches any given value.  Since there is no configuration for this type of
# matcher, it must be used as a singleton.
#
# source://state_machines//lib/state_machines/matcher.rb#25
class StateMachines::AllMatcher < ::StateMachines::Matcher
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Generates a blacklist matcher based on the given set of values
  #
  # == Examples
  #
  #   matcher = StateMachines::AllMatcher.instance - [:parked, :idling]
  #   matcher.matches?(:parked)       # => false
  #   matcher.matches?(:first_gear)   # => true
  #
  # source://state_machines//lib/state_machines/matcher.rb#35
  def -(other); end

  # A human-readable description of this matcher.  Always "all".
  #
  # source://state_machines//lib/state_machines/matcher.rb#51
  def description; end

  # Generates a blacklist matcher based on the given set of values
  #
  # == Examples
  #
  #   matcher = StateMachines::AllMatcher.instance - [:parked, :idling]
  #   matcher.matches?(:parked)       # => false
  #   matcher.matches?(:first_gear)   # => true
  #
  # source://state_machines//lib/state_machines/matcher.rb#38
  def except(other); end

  # Always returns the given set of values
  #
  # source://state_machines//lib/state_machines/matcher.rb#46
  def filter(values); end

  # Always returns true
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/matcher.rb#41
  def matches?(_value, _context = T.unsafe(nil)); end

  class << self
    private

    # source://state_machines//lib/state_machines/matcher.rb#26
    def allocate; end

    # source://state_machines//lib/state_machines/matcher.rb#26
    def new(*_arg0); end
  end
end

# Represents a collection of transitions that were generated from attribute-
# based events
#
# source://state_machines//lib/state_machines/transition_collection.rb#215
class StateMachines::AttributeTransitionCollection < ::StateMachines::TransitionCollection
  # @return [AttributeTransitionCollection] a new instance of AttributeTransitionCollection
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#216
  def initialize(transitions = T.unsafe(nil), options = T.unsafe(nil)); end

  private

  # Tracks that before callbacks have now completed
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#266
  def persist; end

  # Resets callback tracking
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#272
  def reset; end

  # Resets the event attribute so it can be re-evaluated if attempted again
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#278
  def rollback; end

  # Hooks into running transition callbacks so that event / event transition
  # attributes can be properly updated
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#224
  def run_callbacks(index = T.unsafe(nil)); end
end

# Matches everything but a specific set of values
#
# source://state_machines//lib/state_machines/matcher.rb#77
class StateMachines::BlacklistMatcher < ::StateMachines::Matcher
  # A human-readable description of this matcher
  #
  # source://state_machines//lib/state_machines/matcher.rb#97
  def description; end

  # Finds all values that are *not* within the blacklist configured for this
  # matcher
  #
  # source://state_machines//lib/state_machines/matcher.rb#92
  def filter(values); end

  # Checks whether the given value exists outside the blacklist configured
  # for this matcher.
  #
  # == Examples
  #
  #   matcher = StateMachines::BlacklistMatcher.new([:parked, :idling])
  #   matcher.matches?(:parked)       # => false
  #   matcher.matches?(:first_gear)   # => true
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/matcher.rb#86
  def matches?(value, _context = T.unsafe(nil)); end
end

# Represents a set of requirements that must be met in order for a transition
# or callback to occur.  Branches verify that the event, from state, and to
# state of the transition match, in addition to if/unless conditionals for
# an object's state.
#
# source://state_machines//lib/state_machines/branch.rb#10
class StateMachines::Branch
  include ::StateMachines::EvalHelpers

  # Creates a new branch
  #
  # @return [Branch] a new instance of Branch
  #
  # source://state_machines//lib/state_machines/branch.rb#33
  def initialize(options = T.unsafe(nil)); end

  # Determines whether the given object / query matches the requirements
  # configured for this branch.  In addition to matching the event, from state,
  # and to state, this will also check whether the configured :if/:unless
  # conditions pass on the given object.
  #
  # == Examples
  #
  #   branch = StateMachines::Branch.new(:parked => :idling, :on => :ignite)
  #
  #   # Successful
  #   branch.matches?(object, :on => :ignite)                                   # => true
  #   branch.matches?(object, :from => nil)                                     # => true
  #   branch.matches?(object, :from => :parked)                                 # => true
  #   branch.matches?(object, :to => :idling)                                   # => true
  #   branch.matches?(object, :from => :parked, :to => :idling)                 # => true
  #   branch.matches?(object, :on => :ignite, :from => :parked, :to => :idling) # => true
  #
  #   # Unsuccessful
  #   branch.matches?(object, :on => :park)                                     # => false
  #   branch.matches?(object, :from => :idling)                                 # => false
  #   branch.matches?(object, :to => :first_gear)                               # => false
  #   branch.matches?(object, :from => :parked, :to => :first_gear)             # => false
  #   branch.matches?(object, :on => :park, :from => :parked, :to => :idling)   # => false
  # Alias for Minitest's assert_match
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/branch.rb#99
  def =~(object, query = T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/branch.rb#136
  def draw(graph, event, valid_states, io = T.unsafe(nil)); end

  # The requirement for verifying the event being matched
  #
  # source://state_machines//lib/state_machines/branch.rb#20
  def event_requirement; end

  # The condition that must be met on an object
  #
  # source://state_machines//lib/state_machines/branch.rb#14
  def if_condition; end

  # A list of all of the states known to this branch.  This will pull states
  # from the following options (in the same order):
  # * +from+ / +except_from+
  # * +to+ / +except_to+
  #
  # source://state_machines//lib/state_machines/branch.rb#30
  def known_states; end

  # Attempts to match the given object / query against the set of requirements
  # configured for this branch.  In addition to matching the event, from state,
  # and to state, this will also check whether the configured :if/:unless
  # conditions pass on the given object.
  #
  # If a match is found, then the event/state requirements that the query
  # passed successfully will be returned.  Otherwise, nil is returned if there
  # was no match.
  #
  # Query options:
  # * <tt>:from</tt> - One or more states being transitioned from.  If none
  #   are specified, then this will always match.
  # * <tt>:to</tt> - One or more states being transitioned to.  If none are
  #   specified, then this will always match.
  # * <tt>:on</tt> - One or more events that fired the transition.  If none
  #   are specified, then this will always match.
  # * <tt>:guard</tt> - Whether to guard matches with the if/unless
  #   conditionals defined for this branch.  Default is true.
  #
  # Event arguments are passed to guard conditions if they accept multiple parameters.
  #
  # == Examples
  #
  #   branch = StateMachines::Branch.new(:parked => :idling, :on => :ignite)
  #
  #   branch.match(object, :on => :ignite)  # => {:to => ..., :from => ..., :on => ...}
  #   branch.match(object, :on => :park)    # => nil
  #
  # source://state_machines//lib/state_machines/branch.rb#128
  def match(object, query = T.unsafe(nil), event_args = T.unsafe(nil)); end

  # Determines whether the given object / query matches the requirements
  # configured for this branch.  In addition to matching the event, from state,
  # and to state, this will also check whether the configured :if/:unless
  # conditions pass on the given object.
  #
  # == Examples
  #
  #   branch = StateMachines::Branch.new(:parked => :idling, :on => :ignite)
  #
  #   # Successful
  #   branch.matches?(object, :on => :ignite)                                   # => true
  #   branch.matches?(object, :from => nil)                                     # => true
  #   branch.matches?(object, :from => :parked)                                 # => true
  #   branch.matches?(object, :to => :idling)                                   # => true
  #   branch.matches?(object, :from => :parked, :to => :idling)                 # => true
  #   branch.matches?(object, :on => :ignite, :from => :parked, :to => :idling) # => true
  #
  #   # Unsuccessful
  #   branch.matches?(object, :on => :park)                                     # => false
  #   branch.matches?(object, :from => :idling)                                 # => false
  #   branch.matches?(object, :to => :first_gear)                               # => false
  #   branch.matches?(object, :from => :parked, :to => :first_gear)             # => false
  #   branch.matches?(object, :on => :park, :from => :parked, :to => :idling)   # => false
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/branch.rb#94
  def matches?(object, query = T.unsafe(nil)); end

  # One or more requirements for verifying the states being matched.  All
  # requirements contain a mapping of {:from => matcher, :to => matcher}.
  #
  # source://state_machines//lib/state_machines/branch.rb#24
  def state_requirements; end

  # The condition that must *not* be met on an object
  #
  # source://state_machines//lib/state_machines/branch.rb#17
  def unless_condition; end

  protected

  # Builds a matcher strategy to use for the given options.  If neither a
  # whitelist nor a blacklist option is specified, then an AllMatcher is
  # built.
  #
  # source://state_machines//lib/state_machines/branch.rb#145
  def build_matcher(options, whitelist_option, blacklist_option); end

  # Verifies that the event requirement matches the given query
  #
  # source://state_machines//lib/state_machines/branch.rb#173
  def match_event(query); end

  # Verifies that all configured requirements (event and state) match the
  # given query.  If a match is found, then a hash containing the
  # event/state requirements that passed will be returned; otherwise, nil.
  #
  # source://state_machines//lib/state_machines/branch.rb#164
  def match_query(query); end

  # Verifies that the state requirements match the given query.  If a
  # matching requirement is found, then it is returned.
  #
  # source://state_machines//lib/state_machines/branch.rb#179
  def match_states(query); end

  # Verifies that the conditionals for this branch evaluate to true for the
  # given object. Event arguments are passed to guards that accept multiple parameters.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/branch.rb#193
  def matches_conditions?(object, query, event_args = T.unsafe(nil)); end

  # Verifies that an option in the given query matches the values required
  # for that option
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/branch.rb#187
  def matches_requirement?(query, option, requirement); end

  private

  # @raise [ArgumentError]
  #
  # source://state_machines//lib/state_machines/branch.rb#236
  def check_state(object, machine_name, state_name); end

  # source://state_machines//lib/state_machines/branch.rb#219
  def validate_and_check_state_guards(object, guards); end
end

# Callbacks represent hooks into objects that allow logic to be triggered
# before, after, or around a specific set of transitions.
#
# source://state_machines//lib/state_machines/callback.rb#9
class StateMachines::Callback
  include ::StateMachines::EvalHelpers

  # Creates a new callback that can get called based on the configured
  # options.
  #
  # In addition to the possible configuration options for branches, the
  # following options can be configured:
  # * <tt>:bind_to_object</tt> - Whether to bind the callback to the object involved.
  #   If set to false, the object will be passed as a parameter instead.
  #   Default is integration-specific or set to the application default.
  # * <tt>:terminator</tt> - A block/proc that determines what callback
  #   results should cause the callback chain to halt (if not using the
  #   default <tt>throw :halt</tt> technique).
  #
  # More information about how those options affect the behavior of the
  # callback can be found in their attribute definitions.
  #
  # @raise [ArgumentError]
  # @return [Callback] a new instance of Callback
  #
  # source://state_machines//lib/state_machines/callback.rb#125
  def initialize(type, *args, &block); end

  # The branch that determines whether or not this callback can be invoked
  # based on the context of the transition.  The event, from state, and
  # to state must all match in order for the branch to pass.
  #
  # See StateMachines::Branch for more information.
  #
  # source://state_machines//lib/state_machines/callback.rb#109
  def branch; end

  # Runs the callback as long as the transition context matches the branch
  # requirements configured for this callback.  If a block is provided, it
  # will be called when the last method has run.
  #
  # If a terminator has been configured and it matches the result from the
  # evaluated method, then the callback chain should be halted.
  #
  # source://state_machines//lib/state_machines/callback.rb#159
  def call(object, context = T.unsafe(nil), *_arg2, &_arg3); end

  # Gets a list of the states known to this callback by looking at the
  # branch's known states
  #
  # source://state_machines//lib/state_machines/callback.rb#149
  def known_states; end

  # An optional block for determining whether to cancel the callback chain
  # based on the return value of the callback.  By default, the callback
  # chain never cancels based on the return value (i.e. there is no implicit
  # terminator).  Certain integrations, such as ActiveRecord and Sequel,
  # change this default value.
  #
  # == Examples
  #
  # Canceling the callback chain without a terminator:
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition do |vehicle|
  #         throw :halt
  #       end
  #     end
  #   end
  #
  # Canceling the callback chain with a terminator value of +false+:
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition do |vehicle|
  #         false
  #       end
  #     end
  #   end
  #
  # source://state_machines//lib/state_machines/callback.rb#102
  def terminator; end

  # The type of callback chain this callback is for.  This can be one of the
  # following:
  # * +before+
  # * +after+
  # * +around+
  # * +failure+
  #
  # source://state_machines//lib/state_machines/callback.rb#73
  def type; end

  # The type of callback chain this callback is for.  This can be one of the
  # following:
  # * +before+
  # * +after+
  # * +around+
  # * +failure+
  #
  # source://state_machines//lib/state_machines/callback.rb#73
  def type=(_arg0); end

  private

  # Generates a method that can be bound to the object being transitioned
  # when the callback is invoked
  #
  # source://state_machines//lib/state_machines/callback.rb#204
  def bound_method(block); end

  # Runs all of the methods configured for this callback.
  #
  # When running +around+ callbacks, this will evaluate each method and
  # yield when the last method has yielded.  The callback will only halt if
  # one of the methods does not yield.
  #
  # For all other types of callbacks, this will evaluate each method in
  # order.  The callback will only halt if the resulting value from the
  # method passes the terminator.
  #
  # source://state_machines//lib/state_machines/callback.rb#179
  def run_methods(object, context = T.unsafe(nil), index = T.unsafe(nil), *args, &block); end

  class << self
    # Determines whether to automatically bind the callback to the object
    # being transitioned.  This only applies to callbacks that are defined as
    # lambda blocks (or Procs).  Some integrations, such as DataMapper, handle
    # callbacks by executing them bound to the object involved, while other
    # integrations, such as ActiveRecord, pass the object as an argument to
    # the callback.  This can be configured on an application-wide basis by
    # setting this configuration to +true+ or +false+.  The default value
    # is +false+.
    #
    # *Note* that the DataMapper and Sequel integrations automatically
    # configure this value on a per-callback basis, so it does not have to
    # be enabled application-wide.
    #
    # == Examples
    #
    # When not bound to the object:
    #
    #   class Vehicle
    #     state_machine do
    #       before_transition do |vehicle|
    #         vehicle.set_alarm
    #       end
    #     end
    #
    #     def set_alarm
    #       ...
    #     end
    #   end
    #
    # When bound to the object:
    #
    #   StateMachines::Callback.bind_to_object = true
    #
    #   class Vehicle
    #     state_machine do
    #       before_transition do
    #         self.set_alarm
    #       end
    #     end
    #
    #     def set_alarm
    #       ...
    #     end
    #   end
    #
    # source://state_machines//lib/state_machines/callback.rb#57
    def bind_to_object; end

    # Determines whether to automatically bind the callback to the object
    # being transitioned.  This only applies to callbacks that are defined as
    # lambda blocks (or Procs).  Some integrations, such as DataMapper, handle
    # callbacks by executing them bound to the object involved, while other
    # integrations, such as ActiveRecord, pass the object as an argument to
    # the callback.  This can be configured on an application-wide basis by
    # setting this configuration to +true+ or +false+.  The default value
    # is +false+.
    #
    # *Note* that the DataMapper and Sequel integrations automatically
    # configure this value on a per-callback basis, so it does not have to
    # be enabled application-wide.
    #
    # == Examples
    #
    # When not bound to the object:
    #
    #   class Vehicle
    #     state_machine do
    #       before_transition do |vehicle|
    #         vehicle.set_alarm
    #       end
    #     end
    #
    #     def set_alarm
    #       ...
    #     end
    #   end
    #
    # When bound to the object:
    #
    #   StateMachines::Callback.bind_to_object = true
    #
    #   class Vehicle
    #     state_machine do
    #       before_transition do
    #         self.set_alarm
    #       end
    #     end
    #
    #     def set_alarm
    #       ...
    #     end
    #   end
    #
    # source://state_machines//lib/state_machines/callback.rb#57
    def bind_to_object=(_arg0); end

    # The application-wide terminator to use for callbacks when not
    # explicitly defined.  Terminators determine whether to cancel a
    # callback chain based on the return value of the callback.
    #
    # See StateMachines::Callback#terminator for more information.
    #
    # source://state_machines//lib/state_machines/callback.rb#64
    def terminator; end

    # The application-wide terminator to use for callbacks when not
    # explicitly defined.  Terminators determine whether to cancel a
    # callback chain based on the return value of the callback.
    #
    # See StateMachines::Callback#terminator for more information.
    #
    # source://state_machines//lib/state_machines/callback.rb#64
    def terminator=(_arg0); end
  end
end

# source://state_machines//lib/state_machines/extensions.rb#4
module StateMachines::ClassMethods
  # Gets the current list of state machines defined for this class.  This
  # class-level attribute acts like an inheritable attribute.  The attribute
  # is available to each subclass, each having a copy of its superclass's
  # attribute.
  #
  # The hash of state machines maps <tt>:attribute</tt> => +machine+, e.g.
  #
  #   Vehicle.state_machines # => {:state => #<StateMachines::Machine:0xb6f6e4a4 ...>}
  #
  # source://state_machines//lib/state_machines/extensions.rb#19
  def state_machines; end

  class << self
    # source://state_machines//lib/state_machines/extensions.rb#5
    def extended(base); end
  end
end

# An error occurred during a state machine invocation
#
# source://state_machines//lib/state_machines/error.rb#5
class StateMachines::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://state_machines//lib/state_machines/error.rb#9
  def initialize(object, message = T.unsafe(nil)); end

  # The object that failed
  #
  # source://state_machines//lib/state_machines/error.rb#7
  def object; end
end

# Provides a set of helper methods for evaluating methods within the context
# of an object.
#
# source://state_machines//lib/state_machines/eval_helpers.rb#8
module StateMachines::EvalHelpers
  # Evaluates one of several different types of methods within the context
  # of the given object.  Methods can be one of the following types:
  # * Symbol
  # * Method / Proc
  # * String
  #
  # == Examples
  #
  # Below are examples of the various ways that a method can be evaluated
  # on an object:
  #
  #   class Person
  #     def initialize(name)
  #       @name = name
  #     end
  #
  #     def name
  #       @name
  #     end
  #   end
  #
  #   class PersonCallback
  #     def self.run(person)
  #       person.name
  #     end
  #   end
  #
  #   person = Person.new('John Smith')
  #
  #   evaluate_method(person, :name)                            # => "John Smith"
  #   evaluate_method(person, PersonCallback.method(:run))      # => "John Smith"
  #   evaluate_method(person, Proc.new {|person| person.name})  # => "John Smith"
  #   evaluate_method(person, lambda {|person| person.name})    # => "John Smith"
  #   evaluate_method(person, '@name')                          # => "John Smith"
  #
  # == Additional arguments
  #
  # Additional arguments can be passed to the methods being evaluated.  If
  # the method defines additional arguments other than the object context,
  # then all arguments are required.
  #
  # For guard conditions in state machines, event arguments can be passed
  # automatically based on the guard's arity:
  # - Guards with arity 1 receive only the object (backward compatible)
  # - Guards with arity -1 or > 1 receive object + event arguments
  #
  # For example,
  #
  #   person = Person.new('John Smith')
  #
  #   evaluate_method(person, lambda {|person| person.name}, 21)                              # => "John Smith"
  #   evaluate_method(person, lambda {|person, age| "#{person.name} is #{age}"}, 21)          # => "John Smith is 21"
  #   evaluate_method(person, lambda {|person, age| "#{person.name} is #{age}"}, 21, 'male')  # => ArgumentError: wrong number of arguments (3 for 2)
  #
  # With event arguments for guards:
  #
  #   # Single parameter guard (backward compatible)
  #   guard = lambda {|obj| obj.valid? }
  #   evaluate_method_with_event_args(object, guard, [arg1, arg2])  # => calls guard.call(object)
  #
  #   # Multi-parameter guard (receives event args)
  #   guard = lambda {|obj, *args| obj.valid? && args[0] == :force }
  #   evaluate_method_with_event_args(object, guard, [:force])      # => calls guard.call(object, :force)
  #
  # source://state_machines//lib/state_machines/eval_helpers.rb#72
  def evaluate_method(object, method, *args, **_arg3, &block); end

  # Evaluates a guard method with support for event arguments passed to transitions.
  # This method uses arity detection to determine whether to pass event arguments
  # to the guard, ensuring backward compatibility.
  #
  # == Parameters
  # * object - The object context to evaluate within
  # * method - The guard method/proc to evaluate
  # * event_args - Array of arguments passed to the event (optional)
  #
  # == Arity-based behavior
  # * Arity 1: Only passes the object (backward compatible)
  # * Arity -1 or > 1: Passes object + event arguments
  #
  # == Examples
  #
  #   # Backward compatible single-parameter guard
  #   guard = lambda {|obj| obj.valid? }
  #   evaluate_method_with_event_args(object, guard, [:force])  # => calls guard.call(object)
  #
  #   # New multi-parameter guard receiving event args
  #   guard = lambda {|obj, *args| obj.valid? && args[0] != :skip }
  #   evaluate_method_with_event_args(object, guard, [:skip])   # => calls guard.call(object, :skip)
  #
  # source://state_machines//lib/state_machines/eval_helpers.rb#160
  def evaluate_method_with_event_args(object, method, event_args = T.unsafe(nil)); end

  private

  # Validates string input before eval to prevent code injection
  # This is a basic safety check - not foolproof security
  #
  # source://state_machines//lib/state_machines/eval_helpers.rb#215
  def validate_eval_string(method_string); end
end

# An event defines an action that transitions an attribute from one state to
# another.  The state that an attribute is transitioned to depends on the
# branches configured for the event.
#
# source://state_machines//lib/state_machines/event.rb#9
class StateMachines::Event
  include ::StateMachines::MatcherHelpers

  # Creates a new event within the context of the given machine
  #
  # Configuration options:
  # * <tt>:human_name</tt> - The human-readable version of this event's name
  #
  # @return [Event] a new instance of Event
  #
  # source://state_machines//lib/state_machines/event.rb#36
  def initialize(machine, name, options = T.unsafe(nil), human_name: T.unsafe(nil), **extra_options); end

  # The list of branches that determine what state this event transitions
  # objects to when fired
  #
  # source://state_machines//lib/state_machines/event.rb#26
  def branches; end

  # Determines whether any transitions can be performed for this event based
  # on the current state of the given object.
  #
  # If the event can't be fired, then this will return false, otherwise true.
  #
  # *Note* that this will not take the object context into account.  Although
  # a transition may be possible based on the state machine definition,
  # object-specific behaviors (like validations) may prevent it from firing.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/event.rb#122
  def can_fire?(object, requirements = T.unsafe(nil)); end

  # Evaluates the given block within the context of this event.  This simply
  # provides a DSL-like syntax for defining transitions.
  #
  # source://state_machines//lib/state_machines/event.rb#82
  def context(&_arg0); end

  # source://state_machines//lib/state_machines/event.rb#199
  def draw(graph, options = T.unsafe(nil), io = T.unsafe(nil)); end

  # Attempts to perform the next available transition on the given object.
  # If no transitions can be made, then this will return false, otherwise
  # true.
  #
  # Any additional arguments are passed to the StateMachines::Transition#perform
  # instance method.
  #
  # source://state_machines//lib/state_machines/event.rb#168
  def fire(object, *event_args); end

  # Transforms the event name into a more human-readable format, such as
  # "turn on" instead of "turn_on"
  #
  # source://state_machines//lib/state_machines/event.rb#76
  def human_name(klass = T.unsafe(nil)); end

  # The human-readable name for the event
  #
  # source://state_machines//lib/state_machines/event.rb#22
  def human_name=(_arg0); end

  # Generates a nicely formatted description of this event's contents.
  #
  # For example,
  #
  #   event = StateMachines::Event.new(machine, :park)
  #   event.transition all - :idling => :parked, :idling => same
  #   event   # => #<StateMachines::Event name=:park transitions=[all - :idling => :parked, :idling => same]>
  #
  # source://state_machines//lib/state_machines/event.rb#210
  def inspect; end

  # A list of all of the states known to this event using the configured
  # branches/transitions as the source
  #
  # source://state_machines//lib/state_machines/event.rb#30
  def known_states; end

  # The state machine for which this event is defined
  #
  # source://state_machines//lib/state_machines/event.rb#13
  def machine; end

  # The state machine for which this event is defined
  #
  # source://state_machines//lib/state_machines/event.rb#13
  def machine=(_arg0); end

  # The name of the event
  #
  # source://state_machines//lib/state_machines/event.rb#16
  def name; end

  # Marks the object as invalid and runs any failure callbacks associated with
  # this event.  This should get called anytime this event fails to transition.
  #
  # source://state_machines//lib/state_machines/event.rb#181
  def on_failure(object, *args); end

  # The fully-qualified name of the event, scoped by the machine's namespace
  #
  # source://state_machines//lib/state_machines/event.rb#19
  def qualified_name; end

  # Resets back to the initial state of the event, with no branches / known
  # states associated.  This allows you to redefine an event in situations
  # where you either are re-using an existing state machine implementation
  # or are subclassing machines.
  #
  # source://state_machines//lib/state_machines/event.rb#194
  def reset; end

  # Creates a new transition that determines what to change the current state
  # to when this event fires.
  #
  # Since this transition is being defined within an event context, you do
  # *not* need to specify the <tt>:on</tt> option for the transition.  For
  # example:
  #
  #  state_machine do
  #    event :ignite do
  #      transition :parked => :idling, :idling => same, :if => :seatbelt_on? # Transitions to :idling if seatbelt is on
  #      transition all => :parked, :unless => :seatbelt_on?                  # Transitions to :parked if seatbelt is off
  #    end
  #  end
  #
  # See StateMachines::Machine#transition for a description of the possible
  # configurations for defining transitions.
  #
  # @raise [ArgumentError]
  #
  # source://state_machines//lib/state_machines/event.rb#102
  def transition(options); end

  # Finds and builds the next transition that can be performed on the given
  # object.  If no transitions can be made, then this will return nil.
  #
  # Valid requirement options:
  # * <tt>:from</tt> - One or more states being transitioned from.  If none
  #   are specified, then this will be the object's current state.
  # * <tt>:to</tt> - One or more states being transitioned to.  If none are
  #   specified, then this will match any to state.
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one.  Default is true.
  #
  # Event arguments are passed to guard conditions if they accept multiple parameters.
  #
  # source://state_machines//lib/state_machines/event.rb#138
  def transition_for(object, requirements = T.unsafe(nil), *event_args); end

  protected

  # Add the various instance methods that can transition the object using
  # the current event
  #
  # source://state_machines//lib/state_machines/event.rb#224
  def add_actions; end

  private

  # Creates a copy of this event in addition to the list of associated
  # branches to prevent conflicts across events within a class hierarchy.
  #
  # source://state_machines//lib/state_machines/event.rb#68
  def initialize_copy(orig); end
end

# Represents a collection of events in a state machine
#
# source://state_machines//lib/state_machines/event_collection.rb#5
class StateMachines::EventCollection < ::StateMachines::NodeCollection
  # @return [EventCollection] a new instance of EventCollection
  #
  # source://state_machines//lib/state_machines/event_collection.rb#6
  def initialize(machine); end

  # Gets the transition that should be performed for the event stored in the
  # given object's event attribute.  This also takes an additional parameter
  # for automatically invalidating the object if the event or transition are
  # invalid.  By default, this is turned off.
  #
  # *Note* that if a transition has already been generated for the event, then
  # that transition will be used.
  #
  # == Examples
  #
  #   class Vehicle < ActiveRecord::Base
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new                       # => #<Vehicle id: nil, state: "parked">
  #   events = Vehicle.state_machine.events
  #
  #   vehicle.state_event = nil
  #   events.attribute_transition_for(vehicle)    # => nil # Event isn't defined
  #
  #   vehicle.state_event = 'invalid'
  #   events.attribute_transition_for(vehicle)    # => false # Event is invalid
  #
  #   vehicle.state_event = 'ignite'
  #   events.attribute_transition_for(vehicle)    # => #<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>
  #
  # source://state_machines//lib/state_machines/event_collection.rb#116
  def attribute_transition_for(object, invalidate = T.unsafe(nil)); end

  # Gets the list of transitions that can be run on the given object.
  #
  # Valid requirement options:
  # * <tt>:from</tt> - One or more states being transitioned from.  If none
  #   are specified, then this will be the object's current state.
  # * <tt>:to</tt> - One or more states being transitioned to.  If none are
  #   specified, then this will match any to state.
  # * <tt>:on</tt> - One or more events that fire the transition.  If none
  #   are specified, then this will match any event.
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one.  Default is true.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :park do
  #         transition :idling => :parked
  #       end
  #
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #   end
  #
  #   events = Vehicle.state_machine.events
  #
  #   vehicle = Vehicle.new                             # => #<Vehicle:0xb7c464b0 @state="parked">
  #   events.transitions_for(vehicle)                   # => [#<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
  #
  #   vehicle.state = 'idling'
  #   events.transitions_for(vehicle)                   # => [#<StateMachines::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>]
  #
  #   # Search for explicit transitions regardless of the current state
  #   events.transitions_for(vehicle, :from => :parked) # => [#<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
  #
  # source://state_machines//lib/state_machines/event_collection.rb#83
  def transitions_for(object, requirements = T.unsafe(nil)); end

  # Gets the list of events that can be fired on the given object.
  #
  # Valid requirement options:
  # * <tt>:from</tt> - One or more states being transitioned from.  If none
  #   are specified, then this will be the object's current state.
  # * <tt>:to</tt> - One or more states being transitioned to.  If none are
  #   specified, then this will match any to state.
  # * <tt>:on</tt> - One or more events that fire the transition.  If none
  #   are specified, then this will match any event.
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one.  Default is true.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :park do
  #         transition :idling => :parked
  #       end
  #
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #   end
  #
  #   events = Vehicle.state_machine(:state).events
  #
  #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
  #   events.valid_for(vehicle)           # => [#<StateMachines::Event name=:ignite transitions=[:parked => :idling]>]
  #
  #   vehicle.state = 'idling'
  #   events.valid_for(vehicle)           # => [#<StateMachines::Event name=:park transitions=[:idling => :parked]>]
  #
  # source://state_machines//lib/state_machines/event_collection.rb#43
  def valid_for(object, requirements = T.unsafe(nil)); end

  private

  # source://state_machines//lib/state_machines/event_collection.rb#145
  def match(requirements); end
end

# Represents a type of module that defines instance / class methods for a
# state machine
#
# source://state_machines//lib/state_machines/helper_module.rb#6
class StateMachines::HelperModule < ::Module
  # @return [HelperModule] a new instance of HelperModule
  #
  # source://state_machines//lib/state_machines/helper_module.rb#7
  def initialize(machine, kind); end

  # Provides a human-readable description of the module
  #
  # source://state_machines//lib/state_machines/helper_module.rb#13
  def to_s; end
end

# source://state_machines//lib/state_machines/extensions.rb#24
module StateMachines::InstanceMethods
  # Runs one or more events in parallel.  All events will run through the
  # following steps:
  # * Before callbacks
  # * Persist state
  # * Invoke action
  # * After callbacks
  #
  # For example, if two events (for state machines A and B) are run in
  # parallel, the order in which steps are run is:
  # * A - Before transition callbacks
  # * B - Before transition callbacks
  # * A - Persist new state
  # * B - Persist new state
  # * A - Invoke action
  # * B - Invoke action (only if different than A's action)
  # * A - After transition callbacks
  # * B - After transition callbacks
  #
  # *Note* that multiple events on the same state machine / attribute cannot
  # be run in parallel.  If this is attempted, an ArgumentError will be
  # raised.
  #
  # == Halting callbacks
  #
  # When running multiple events in parallel, special consideration should
  # be taken with regard to how halting within callbacks affects the flow.
  #
  # For *before* callbacks, any <tt>:halt</tt> error that's thrown will
  # immediately cancel the perform for all transitions.  As a result, it's
  # possible for one event's transition to affect the continuation of
  # another.
  #
  # On the other hand, any <tt>:halt</tt> error that's thrown within an
  # *after* callback with only affect that event's transition.  Other
  # transitions will continue to run their own callbacks.
  #
  # == Example
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #
  #       event :park do
  #         transition :idling => :parked
  #       end
  #     end
  #
  #     state_machine :alarm_state, :namespace => 'alarm', :initial => :on do
  #       event :enable do
  #         transition all => :active
  #       end
  #
  #       event :disable do
  #         transition all => :off
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
  #   vehicle.state                                 # => "parked"
  #   vehicle.alarm_state                           # => "active"
  #
  #   vehicle.fire_events(:ignite, :disable_alarm)  # => true
  #   vehicle.state                                 # => "idling"
  #   vehicle.alarm_state                           # => "off"
  #
  #   # If any event fails, the entire event chain fails
  #   vehicle.fire_events(:ignite, :enable_alarm)   # => false
  #   vehicle.state                                 # => "idling"
  #   vehicle.alarm_state                           # => "off"
  #
  #   # Exception raised on invalid event
  #   vehicle.fire_events(:park, :invalid)          # => StateMachines::InvalidEvent: :invalid is an unknown event
  #   vehicle.state                                 # => "idling"
  #   vehicle.alarm_state                           # => "off"
  #
  # source://state_machines//lib/state_machines/extensions.rb#102
  def fire_events(*events); end

  # Run one or more events in parallel.  If any event fails to run, then
  # a StateMachines::InvalidTransition exception will be raised.
  #
  # See StateMachines::InstanceMethods#fire_events for more information.
  #
  # == Example
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #
  #       event :park do
  #         transition :idling => :parked
  #       end
  #     end
  #
  #     state_machine :alarm_state, :namespace => 'alarm', :initial => :active do
  #       event :enable do
  #         transition all => :active
  #       end
  #
  #       event :disable do
  #         transition all => :off
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new                         # => #<Vehicle:0xb7c02850 @state="parked", @alarm_state="active">
  #   vehicle.fire_events(:ignite, :disable_alarm)  # => true
  #
  #   vehicle.fire_events!(:ignite, :disable_alarm) # => StateMachines::InvalidParallelTransition: Cannot run events in parallel: ignite, disable_alarm
  #
  # source://state_machines//lib/state_machines/extensions.rb#139
  def fire_events!(*events); end

  protected

  # source://state_machines//lib/state_machines/extensions.rb#146
  def initialize_state_machines(options = T.unsafe(nil), &_arg1); end
end

# An invalid integration was registered
#
# source://state_machines//lib/state_machines/error.rb#44
class StateMachines::IntegrationError < ::StandardError; end

# An invalid integration was specified
#
# source://state_machines//lib/state_machines/error.rb#17
class StateMachines::IntegrationNotFound < ::StateMachines::Error
  # @return [IntegrationNotFound] a new instance of IntegrationNotFound
  #
  # source://state_machines//lib/state_machines/error.rb#18
  def initialize(name); end

  # source://state_machines//lib/state_machines/error.rb#34
  def error_message; end

  # source://state_machines//lib/state_machines/error.rb#30
  def no_integrations; end

  # source://state_machines//lib/state_machines/error.rb#22
  def valid_integrations; end

  # source://state_machines//lib/state_machines/error.rb#26
  def valid_integrations_name; end
end

# Integrations allow state machines to take advantage of features within the
# context of a particular library.  This is currently most useful with
# database libraries.  For example, the various database integrations allow
# state machines to hook into features like:
# * Saving
# * Transactions
# * Observers
# * Scopes
# * Callbacks
# * Validation errors
#
# This type of integration allows the user to work with state machines in a
# fashion similar to other object models in their application.
#
# The integration interface is loosely defined by various unimplemented
# methods in the StateMachines::Machine class.  See that class or the various
# built-in integrations for more information about how to define additional
# integrations.
#
# source://state_machines//lib/state_machines/integrations.rb#22
module StateMachines::Integrations
  class << self
    # Finds an integration with the given name.  If the integration cannot be
    # found, then a NameError exception will be raised.
    #
    # == Examples
    #
    #   StateMachines::Integrations.find_by_name(:active_model)  # => StateMachines::Integrations::ActiveModel
    #   StateMachines::Integrations.find_by_name(:active_record) # => StateMachines::Integrations::ActiveRecord
    #   StateMachines::Integrations.find_by_name(:invalid)       # => StateMachines::IntegrationNotFound: :invalid is an invalid integration
    #
    # source://state_machines//lib/state_machines/integrations.rb#98
    def find_by_name(name); end

    # Gets a list of all of the available integrations for use.
    #
    # == Example
    #
    #   StateMachines::Integrations.integrations
    #   # => []
    #   StateMachines::Integrations.register(StateMachines::Integrations::ActiveModel)
    #   StateMachines::Integrations.integrations
    #   # => [StateMachines::Integrations::ActiveModel]
    #
    # source://state_machines//lib/state_machines/integrations.rb#50
    def integrations; end

    # Gets a list of all of the available integrations for use.
    #
    # == Example
    #
    #   StateMachines::Integrations.integrations
    #   # => []
    #   StateMachines::Integrations.register(StateMachines::Integrations::ActiveModel)
    #   StateMachines::Integrations.integrations
    #   # => [StateMachines::Integrations::ActiveModel]
    #
    # source://state_machines//lib/state_machines/integrations.rb#52
    def list; end

    # Attempts to find an integration that matches the given class.  This will
    # look through all of the built-in integrations under the StateMachines::Integrations
    # namespace and find one that successfully matches the class.
    #
    # == Examples
    #
    #   class Vehicle
    #   end
    #
    #   class ActiveModelVehicle
    #     include ActiveModel::Observing
    #     include ActiveModel::Validations
    #   end
    #
    #   class ActiveRecordVehicle < ActiveRecord::Base
    #   end
    #
    #   StateMachines::Integrations.match(Vehicle)             # => nil
    #   StateMachines::Integrations.match(ActiveModelVehicle)  # => StateMachines::Integrations::ActiveModel
    #   StateMachines::Integrations.match(ActiveRecordVehicle) # => StateMachines::Integrations::ActiveRecord
    #
    # source://state_machines//lib/state_machines/integrations.rb#74
    def match(klass); end

    # Attempts to find an integration that matches the given list of ancestors.
    # This will look through all of the built-in integrations under the StateMachines::Integrations
    # namespace and find one that successfully matches one of the ancestors.
    #
    # == Examples
    #
    #   StateMachines::Integrations.match_ancestors([])                    # => nil
    #   StateMachines::Integrations.match_ancestors([ActiveRecord::Base]) # => StateMachines::Integrations::ActiveModel
    #
    # source://state_machines//lib/state_machines/integrations.rb#86
    def match_ancestors(ancestors); end

    # Register integration
    #
    # source://state_machines//lib/state_machines/integrations.rb#27
    def register(name_or_module); end

    # source://state_machines//lib/state_machines/integrations.rb#37
    def reset; end

    private

    # source://state_machines//lib/state_machines/integrations.rb#104
    def add(integration); end
  end
end

# Provides a set of base helpers for managing individual integrations
#
# source://state_machines//lib/state_machines/integrations/base.rb#6
module StateMachines::Integrations::Base
  mixes_in_class_methods ::StateMachines::Integrations::Base::ClassMethods

  class << self
    # source://state_machines//lib/state_machines/integrations/base.rb#44
    def included(base); end
  end
end

# source://state_machines//lib/state_machines/integrations/base.rb#7
module StateMachines::Integrations::Base::ClassMethods
  # The default options to use for state machines using this integration
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#9
  def defaults; end

  # The name of the integration
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#12
  def integration_name; end

  # Additional options that this integration adds to the state machine.
  # Integrations can override this method to specify additional valid options.
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#39
  def integration_options; end

  # Whether the integration should be used for the given class.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#28
  def matches?(klass); end

  # Whether the integration should be used for the given list of ancestors.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#33
  def matches_ancestors?(ancestors); end

  # The list of ancestor names that cause this integration to matched.
  #
  # source://state_machines//lib/state_machines/integrations/base.rb#23
  def matching_ancestors; end
end

# A method was called in an invalid state context
#
# source://state_machines//lib/state_machines/error.rb#113
class StateMachines::InvalidContext < ::StateMachines::Error; end

# An invalid event was specified
#
# source://state_machines//lib/state_machines/error.rb#48
class StateMachines::InvalidEvent < ::StateMachines::Error
  # @return [InvalidEvent] a new instance of InvalidEvent
  #
  # source://state_machines//lib/state_machines/error.rb#52
  def initialize(object, event_name); end

  # The event that was attempted to be run
  #
  # source://state_machines//lib/state_machines/error.rb#50
  def event; end
end

# A set of transition failed to run in parallel
#
# source://state_machines//lib/state_machines/error.rb#101
class StateMachines::InvalidParallelTransition < ::StateMachines::Error
  # @return [InvalidParallelTransition] a new instance of InvalidParallelTransition
  #
  # source://state_machines//lib/state_machines/error.rb#105
  def initialize(object, events); end

  # The set of events that failed the transition(s)
  #
  # source://state_machines//lib/state_machines/error.rb#103
  def events; end
end

# An invalid transition was attempted
#
# source://state_machines//lib/state_machines/error.rb#60
class StateMachines::InvalidTransition < ::StateMachines::Error
  # @return [InvalidTransition] a new instance of InvalidTransition
  #
  # source://state_machines//lib/state_machines/error.rb#67
  def initialize(object, machine, event); end

  # The event that triggered the failed transition
  #
  # source://state_machines//lib/state_machines/error.rb#80
  def event; end

  # The current state value for the machine
  #
  # source://state_machines//lib/state_machines/error.rb#65
  def from; end

  # The name for the current state
  #
  # source://state_machines//lib/state_machines/error.rb#90
  def from_name; end

  # The machine attempting to be transitioned
  #
  # source://state_machines//lib/state_machines/error.rb#62
  def machine; end

  # The fully-qualified name of the event that triggered the failed transition
  #
  # source://state_machines//lib/state_machines/error.rb#85
  def qualified_event; end

  # The fully-qualified name for the current state
  #
  # source://state_machines//lib/state_machines/error.rb#95
  def qualified_from_name; end
end

# Matches a loopback of two values within a context.  Since there is no
# configuration for this type of matcher, it must be used as a singleton.
#
# source://state_machines//lib/state_machines/matcher.rb#104
class StateMachines::LoopbackMatcher < ::StateMachines::Matcher
  include ::Singleton::SingletonInstanceMethods
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # A human-readable description of this matcher.  Always "same".
  #
  # source://state_machines//lib/state_machines/matcher.rb#120
  def description; end

  # Checks whether the given value matches what the value originally was.
  # This value should be defined in the context.
  #
  # == Examples
  #
  #   matcher = StateMachines::LoopbackMatcher.instance
  #   matcher.matches?(:parked, :from => :parked)   # => true
  #   matcher.matches?(:parked, :from => :idling)   # => false
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/matcher.rb#115
  def matches?(value, context); end

  class << self
    private

    # source://state_machines//lib/state_machines/matcher.rb#105
    def allocate; end

    # source://state_machines//lib/state_machines/matcher.rb#105
    def new(*_arg0); end
  end
end

# Represents a state machine for a particular attribute.  State machines
# consist of states, events and a set of transitions that define how the
# state changes after a particular event is fired.
#
# A state machine will not know all of the possible states for an object
# unless they are referenced *somewhere* in the state machine definition.
# As a result, any unused states should be defined with the +other_states+
# or +state+ helper.
#
# == Actions
#
# When an action is configured for a state machine, it is invoked when an
# object transitions via an event.  The success of the event becomes
# dependent on the success of the action.  If the action is successful, then
# the transitioned state remains persisted.  However, if the action fails
# (by returning false), the transitioned state will be rolled back.
#
# For example,
#
#   class Vehicle
#     attr_accessor :fail, :saving_state
#
#     state_machine :initial => :parked, :action => :save do
#       event :ignite do
#         transition :parked => :idling
#       end
#
#       event :park do
#         transition :idling => :parked
#       end
#     end
#
#     def save
#       @saving_state = state
#       fail != true
#     end
#   end
#
#   vehicle = Vehicle.new     # => #<Vehicle:0xb7c27024 @state="parked">
#   vehicle.save              # => true
#   vehicle.saving_state      # => "parked" # The state was "parked" was save was called
#
#   # Successful event
#   vehicle.ignite            # => true
#   vehicle.saving_state      # => "idling" # The state was "idling" when save was called
#   vehicle.state             # => "idling"
#
#   # Failed event
#   vehicle.fail = true
#   vehicle.park              # => false
#   vehicle.saving_state      # => "parked"
#   vehicle.state             # => "idling"
#
# As shown, even though the state is set prior to calling the +save+ action
# on the object, it will be rolled back to the original state if the action
# fails.  *Note* that this will also be the case if an exception is raised
# while calling the action.
#
# === Indirect transitions
#
# In addition to the action being run as the _result_ of an event, the action
# can also be used to run events itself.  For example, using the above as an
# example:
#
#   vehicle = Vehicle.new           # => #<Vehicle:0xb7c27024 @state="parked">
#
#   vehicle.state_event = 'ignite'
#   vehicle.save                    # => true
#   vehicle.state                   # => "idling"
#   vehicle.state_event             # => nil
#
# As can be seen, the +save+ action automatically invokes the event stored in
# the +state_event+ attribute (<tt>:ignite</tt> in this case).
#
# One important note about using this technique for running transitions is
# that if the class in which the state machine is defined *also* defines the
# action being invoked (and not a superclass), then it must manually run the
# StateMachine hook that checks for event attributes.
#
# For example, in ActiveRecord, DataMapper, Mongoid, MongoMapper, and Sequel,
# the default action (+save+) is already defined in a base class.  As a result,
# when a state machine is defined in a model / resource, StateMachine can
# automatically hook into the +save+ action.
#
# On the other hand, the Vehicle class from above defined its own +save+
# method (and there is no +save+ method in its superclass).  As a result, it
# must be modified like so:
#
#     def save
#       self.class.state_machines.transitions(self, :save).perform do
#         @saving_state = state
#         fail != true
#       end
#     end
#
# This will add in the functionality for firing the event stored in the
# +state_event+ attribute.
#
# == Callbacks
#
# Callbacks are supported for hooking before and after every possible
# transition in the machine.  Each callback is invoked in the order in which
# it was defined.  See StateMachines::Machine#before_transition and
# StateMachines::Machine#after_transition for documentation on how to define
# new callbacks.
#
# *Note* that callbacks only get executed within the context of an event.  As
# a result, if a class has an initial state when it's created, any callbacks
# that would normally get executed when the object enters that state will
# *not* get triggered.
#
# For example,
#
#   class Vehicle
#     state_machine initial: :parked do
#       after_transition all => :parked do
#         raise ArgumentError
#       end
#       ...
#     end
#   end
#
#   vehicle = Vehicle.new   # => #<Vehicle id: 1, state: "parked">
#   vehicle.save            # => true (no exception raised)
#
# If you need callbacks to get triggered when an object is created, this
# should be done by one of the following techniques:
# * Use a <tt>before :create</tt> or equivalent hook:
#
#     class Vehicle
#       before :create, :track_initial_transition
#
#       state_machine do
#         ...
#       end
#     end
#
# * Set an initial state and use the correct event to create the
#   object with the proper state, resulting in callbacks being triggered and
#   the object getting persisted (note that the <tt>:pending</tt> state is
#   actually stored as nil):
#
#     class Vehicle
#        state_machine initial: :pending
#         after_transition pending: :parked, do: :track_initial_transition
#
#         event :park do
#           transition pending: :parked
#         end
#
#         state :pending, value: nil
#       end
#     end
#
#     vehicle = Vehicle.new
#     vehicle.park
#
# * Use a default event attribute that will automatically trigger when the
#   configured action gets run (note that the <tt>:pending</tt> state is
#   actually stored as nil):
#
#     class Vehicle < ActiveRecord::Base
#       state_machine initial: :pending
#         after_transition pending: :parked, do: :track_initial_transition
#
#         event :park do
#           transition pending: :parked
#         end
#
#         state :pending, value: nil
#       end
#
#       def initialize(*)
#         super
#         self.state_event = 'park'
#       end
#     end
#
#     vehicle = Vehicle.new
#     vehicle.save
#
# === Canceling callbacks
#
# Callbacks can be canceled by throwing :halt at any point during the
# callback.  For example,
#
#   ...
#   throw :halt
#   ...
#
# If a +before+ callback halts the chain, the associated transition and all
# later callbacks are canceled.  If an +after+ callback halts the chain,
# the later callbacks are canceled, but the transition is still successful.
#
# These same rules apply to +around+ callbacks with the exception that any
# +around+ callback that doesn't yield will essentially result in :halt being
# thrown.  Any code executed after the yield will behave in the same way as
# +after+ callbacks.
#
# *Note* that if a +before+ callback fails and the bang version of an event
# was invoked, an exception will be raised instead of returning false.  For
# example,
#
#   class Vehicle
#     state_machine :initial => :parked do
#       before_transition any => :idling, :do => lambda {|vehicle| throw :halt}
#       ...
#     end
#   end
#
#   vehicle = Vehicle.new
#   vehicle.park        # => false
#   vehicle.park!       # => StateMachines::InvalidTransition: Cannot transition state via :park from "idling"
#
# == Observers
#
# Observers, in the sense of external classes and *not* Ruby's Observable
# mechanism, can hook into state machines as well.  Such observers use the
# same callback api that's used internally.
#
# Below are examples of defining observers for the following state machine:
#
#   class Vehicle
#     state_machine do
#       event :park do
#         transition idling: :parked
#       end
#       ...
#     end
#     ...
#   end
#
# Event/Transition behaviors:
#
#   class VehicleObserver
#     def self.before_park(vehicle, transition)
#       logger.info "#{vehicle} instructed to park... state is: #{transition.from}, state will be: #{transition.to}"
#     end
#
#     def self.after_park(vehicle, transition, result)
#       logger.info "#{vehicle} instructed to park... state was: #{transition.from}, state is: #{transition.to}"
#     end
#
#     def self.before_transition(vehicle, transition)
#       logger.info "#{vehicle} instructed to #{transition.event}... #{transition.attribute} is: #{transition.from}, #{transition.attribute} will be: #{transition.to}"
#     end
#
#     def self.after_transition(vehicle, transition)
#       logger.info "#{vehicle} instructed to #{transition.event}... #{transition.attribute} was: #{transition.from}, #{transition.attribute} is: #{transition.to}"
#     end
#
#     def self.around_transition(vehicle, transition)
#       logger.info Benchmark.measure { yield }
#     end
#   end
#
#   Vehicle.state_machine do
#     before_transition :on => :park, :do => VehicleObserver.method(:before_park)
#     before_transition VehicleObserver.method(:before_transition)
#
#     after_transition :on => :park, :do => VehicleObserver.method(:after_park)
#     after_transition VehicleObserver.method(:after_transition)
#
#     around_transition VehicleObserver.method(:around_transition)
#   end
#
# One common callback is to record transitions for all models in the system
# for auditing/debugging purposes.  Below is an example of an observer that
# can easily automate this process for all models:
#
#   class StateMachineObserver
#     def self.before_transition(object, transition)
#       Audit.log_transition(object.attributes)
#     end
#   end
#
#   [Vehicle, Switch, Project].each do |klass|
#     klass.state_machines.each do |attribute, machine|
#       machine.before_transition StateMachineObserver.method(:before_transition)
#     end
#   end
#
# Additional observer-like behavior may be exposed by the various integrations
# available.  See below for more information on integrations.
#
# == Overriding instance / class methods
#
# Hooking in behavior to the generated instance / class methods from the
# state machine, events, and states is very simple because of the way these
# methods are generated on the class.  Using the class's ancestors, the
# original generated method can be referred to via +super+.  For example,
#
#   class Vehicle
#     state_machine do
#       event :park do
#         ...
#       end
#     end
#
#     def park(*args)
#       logger.info "..."
#       super
#     end
#   end
#
# In the above example, the +park+ instance method that's generated on the
# Vehicle class (by the associated event) is overridden with custom behavior.
# Once this behavior is complete, the original method from the state machine
# is invoked by simply calling +super+.
#
# The same technique can be used for +state+, +state_name+, and all other
# instance *and* class methods on the Vehicle class.
#
# == Method conflicts
#
# By default state_machine does not redefine methods that exist on
# superclasses (*including* Object) or any modules (*including* Kernel) that
# were included before it was defined.  This is in order to ensure that
# existing behavior on the class is not broken by the inclusion of
# state_machine.
#
# If a conflicting method is detected, state_machine will generate a warning.
# For example, consider the following class:
#
#   class Vehicle
#     state_machine do
#       event :open do
#         ...
#       end
#     end
#   end
#
# In the above class, an event named "open" is defined for its state machine.
# However, "open" is already defined as an instance method in Ruby's Kernel
# module that gets included in every Object.  As a result, state_machine will
# generate the following warning:
#
#   Instance method "open" is already defined in Object, use generic helper instead or set StateMachines::Machine.ignore_method_conflicts = true.
#
# Even though you may not be using Kernel's implementation of the "open"
# instance method, state_machine isn't aware of this and, as a result, stays
# safe and just skips redefining the method.
#
# As with almost all helpers methods defined by state_machine in your class,
# there are generic methods available for working around this method conflict.
# In the example above, you can invoke the "open" event like so:
#
#   vehicle = Vehicle.new       # => #<Vehicle:0xb72686b4 @state=nil>
#   vehicle.fire_events(:open)  # => true
#
#   # This will not work
#   vehicle.open                # => NoMethodError: private method `open' called for #<Vehicle:0xb72686b4 @state=nil>
#
# If you want to take on the risk of overriding existing methods and just
# ignore method conflicts altogether, you can do so by setting the following
# configuration:
#
#   StateMachines::Machine.ignore_method_conflicts = true
#
# This will allow you to define events like "open" as described above and
# still generate the "open" instance helper method.  For example:
#
#   StateMachines::Machine.ignore_method_conflicts = true
#
#   class Vehicle
#     state_machine do
#       event :open do
#         ...
#     end
#   end
#
#   vehicle = Vehicle.new   # => #<Vehicle:0xb72686b4 @state=nil>
#   vehicle.open            # => true
#
# By default, state_machine helps prevent you from making mistakes and
# accidentally overriding methods that you didn't intend to.  Once you
# understand this and what the consequences are, setting the
# +ignore_method_conflicts+ option is a perfectly reasonable workaround.
#
# == Integrations
#
# By default, state machines are library-agnostic, meaning that they work
# on any Ruby class and have no external dependencies.  However, there are
# certain libraries which expose additional behavior that can be taken
# advantage of by state machines.
#
# This library is built to work out of the box with a few popular Ruby
# libraries that allow for additional behavior to provide a cleaner and
# smoother experience.  This is especially the case for objects backed by a
# database that may allow for transactions, persistent storage,
# search/filters, callbacks, etc.
#
# When a state machine is defined for classes using any of the above libraries,
# it will try to automatically determine the integration to use (Agnostic,
# ActiveModel, ActiveRecord, DataMapper, Mongoid, MongoMapper, or Sequel)
# based on the class definition.  To see how each integration affects the
# machine's behavior, refer to all constants defined under the
# StateMachines::Integrations namespace.
#
# source://state_machines//lib/state_machines/machine/class_methods.rb#4
class StateMachines::Machine
  include ::StateMachines::Machine::AsyncExtensions
  include ::StateMachines::EvalHelpers
  include ::StateMachines::MatcherHelpers
  include ::StateMachines::Machine::Utilities
  include ::StateMachines::Machine::Parsing
  include ::StateMachines::Machine::Validation
  include ::StateMachines::Machine::HelperGenerators
  include ::StateMachines::Machine::ActionHooks
  include ::StateMachines::Machine::Scoping
  include ::StateMachines::Machine::Configuration
  include ::StateMachines::Machine::StateMethods
  include ::StateMachines::Machine::EventMethods
  include ::StateMachines::Machine::Callbacks
  include ::StateMachines::Machine::Rendering
  include ::StateMachines::Machine::Integration
  extend ::StateMachines::Machine::ClassMethods

  # The action to invoke when an object transitions
  #
  # source://state_machines//lib/state_machines/machine.rb#469
  def action; end

  # Determines whether an action hook was defined for firing attribute-based
  # event transitions when the configured action gets called.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine.rb#1615
  def action_hook?(self_only = T.unsafe(nil)); end

  # Creates a callback that will be invoked *after* a transition failures to
  # be performed so long as the given requirements match the transition.
  #
  # See +before_transition+ for a description of the possible configurations
  # for defining callbacks.  *Note* however that you cannot define the state
  # requirements in these callbacks.  You may only define event requirements.
  #
  # = The callback
  #
  # Failure callbacks get invoked whenever an event fails to execute.  This
  # can happen when no transition is available, a +before+ callback halts
  # execution, or the action associated with this machine fails to succeed.
  # In any of these cases, any failure callback that matches the attempted
  # transition will be run.
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine do
  #       after_failure do |vehicle, transition|
  #         logger.error "vehicle #{vehicle} failed to transition on #{transition.event}"
  #       end
  #
  #       after_failure :on => :ignite, :do => :log_ignition_failure
  #
  #       ...
  #     end
  #   end
  #
  # source://state_machines//lib/state_machines/machine.rb#1483
  def after_failure(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *after* a transition is
  # performed so long as the given requirements match the transition.
  #
  # See +before_transition+ for a description of the possible configurations
  # for defining callbacks.
  #
  # source://state_machines//lib/state_machines/machine.rb#1378
  def after_transition(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *around* a transition so long as
  # the given requirements match the transition.
  #
  # == The callback
  #
  # Around callbacks wrap transitions, executing code both before and after.
  # These callbacks are defined in the exact same manner as before / after
  # callbacks with the exception that the transition must be yielded to in
  # order to finish running it.
  #
  # If defining +around+ callbacks using blocks, you must yield within the
  # transition by directly calling the block (since yielding is not allowed
  # within blocks).
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine do
  #       around_transition do |block|
  #         Benchmark.measure { block.call }
  #       end
  #
  #       around_transition do |vehicle, block|
  #         logger.info "vehicle was #{state}..."
  #         block.call
  #         logger.info "...and is now #{state}"
  #       end
  #
  #       around_transition do |vehicle, transition, block|
  #         logger.info "before #{transition.event}: #{vehicle.state}"
  #         block.call
  #         logger.info "after #{transition.event}: #{vehicle.state}"
  #       end
  #     end
  #   end
  #
  # Notice that referencing the block is similar to doing so within an
  # actual method definition in that it is always the last argument.
  #
  # On the other hand, if you're defining +around+ callbacks using method
  # references, you can yield like normal:
  #
  #   class Vehicle
  #     state_machine do
  #       around_transition :benchmark
  #       ...
  #     end
  #
  #     def benchmark
  #       Benchmark.measure { yield }
  #     end
  #   end
  #
  # See +before_transition+ for a description of the possible configurations
  # for defining callbacks.
  #
  # source://state_machines//lib/state_machines/machine.rb#1444
  def around_transition(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *before* a transition is
  # performed so long as the given requirements match the transition.
  #
  # == The callback
  #
  # Callbacks must be defined as either an argument, in the :do option, or
  # as a block.  For example,
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition :set_alarm
  #       before_transition :set_alarm, all => :parked
  #       before_transition all => :parked, :do => :set_alarm
  #       before_transition all => :parked do |vehicle, transition|
  #         vehicle.set_alarm
  #       end
  #       ...
  #     end
  #   end
  #
  # Notice that the first three callbacks are the same in terms of how the
  # methods to invoke are defined.  However, using the <tt>:do</tt> can
  # provide for a more fluid DSL.
  #
  # In addition, multiple callbacks can be defined like so:
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition :set_alarm, :lock_doors, all => :parked
  #       before_transition all => :parked, :do => [:set_alarm, :lock_doors]
  #       before_transition :set_alarm do |vehicle, transition|
  #         vehicle.lock_doors
  #       end
  #     end
  #   end
  #
  # Notice that the different ways of configuring methods can be mixed.
  #
  # == State requirements
  #
  # Callbacks can require that the machine be transitioning from and to
  # specific states.  These requirements use a Hash syntax to map beginning
  # states to ending states.  For example,
  #
  #   before_transition :parked => :idling, :idling => :first_gear, :do => :set_alarm
  #
  # In this case, the +set_alarm+ callback will only be called if the machine
  # is transitioning from +parked+ to +idling+ or from +idling+ to +parked+.
  #
  # To help define state requirements, a set of helpers are available for
  # slightly more complex matching:
  # * <tt>all</tt> - Matches every state/event in the machine
  # * <tt>all - [:parked, :idling, ...]</tt> - Matches every state/event except those specified
  # * <tt>any</tt> - An alias for +all+ (matches every state/event in the machine)
  # * <tt>same</tt> - Matches the same state being transitioned from
  #
  # See StateMachines::MatcherHelpers for more information.
  #
  # Examples:
  #
  #   before_transition :parked => [:idling, :first_gear], :do => ...     # Matches from parked to idling or first_gear
  #   before_transition all - [:parked, :idling] => :idling, :do => ...   # Matches from every state except parked and idling to idling
  #   before_transition all => :parked, :do => ...                        # Matches all states to parked
  #   before_transition any => same, :do => ...                           # Matches every loopback
  #
  # == Event requirements
  #
  # In addition to state requirements, an event requirement can be defined so
  # that the callback is only invoked on specific events using the +on+
  # option.  This can also use the same matcher helpers as the state
  # requirements.
  #
  # Examples:
  #
  #   before_transition :on => :ignite, :do => ...                        # Matches only on ignite
  #   before_transition :on => all - :ignite, :do => ...                  # Matches on every event except ignite
  #   before_transition :parked => :idling, :on => :ignite, :do => ...    # Matches from parked to idling on ignite
  #
  # == Verbose Requirements
  #
  # Requirements can also be defined using verbose options rather than the
  # implicit Hash syntax and helper methods described above.
  #
  # Configuration options:
  # * <tt>:from</tt> - One or more states being transitioned from.  If none
  #   are specified, then all states will match.
  # * <tt>:to</tt> - One or more states being transitioned to.  If none are
  #   specified, then all states will match.
  # * <tt>:on</tt> - One or more events that fired the transition.  If none
  #   are specified, then all events will match.
  # * <tt>:except_from</tt> - One or more states *not* being transitioned from
  # * <tt>:except_to</tt> - One more states *not* being transitioned to
  # * <tt>:except_on</tt> - One or more events that *did not* fire the transition
  #
  # Examples:
  #
  #   before_transition :from => :ignite, :to => :idling, :on => :park, :do => ...
  #   before_transition :except_from => :ignite, :except_to => :idling, :except_on => :park, :do => ...
  #
  # == Conditions
  #
  # In addition to the state/event requirements, a condition can also be
  # defined to help determine whether the callback should be invoked.
  #
  # Configuration options:
  # * <tt>:if</tt> - A method, proc or string to call to determine if the
  #   callback should occur (e.g. :if => :allow_callbacks, or
  #   :if => lambda {|user| user.signup_step > 2}). The method, proc or string
  #   should return or evaluate to a true or false value.
  # * <tt>:unless</tt> - A method, proc or string to call to determine if the
  #   callback should not occur (e.g. :unless => :skip_callbacks, or
  #   :unless => lambda {|user| user.signup_step <= 2}). The method, proc or
  #   string should return or evaluate to a true or false value.
  #
  # Examples:
  #
  #   before_transition :parked => :idling, :if => :moving?, :do => ...
  #   before_transition :on => :ignite, :unless => :seatbelt_on?, :do => ...
  #
  # == Accessing the transition
  #
  # In addition to passing the object being transitioned, the actual
  # transition describing the context (e.g. event, from, to) can be accessed
  # as well.  This additional argument is only passed if the callback allows
  # for it.
  #
  # For example,
  #
  #   class Vehicle
  #     # Only specifies one parameter (the object being transitioned)
  #     before_transition all => :parked do |vehicle|
  #       vehicle.set_alarm
  #     end
  #
  #     # Specifies 2 parameters (object being transitioned and actual transition)
  #     before_transition all => :parked do |vehicle, transition|
  #       vehicle.set_alarm(transition)
  #     end
  #   end
  #
  # *Note* that the object in the callback will only be passed in as an
  # argument if callbacks are configured to *not* be bound to the object
  # involved.  This is the default and may change on a per-integration basis.
  #
  # See StateMachines::Transition for more information about the
  # attributes available on the transition.
  #
  # == Usage with delegates
  #
  # As noted above, state_machine uses the callback method's argument list
  # arity to determine whether to include the transition in the method call.
  # If you're using delegates, such as those defined in ActiveSupport or
  # Forwardable, the actual arity of the delegated method gets masked.  This
  # means that callbacks which reference delegates will always get passed the
  # transition as an argument.  For example:
  #
  #   class Vehicle
  #     extend Forwardable
  #     delegate :refresh => :dashboard
  #
  #     state_machine do
  #       before_transition :refresh
  #       ...
  #     end
  #
  #     def dashboard
  #       @dashboard ||= Dashboard.new
  #     end
  #   end
  #
  #   class Dashboard
  #     def refresh(transition)
  #       # ...
  #     end
  #   end
  #
  # In the above example, <tt>Dashboard#refresh</tt> *must* defined a
  # +transition+ argument.  Otherwise, an +ArgumentError+ exception will get
  # raised.  The only way around this is to avoid the use of delegates and
  # manually define the delegate method so that the correct arity is used.
  #
  # == Examples
  #
  # Below is an example of a class with one state machine and various types
  # of +before+ transitions defined for it:
  #
  #   class Vehicle
  #     state_machine do
  #       # Before all transitions
  #       before_transition :update_dashboard
  #
  #       # Before specific transition:
  #       before_transition [:first_gear, :idling] => :parked, :on => :park, :do => :take_off_seatbelt
  #
  #       # With conditional callback:
  #       before_transition all => :parked, :do => :take_off_seatbelt, :if => :seatbelt_on?
  #
  #       # Using helpers:
  #       before_transition all - :stalled => same, :on => any - :crash, :do => :update_dashboard
  #       ...
  #     end
  #   end
  #
  # As can be seen, any number of transitions can be created using various
  # combinations of configuration options.
  #
  # source://state_machines//lib/state_machines/machine.rb#1362
  def before_transition(*args, **options, &_arg2); end

  # The callbacks to invoke before/after a transition is performed
  #
  # Maps :before => callbacks and :after => callbacks
  #
  # source://state_machines//lib/state_machines/machine.rb#466
  def callbacks; end

  # Defines a new helper method in an instance or class scope with the given
  # name.  If the method is already defined in the scope, then this will not
  # override it.
  #
  # If passing in a block, there are two side effects to be aware of
  # 1. The method cannot be chained, meaning that the block cannot call +super+
  # 2. If the method is already defined in an ancestor, then it will not get
  #    overridden and a warning will be output.
  #
  # Example:
  #
  #   # Instance helper
  #   machine.define_helper(:instance, :state_name) do |machine, object|
  #     machine.states.match(object).name
  #   end
  #
  #   # Class helper
  #   machine.define_helper(:class, :state_machine_name) do |machine, klass|
  #     "State"
  #   end
  #
  # You can also define helpers using string evaluation like so:
  #
  #   # Instance helper
  #   machine.define_helper :instance, <<-end_eval, __FILE__, __LINE__ + 1
  #     def state_name
  #       self.class.state_machine(:state).states.match(self).name
  #     end
  #   end_eval
  #
  #   # Class helper
  #   machine.define_helper :class, <<-end_eval, __FILE__, __LINE__ + 1
  #     def state_machine_name
  #       "State"
  #     end
  #   end_eval
  #
  # source://state_machines//lib/state_machines/machine.rb#552
  def define_helper(scope, method, *_arg2, **_arg3, &block); end

  # source://state_machines//lib/state_machines/machine.rb#1609
  def draw(**_arg0); end

  # Gets a description of the errors for the given object.  This is used to
  # provide more detailed information when an InvalidTransition exception is
  # raised.
  #
  # source://state_machines//lib/state_machines/machine.rb#1569
  def errors_for(_object); end

  # The events that trigger transitions.  These are sorted, by default, in
  # the order in which they were defined.
  #
  # source://state_machines//lib/state_machines/machine.rb#450
  def events; end

  # Generates the message to use when invalidating the given object after
  # failing to transition on a specific event
  #
  # source://state_machines//lib/state_machines/machine.rb#1580
  def generate_message(name, values = T.unsafe(nil)); end

  # Marks the given object as invalid with the given message.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine.rb#1564
  def invalidate(_object, _attribute, _message, _values = T.unsafe(nil)); end

  # The name of the machine, used for scoping methods generated for the
  # machine as a whole (not states or events)
  #
  # source://state_machines//lib/state_machines/machine.rb#446
  def name; end

  # An identifier that forces all methods (including state predicates and
  # event methods) to be generated with the value prefixed or suffixed,
  # depending on the context.
  #
  # source://state_machines//lib/state_machines/machine.rb#474
  def namespace; end

  # The class that the machine is defined in
  #
  # source://state_machines//lib/state_machines/machine.rb#442
  def owner_class; end

  # source://state_machines//lib/state_machines/machine.rb#1605
  def renderer; end

  # Resets any errors previously added when invalidating the given object.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine.rb#1576
  def reset(_object); end

  # A list of all of the states known to this state machine.  This will pull
  # states from the following sources:
  # * Initial state
  # * State behaviors
  # * Event transitions (:to, :from, and :except_from options)
  # * Transition callbacks (:to, :from, :except_to, and :except_from options)
  # * Unreferenced states (using +other_states+ helper)
  #
  # These are sorted, by default, in the order in which they were referenced.
  #
  # source://state_machines//lib/state_machines/machine.rb#461
  def states; end

  # Whether the machine will use transactions when firing events
  #
  # source://state_machines//lib/state_machines/machine.rb#477
  def use_transactions; end

  # Runs a transaction, rolling back any changes if the yielded block fails.
  #
  # This is only applicable to integrations that involve databases.  By
  # default, this will not run any transactions since the changes aren't
  # taking place within the context of a database.
  #
  # source://state_machines//lib/state_machines/machine.rb#1597
  def within_transaction(object, &_arg1); end

  protected

  # Runs additional initialization hooks.  By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine.rb#1622
  def after_initialize; end

  # Gets the initial attribute value defined by the owner class (outside of
  # the machine's definition). By default, this is always nil.
  #
  # source://state_machines//lib/state_machines/machine.rb#1636
  def owner_class_attribute_default; end

  # Checks whether the given state matches the attribute default specified
  # by the owner class
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine.rb#1642
  def owner_class_attribute_default_matches?(state); end

  # Always yields
  #
  # source://state_machines//lib/state_machines/machine.rb#1630
  def transaction(_object); end
end

# source://state_machines//lib/state_machines/machine/action_hooks.rb#5
module StateMachines::Machine::ActionHooks
  protected

  # The method to hook into for triggering transitions when invoked.  By
  # default, this is the action configured for the machine.
  #
  # Since the default hook technique relies on module inheritance, the
  # action must be defined in an ancestor of the owner classs in order for
  # it to be the action hook.
  #
  # source://state_machines//lib/state_machines/machine/action_hooks.rb#48
  def action_hook; end

  # Adds helper methods for automatically firing events when an action
  # is invoked
  #
  # source://state_machines//lib/state_machines/machine/action_hooks.rb#17
  def define_action_helpers; end

  # Determines whether action helpers should be defined for this machine.
  # This is only true if there is an action configured and no other machines
  # have process this same configuration already.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/action_hooks.rb#11
  def define_action_helpers?; end

  # Hooks directly into actions by defining the same method in an included
  # module.  As a result, when the action gets invoked, any state events
  # defined for the object will get run.  Method visibility is preserved.
  #
  # source://state_machines//lib/state_machines/machine/action_hooks.rb#27
  def define_action_hook; end
end

# AsyncMode extensions for the Machine class
# Provides async-aware methods while maintaining backward compatibility
#
# source://state_machines//lib/state_machines/machine/async_extensions.rb#10
module StateMachines::Machine::AsyncExtensions
  # Check if this specific machine instance has async mode enabled
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/async_extensions.rb#63
  def async_mode_enabled?; end

  # Configure this specific machine instance for async mode
  #
  # Example:
  #   class Vehicle
  #     state_machine initial: :parked do
  #       configure_async_mode! # Enable async for this machine
  #
  #       event :ignite do
  #         transition parked: :idling
  #       end
  #     end
  #   end
  #
  # source://state_machines//lib/state_machines/machine/async_extensions.rb#25
  def configure_async_mode!(enabled = T.unsafe(nil)); end

  # Thread-safe version of state reading
  #
  # source://state_machines//lib/state_machines/machine/async_extensions.rb#68
  def read_safely(object, attribute, ivar = T.unsafe(nil)); end

  # Thread-safe callback execution for async operations
  #
  # source://state_machines//lib/state_machines/machine/async_extensions.rb#78
  def run_callbacks_safely(type, object, context, transition); end

  # Thread-safe version of state writing
  #
  # source://state_machines//lib/state_machines/machine/async_extensions.rb#73
  def write_safely(object, attribute, value, ivar = T.unsafe(nil)); end
end

# source://state_machines//lib/state_machines/machine/callbacks.rb#5
module StateMachines::Machine::Callbacks
  # Creates a callback that will be invoked after a transition has failed
  # to be performed.
  #
  # source://state_machines//lib/state_machines/machine/callbacks.rb#47
  def after_failure(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *after* a transition is
  # performed so long as the given requirements match the transition.
  #
  # source://state_machines//lib/state_machines/machine/callbacks.rb#21
  def after_transition(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *around* a transition so long
  # as the given requirements match the transition.
  #
  # source://state_machines//lib/state_machines/machine/callbacks.rb#34
  def around_transition(*args, **options, &_arg2); end

  # Creates a callback that will be invoked *before* a transition is
  # performed so long as the given requirements match the transition.
  #
  # source://state_machines//lib/state_machines/machine/callbacks.rb#8
  def before_transition(*args, **options, &_arg2); end
end

# source://state_machines//lib/state_machines/machine/class_methods.rb#5
module StateMachines::Machine::ClassMethods
  # source://state_machines//lib/state_machines/machine/class_methods.rb#55
  def default_messages; end

  # source://state_machines//lib/state_machines/machine/class_methods.rb#63
  def default_messages=(messages); end

  # @raise [NotImplementedError]
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#47
  def draw(*_arg0); end

  # Attempts to find or create a state machine for the given class.  For
  # example,
  #
  #   StateMachines::Machine.find_or_create(Vehicle)
  #   StateMachines::Machine.find_or_create(Vehicle, :initial => :parked)
  #   StateMachines::Machine.find_or_create(Vehicle, :status)
  #   StateMachines::Machine.find_or_create(Vehicle, :status, :initial => :parked)
  #
  # If a machine of the given name already exists in one of the class's
  # superclasses, then a copy of that machine will be created and stored
  # in the new owner class (the original will remain unchanged).
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#17
  def find_or_create(owner_class, *args, &_arg2); end

  # Default messages to use for validation errors in ORM integrations
  # Thread-safe access via atomic operations on simple values
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#53
  def ignore_method_conflicts; end

  # Default messages to use for validation errors in ORM integrations
  # Thread-safe access via atomic operations on simple values
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#53
  def ignore_method_conflicts=(_arg0); end

  # source://state_machines//lib/state_machines/machine/class_methods.rb#77
  def renderer; end

  # Sets the attribute renderer
  #
  # @param value the value to set the attribute renderer to.
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#75
  def renderer=(_arg0); end

  # source://state_machines//lib/state_machines/machine/class_methods.rb#68
  def replace_messages(message_hash); end

  private

  # Deep freezes a hash and all its string values for thread safety
  #
  # source://state_machines//lib/state_machines/machine/class_methods.rb#86
  def deep_freeze_hash(hash); end
end

# source://state_machines//lib/state_machines/machine/configuration.rb#5
module StateMachines::Machine::Configuration
  # Initializes a new state machine with the given configuration.
  #
  # source://state_machines//lib/state_machines/machine/configuration.rb#7
  def initialize(owner_class, *args, &_arg2); end

  # Gets the attribute name for the given machine scope.
  #
  # source://state_machines//lib/state_machines/machine/configuration.rb#131
  def attribute(name = T.unsafe(nil)); end

  # Sets the initial state of the machine.  This can be either the static name
  # of a state or a lambda block which determines the initial state at
  # creation time.
  #
  # source://state_machines//lib/state_machines/machine/configuration.rb#109
  def initial_state=(new_initial_state); end

  # Sets the class which is the owner of this state machine.  Any methods
  # generated by states, events, or other parts of the machine will be defined
  # on the given owner class.
  #
  # source://state_machines//lib/state_machines/machine/configuration.rb#81
  def owner_class=(klass); end

  private

  # Creates a copy of this machine in addition to copies of each associated
  # event/states/callback, so that the modifications to those collections do
  # not affect the original machine.
  #
  # source://state_machines//lib/state_machines/machine/configuration.rb#66
  def initialize_copy(orig); end
end

# source://state_machines//lib/state_machines/machine/event_methods.rb#5
module StateMachines::Machine::EventMethods
  # Defines one or more events for the machine and the transitions that can
  # be performed when those events are run.
  #
  # source://state_machines//lib/state_machines/machine/event_methods.rb#8
  def event(*names, &_arg1); end

  # Defines one or more events for the machine and the transitions that can
  # be performed when those events are run.
  #
  # source://state_machines//lib/state_machines/machine/event_methods.rb#37
  def on(*names, &_arg1); end

  # Gets the list of all possible transition paths from the current state to
  # the given target state.  If multiple target states are provided, then
  # this will return all possible paths to those states.
  #
  # source://state_machines//lib/state_machines/machine/event_methods.rb#54
  def paths_for(object, requirements = T.unsafe(nil)); end

  # Creates a new transition that determines what to change the current state
  # to when an event fires.
  #
  # @raise [ArgumentError]
  #
  # source://state_machines//lib/state_machines/machine/event_methods.rb#41
  def transition(options); end
end

# source://state_machines//lib/state_machines/machine/helper_generators.rb#5
module StateMachines::Machine::HelperGenerators
  protected

  # Adds helper methods for getting information about this state machine's
  # events
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#51
  def define_event_helpers; end

  # Adds helper methods for interacting with the state machine, including
  # for states, events, and transitions
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#10
  def define_helpers; end

  # Adds helper methods for accessing naming information about states and
  # events on the owner class
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#102
  def define_name_helpers; end

  # Adds helper methods for getting information about this state machine's
  # available transition paths
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#93
  def define_path_helpers; end

  # Adds reader/writer methods for accessing the state attribute
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#31
  def define_state_accessor; end

  # Defines the initial values for state machine attributes.  Static values
  # are set prior to the original initialize method and dynamic values are
  # set *after* the initialize method in case it is dependent on it.
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#22
  def define_state_initializer; end

  # Adds predicate method to the owner class for determining the name of the
  # current state
  #
  # source://state_machines//lib/state_machines/machine/helper_generators.rb#40
  def define_state_predicate; end
end

# source://state_machines//lib/state_machines/machine/integration.rb#5
module StateMachines::Machine::Integration
  # Gets a description of the errors for the given object.  This is used to
  # provide more detailed information when an InvalidTransition exception is
  # raised.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#14
  def errors_for(_object); end

  # Generates a user-friendly name for the given message.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#24
  def generate_message(name, values = T.unsafe(nil)); end

  # Marks the given object as invalid with the given message.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#9
  def invalidate(_object, _attribute, _message, _values = T.unsafe(nil)); end

  # Resets any errors previously added when invalidating the given object.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#21
  def reset(_object); end

  # Runs a transaction, yielding the given block.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#31
  def within_transaction(object, &_arg1); end

  protected

  # Runs additional initialization hooks.  By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#42
  def after_initialize; end

  # Gets the initial attribute value defined by the owner class (outside of
  # the machine's definition). By default, this is always nil.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#51
  def owner_class_attribute_default; end

  # Checks whether the given state matches the attribute default specified
  # by the owner class
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#57
  def owner_class_attribute_default_matches?(state); end

  # Always yields
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#45
  def transaction(_object); end

  private

  # Gets the default messages that can be used in the machine for invalid
  # transitions.
  #
  # source://state_machines//lib/state_machines/machine/integration.rb#65
  def default_messages; end
end

# source://state_machines//lib/state_machines/machine/parsing.rb#5
module StateMachines::Machine::Parsing
  private

  # Adds a new transition callback of the given type.
  #
  # source://state_machines//lib/state_machines/machine/parsing.rb#31
  def add_callback(type, options, &_arg2); end

  # Tracks the given set of events in the list of all known events for
  # this machine
  #
  # source://state_machines//lib/state_machines/machine/parsing.rb#60
  def add_events(new_events); end

  # Tracks the given set of states in the list of all known states for
  # this machine
  #
  # source://state_machines//lib/state_machines/machine/parsing.rb#39
  def add_states(new_states); end

  # Parses callback arguments for backward compatibility with both positional
  # and keyword argument styles. Supports Ruby 3.2+ keyword arguments while
  # maintaining full backward compatibility with the legacy API.
  #
  # source://state_machines//lib/state_machines/machine/parsing.rb#11
  def parse_callback_arguments(args, options); end
end

# source://state_machines//lib/state_machines/machine/rendering.rb#5
module StateMachines::Machine::Rendering
  # Generates a visual representation of this machine for a given format.
  #
  # source://state_machines//lib/state_machines/machine/rendering.rb#12
  def draw(**_arg0); end

  # Gets the renderer for this machine.
  #
  # source://state_machines//lib/state_machines/machine/rendering.rb#7
  def renderer; end
end

# source://state_machines//lib/state_machines/machine/scoping.rb#5
module StateMachines::Machine::Scoping
  protected

  # Creates a scope for finding objects *with* a particular value or values
  # for the attribute.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/scoping.rb#35
  def create_with_scope(name); end

  # Creates a scope for finding objects *without* a particular value or
  # values for the attribute.
  #
  # By default, this is a no-op.
  #
  # source://state_machines//lib/state_machines/machine/scoping.rb#41
  def create_without_scope(name); end

  # Defines the with/without scope helpers for this attribute.  Both the
  # singular and plural versions of the attribute are defined for each
  # scope helper.  A custom plural can be specified if it cannot be
  # automatically determined by either calling +pluralize+ on the attribute
  # name or adding an "s" to the end of the name.
  #
  # source://state_machines//lib/state_machines/machine/scoping.rb#13
  def define_scopes(custom_plural = T.unsafe(nil)); end
end

# source://state_machines//lib/state_machines/machine/state_methods.rb#5
module StateMachines::Machine::StateMethods
  # Whether a dynamic initial state is being used in the machine
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#14
  def dynamic_initial_state?; end

  # Gets the initial state of the machine for the given object. If a dynamic
  # initial state was configured for this machine, then the object will be
  # passed into the lambda block to help determine the actual state.
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#9
  def initial_state(object); end

  # Initializes the state on the given object.  Initial values are only set if
  # the machine's attribute hasn't been previously initialized.
  #
  # Configuration options:
  # * <tt>:force</tt> - Whether to initialize the state regardless of its
  #   current value
  # * <tt>:to</tt> - A hash to set the initial value in instead of writing
  #   directly to the object
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#26
  def initialize_state(object, options = T.unsafe(nil)); end

  # Customizes the definition of one or more states in the machine.
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#73
  def other_states(*names, &_arg1); end

  # Gets the current value stored in the given object's attribute.
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#76
  def read(object, attribute, ivar = T.unsafe(nil)); end

  # Customizes the definition of one or more states in the machine.
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#40
  def state(*names, &_arg1); end

  # Sets a new value in the given object's attribute.
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#86
  def write(object, attribute, value, ivar = T.unsafe(nil)); end

  protected

  # Determines if the machine's attribute needs to be initialized.  This
  # will only be true if the machine's attribute is blank.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/state_methods.rb#95
  def initialize_state?(object); end
end

# source://state_machines//lib/state_machines/machine/utilities.rb#5
module StateMachines::Machine::Utilities
  protected

  # Adds sibling machine configurations to the current machine.  This
  # will add states from other machines that have the same attribute.
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#77
  def add_sibling_machine_configs; end

  # Looks up the ancestor class that has the given method defined.  This
  # is used to find the method owner which is used to determine where to
  # define new methods.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#23
  def owner_class_ancestor_has_method?(scope, method); end

  # Determines whether the given method is defined in the owner class or
  # in a superclass.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#52
  def owner_class_has_method?(scope, method); end

  # Pluralizes the given word using #pluralize (if available) or simply
  # adding an "s" to the end of the word
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#59
  def pluralize(word); end

  # Generates the results for the given scope based on one or more states to
  # filter by
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#70
  def run_scope(scope, machine, klass, states); end

  # Looks up other machines that have been defined in the owner class and
  # are targeting the same attribute as this machine.  When accessing
  # sibling machines, they will be automatically copied for the current
  # class if they haven't been already.  This ensures that any configuration
  # changes made to the sibling machines only affect this class and not any
  # base class that may have originally defined the machine.
  #
  # source://state_machines//lib/state_machines/machine/utilities.rb#14
  def sibling_machines; end
end

# source://state_machines//lib/state_machines/machine/validation.rb#5
module StateMachines::Machine::Validation
  private

  # Validates string input before eval to prevent code injection
  # This is a basic safety check - not foolproof security
  #
  # source://state_machines//lib/state_machines/machine/validation.rb#24
  def validate_eval_string(method_string); end
end

# Frozen constant to avoid repeated array allocations
#
# source://state_machines//lib/state_machines/machine/validation.rb#7
StateMachines::Machine::Validation::DANGEROUS_PATTERNS = T.let(T.unsafe(nil), Array)

# Represents a collection of state machines for a class
#
# source://state_machines//lib/state_machines/machine_collection.rb#7
class StateMachines::MachineCollection < ::Hash
  # Runs one or more events in parallel on the given object.  See
  # StateMachines::InstanceMethods#fire_events for more information.
  #
  # source://state_machines//lib/state_machines/machine_collection.rb#52
  def fire_events(object, *events); end

  # Initializes the state of each machine in the given object.  This can allow
  # states to be initialized in two groups: static and dynamic.  For example:
  #
  #   machines.initialize_states(object) do
  #     # After static state initialization, before dynamic state initialization
  #   end
  #
  # If no block is provided, then all states will still be initialized.
  #
  # Valid configuration options:
  # * <tt>:static</tt> - Whether to initialize static states. Unless set to
  #   false, the state will be initialized regardless of its current value.
  #   Default is true.
  # * <tt>:dynamic</tt> - Whether to initialize dynamic states.  If set to
  #   :force, the state will be initialized regardless of its current value.
  #   Default is true.
  # * <tt>:to</tt> - A hash to write the initialized state to instead of
  #   writing to the object.  Default is to write directly to the object.
  #
  # source://state_machines//lib/state_machines/machine_collection.rb#26
  def initialize_states(object, options = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # Builds the collection of transitions for all event attributes defined on
  # the given object.  This will only include events whose machine actions
  # match the one specified.
  #
  # These should only be fired as a result of the action being run.
  #
  # source://state_machines//lib/state_machines/machine_collection.rb#84
  def transitions(object, action, options = T.unsafe(nil)); end

  protected

  # source://state_machines//lib/state_machines/machine_collection.rb#94
  def resolve_use_transactions; end
end

# source://state_machines//lib/state_machines/macro_methods.rb#7
module StateMachines::MacroMethods
  # Creates a new state machine with the given name.  The default name, if not
  # specified, is <tt>:state</tt>.
  #
  # Configuration options:
  # * <tt>:attribute</tt> - The name of the attribute to store the state value
  #   in.  By default, this is the same as the name of the machine.
  # * <tt>:initial</tt> - The initial state of the attribute. This can be a
  #   static state or a lambda block which will be evaluated at runtime
  #   (e.g. lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling}).
  #   Default is nil.
  # * <tt>:initialize</tt> - Whether to automatically initialize the attribute
  #   by hooking into #initialize on the owner class.  Default is true.
  # * <tt>:action</tt> - The instance method to invoke when an object
  #   transitions. Default is nil unless otherwise specified by the
  #   configured integration.
  # * <tt>:namespace</tt> - The name to use for namespacing all generated
  #   state / event instance methods (e.g. "heater" would generate
  #   :turn_on_heater and :turn_off_heater for the :turn_on/:turn_off events).
  #   Default is nil.
  # * <tt>:integration</tt> - The name of the integration to use for adding
  #   library-specific behavior to the machine.  Built-in integrations
  #   include :active_model, :active_record, :data_mapper, :mongo_mapper, and
  #   :sequel.  By default, this is determined automatically.
  #
  # Configuration options relevant to ORM integrations:
  # * <tt>:plural</tt> - The pluralized version of the name.  By default, this
  #   will attempt to call +pluralize+ on the name.  If this method is not
  #   available, an "s" is appended.  This is used for generating scopes.
  # * <tt>:messages</tt> - The error messages to use when invalidating
  #   objects due to failed transitions.  Messages include:
  #   * <tt>:invalid</tt>
  #   * <tt>:invalid_event</tt>
  #   * <tt>:invalid_transition</tt>
  # * <tt>:use_transactions</tt> - Whether transactions should be used when
  #   firing events.  Default is true unless otherwise specified by the
  #   configured integration.
  #
  # This also expects a block which will be used to actually configure the
  # states, events and transitions for the state machine.  *Note* that this
  # block will be executed within the context of the state machine.  As a
  # result, you will not be able to access any class methods unless you refer
  # to them directly (i.e. specifying the class name).
  #
  # For examples on the types of state machine configurations and blocks, see
  # the section below.
  #
  # == Examples
  #
  # With the default name/attribute and no configuration:
  #
  #   class Vehicle
  #     state_machine do
  #       event :park do
  #         ...
  #       end
  #     end
  #   end
  #
  # The above example will define a state machine named "state" that will
  # store the value in the +state+ attribute.  Every vehicle will start
  # without an initial state.
  #
  # With a custom name / attribute:
  #
  #   class Vehicle
  #     state_machine :status, :attribute => :status_value do
  #       ...
  #     end
  #   end
  #
  # With a static initial state:
  #
  #   class Vehicle
  #     state_machine :status, :initial => :parked do
  #       ...
  #     end
  #   end
  #
  # With a dynamic initial state:
  #
  #   class Vehicle
  #     state_machine :status, :initial => lambda {|vehicle| vehicle.speed == 0 ? :parked : :idling} do
  #       ...
  #     end
  #   end
  #
  # == Class Methods
  #
  # The following class methods will be automatically generated by the
  # state machine based on the *name* of the machine.  Any existing methods
  # will not be overwritten.
  # * <tt>human_state_name(state)</tt> - Gets the humanized value for the
  #   given state.  This may be generated by internationalization libraries if
  #   supported by the integration.
  # * <tt>human_state_event_name(event)</tt> - Gets the humanized value for
  #   the given event.  This may be generated by internationalization
  #   libraries if supported by the integration.
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #
  #       event :shift_up do
  #         transition :idling => :first_gear
  #       end
  #     end
  #   end
  #
  #   Vehicle.human_state_name(:parked)         # => "parked"
  #   Vehicle.human_state_name(:first_gear)     # => "first gear"
  #   Vehicle.human_state_event_name(:park)     # => "park"
  #   Vehicle.human_state_event_name(:shift_up) # => "shift up"
  #
  # == Instance Methods
  #
  # The following instance methods will be automatically generated by the
  # state machine based on the *name* of the machine.  Any existing methods
  # will not be overwritten.
  # * <tt>state</tt> - Gets the current value for the attribute
  # * <tt>state=(value)</tt> - Sets the current value for the attribute
  # * <tt>state?(name)</tt> - Checks the given state name against the current
  #   state.  If the name is not a known state, then an ArgumentError is raised.
  # * <tt>state_name</tt> - Gets the name of the state for the current value
  # * <tt>human_state_name</tt> - Gets the human-readable name of the state
  #   for the current value
  # * <tt>state_events(requirements = {})</tt> - Gets the list of events that
  #   can be fired on the current object's state (uses the *unqualified* event
  #   names)
  # * <tt>state_transitions(requirements = {})</tt> - Gets the list of
  #   transitions that can be made on the current object's state
  # * <tt>state_paths(requirements = {})</tt> - Gets the list of sequences of
  #   transitions that can be run from the current object's state
  # * <tt>fire_state_event(name, *args)</tt> - Fires an arbitrary event with
  #   the given argument list. This is essentially the same as calling the
  #   actual event method itself.
  #
  # The <tt>state_events</tt>, <tt>state_transitions</tt>, and <tt>state_paths</tt>
  # helpers all take an optional set of requirements for determining what's
  # available for the current object.  These requirements include:
  # * <tt>:from</tt> - One or more states to transition from.  If none are
  #   specified, then this will be the object's current state.
  # * <tt>:to</tt> - One or more states to transition to.  If none are
  #   specified, then this will match any to state.
  # * <tt>:on</tt> - One or more events to transition on.  If none are
  #   specified, then this will match any event.
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one.  Default is true.
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #
  #       event :park do
  #         transition :idling => :parked
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new
  #   vehicle.state                             # => "parked"
  #   vehicle.state_name                        # => :parked
  #   vehicle.human_state_name                  # => "parked"
  #   vehicle.state?(:parked)                   # => true
  #
  #   # Changing state
  #   vehicle.state = 'idling'
  #   vehicle.state                             # => "idling"
  #   vehicle.state_name                        # => :idling
  #   vehicle.state?(:parked)                   # => false
  #
  #   # Getting current event / transition availability
  #   vehicle.state_events                      # => [:park]
  #   vehicle.park                              # => true
  #   vehicle.state_events                      # => [:ignite]
  #   vehicle.state_events(:from => :idling)    # => [:park]
  #   vehicle.state_events(:to => :parked)      # => []
  #
  #   vehicle.state_transitions                 # => [#<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
  #   vehicle.ignite                            # => true
  #   vehicle.state_transitions                 # => [#<StateMachines::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>]
  #
  #   vehicle.state_transitions(:on => :ignite) # => []
  #
  #   # Getting current path availability
  #   vehicle.state_paths                       # => [
  #                                             #     [#<StateMachines::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
  #                                             #      #<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
  #                                             #   ]
  #   vehicle.state_paths(:guard => false)      # =>
  #                                             #     [#<StateMachines::Transition attribute=:state event=:park from="idling" from_name=:idling to="parked" to_name=:parked>,
  #                                             #      #<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>]
  #                                             #   ]
  #
  #   # Fire arbitrary events
  #   vehicle.fire_state_event(:park)           # => true
  #
  # == Attribute initialization
  #
  # For most classes, the initial values for state machine attributes are
  # automatically assigned when a new object is created.  However, this
  # behavior will *not* work if the class defines an +initialize+ method
  # without properly calling +super+.
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       ...
  #     end
  #   end
  #
  #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
  #   vehicle.state           # => "parked"
  #
  # In the above example, no +initialize+ method is defined.  As a result,
  # the default behavior of initializing the state machine attributes is used.
  #
  # In the following example, a custom +initialize+ method is defined:
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       ...
  #     end
  #
  #     def initialize
  #     end
  #   end
  #
  #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c77678>
  #   vehicle.state           # => nil
  #
  # Since the +initialize+ method is defined, the state machine attributes
  # never get initialized.  In order to ensure that all initialization hooks
  # are called, the custom method *must* call +super+ without any arguments
  # like so:
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       ...
  #     end
  #
  #     def initialize(attributes = {})
  #       ...
  #       super()
  #     end
  #   end
  #
  #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
  #   vehicle.state           # => "parked"
  #
  # Because of the way the inclusion of modules works in Ruby, calling
  # <tt>super()</tt> will not only call the superclass's +initialize+, but
  # also +initialize+ on all included modules.  This allows the original state
  # machine hook to get called properly.
  #
  # If you want to avoid calling the superclass's constructor, but still want
  # to initialize the state machine attributes:
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       ...
  #     end
  #
  #     def initialize(attributes = {})
  #       ...
  #       initialize_state_machines
  #     end
  #   end
  #
  #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
  #   vehicle.state           # => "parked"
  #
  # You may also need to call the +initialize_state_machines+ helper manually
  # in cases where you want to change how static / dynamic initial states get
  # set.  For example, the following example forces the initialization of
  # static states regardless of their current value:
  #
  #   class Vehicle
  #     state_machine :state, :initial => :parked do
  #       state nil, :idling
  #       ...
  #     end
  #
  #     def initialize(attributes = {})
  #       @state = 'idling'
  #       initialize_state_machines(:static => :force) do
  #         ...
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new   # => #<Vehicle:0xb7c8dbf8 @state="parked">
  #   vehicle.state           # => "parked"
  #
  # The above example is also noteworthy because it demonstrates how to avoid
  # initialization issues when +nil+ is a valid state.  Without passing in
  # <tt>:static => :force</tt>, state_machine would never have initialized
  # the state because +nil+ (the default attribute value) would have been
  # interpreted as a valid current state.  As a result, state_machine would
  # have simply skipped initialization.
  #
  # == States
  #
  # All of the valid states for the machine are automatically tracked based
  # on the events, transitions, and callbacks defined for the machine.  If
  # there are additional states that are never referenced, these should be
  # explicitly added using the StateMachines::Machine#state or
  # StateMachines::Machine#other_states helpers.
  #
  # When a new state is defined, a predicate method for that state is
  # generated on the class.  For example,
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition all => :idling
  #       end
  #     end
  #   end
  #
  # ...will generate the following instance methods (assuming they're not
  # already defined in the class):
  # * <tt>parked?</tt>
  # * <tt>idling?</tt>
  #
  # Each predicate method will return true if it matches the object's
  # current state.  Otherwise, it will return false.
  #
  # == Attribute access
  #
  # The actual value for a state is stored in the attribute configured for the
  # state machine.  In most cases, this is the same as the name of the state
  # machine.  For example:
  #
  #   class Vehicle
  #     attr_accessor :state
  #
  #     state_machine :state, :initial => :parked do
  #       ...
  #       state :parked, :value => 0
  #       start :idling, :value => 1
  #     end
  #   end
  #
  #   vehicle = Vehicle.new # => #<Vehicle:0xb712da60 @state=0>
  #   vehicle.state         # => 0
  #   vehicle.parked?       # => true
  #   vehicle.state = 1
  #   vehicle.idling?       # => true
  #
  # The most important thing to note from the example above is what it means
  # to read from and write to the state machine's attribute.  In particular,
  # state_machine treats the attribute (+state+ in this case) like a basic
  # attr_accessor that's been defined on the class.  There are no special
  # behaviors added, such as allowing the attribute to be written to based on
  # the name of a state in the machine.  This is the case for a few reasons:
  # * Setting the attribute directly is an edge case that is meant to only be
  #   used when you want to skip state_machine altogether.  This means that
  #   state_machine shouldn't have any effect on the attribute accessor
  #   methods.  If you want to change the state, you should be using one of
  #   the events defined in the state machine.
  # * Many ORMs provide custom behavior for the attribute reader / writer - it
  #   may even be defined by your own framework / method implementation just
  #   the example above showed.  In order to avoid having to worry about the
  #   different ways an attribute can get written, state_machine just makes
  #   sure that the configured value for a state is always used when writing
  #   to the attribute.
  #
  # If you were interested in accessing the name of a state (instead of its
  # actual value through the attribute), you could do the following:
  #
  #   vehicle.state_name    # => :idling
  #
  # == Events and Transitions
  #
  # Events defined on the machine are the interface to transitioning states
  # for an object.  Events can be fired either directly (through the method
  # generated for the event) or indirectly (through attributes defined on
  # the machine).
  #
  # For example,
  #
  #   class Vehicle
  #     include DataMapper::Resource
  #     property :id, Serial
  #
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #
  #     state_machine :alarm_state, :initial => :active do
  #       event :disable do
  #         transition all => :off
  #       end
  #     end
  #   end
  #
  #   # Fire +ignite+ event directly
  #   vehicle = Vehicle.create    # => #<Vehicle id=1 state="parked" alarm_state="active">
  #   vehicle.ignite              # => true
  #   vehicle.state               # => "idling"
  #   vehicle.alarm_state         # => "active"
  #
  #   # Fire +disable+ event automatically
  #   vehicle.alarm_state_event = 'disable'
  #   vehicle.save                # => true
  #   vehicle.alarm_state         # => "off"
  #
  # In the above example, the +state+ attribute is transitioned using the
  # +ignite+ action that's generated from the state machine.  On the other
  # hand, the +alarm_state+ attribute is transitioned using the +alarm_state_event+
  # attribute that automatically gets fired when the machine's action (+save+)
  # is invoked.
  #
  # For more information about how to configure an event and its associated
  # transitions, see StateMachines::Machine#event.
  #
  # == Defining callbacks
  #
  # Within the +state_machine+ block, you can also define callbacks for
  # transitions.  For more information about defining these callbacks,
  # see StateMachines::Machine#before_transition, StateMachines::Machine#after_transition,
  # and StateMachines::Machine#around_transition, and StateMachines::Machine#after_failure.
  #
  # == Namespaces
  #
  # When a namespace is configured for a state machine, the name provided
  # will be used in generating the instance methods for interacting with
  # states/events in the machine.  This is particularly useful when a class
  # has multiple state machines and it would be difficult to differentiate
  # between the various states / events.
  #
  # For example,
  #
  #   class Vehicle
  #     state_machine :heater_state, :initial => :off, :namespace => 'heater' do
  #       event :turn_on do
  #         transition all => :on
  #       end
  #
  #       event :turn_off do
  #         transition all => :off
  #       end
  #     end
  #
  #     state_machine :alarm_state, :initial => :active, :namespace => 'alarm' do
  #       event :turn_on do
  #         transition all => :active
  #       end
  #
  #       event :turn_off do
  #         transition all => :off
  #       end
  #     end
  #   end
  #
  # The above class defines two state machines: +heater_state+ and +alarm_state+.
  # For the +heater_state+ machine, the following methods are generated since
  # it's namespaced by "heater":
  # * <tt>can_turn_on_heater?</tt>
  # * <tt>turn_on_heater</tt>
  # * ...
  # * <tt>can_turn_off_heater?</tt>
  # * <tt>turn_off_heater</tt>
  # * ..
  # * <tt>heater_off?</tt>
  # * <tt>heater_on?</tt>
  #
  # As shown, each method is unique to the state machine so that the states
  # and events don't conflict.  The same goes for the +alarm_state+ machine:
  # * <tt>can_turn_on_alarm?</tt>
  # * <tt>turn_on_alarm</tt>
  # * ...
  # * <tt>can_turn_off_alarm?</tt>
  # * <tt>turn_off_alarm</tt>
  # * ..
  # * <tt>alarm_active?</tt>
  # * <tt>alarm_off?</tt>
  #
  # == Scopes
  #
  # For integrations that support it, a group of default scope filters will
  # be automatically created for assisting in finding objects that have the
  # attribute set to one of a given set of states.
  #
  # For example,
  #
  #   Vehicle.with_state(:parked)               # => All vehicles where the state is parked
  #   Vehicle.with_states(:parked, :idling)     # => All vehicles where the state is either parked or idling
  #
  #   Vehicle.without_state(:parked)            # => All vehicles where the state is *not* parked
  #   Vehicle.without_states(:parked, :idling)  # => All vehicles where the state is *not* parked or idling
  #
  # *Note* that if class methods already exist with those names (i.e.
  # :with_state, :with_states, :without_state, or :without_states), then a
  # scope will not be defined for that name.
  #
  # See StateMachines::Machine for more information about using integrations
  # and the individual integration docs for information about the actual
  # scopes that are generated.
  #
  # source://state_machines//lib/state_machines/macro_methods.rb#518
  def state_machine(*_arg0, &_arg1); end
end

# Provides a general strategy pattern for determining whether a match is found
# for a value.  The algorithm that actually determines the match depends on
# the matcher in use.
#
# source://state_machines//lib/state_machines/matcher.rb#7
class StateMachines::Matcher
  # Creates a new matcher for querying against the given set of values
  #
  # @return [Matcher] a new instance of Matcher
  #
  # source://state_machines//lib/state_machines/matcher.rb#12
  def initialize(values = T.unsafe(nil)); end

  # Generates a subset of values that exists in both the set of values being
  # filtered and the values configured for the matcher
  #
  # source://state_machines//lib/state_machines/matcher.rb#18
  def filter(values); end

  # The list of values against which queries are matched
  #
  # source://state_machines//lib/state_machines/matcher.rb#9
  def values; end
end

# Provides a set of helper methods for generating matchers
#
# source://state_machines//lib/state_machines/matcher_helpers.rb#5
module StateMachines::MatcherHelpers
  # Represents a state that matches all known states in a machine.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition any => :parked, :do => lambda {...}
  #       before_transition all - :parked => all - :idling, :do => lambda {}
  #
  #       event :park
  #         transition all => :parked
  #       end
  #
  #       event :crash
  #         transition all - :parked => :stalled
  #       end
  #     end
  #   end
  #
  # In the above example, +all+ will match the following states since they
  # are known:
  # * +parked+
  # * +stalled+
  # * +idling+
  #
  # source://state_machines//lib/state_machines/matcher_helpers.rb#30
  def all; end

  # Represents a state that matches all known states in a machine.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine do
  #       before_transition any => :parked, :do => lambda {...}
  #       before_transition all - :parked => all - :idling, :do => lambda {}
  #
  #       event :park
  #         transition all => :parked
  #       end
  #
  #       event :crash
  #         transition all - :parked => :stalled
  #       end
  #     end
  #   end
  #
  # In the above example, +all+ will match the following states since they
  # are known:
  # * +parked+
  # * +stalled+
  # * +idling+
  #
  # source://state_machines//lib/state_machines/matcher_helpers.rb#33
  def any; end

  # Represents a state that matches the original +from+ state.  This is useful
  # for defining transitions which are loopbacks.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine do
  #       event :ignite
  #         transition [:idling, :first_gear] => same
  #       end
  #     end
  #   end
  #
  # In the above example, +same+ will match whichever the from state is.  In
  # the case of the +ignite+ event, it is essential the same as the following:
  #
  #   transition :idling => :idling, :first_gear => :first_gear
  #
  # source://state_machines//lib/state_machines/matcher_helpers.rb#52
  def same; end
end

# Represents a collection of nodes in a state machine, be it events or states.
# Nodes will not differentiate between the String and Symbol versions of the
# values being indexed.
#
# source://state_machines//lib/state_machines/node_collection.rb#9
class StateMachines::NodeCollection
  include ::Enumerable

  # Creates a new collection of nodes for the given state machine.  By default,
  # the collection is empty.
  #
  # Configuration options:
  # * <tt>:index</tt> - One or more attributes to automatically generate
  #   hashed indices for in order to perform quick lookups.  Default is to
  #   index by the :name attribute
  #
  # @return [NodeCollection] a new instance of NodeCollection
  #
  # source://state_machines//lib/state_machines/node_collection.rb#22
  def initialize(machine, options = T.unsafe(nil)); end

  # Adds a new node to the collection.  By doing so, this will also add it to
  # the configured indices.  This will also evaluate any existings contexts
  # that match the new node.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#90
  def <<(node); end

  # Gets the node indexed by the given key.  By default, this will look up the
  # key in the first index configured for the collection.  A custom index can
  # be specified like so:
  #
  #   collection['parked', :value]
  #
  # The above will look up the "parked" key in a hash indexed by each node's
  # +value+ attribute.
  #
  # If the key cannot be found, then nil will be returned.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#147
  def [](key, index_name = T.unsafe(nil)); end

  # Gets the node at the given index.
  #
  #   states = StateMachines::NodeCollection.new
  #   states << StateMachines::State.new(machine, :parked)
  #   states << StateMachines::State.new(machine, :idling)
  #
  #   states.at(0).name    # => :parked
  #   states.at(1).name    # => :idling
  #
  # source://state_machines//lib/state_machines/node_collection.rb#133
  def at(index); end

  # Appends a group of nodes to the collection
  #
  # source://state_machines//lib/state_machines/node_collection.rb#98
  def concat(nodes); end

  # Tracks a context that should be evaluated for any nodes that get added
  # which match the given set of nodes.  Matchers can be used so that the
  # context can get added once and evaluated after multiple adds.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#77
  def context(nodes, &block); end

  # Calls the block once for each element in self, passing that element as a
  # parameter.
  #
  #   states = StateMachines::NodeCollection.new
  #   states << StateMachines::State.new(machine, :parked)
  #   states << StateMachines::State.new(machine, :idling)
  #   states.each {|state| puts state.name, ' -- '}
  #
  # ...produces:
  #
  #   parked -- idling --
  #
  # source://state_machines//lib/state_machines/node_collection.rb#120
  def each(&_arg0); end

  # Gets the node indexed by the given key.  By default, this will look up the
  # key in the first index configured for the collection.  A custom index can
  # be specified like so:
  #
  #   collection['parked', :value]
  #
  # The above will look up the "parked" key in a hash indexed by each node's
  # +value+ attribute.
  #
  # If the key cannot be found, then an IndexError exception will be raised:
  #
  #   collection['invalid', :value]   # => IndexError: "invalid" is an invalid value
  #
  # source://state_machines//lib/state_machines/node_collection.rb#166
  def fetch(key, index_name = T.unsafe(nil)); end

  # Gets the set of unique keys for the given index
  #
  # source://state_machines//lib/state_machines/node_collection.rb#70
  def keys(index_name = T.unsafe(nil)); end

  # Gets the number of nodes in this collection
  #
  # source://state_machines//lib/state_machines/node_collection.rb#65
  def length; end

  # The machine associated with the nodes
  #
  # source://state_machines//lib/state_machines/node_collection.rb#13
  def machine; end

  # Changes the current machine associated with the collection.  In turn, this
  # will change the state machine associated with each node in the collection.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#59
  def machine=(new_machine); end

  # Updates the indexed keys for the given node.  If the node's attribute
  # has changed since it was added to the collection, the old indexed keys
  # will be replaced with the updated ones.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#105
  def update(node); end

  protected

  # Adds the given key / node combination to an index, including the string
  # and symbol versions of the index
  #
  # source://state_machines//lib/state_machines/node_collection.rb#187
  def add_to_index(name, key, node); end

  # Evaluates the given context for a particular node.  This will only
  # evaluate the context if the node matches.
  #
  # source://state_machines//lib/state_machines/node_collection.rb#222
  def eval_context(context, node); end

  # Gets the given index.  If the index does not exist, then an ArgumentError
  # is raised.
  #
  # @raise [ArgumentError]
  #
  # source://state_machines//lib/state_machines/node_collection.rb#174
  def index(name); end

  # Removes the given key from an index, including the string and symbol
  # versions of the index
  #
  # source://state_machines//lib/state_machines/node_collection.rb#195
  def remove_from_index(name, key); end

  # Determines whether the given value can be converted to a symbol
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/node_collection.rb#216
  def to_sym?(value); end

  # Updates the node for the given index, including the string and symbol
  # versions of the index
  #
  # source://state_machines//lib/state_machines/node_collection.rb#203
  def update_index(name, node); end

  # Gets the value for the given attribute on the node
  #
  # source://state_machines//lib/state_machines/node_collection.rb#181
  def value(node, attribute); end

  private

  # Creates a copy of this collection such that modifications don't affect
  # the original collection
  #
  # source://state_machines//lib/state_machines/node_collection.rb#40
  def initialize_copy(orig); end
end

# Define the module if it doesn't exist yet
# Module for validating options without monkey-patching Hash
# Provides the same functionality as the Hash monkey patch but in a cleaner way
#
# source://state_machines//lib/state_machines/options_validator.rb#7
module StateMachines::OptionsValidator
  class << self
    # Validates that at most one of the exclusive keys is present in the options hash
    #
    # @param caller_info [String] Information about the calling method for better error messages
    # @param exclusive_keys [Array<Symbol>] List of mutually exclusive keys
    # @param options [Hash] The options hash to validate
    # @raise [ArgumentError] If more than one exclusive key is found
    #
    # source://state_machines//lib/state_machines/options_validator.rb#33
    def assert_exclusive_keys!(options, *exclusive_keys, caller_info: T.unsafe(nil)); end

    # Validates that all keys in the options hash are in the list of valid keys
    #
    # @param caller_info [String] Information about the calling method for better error messages
    # @param options [Hash] The options hash to validate
    # @param valid_keys [Array<Symbol>] List of valid key names
    # @raise [ArgumentError] If any invalid keys are found
    #
    # source://state_machines//lib/state_machines/options_validator.rb#15
    def assert_valid_keys!(options, *valid_keys, caller_info: T.unsafe(nil)); end

    # Helper method for backwards compatibility - allows gradual migration
    # from Hash monkey patch to this module
    #
    # @param options [Hash] The options to validate
    # @param valid_keys [Array<Symbol>] Valid keys
    # @return [Hash] The same options hash (for chaining)
    #
    # source://state_machines//lib/state_machines/options_validator.rb#66
    def validate_and_return(options, *valid_keys); end

    # Validates options using a more convenient interface that works with both
    # hash-style and kwargs-style method definitions
    #
    # @param caller_info [String] Information about the calling method
    # @param exclusive_key_groups [Array<Array<Symbol>>] Groups of mutually exclusive keys
    # @param valid_keys [Array<Symbol>] List of valid key names
    # @return [Proc] A validation proc that can be called with options
    #
    # source://state_machines//lib/state_machines/options_validator.rb#50
    def validator(valid_keys: T.unsafe(nil), exclusive_key_groups: T.unsafe(nil), caller_info: T.unsafe(nil)); end
  end
end

# A path represents a sequence of transitions that can be run for a particular
# object.  Paths can walk to new transitions, revealing all of the possible
# branches that can be encountered in the object's state machine.
#
# source://state_machines//lib/state_machines/path.rb#9
class StateMachines::Path < ::Array
  # Creates a new transition path for the given object.  Initially this is an
  # empty path.  In order to start walking the path, it must be populated with
  # an initial transition.
  #
  # Configuration options:
  # * <tt>:target</tt> - The target state to end the path on
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one
  #
  # @return [Path] a new instance of Path
  #
  # source://state_machines//lib/state_machines/path.rb#24
  def initialize(object, machine, options = T.unsafe(nil)); end

  # Determines whether or not this path has completed.  A path is considered
  # complete when one of the following conditions is met:
  # * The last transition in the path ends on the target state
  # * There are no more transitions remaining to walk and there is no target
  #   state
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/path.rb#87
  def complete?; end

  # Lists all of the events that can be fired through this path.
  #
  # For example,
  #
  #   path.events # => [:park, :ignite, :shift_up, ...]
  #
  # source://state_machines//lib/state_machines/path.rb#72
  def events; end

  # The initial state name for this path
  #
  # source://state_machines//lib/state_machines/path.rb#39
  def from_name; end

  # Lists all of the from states that can be reached through this path.
  #
  # For example,
  #
  #   path.to_states  # => [:parked, :idling, :first_gear, ...]
  #
  # source://state_machines//lib/state_machines/path.rb#48
  def from_states; end

  # The state machine this path is walking
  #
  # source://state_machines//lib/state_machines/path.rb#14
  def machine; end

  # The object whose state machine is being walked
  #
  # source://state_machines//lib/state_machines/path.rb#11
  def object; end

  # The end state name for this path.  If a target state was specified for
  # the path, then that will be returned if the path is complete.
  #
  # source://state_machines//lib/state_machines/path.rb#54
  def to_name; end

  # Lists all of the to states that can be reached through this path.
  #
  # For example,
  #
  #   path.to_states  # => [:parked, :idling, :first_gear, ...]
  #
  # source://state_machines//lib/state_machines/path.rb#63
  def to_states; end

  # Walks down the next transitions at the end of this path.  This will only
  # walk down paths that are considered valid.
  #
  # source://state_machines//lib/state_machines/path.rb#78
  def walk; end

  private

  # Determines whether it's possible to walk to the given transition from
  # the current path.  A transition can be walked to if:
  # * It has not been recently walked and
  # * If a target is specified, it has not been walked to twice yet
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/path.rb#113
  def can_walk_to?(transition); end

  # source://state_machines//lib/state_machines/path.rb#33
  def initialize_copy(orig); end

  # Determines whether the given transition has been recently walked down in
  # this path.  If a target is configured for this path, then this will only
  # look at transitions walked down since the target was last reached.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/path.rb#101
  def recently_walked?(transition); end

  # Calculates the number of times the given state has been walked to
  #
  # source://state_machines//lib/state_machines/path.rb#94
  def times_walked_to(state); end

  # Get the next set of transitions that can be walked to starting from the
  # end of this path
  #
  # source://state_machines//lib/state_machines/path.rb#119
  def transitions; end
end

# Represents a collection of paths that are generated based on a set of
# requirements regarding what states to start and end on
#
# source://state_machines//lib/state_machines/path_collection.rb#8
class StateMachines::PathCollection < ::Array
  # Creates a new collection of paths with the given requirements.
  #
  # Configuration options:
  # * <tt>:from</tt> - The initial state to start from
  # * <tt>:to</tt> - The target end state
  # * <tt>:deep</tt> - Whether to enable deep searches for the target state.
  # * <tt>:guard</tt> - Whether to guard transitions with the if/unless
  #   conditionals defined for each one
  #
  # @return [PathCollection] a new instance of PathCollection
  #
  # source://state_machines//lib/state_machines/path_collection.rb#29
  def initialize(object, machine, options = T.unsafe(nil)); end

  # Lists all of the events that can be fired through the paths in this
  # collection.
  #
  # For example,
  #
  #   paths.events  # => [:park, :ignite, :shift_up, ...]
  #
  # source://state_machines//lib/state_machines/path_collection.rb#69
  def events; end

  # The initial state to start each path from
  #
  # source://state_machines//lib/state_machines/path_collection.rb#16
  def from_name; end

  # Lists all of the states that can be transitioned from through the paths in
  # this collection.
  #
  # For example,
  #
  #   paths.from_states # => [:parked, :idling, :first_gear, ...]
  #
  # source://state_machines//lib/state_machines/path_collection.rb#49
  def from_states; end

  # The state machine these path are walking
  #
  # source://state_machines//lib/state_machines/path_collection.rb#13
  def machine; end

  # The object whose state machine is being walked
  #
  # source://state_machines//lib/state_machines/path_collection.rb#10
  def object; end

  # The target state for each path
  #
  # source://state_machines//lib/state_machines/path_collection.rb#19
  def to_name; end

  # Lists all of the states that can be transitioned to through the paths in
  # this collection.
  #
  # For example,
  #
  #   paths.to_states # => [:idling, :first_gear, :second_gear, ...]
  #
  # source://state_machines//lib/state_machines/path_collection.rb#59
  def to_states; end

  private

  # Gets the initial set of paths to walk
  #
  # source://state_machines//lib/state_machines/path_collection.rb#76
  def initial_paths; end

  # Walks down the given path.  Each new path that matches the configured
  # requirements will be added to this collection.
  #
  # source://state_machines//lib/state_machines/path_collection.rb#86
  def walk(path); end
end

# Module to extend Fiber instances for pausable state tracking
#
# source://state_machines//lib/state_machines/transition.rb#5
module StateMachines::PausableFiber
  # Returns the value of attribute state_machine_fiber_pausable.
  #
  # source://state_machines//lib/state_machines/transition.rb#6
  def state_machine_fiber_pausable; end

  # Sets the attribute state_machine_fiber_pausable
  #
  # @param value the value to set the attribute state_machine_fiber_pausable to.
  #
  # source://state_machines//lib/state_machines/transition.rb#6
  def state_machine_fiber_pausable=(_arg0); end
end

# source://state_machines//lib/state_machines/stdio_renderer.rb#4
module StateMachines::STDIORenderer
  private

  # source://state_machines//lib/state_machines/stdio_renderer.rb#31
  def draw_branch(branch, _graph, _event, options: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#11
  def draw_class(machine:, io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#26
  def draw_event(event, _graph, options: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#41
  def draw_events(machine:, io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#5
  def draw_machine(machine, io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#61
  def draw_requirement(requirement); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#36
  def draw_state(state, _graph, options: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/stdio_renderer.rb#15
  def draw_states(machine:, io: T.unsafe(nil)); end

  class << self
    # source://state_machines//lib/state_machines/stdio_renderer.rb#31
    def draw_branch(branch, _graph, _event, options: T.unsafe(nil), io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#11
    def draw_class(machine:, io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#26
    def draw_event(event, _graph, options: T.unsafe(nil), io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#41
    def draw_events(machine:, io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#5
    def draw_machine(machine, io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#61
    def draw_requirement(requirement); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#36
    def draw_state(state, _graph, options: T.unsafe(nil), io: T.unsafe(nil)); end

    # source://state_machines//lib/state_machines/stdio_renderer.rb#15
    def draw_states(machine:, io: T.unsafe(nil)); end
  end
end

# A state defines a value that an attribute can be in after being transitioned
# 0 or more times.  States can represent a value of any type in Ruby, though
# the most common (and default) type is String.
#
# In addition to defining the machine's value, a state can also define a
# behavioral context for an object when that object is in the state.  See
# StateMachines::Machine#state for more information about how state-driven
# behavior can be utilized.
#
# source://state_machines//lib/state_machines/state.rb#14
class StateMachines::State
  # Creates a new state within the context of the given machine.
  #
  # Configuration options:
  # * <tt>:initial</tt> - Whether this state is the beginning state for the
  #   machine. Default is false.
  # * <tt>:value</tt> - The value to store when an object transitions to this
  #   state.  Default is the name (stringified).
  # * <tt>:cache</tt> - If a dynamic value (via a lambda block) is being used,
  #   then setting this to true will cache the evaluated result
  # * <tt>:if</tt> - Determines whether a value matches this state
  #   (e.g. :value => lambda {Time.now}, :if => lambda {|state| !state.nil?}).
  #   By default, the configured value is matched.
  # * <tt>:human_name</tt> - The human-readable version of this state's name
  #
  # @return [State] a new instance of State
  #
  # source://state_machines//lib/state_machines/state.rb#56
  def initialize(machine, name, options = T.unsafe(nil), initial: T.unsafe(nil), value: T.unsafe(nil), cache: T.unsafe(nil), if: T.unsafe(nil), human_name: T.unsafe(nil), **extra_options); end

  # Whether this state's value should be cached after being evaluated
  #
  # source://state_machines//lib/state_machines/state.rb#33
  def cache; end

  # Whether this state's value should be cached after being evaluated
  #
  # source://state_machines//lib/state_machines/state.rb#33
  def cache=(_arg0); end

  # Calls a method defined in this state's context on the given object.  All
  # arguments and any block will be passed into the method defined.
  #
  # If the method has never been defined for this state, then a NoMethodError
  # will be raised.
  #
  # source://state_machines//lib/state_machines/state.rb#243
  def call(object, method, *args, &_arg3); end

  # Defines a context for the state which will be enabled on instances of
  # the owner class when the machine is in this state.
  #
  # This can be called multiple times.  Each time a new context is created,
  # a new module will be included in the owner class.
  #
  # source://state_machines//lib/state_machines/state.rb#205
  def context(&_arg0); end

  # The list of methods that have been defined in this state's context
  #
  # source://state_machines//lib/state_machines/state.rb#232
  def context_methods; end

  # Generates a human-readable description of this state's name / value:
  #
  # For example,
  #
  #   State.new(machine, :parked).description                               # => "parked"
  #   State.new(machine, :parked, :value => :parked).description            # => "parked"
  #   State.new(machine, :parked, :value => nil).description                # => "parked (nil)"
  #   State.new(machine, :parked, :value => 1).description                  # => "parked (1)"
  #   State.new(machine, :parked, :value => lambda {Time.now}).description  # => "parked (*)
  #
  # Configuration options:
  # * <tt>:human_name</tt> - Whether to use this state's human name in the
  #   description or just the internal name
  #
  # source://state_machines//lib/state_machines/state.rb#151
  def description(options = T.unsafe(nil)); end

  # source://state_machines//lib/state_machines/state.rb#265
  def draw(graph, options = T.unsafe(nil), io = T.unsafe(nil)); end

  # Determines whether there are any states that can be transitioned to from
  # this state.  If there are none, then this state is considered *final*.
  # Any objects in a final state will remain so forever given the current
  # machine's definition.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/state.rb#122
  def final?; end

  # Transforms the state name into a more human-readable format, such as
  # "first gear" instead of "first_gear"
  #
  # source://state_machines//lib/state_machines/state.rb#134
  def human_name(klass = T.unsafe(nil)); end

  # The human-readable name for the state
  #
  # source://state_machines//lib/state_machines/state.rb#26
  def human_name=(_arg0); end

  # Whether or not this state is the initial state to use for new objects
  #
  # source://state_machines//lib/state_machines/state.rb#36
  def initial; end

  # Whether or not this state is the initial state to use for new objects
  #
  # source://state_machines//lib/state_machines/state.rb#36
  def initial=(_arg0); end

  # Whether or not this state is the initial state to use for new objects
  #
  # source://state_machines//lib/state_machines/state.rb#37
  def initial?; end

  # Generates a nicely formatted description of this state's contents.
  #
  # For example,
  #
  #   state = StateMachines::State.new(machine, :parked, :value => 1, :initial => true)
  #   state   # => #<StateMachines::State name=:parked value=1 initial=true context=[]>
  #
  # source://state_machines//lib/state_machines/state.rb#275
  def inspect; end

  # The state machine for which this state is defined
  #
  # source://state_machines//lib/state_machines/state.rb#16
  def machine; end

  # source://state_machines//lib/state_machines/state.rb#113
  def machine=(machine); end

  # A custom lambda block for determining whether a given value matches this
  # state
  #
  # source://state_machines//lib/state_machines/state.rb#41
  def matcher; end

  # A custom lambda block for determining whether a given value matches this
  # state
  #
  # source://state_machines//lib/state_machines/state.rb#41
  def matcher=(_arg0); end

  # Determines whether this state matches the given value.  If no matcher is
  # configured, then this will check whether the values are equivalent.
  # Otherwise, the matcher will determine the result.
  #
  # For example,
  #
  #   # Without a matcher
  #   state = State.new(machine, :parked, :value => 1)
  #   state.matches?(1)           # => true
  #   state.matches?(2)           # => false
  #
  #   # With a matcher
  #   state = State.new(machine, :parked, :value => lambda {Time.now}, :if => lambda {|value| !value.nil?})
  #   state.matches?(nil)         # => false
  #   state.matches?(Time.now)    # => true
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/state.rb#196
  def matches?(other_value); end

  # The unique identifier for the state used in event and callback definitions
  #
  # source://state_machines//lib/state_machines/state.rb#19
  def name; end

  # The fully-qualified identifier for the state, scoped by the machine's
  # namespace
  #
  # source://state_machines//lib/state_machines/state.rb#23
  def qualified_name; end

  # The value that represents this state.  This will optionally evaluate the
  # original block if it's a lambda block.  Otherwise, the static value is
  # returned.
  #
  # For example,
  #
  #   State.new(machine, :parked, :value => 1).value                        # => 1
  #   State.new(machine, :parked, :value => lambda {Time.now}).value        # => Tue Jan 01 00:00:00 UTC 2008
  #   State.new(machine, :parked, :value => lambda {Time.now}).value(false) # => <Proc:0xb6ea7ca0@...>
  #
  # source://state_machines//lib/state_machines/state.rb#167
  def value(eval = T.unsafe(nil)); end

  # The value that is written to a machine's attribute when an object
  # transitions into this state
  #
  # source://state_machines//lib/state_machines/state.rb#30
  def value=(_arg0); end

  private

  # Adds a predicate method to the owner class so long as a name has
  # actually been configured for the state
  #
  # source://state_machines//lib/state_machines/state.rb#289
  def add_predicate; end

  # Should the value be cached after it's evaluated for the first time?
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/state.rb#283
  def cache_value?; end

  # Generates the name of the method containing the actual implementation
  #
  # source://state_machines//lib/state_machines/state.rb#304
  def context_name_for(method); end

  # Creates a copy of this state, excluding the context to prevent conflicts
  # across different machines.
  #
  # source://state_machines//lib/state_machines/state.rb#108
  def initialize_copy(orig); end

  # source://state_machines//lib/state_machines/state.rb#308
  def warn_about_method_conflict(method, defined_in); end
end

# Represents a collection of states in a state machine
#
# source://state_machines//lib/state_machines/state_collection.rb#5
class StateMachines::StateCollection < ::StateMachines::NodeCollection
  # @return [StateCollection] a new instance of StateCollection
  #
  # source://state_machines//lib/state_machines/state_collection.rb#6
  def initialize(machine); end

  # Gets the order in which states should be displayed based on where they
  # were first referenced.  This will order states in the following priority:
  #
  # 1. Initial state
  # 2. Event transitions (:from, :except_from, :to, :except_to options)
  # 3. States with behaviors
  # 4. States referenced via +state+ or +other_states+
  # 5. States referenced in callbacks
  #
  # This order will determine how the GraphViz visualizations are rendered.
  #
  # source://state_machines//lib/state_machines/state_collection.rb#93
  def by_priority; end

  # Determines the current state of the given object as configured by this
  # state machine.  This will attempt to find a known state that matches
  # the value of the attribute on the object.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       other_states :idling
  #     end
  #   end
  #
  #   states = Vehicle.state_machine.states
  #
  #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
  #   states.match(vehicle)         # => #<StateMachines::State name=:parked value="parked" initial=true>
  #
  #   vehicle.state = 'idling'
  #   states.match(vehicle)         # => #<StateMachines::State name=:idling value="idling" initial=true>
  #
  #   vehicle.state = 'invalid'
  #   states.match(vehicle)         # => nil
  #
  # source://state_machines//lib/state_machines/state_collection.rb#55
  def match(object); end

  # Determines the current state of the given object as configured by this
  # state machine.  If no state is found, then an ArgumentError will be
  # raised.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       other_states :idling
  #     end
  #   end
  #
  #   states = Vehicle.state_machine.states
  #
  #   vehicle = Vehicle.new         # => #<Vehicle:0xb7c464b0 @state="parked">
  #   states.match!(vehicle)        # => #<StateMachines::State name=:parked value="parked" initial=true>
  #
  #   vehicle.state = 'invalid'
  #   states.match!(vehicle)        # => ArgumentError: "invalid" is not a known state value
  #
  # source://state_machines//lib/state_machines/state_collection.rb#79
  def match!(object); end

  # Determines whether the given object is in a specific state.  If the
  # object's current value doesn't match the state, then this will return
  # false, otherwise true.  If the given state is unknown, then an IndexError
  # will be raised.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       other_states :idling
  #     end
  #   end
  #
  #   states = Vehicle.state_machine.states
  #   vehicle = Vehicle.new               # => #<Vehicle:0xb7c464b0 @state="parked">
  #
  #   states.matches?(vehicle, :parked)   # => true
  #   states.matches?(vehicle, :idling)   # => false
  #   states.matches?(vehicle, :invalid)  # => IndexError: :invalid is an invalid key for :name index
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/state_collection.rb#29
  def matches?(object, name); end

  private

  # Gets the value for the given attribute on the node
  #
  # source://state_machines//lib/state_machines/state_collection.rb#109
  def value(node, attribute); end
end

# Represents a module which will get evaluated within the context of a state.
#
# Class-level methods are proxied to the owner class, injecting a custom
# <tt>:if</tt> condition along with method.  This assumes that the method has
# support for a set of configuration options, including <tt>:if</tt>.  This
# condition will check that the object's state matches this context's state.
#
# Instance-level methods are used to define state-driven behavior on the
# state's owner class.
#
# == Examples
#
#   class Vehicle
#     class << self
#       attr_accessor :validations
#
#       def validate(options, &block)
#         validations << options
#       end
#     end
#
#     self.validations = []
#     attr_accessor :state, :simulate
#
#     def moving?
#       self.class.validations.all? {|validation| validation[:if].call(self)}
#     end
#   end
#
# In the above class, a simple set of validation behaviors have been defined.
# Each validation consists of a configuration like so:
#
#   Vehicle.validate :unless => :simulate
#   Vehicle.validate :if => lambda {|vehicle| ...}
#
# In order to scope validations to a particular state context, the class-level
# +validate+ method can be invoked like so:
#
#   machine = StateMachines::Machine.new(Vehicle)
#   context = StateMachines::StateContext.new(machine.state(:first_gear))
#   context.validate(:unless => :simulate)
#
#   vehicle = Vehicle.new     # => #<Vehicle:0xb7ce491c @simulate=nil, @state=nil>
#   vehicle.moving?           # => false
#
#   vehicle.state = 'first_gear'
#   vehicle.moving?           # => true
#
#   vehicle.simulate = true
#   vehicle.moving?           # => false
#
# source://state_machines//lib/state_machines/state_context.rb#56
class StateMachines::StateContext < ::Module
  include ::StateMachines::EvalHelpers

  # Creates a new context for the given state
  #
  # @return [StateContext] a new instance of StateContext
  #
  # source://state_machines//lib/state_machines/state_context.rb#66
  def initialize(state); end

  # The state machine for which this context's state is defined
  #
  # source://state_machines//lib/state_machines/state_context.rb#60
  def machine; end

  # Hooks in condition-merging to methods that don't exist in this module
  #
  # source://state_machines//lib/state_machines/state_context.rb#100
  def method_missing(*args, &_arg1); end

  # The state that must be present in an object for this context to be active
  #
  # source://state_machines//lib/state_machines/state_context.rb#63
  def state; end

  # Creates a new transition that determines what to change the current state
  # to when an event fires from this state.
  #
  # Since this transition is being defined within a state context, you do
  # *not* need to specify the <tt>:from</tt> option for the transition.  For
  # example:
  #
  #   state_machine do
  #     state :parked do
  #       transition :to => :idling, :on => [:ignite, :shift_up]                          # Transitions to :idling
  #       transition :from => [:idling, :parked], :on => :park, :unless => :seatbelt_on?  # Transitions to :parked if seatbelt is off
  #     end
  #   end
  #
  # See StateMachines::Machine#transition for a description of the possible
  # configurations for defining transitions.
  #
  # @raise [ArgumentError]
  #
  # source://state_machines//lib/state_machines/state_context.rb#91
  def transition(options); end
end

# Cross-platform syntax validation for eval strings
# Supports CRuby, JRuby, TruffleRuby via pluggable backends
#
# source://state_machines//lib/state_machines/syntax_validator.rb#8
module StateMachines::SyntaxValidator
  private

  # Lazily pick the best backend for this platform
  # Prefer RubyVM for performance on CRuby, fallback to Ripper for compatibility
  #
  # source://state_machines//lib/state_machines/syntax_validator.rb#19
  def backend; end

  # Public API: raises SyntaxError if code is invalid
  #
  # source://state_machines//lib/state_machines/syntax_validator.rb#10
  def validate!(code, filename = T.unsafe(nil)); end

  class << self
    # Lazily pick the best backend for this platform
    # Prefer RubyVM for performance on CRuby, fallback to Ripper for compatibility
    #
    # source://state_machines//lib/state_machines/syntax_validator.rb#26
    def backend; end

    # Public API: raises SyntaxError if code is invalid
    #
    # source://state_machines//lib/state_machines/syntax_validator.rb#13
    def validate!(code, filename = T.unsafe(nil)); end
  end
end

# Universal Ruby backend via Ripper
#
# source://state_machines//lib/state_machines/syntax_validator.rb#44
module StateMachines::SyntaxValidator::RipperBackend
  private

  # source://state_machines//lib/state_machines/syntax_validator.rb#45
  def validate!(code, filename); end

  class << self
    # source://state_machines//lib/state_machines/syntax_validator.rb#54
    def validate!(code, filename); end
  end
end

# MRI backend using RubyVM::InstructionSequence
#
# source://state_machines//lib/state_machines/syntax_validator.rb#29
module StateMachines::SyntaxValidator::RubyVmBackend
  private

  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/syntax_validator.rb#30
  def available?; end

  # source://state_machines//lib/state_machines/syntax_validator.rb#35
  def validate!(code, filename); end

  class << self
    # @return [Boolean]
    #
    # source://state_machines//lib/state_machines/syntax_validator.rb#33
    def available?; end

    # source://state_machines//lib/state_machines/syntax_validator.rb#40
    def validate!(code, filename); end
  end
end

# A transition represents a state change for a specific attribute.
#
# Transitions consist of:
# * An event
# * A starting state
# * An ending state
#
# source://state_machines//lib/state_machines/transition.rb#15
class StateMachines::Transition
  # Creates a new, specific transition
  #
  # @return [Transition] a new instance of Transition
  #
  # source://state_machines//lib/state_machines/transition.rb#39
  def initialize(object, machine, event, from_name, to_name, read_state = T.unsafe(nil)); end

  # Determines equality of transitions by testing whether the object, states,
  # and event involved in the transition are equal
  #
  # source://state_machines//lib/state_machines/transition.rb#298
  def ==(other); end

  # The action that will be run when this transition is performed
  #
  # source://state_machines//lib/state_machines/transition.rb#64
  def action; end

  # The arguments passed in to the event that triggered the transition
  # (does not include the +run_action+ boolean argument if specified)
  #
  # source://state_machines//lib/state_machines/transition.rb#30
  def args; end

  # The arguments passed in to the event that triggered the transition
  # (does not include the +run_action+ boolean argument if specified)
  #
  # source://state_machines//lib/state_machines/transition.rb#30
  def args=(_arg0); end

  # The attribute which this transition's machine is defined for
  #
  # source://state_machines//lib/state_machines/transition.rb#59
  def attribute; end

  # A hash of all the core attributes defined for this transition with their
  # names as keys and values of the attributes as values.
  #
  # == Example
  #
  #   machine = StateMachine.new(Vehicle)
  #   transition = StateMachines::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
  #   transition.attributes   # => {:object => #<Vehicle:0xb7d60ea4>, :attribute => :state, :event => :ignite, :from => 'parked', :to => 'idling'}
  #
  # source://state_machines//lib/state_machines/transition.rb#140
  def attributes; end

  # The event that triggered the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#69
  def event; end

  # The original state value *before* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#23
  def from; end

  # The state name *before* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#84
  def from_name; end

  # The human-readable name of the event that triggered the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#79
  def human_event; end

  # The human-readable state name *before* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#94
  def human_from_name; end

  # The new human-readable state name *after* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#109
  def human_to_name; end

  # Generates a nicely formatted description of this transitions's contents.
  #
  # For example,
  #
  #   transition = StateMachines::Transition.new(object, machine, :ignite, :parked, :idling)
  #   transition   # => #<StateMachines::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling>
  #
  # source://state_machines//lib/state_machines/transition.rb#313
  def inspect; end

  # Does this transition represent a loopback (i.e. the from and to state
  # are the same)
  #
  # == Example
  #
  #   machine = StateMachine.new(Vehicle)
  #   StateMachines::Transition.new(Vehicle.new, machine, :park, :parked, :parked).loopback?   # => true
  #   StateMachines::Transition.new(Vehicle.new, machine, :park, :idling, :parked).loopback?   # => false
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition.rb#121
  def loopback?; end

  # The state machine for which this transition is defined
  #
  # source://state_machines//lib/state_machines/transition.rb#20
  def machine; end

  # The object being transitioned
  #
  # source://state_machines//lib/state_machines/transition.rb#17
  def object; end

  # Checks whether this transition is currently paused.
  # Returns true if there is a paused fiber, false otherwise.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition.rb#319
  def paused?; end

  # Runs the actual transition and any before/after callbacks associated
  # with the transition.  The action associated with the transition/machine
  # can be skipped by passing in +false+.
  #
  # == Examples
  #
  #   class Vehicle
  #     state_machine :action => :save do
  #       ...
  #     end
  #   end
  #
  #   vehicle = Vehicle.new
  #   transition = StateMachines::Transition.new(vehicle, machine, :ignite, :parked, :idling)
  #   transition.perform                              # => Runs the +save+ action after setting the state attribute
  #   transition.perform(false)                       # => Only sets the state attribute
  #   transition.perform(run_action: false)           # => Only sets the state attribute
  #   transition.perform(Time.now)                    # => Passes in additional arguments and runs the +save+ action
  #   transition.perform(Time.now, false)             # => Passes in additional arguments and only sets the state attribute
  #   transition.perform(Time.now, run_action: false) # => Passes in additional arguments and only sets the state attribute
  #
  # source://state_machines//lib/state_machines/transition.rb#164
  def perform(*args); end

  # Transitions the current value of the state to that specified by the
  # transition.  Once the state is persisted, it cannot be persisted again
  # until this transition is reset.
  #
  # == Example
  #
  #   class Vehicle
  #     state_machine do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new
  #   transition = StateMachines::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling)
  #   transition.persist
  #
  #   vehicle.state   # => 'idling'
  #
  # source://state_machines//lib/state_machines/transition.rb#250
  def persist; end

  # The fully-qualified name of the event that triggered the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#74
  def qualified_event; end

  # The fully-qualified state name *before* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#89
  def qualified_from_name; end

  # The new fully-qualified state name *after* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#104
  def qualified_to_name; end

  # Resets any tracking of which callbacks have already been run and whether
  # the state has already been persisted
  #
  # source://state_machines//lib/state_machines/transition.rb#288
  def reset; end

  # The result of invoking the action associated with the machine
  #
  # source://state_machines//lib/state_machines/transition.rb#33
  def result; end

  # Checks whether this transition has a paused fiber that can be resumed.
  # Returns true if there is a paused fiber, false otherwise.
  #
  # Note: The actual resuming happens automatically when run_callbacks is called
  # again on a transition with a paused fiber.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition.rb#328
  def resumable?; end

  # Manually resumes the execution of a previously paused callback.
  # Returns true if the transition was successfully resumed and completed,
  # false if there was no paused fiber, and raises an exception if the
  # transition was halted.
  #
  # source://state_machines//lib/state_machines/transition.rb#336
  def resume!(&block); end

  # Rolls back changes made to the object's state via this transition.  This
  # will revert the state back to the +from+ value.
  #
  # == Example
  #
  #   class Vehicle
  #     state_machine :initial => :parked do
  #       event :ignite do
  #         transition :parked => :idling
  #       end
  #     end
  #   end
  #
  #   vehicle = Vehicle.new     # => #<Vehicle:0xb7b7f568 @state="parked">
  #   transition = StateMachines::Transition.new(vehicle, Vehicle.state_machine, :ignite, :parked, :idling)
  #
  #   # Persist the new state
  #   vehicle.state             # => "parked"
  #   transition.persist
  #   vehicle.state             # => "idling"
  #
  #   # Roll back to the original state
  #   transition.rollback
  #   vehicle.state             # => "parked"
  #
  # source://state_machines//lib/state_machines/transition.rb#281
  def rollback; end

  # Runs the before / after callbacks for this transition.  If a block is
  # provided, then it will be executed between the before and after callbacks.
  #
  # Configuration options:
  # * +before+ - Whether to run before callbacks.
  # * +after+ - Whether to run after callbacks.  If false, then any around
  #   callbacks will be paused until called again with +after+ enabled.
  #   Default is true.
  #
  # This will return true if all before callbacks gets executed.  After
  # callbacks will not have an effect on the result.
  #
  # source://state_machines//lib/state_machines/transition.rb#198
  def run_callbacks(options = T.unsafe(nil), &block); end

  # The new state value *after* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#26
  def to; end

  # The new state name *after* the transition
  #
  # source://state_machines//lib/state_machines/transition.rb#99
  def to_name; end

  # Whether the transition is only existing temporarily for the object
  #
  # source://state_machines//lib/state_machines/transition.rb#36
  def transient=(_arg0); end

  # Is this transition existing for a short period only?  If this is set, it
  # indicates that the transition (or the event backing it) should not be
  # written to the object if it fails.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition.rb#128
  def transient?; end

  # Runs a block within a transaction for the object being transitioned.
  # By default, transactions are a no-op unless otherwise defined by the
  # machine's integration.
  #
  # source://state_machines//lib/state_machines/transition.rb#183
  def within_transaction(&_arg0); end

  private

  # Runs the machine's +after+ callbacks for this transition.  Only
  # callbacks that are configured to match the event, from state, and to
  # state will be invoked.
  #
  # Once the callbacks are run, they cannot be run again until this transition
  # is reset.
  #
  # == Halting
  #
  # If any callback throws a <tt>:halt</tt> exception, it will be caught
  # and the callback chain will be automatically stopped.  However, this
  # exception will not bubble up to the caller since +after+ callbacks
  # should never halt the execution of a +perform+.
  #
  # source://state_machines//lib/state_machines/transition.rb#569
  def after; end

  # Runs the machine's +before+ callbacks for this transition.  Only
  # callbacks that are configured to match the event, from state, and to
  # state will be invoked.
  #
  # Once the callbacks are run, they cannot be run again until this transition
  # is reset.
  #
  # source://state_machines//lib/state_machines/transition.rb#508
  def before(complete = T.unsafe(nil), index = T.unsafe(nil), &block); end

  # Gets a hash of the context defining this unique transition (including
  # event, from state, and to state).
  #
  # == Example
  #
  #   machine = StateMachine.new(Vehicle)
  #   transition = StateMachines::Transition.new(Vehicle.new, machine, :ignite, :parked, :idling)
  #   transition.context    # => {:on => :ignite, :from => :parked, :to => :idling}
  #
  # source://state_machines//lib/state_machines/transition.rb#592
  def context; end

  # Runs a block that may get paused.  If the block doesn't pause, then
  # execution will continue as normal.  If the block gets paused, then it
  # will take care of switching the execution context when it's resumed.
  #
  # This will return true if the given block halts for a reason other than
  # getting paused.
  #
  # Options:
  # * :fiber - Whether to use fiber-based execution (default: true)
  #
  # source://state_machines//lib/state_machines/transition.rb#360
  def pausable(options = T.unsafe(nil)); end

  # Pauses the current callback execution.  This should only occur within
  # around callbacks when the remainder of the callback will be executed at
  # a later point in time.
  #
  # source://state_machines//lib/state_machines/transition.rb#482
  def pause; end
end

# Represents a collection of transitions in a state machine
#
# source://state_machines//lib/state_machines/transition_collection.rb#7
class StateMachines::TransitionCollection < ::Array
  # Creates a new collection of transitions that can be run in parallel.  Each
  # transition *must* be for a different attribute.
  #
  # Configuration options:
  # * <tt>:actions</tt> - Whether to run the action configured for each transition
  # * <tt>:after</tt> - Whether to run after callbacks
  # * <tt>:transaction</tt> - Whether to wrap transitions within a transaction
  #
  # @raise [ArgumentError]
  # @return [TransitionCollection] a new instance of TransitionCollection
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#27
  def initialize(transitions = T.unsafe(nil), options = T.unsafe(nil)); end

  # Options passed to the collection
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#18
  def options; end

  # Runs each of the collection's transitions in parallel.
  #
  # All transitions will run through the following steps:
  # 1. Before callbacks
  # 2. Persist state
  # 3. Invoke action
  # 4. After callbacks (if configured)
  # 5. Rollback (if action is unsuccessful)
  #
  # If a block is passed to this method, that block will be called instead
  # of invoking each transition's action.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#62
  def perform(&block); end

  # Whether to skip running the action for each transition's machine
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#9
  def skip_actions; end

  # Whether to skip running the after callbacks
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#12
  def skip_after; end

  # Whether transitions should wrapped around a transaction block
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#15
  def use_transactions; end

  protected

  # source://state_machines//lib/state_machines/transition_collection.rb#90
  def results; end

  private

  # Gets the list of actions to run.  If configured to skip actions, then
  # this will return an empty collection.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#116
  def actions; end

  # Wraps the given block with a rescue handler so that any exceptions that
  # occur will automatically result in the transition rolling back any changes
  # that were made to the object involved.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#192
  def catch_exceptions; end

  # Gets the object being transitioned
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#110
  def object; end

  # Transitions the current value of the object's states to those specified by
  # each transition
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#163
  def persist; end

  # Resets any information tracked from previous attempts to perform the
  # collection
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#129
  def reset; end

  # Rolls back changes made to the object's states via each transition
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#185
  def rollback; end

  # Runs the actions for each transition.  If a block is given method, then it
  # will be called instead of invoking each transition's action.
  #
  # The results of the actions will be used to determine #success?.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#171
  def run_actions; end

  # Runs each transition's callbacks recursively.  Once all before callbacks
  # have been executed, the transitions will then be persisted and the
  # configured actions will be run.
  #
  # If any transition fails to run its callbacks, :halt will be thrown.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#139
  def run_callbacks(index = T.unsafe(nil), &block); end

  # Did each transition perform successfully?  This will only be true if the
  # following requirements are met:
  # * No +before+ callbacks halt
  # * All actions run successfully (always true if skipping actions)
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#105
  def success?; end

  # Determines whether an event attribute be used to trigger the transitions
  # in this collection or whether the transitions be run directly *outside*
  # of the action.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#123
  def use_event_attributes?; end

  # Is this a valid set of transitions?  If the collection was creating with
  # any +false+ values for transitions, then the the collection will be
  # marked as invalid.
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#97
  def valid?; end

  # Runs a block within a transaction for the object being transitioned.  If
  # transactions are disabled, then this is a no-op.
  #
  # source://state_machines//lib/state_machines/transition_collection.rb#201
  def within_transaction; end
end

# source://state_machines//lib/state_machines/version.rb#4
StateMachines::VERSION = T.let(T.unsafe(nil), String)

# Matches a specific set of values
#
# source://state_machines//lib/state_machines/matcher.rb#57
class StateMachines::WhitelistMatcher < ::StateMachines::Matcher
  # A human-readable description of this matcher
  #
  # source://state_machines//lib/state_machines/matcher.rb#71
  def description; end

  # Checks whether the given value exists within the whitelist configured
  # for this matcher.
  #
  # == Examples
  #
  #   matcher = StateMachines::WhitelistMatcher.new([:parked, :idling])
  #   matcher.matches?(:parked)       # => true
  #   matcher.matches?(:first_gear)   # => false
  #
  # @return [Boolean]
  #
  # source://state_machines//lib/state_machines/matcher.rb#66
  def matches?(value, _context = T.unsafe(nil)); end
end
