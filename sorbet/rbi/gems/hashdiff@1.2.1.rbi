# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hashdiff` gem.
# Please instead update this file by running `bin/tapioca gem hashdiff`.


# pkg:gem/hashdiff#lib/hashdiff/util.rb:3
module Hashdiff
  class << self
    # Best diff two objects, which tries to generate the smallest change set using different similarity values.
    #
    # Hashdiff.best_diff is useful in case of comparing two objects which include similar hashes in arrays.
    #
    # @param [Array, Hash] obj1
    # @param [Array, Hash] obj2
    # @param [Hash] options the options to use when comparing
    #   * :strict (Boolean) [true] whether numeric values will be compared on type as well as value.  Set to false to allow comparing Integer, Float, BigDecimal to each other
    #   * :ignore_keys (Symbol, String or Array) [[]] a list of keys to ignore. No comparison is made for the specified key(s) in either hash
    #   * :indifferent (Boolean) [false] whether to treat hash keys indifferently.  Set to true to ignore differences between symbol keys (ie. {a: 1} ~= {'a' => 1})
    #   * :delimiter (String) ['.'] the delimiter used when returning nested key references
    #   * :numeric_tolerance (Numeric) [0] should be a positive numeric value.  Value by which numeric differences must be greater than.  By default, numeric values are compared exactly; with the :tolerance option, the difference between numeric values must be greater than the given value.
    #   * :strip (Boolean) [false] whether or not to call #strip on strings before comparing
    #   * :array_path (Boolean) [false] whether to return the path references for nested values in an array, can be used for patch compatibility with non string keys.
    #   * :use_lcs (Boolean) [true] whether or not to use an implementation of the Longest common subsequence algorithm for comparing arrays, produces better diffs but is slower.
    #   * :preserve_key_order (Boolean) [false] If false, operations are grouped by type (-, ~, then +) then by hash key alphabetically. If true, preserves the original key order from the first hash and appends new keys from the second hash in order.
    #
    # @yield [path, value1, value2] Optional block is used to compare each value, instead of default #==. If the block returns value other than true of false, then other specified comparison options will be used to do the comparison.
    #
    # @return [Array] an array of changes.
    #   e.g. [[ '+', 'a.b', '45' ], [ '-', 'a.c', '5' ], [ '~', 'a.x', '45', '63']]
    #
    # @example
    #   a = {'x' => [{'a' => 1, 'c' => 3, 'e' => 5}, {'y' => 3}]}
    #   b = {'x' => [{'a' => 1, 'b' => 2, 'e' => 5}] }
    #   diff = Hashdiff.best_diff(a, b)
    #   diff.should == [['-', 'x[0].c', 3], ['+', 'x[0].b', 2], ['-', 'x[1].y', 3], ['-', 'x[1]', {}]]
    #
    # @since 0.0.1
    #
    # pkg:gem/hashdiff#lib/hashdiff/diff.rb:33
    def best_diff(obj1, obj2, options = T.unsafe(nil), &block); end

    # @private
    #
    # check if objects are comparable
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:108
    def comparable?(obj1, obj2, strict = T.unsafe(nil)); end

    # @private
    #
    # check for equality or "closeness" within given tolerance
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:86
    def compare_values(obj1, obj2, options = T.unsafe(nil)); end

    # @private
    #
    # count node differences
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:25
    def count_diff(diffs); end

    # @private
    #
    # count total nodes for an object
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:36
    def count_nodes(obj); end

    # @private
    #
    # try custom comparison
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:119
    def custom_compare(method, key, obj1, obj2); end

    # @private
    #
    # decode property path into an array
    # @param [String] path Property-string
    # @param [String] delimiter Property-string delimiter
    #
    # e.g. "a.b[3].c" => ['a', 'b', 3, 'c']
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:58
    def decode_property_path(path, delimiter = T.unsafe(nil)); end

    # Compute the diff of two hashes or arrays
    #
    # @param [Array, Hash] obj1
    # @param [Array, Hash] obj2
    # @param [Hash] options the options to use when comparing
    #   * :strict (Boolean) [true] whether numeric values will be compared on type as well as value.  Set to false to allow comparing Integer, Float, BigDecimal to each other
    #   * :ignore_keys (Symbol, String or Array) [[]] a list of keys to ignore. No comparison is made for the specified key(s) in either hash
    #   * :indifferent (Boolean) [false] whether to treat hash keys indifferently.  Set to true to ignore differences between symbol keys (ie. {a: 1} ~= {'a' => 1})
    #   * :similarity (Numeric) [0.8] should be between (0, 1]. Meaningful if there are similar hashes in arrays. See {best_diff}.
    #   * :delimiter (String) ['.'] the delimiter used when returning nested key references
    #   * :numeric_tolerance (Numeric) [0] should be a positive numeric value.  Value by which numeric differences must be greater than.  By default, numeric values are compared exactly; with the :tolerance option, the difference between numeric values must be greater than the given value.
    #   * :strip (Boolean) [false] whether or not to call #strip on strings before comparing
    #   * :array_path (Boolean) [false] whether to return the path references for nested values in an array, can be used for patch compatibility with non string keys.
    #   * :use_lcs (Boolean) [true] whether or not to use an implementation of the Longest common subsequence algorithm for comparing arrays, produces better diffs but is slower.
    #   * :preserve_key_order (Boolean) [false] If false, operations are grouped by type (-, ~, then +) then by hash key alphabetically. If true, preserves the original key order from the first hash and appends new keys from the second hash in order.
    #
    #
    # @yield [path, value1, value2] Optional block is used to compare each value, instead of default #==. If the block returns value other than true of false, then other specified comparison options will be used to do the comparison.
    #
    # @return [Array] an array of changes.
    #   e.g. [[ '+', 'a.b', '45' ], [ '-', 'a.c', '5' ], [ '~', 'a.x', '45', '63']]
    #
    # @example
    #   a = {"a" => 1, "b" => {"b1" => 1, "b2" =>2}}
    #   b = {"a" => 1, "b" => {}}
    #
    #   diff = Hashdiff.diff(a, b)
    #   diff.should == [['-', 'b.b1', 1], ['-', 'b.b2', 2]]
    #
    # @since 0.0.1
    #
    # pkg:gem/hashdiff#lib/hashdiff/diff.rb:82
    def diff(obj1, obj2, options = T.unsafe(nil), &block); end

    # @private
    #
    # diff array using LCS algorithm
    #
    # pkg:gem/hashdiff#lib/hashdiff/diff.rb:127
    def diff_array_lcs(arraya, arrayb, options = T.unsafe(nil)); end

    # @private
    #
    # caculate array difference using LCS algorithm
    # http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
    #
    # pkg:gem/hashdiff#lib/hashdiff/lcs.rb:8
    def lcs(arraya, arrayb, options = T.unsafe(nil)); end

    # @private
    #
    # get the node of hash by given path parts
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:75
    def node(hash, parts); end

    # Apply patch to object
    #
    # @param [Hash, Array] obj the object to be patched, can be an Array or a Hash
    # @param [Array] changes e.g. [[ '+', 'a.b', '45' ], [ '-', 'a.c', '5' ], [ '~', 'a.x', '45', '63']]
    # @param [Hash] options supports following keys:
    #   * :delimiter (String) ['.'] delimiter string for representing nested keys in changes array
    #
    # @return the object after patch
    #
    # @since 0.0.1
    #
    # pkg:gem/hashdiff#lib/hashdiff/patch.rb:17
    def patch!(obj, changes, options = T.unsafe(nil)); end

    # pkg:gem/hashdiff#lib/hashdiff/util.rb:137
    def prefix_append_array_index(prefix, array_index, opts); end

    # pkg:gem/hashdiff#lib/hashdiff/util.rb:129
    def prefix_append_key(prefix, key, opts); end

    # @private
    #
    # judge whether two objects are similar
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:7
    def similar?(obja, objb, options = T.unsafe(nil)); end

    # Unpatch an object
    #
    # @param [Hash, Array] obj the object to be unpatched, can be an Array or a Hash
    # @param [Array] changes e.g. [[ '+', 'a.b', '45' ], [ '-', 'a.c', '5' ], [ '~', 'a.x', '45', '63']]
    # @param [Hash] options supports following keys:
    #   * :delimiter (String) ['.'] delimiter string for representing nested keys in changes array
    #
    # @return the object after unpatch
    #
    # @since 0.0.1
    #
    # pkg:gem/hashdiff#lib/hashdiff/patch.rb:58
    def unpatch!(obj, changes, options = T.unsafe(nil)); end

    private

    # @private
    #
    # checks if both objects are Arrays or Hashes
    #
    # pkg:gem/hashdiff#lib/hashdiff/util.rb:151
    def any_hash_or_array?(obja, objb); end
  end
end

# @private
# Used to compare hashes
#
# pkg:gem/hashdiff#lib/hashdiff/compare_hashes.rb:6
class Hashdiff::CompareHashes
  class << self
    # pkg:gem/hashdiff#lib/hashdiff/compare_hashes.rb:8
    def call(obj1, obj2, opts = T.unsafe(nil)); end
  end
end

# @private
# Used to compare arrays using the lcs algorithm
#
# pkg:gem/hashdiff#lib/hashdiff/lcs_compare_arrays.rb:6
class Hashdiff::LcsCompareArrays
  class << self
    # pkg:gem/hashdiff#lib/hashdiff/lcs_compare_arrays.rb:8
    def call(obj1, obj2, opts = T.unsafe(nil)); end
  end
end

# @private
#
# Used to compare arrays in a linear complexity, which produces longer diffs
# than using the lcs algorithm but is considerably faster
#
# pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:8
class Hashdiff::LinearCompareArray
  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:45
  def initialize(old_array, new_array, options); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:14
  def call; end

  private

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def additions; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:139
  def append_addition(item, index); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:123
  def append_addititions_before_match(match_index); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:144
  def append_deletion(item, index); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:131
  def append_deletions_before_match(match_index); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:149
  def append_differences(difference); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:153
  def changes; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:67
  def compare_at_index; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def deletions; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def differences; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def expected_additions; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def expected_additions=(_arg0); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:59
  def extra_items_in_new_array?; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:55
  def extra_items_in_old_array?; end

  # look ahead in the new array to see if the current item appears later
  # thereby having new items added
  #
  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:89
  def index_of_match_after_additions; end

  # look ahead in the old array to see if the current item appears later
  # thereby having items removed
  #
  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:107
  def index_of_match_after_deletions; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:82
  def item_difference(old_item, new_item, item_index); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:63
  def iterated_through_both_arrays?; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def new_array; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def new_index; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def new_index=(_arg0); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def old_array; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def old_index; end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:43
  def old_index=(_arg0); end

  # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:42
  def options; end

  class << self
    # pkg:gem/hashdiff#lib/hashdiff/linear_compare_array.rb:9
    def call(old_array, new_array, options = T.unsafe(nil)); end
  end
end

# pkg:gem/hashdiff#lib/hashdiff/version.rb:4
Hashdiff::VERSION = T.let(T.unsafe(nil), String)
