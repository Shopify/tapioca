# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis` gem.
# Please instead update this file by running `bin/tapioca gem redis`.


# pkg:gem/redis#lib/redis/errors.rb:3
class Redis
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  # Create a new client instance
  #
  # @param [Hash] options
  # @option options [String] :url (value of the environment variable REDIS_URL) a Redis URL, for a TCP connection:
  #   `redis://:[password]@[hostname]:[port]/[db]` (password, port and database are optional), for a unix socket
  #    connection: `unix://[path to Redis socket]`. This overrides all other options.
  # @option options [String] :host ("127.0.0.1") server hostname
  # @option options [Integer] :port (6379) server port
  # @option options [String] :path path to server socket (overrides host and port)
  # @option options [Float] :timeout (1.0) timeout in seconds
  # @option options [Float] :connect_timeout (same as timeout) timeout for initial connect in seconds
  # @option options [String] :username Username to authenticate against server
  # @option options [String] :password Password to authenticate against server
  # @option options [Integer] :db (0) Database to select after connect and on reconnects
  # @option options [Symbol] :driver Driver to use, currently supported: `:ruby`, `:hiredis`
  # @option options [String] :id ID for the client connection, assigns name to current connection by sending
  #   `CLIENT SETNAME`
  # @option options [Integer, Array<Integer, Float>] :reconnect_attempts Number of attempts trying to connect,
  #   or a list of sleep duration between attempts.
  # @option options [Boolean] :inherit_socket (false) Whether to use socket in forked process or not
  # @option options [String] :name The name of the server group to connect to.
  # @option options [Array] :sentinels List of sentinels to contact
  #
  # @return [Redis] a new client instance
  #
  # pkg:gem/redis#lib/redis.rb:63
  def initialize(options = T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis.rb:98
  def _client; end

  # Disconnect the client as quickly and silently as possible.
  #
  # pkg:gem/redis#lib/redis.rb:88
  def close; end

  # Test whether or not the client is connected
  #
  # pkg:gem/redis#lib/redis.rb:83
  def connected?; end

  # pkg:gem/redis#lib/redis.rb:122
  def connection; end

  # pkg:gem/redis#lib/redis.rb:92
  def disconnect!; end

  # pkg:gem/redis#lib/redis.rb:118
  def dup; end

  # pkg:gem/redis#lib/redis.rb:110
  def id; end

  # pkg:gem/redis#lib/redis.rb:114
  def inspect; end

  # pkg:gem/redis#lib/redis.rb:102
  def pipelined(exception: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis.rb:94
  def with; end

  # Run code without the client reconnecting
  #
  # pkg:gem/redis#lib/redis.rb:78
  def without_reconnect(&block); end

  private

  # pkg:gem/redis#lib/redis.rb:164
  def _subscription(method, timeout, channels, block); end

  # pkg:gem/redis#lib/redis.rb:134
  def initialize_client(options); end

  # pkg:gem/redis#lib/redis.rb:158
  def send_blocking_command(command, timeout, &block); end

  # pkg:gem/redis#lib/redis.rb:150
  def send_command(command, &block); end

  # pkg:gem/redis#lib/redis.rb:146
  def synchronize; end

  class << self
    # pkg:gem/redis#lib/redis.rb:14
    def deprecate!(message); end

    # pkg:gem/redis#lib/redis.rb:12
    def raise_deprecations; end

    # pkg:gem/redis#lib/redis.rb:12
    def raise_deprecations=(_arg0); end

    # pkg:gem/redis#lib/redis.rb:12
    def silence_deprecations; end

    # pkg:gem/redis#lib/redis.rb:12
    def silence_deprecations=(_arg0); end
  end
end

# pkg:gem/redis#lib/redis.rb:8
Redis::BASE_PATH = T.let(T.unsafe(nil), String)

# Base error for connection related errors.
#
# pkg:gem/redis#lib/redis/errors.rb:33
class Redis::BaseConnectionError < ::Redis::BaseError; end

# Base error for all redis-rb errors.
#
# pkg:gem/redis#lib/redis/errors.rb:5
class Redis::BaseError < ::StandardError; end

# Raised when connection to a Redis server cannot be made.
#
# pkg:gem/redis#lib/redis/errors.rb:37
class Redis::CannotConnectError < ::Redis::BaseConnectionError; end

# pkg:gem/redis#lib/redis/client.rb:6
class Redis::Client < ::RedisClient
  # pkg:gem/redis#lib/redis/client.rb:95
  def blocking_call_v(timeout, command, &block); end

  # pkg:gem/redis#lib/redis/client.rb:89
  def call_v(command, &block); end

  # pkg:gem/redis#lib/redis/client.rb:60
  def db; end

  # pkg:gem/redis#lib/redis/client.rb:64
  def host; end

  # pkg:gem/redis#lib/redis/client.rb:48
  def id; end

  # pkg:gem/redis#lib/redis/client.rb:120
  def inherit_socket!; end

  # pkg:gem/redis#lib/redis/client.rb:114
  def multi(watch: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/client.rb:80
  def password; end

  # pkg:gem/redis#lib/redis/client.rb:72
  def path; end

  # pkg:gem/redis#lib/redis/client.rb:108
  def pipelined(exception: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/client.rb:68
  def port; end

  # pkg:gem/redis#lib/redis/client.rb:52
  def server_url; end

  # pkg:gem/redis#lib/redis/client.rb:56
  def timeout; end

  # pkg:gem/redis#lib/redis/client.rb:76
  def username; end

  class << self
    # pkg:gem/redis#lib/redis/client.rb:22
    def config(**kwargs); end

    # pkg:gem/redis#lib/redis/client.rb:26
    def sentinel(**kwargs); end

    # pkg:gem/redis#lib/redis/client.rb:30
    def translate_error!(error, mapping: T.unsafe(nil)); end

    private

    # pkg:gem/redis#lib/redis/client.rb:37
    def translate_error_class(error_class, mapping: T.unsafe(nil)); end
  end
end

# pkg:gem/redis#lib/redis/client.rb:7
Redis::Client::ERROR_MAPPING = T.let(T.unsafe(nil), Hash)

# Raised by the client when command execution returns an error reply.
#
# pkg:gem/redis#lib/redis/errors.rb:20
class Redis::CommandError < ::Redis::BaseError; end

# pkg:gem/redis#lib/redis/commands/bitmaps.rb:4
module Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions

  # Sends a command to Redis and returns its reply.
  #
  # Replies are converted to Ruby objects according to the RESP protocol, so
  # you can expect a Ruby array, integer or nil when Redis sends one. Higher
  # level transformations, such as converting an array of pairs into a Ruby
  # hash, are up to consumers.
  #
  # Redis error replies are raised as Ruby exceptions.
  #
  # pkg:gem/redis#lib/redis/commands.rb:204
  def call(*command, &block); end

  # Interact with the sentinel command (masters, master, slaves, failover)
  #
  # @param [String] subcommand e.g. `masters`, `master`, `slaves`
  # @param [Array<String>] args depends on subcommand
  # @return [Array<String>, Hash<String, String>, String] depends on subcommand
  #
  # pkg:gem/redis#lib/redis/commands.rb:213
  def sentinel(subcommand, *args); end

  private

  # pkg:gem/redis#lib/redis/commands.rb:235
  def method_missing(*command); end
end

# pkg:gem/redis#lib/redis/commands/bitmaps.rb:5
module Redis::Commands::Bitmaps
  # Count the number of set bits in a range of the string value stored at key.
  #
  # @param [String] key
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @param [String, Symbol] scale the scale of the offset range
  #     e.g. 'BYTE' - interpreted as a range of bytes, 'BIT' - interpreted as a range of bits
  # @return [Integer] the number of bits set to 1
  #
  # pkg:gem/redis#lib/redis/commands/bitmaps.rb:33
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil), scale: T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  #
  # @param [String] operation e.g. `and`, `or`, `xor`, `not`
  # @param [String] destkey destination key
  # @param [String, Array<String>] keys one or more source keys to perform `operation`
  # @return [Integer] the length of the string stored in `destkey`
  #
  # pkg:gem/redis#lib/redis/commands/bitmaps.rb:45
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  #
  # @param [String] key
  # @param [Integer] bit whether to look for the first 1 or 0 bit
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @param [String, Symbol] scale the scale of the offset range
  #     e.g. 'BYTE' - interpreted as a range of bytes, 'BIT' - interpreted as a range of bits
  # @return [Integer] the position of the first 1/0 bit.
  #                  -1 if looking for 1 and it is not found or start and stop are given.
  #
  # pkg:gem/redis#lib/redis/commands/bitmaps.rb:62
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil), scale: T.unsafe(nil)); end

  # Returns the bit value at offset in the string value stored at key.
  #
  # @param [String] key
  # @param [Integer] offset bit offset
  # @return [Integer] `0` or `1`
  #
  # pkg:gem/redis#lib/redis/commands/bitmaps.rb:21
  def getbit(key, offset); end

  # Sets or clears the bit at offset in the string value stored at key.
  #
  # @param [String] key
  # @param [Integer] offset bit offset
  # @param [Integer] value bit value `0` or `1`
  # @return [Integer] the original bit value stored at `offset`
  #
  # pkg:gem/redis#lib/redis/commands/bitmaps.rb:12
  def setbit(key, offset, value); end
end

# Commands returning 1 for true and 0 for false may be executed in a pipeline
# where the method call will return nil. Propagate the nil instead of falsely
# returning false.
#
# pkg:gem/redis#lib/redis/commands.rb:42
Redis::Commands::Boolify = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:46
Redis::Commands::BoolifySet = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands/cluster.rb:5
module Redis::Commands::Cluster
  # Sends `ASKING` command to random node and returns its reply.
  #
  # @see https://redis.io/topics/cluster-spec#ask-redirection ASK redirection
  #
  # @return [String] `'OK'`
  #
  # pkg:gem/redis#lib/redis/commands/cluster.rb:23
  def asking; end

  # Sends `CLUSTER *` command to random node and returns its reply.
  #
  # @see https://redis.io/commands#cluster Reference of cluster command
  #
  # @param subcommand [String, Symbol] the subcommand of cluster command
  #   e.g. `:slots`, `:nodes`, `:slaves`, `:info`
  #
  # @return [Object] depends on the subcommand
  #
  # pkg:gem/redis#lib/redis/commands/cluster.rb:14
  def cluster(subcommand, *args); end
end

# pkg:gem/redis#lib/redis/commands/connection.rb:5
module Redis::Commands::Connection
  # Authenticate to the server.
  #
  # @param [Array<String>] args includes both username and password
  #   or only password
  # @return [String] `OK`
  # @see https://redis.io/commands/auth AUTH command
  #
  # pkg:gem/redis#lib/redis/commands/connection.rb:12
  def auth(*args); end

  # Echo the given string.
  #
  # @param [String] value
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/connection.rb:28
  def echo(value); end

  # Ping the server.
  #
  # @param [optional, String] message
  # @return [String] `PONG`
  #
  # pkg:gem/redis#lib/redis/commands/connection.rb:20
  def ping(message = T.unsafe(nil)); end

  # Close the connection.
  #
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/connection.rb:43
  def quit; end

  # Change the selected database for the current connection.
  #
  # @param [Integer] db zero-based index of the DB to use (0 to 15)
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/connection.rb:36
  def select(db); end
end

# pkg:gem/redis#lib/redis/commands.rb:112
Redis::Commands::EMPTY_STREAM_RESPONSE = T.let(T.unsafe(nil), Array)

# pkg:gem/redis#lib/redis/commands.rb:73
Redis::Commands::Floatify = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:86
Redis::Commands::FloatifyPair = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:90
Redis::Commands::FloatifyPairs = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands/geo.rb:5
module Redis::Commands::Geo
  # Adds the specified geospatial items (latitude, longitude, name) to the specified key
  #
  # @param [String] key
  # @param [Array] member arguemnts for member or members: longitude, latitude, name
  # @return [Integer] number of elements added to the sorted set
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:11
  def geoadd(key, *member); end

  # Returns the distance between two members of a geospatial index
  #
  # @param [String ]key
  # @param [Array<String>] members
  # @param ['m', 'km', 'mi', 'ft'] unit
  # @return [String, nil] returns distance in spefied unit if both members present, nil otherwise.
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:70
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # Returns geohash string representing position for specified members of the specified key.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member or array of members
  # @return [Array<String, nil>] returns array containg geohash string if member is present, nil otherwise
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:20
  def geohash(key, member); end

  # Returns longitude and latitude of members of a geospatial index
  #
  # @param [String] key
  # @param [String, Array<String>] member one member or array of members
  # @return [Array<Array<String>, nil>] returns array of elements, where each
  #   element is either array of longitude and latitude or nil
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:60
  def geopos(key, member); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from a point
  #
  # @param [Array] args key, longitude, latitude, radius, unit(m|km|ft|mi)
  # @param ['asc', 'desc'] sort sort returned items from the nearest to the farthest
  #   or the farthest to the nearest relative to the center
  # @param [Integer] count limit the results to the first N matching items
  # @param ['WITHDIST', 'WITHCOORD', 'WITHHASH'] options to return additional information
  # @return [Array<String>] may be changed with `options`
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:33
  def georadius(*args, **geoptions); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from an already existing member
  #
  # @param [Array] args key, member, radius, unit(m|km|ft|mi)
  # @param ['asc', 'desc'] sort sort returned items from the nearest to the farthest or the farthest
  #   to the nearest relative to the center
  # @param [Integer] count limit the results to the first N matching items
  # @param ['WITHDIST', 'WITHCOORD', 'WITHHASH'] options to return additional information
  # @return [Array<String>] may be changed with `options`
  #
  # pkg:gem/redis#lib/redis/commands/geo.rb:48
  def georadiusbymember(*args, **geoptions); end

  private

  # pkg:gem/redis#lib/redis/commands/geo.rb:76
  def _geoarguments(*args, options: T.unsafe(nil), sort: T.unsafe(nil), count: T.unsafe(nil)); end
end

# pkg:gem/redis#lib/redis/commands/hashes.rb:5
module Redis::Commands::Hashes
  # Delete one or more hash fields.
  #
  # @param [String] key
  # @param [String, Array<String>] field
  # @return [Integer] the number of fields that were removed from the hash
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:156
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  #
  # @param [String] key
  # @param [String] field
  # @return [Boolean] whether or not the field exists in the hash
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:166
  def hexists(key, field); end

  # Get the value of a hash field.
  #
  # @param [String] key
  # @param [String] field
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:74
  def hget(key, field); end

  # Get all the fields and values in a hash.
  #
  # @param [String] key
  # @return [Hash<String, String>]
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:210
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  #
  # @param [String] key
  # @param [String] field
  # @param [Integer] increment
  # @return [Integer] value of the field after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:176
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  #
  # @param [String] key
  # @param [String] field
  # @param [Float] increment
  # @return [Float] value of the field after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:186
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  #
  # @param [String] key
  # @return [Array<String>]
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:194
  def hkeys(key); end

  # Get the number of fields in a hash.
  #
  # @param [String] key
  # @return [Integer] number of fields in the hash
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:10
  def hlen(key); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.hmget("hash", "f1", "f2")
  #     # => ["v1", "v2"]
  #
  # @param [String] key
  # @param [Array<String>] fields array of fields
  # @return [Array<String>] an array of values for the specified fields
  #
  # @see #mapped_hmget
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:89
  def hmget(key, *fields, &blk); end

  # Set one or more hash values.
  #
  # @example
  #   redis.hmset("hash", "f1", "v1", "f2", "v2")
  #     # => "OK"
  #
  # @param [String] key
  # @param [Array<String>] attrs array of fields and values
  # @return [String] `"OK"`
  #
  # @see #mapped_hmset
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:50
  def hmset(key, *attrs); end

  # Get one or more random fields from a hash.
  #
  # @example Get one random field
  #   redis.hrandfield("hash")
  #     # => "f1"
  # @example Get multiple random fields
  #   redis.hrandfield("hash", 2)
  #     # => ["f1, "f2"]
  # @example Get multiple random fields with values
  #   redis.hrandfield("hash", 2, with_values: true)
  #     # => [["f1", "s1"], ["f2", "s2"]]
  #
  # @param [String] key
  # @param [Integer] count
  # @param [Hash] options
  #   - `:with_values => true`: include values in output
  #
  # @return [nil, String, Array<String>, Array<[String, Float]>]
  #   - when `key` does not exist, `nil`
  #   - when `count` is not specified, a field name
  #   - when `count` is specified and `:with_values` is not specified, an array of field names
  #   - when `:with_values` is specified, an array with `[field, value]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:138
  def hrandfield(key, count = T.unsafe(nil), withvalues: T.unsafe(nil), with_values: T.unsafe(nil)); end

  # Scan a hash
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.hscan("hash", 0)
  #
  # @param [String, Integer] cursor the cursor of the iteration
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [String, Array<[String, String]>] the next cursor and all found keys
  #
  # See the [Redis Server HSCAN documentation](https://redis.io/docs/latest/commands/hscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:227
  def hscan(key, cursor, **options); end

  # Scan a hash
  #
  # @example Retrieve all of the key/value pairs in a hash
  #   redis.hscan_each("hash").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  #
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [Enumerator] an enumerator for all found keys
  #
  # See the [Redis Server HSCAN documentation](https://redis.io/docs/latest/commands/hscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:246
  def hscan_each(key, **options, &block); end

  # Set one or more hash values.
  #
  # @example
  #   redis.hset("hash", "f1", "v1", "f2", "v2") # => 2
  #   redis.hset("hash", { "f1" => "v1", "f2" => "v2" }) # => 2
  #
  # @param [String] key
  # @param [Array<String> | Hash<String, String>] attrs array or hash of fields and values
  # @return [Integer] The number of fields that were added to the hash
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:23
  def hset(key, *attrs); end

  # Set the value of a hash field, only if the field does not exist.
  #
  # @param [String] key
  # @param [String] field
  # @param [String] value
  # @return [Boolean] whether or not the field was **added** to the hash
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:35
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  #
  # @param [String] key
  # @return [Array<String>]
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:202
  def hvals(key); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.mapped_hmget("hash", "f1", "f2")
  #     # => { "f1" => "v1", "f2" => "v2" }
  #
  # @param [String] key
  # @param [Array<String>] fields array of fields
  # @return [Hash] a hash mapping the specified fields to their values
  #
  # @see #hmget
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:105
  def mapped_hmget(key, *fields); end

  # Set one or more hash values.
  #
  # @example
  #   redis.mapped_hmset("hash", { "f1" => "v1", "f2" => "v2" })
  #     # => "OK"
  #
  # @param [String] key
  # @param [Hash] hash a non-empty hash with fields mapping to values
  # @return [String] `"OK"`
  #
  # @see #hmset
  #
  # pkg:gem/redis#lib/redis/commands/hashes.rb:65
  def mapped_hmset(key, hash); end
end

# pkg:gem/redis#lib/redis/commands.rb:57
Redis::Commands::Hashify = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:157
Redis::Commands::HashifyClusterNodeInfo = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:186
Redis::Commands::HashifyClusterNodes = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:190
Redis::Commands::HashifyClusterSlaves = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:172
Redis::Commands::HashifyClusterSlots = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:96
Redis::Commands::HashifyInfo = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:121
Redis::Commands::HashifyStreamAutoclaim = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:130
Redis::Commands::HashifyStreamAutoclaimJustId = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:115
Redis::Commands::HashifyStreamEntries = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:146
Redis::Commands::HashifyStreamPendingDetails = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:137
Redis::Commands::HashifyStreamPendings = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:103
Redis::Commands::HashifyStreams = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands/hyper_log_log.rb:5
module Redis::Commands::HyperLogLog
  # Add one or more members to a HyperLogLog structure.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member, or array of members
  # @return [Boolean] true if at least 1 HyperLogLog internal register was altered. false otherwise.
  #
  # pkg:gem/redis#lib/redis/commands/hyper_log_log.rb:11
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  #
  # If called with multiple keys, returns the approximate cardinality of the
  # union of the HyperLogLogs contained in the keys.
  #
  # @param [String, Array<String>] keys
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/hyper_log_log.rb:22
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  #
  # @param [String] dest_key destination key
  # @param [String, Array<String>] source_key source key, or array of keys
  # @return [Boolean]
  #
  # pkg:gem/redis#lib/redis/commands/hyper_log_log.rb:32
  def pfmerge(dest_key, *source_key); end
end

# pkg:gem/redis#lib/redis/commands/keys.rb:5
module Redis::Commands::Keys
  # Copy a value from one key to another.
  #
  # @example Copy a value to another key
  #   redis.set "foo", "value"
  #     # => "OK"
  #   redis.copy "foo", "bar"
  #     # => true
  #   redis.get "bar"
  #     # => "value"
  #
  # @example Copy a value to a key in another database
  #   redis.set "foo", "value"
  #     # => "OK"
  #   redis.copy "foo", "bar", db: 2
  #     # => true
  #   redis.select 2
  #     # => "OK"
  #   redis.get "bar"
  #     # => "value"
  #
  # @param [String] source
  # @param [String] destination
  # @param [Integer] db
  # @param [Boolean] replace removes the `destination` key before copying value to it
  # @return [Boolean] whether the key was copied or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:349
  def copy(source, destination, db: T.unsafe(nil), replace: T.unsafe(nil)); end

  # Delete one or more keys.
  #
  # @param [String, Array<String>] keys
  # @return [Integer] number of keys that were deleted
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:252
  def del(*keys); end

  # Return a serialized version of the value stored at a key.
  #
  # @param [String] key
  # @return [String] serialized_value
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:203
  def dump(key); end

  # Determine how many of the keys exists.
  #
  # @param [String, Array<String>] keys
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:271
  def exists(*keys); end

  # Determine if any of the keys exists.
  #
  # @param [String, Array<String>] keys
  # @return [Boolean]
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:279
  def exists?(*keys); end

  # Set a key's time to live in seconds.
  #
  # @param [String] key
  # @param [Integer] seconds time to live
  # @param [Hash] options
  #   - `:nx => true`: Set expiry only when the key has no expiry.
  #   - `:xx => true`: Set expiry only when the key has an existing expiry.
  #   - `:gt => true`: Set expiry only when the new expiry is greater than current one.
  #   - `:lt => true`: Set expiry only when the new expiry is less than current one.
  # @return [Boolean] whether the timeout was set or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:82
  def expire(key, seconds, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # Set the expiration for a key as a UNIX timestamp.
  #
  # @param [String] key
  # @param [Integer] unix_time expiry time specified as a UNIX timestamp
  # @param [Hash] options
  #   - `:nx => true`: Set expiry only when the key has no expiry.
  #   - `:xx => true`: Set expiry only when the key has an existing expiry.
  #   - `:gt => true`: Set expiry only when the new expiry is greater than current one.
  #   - `:lt => true`: Set expiry only when the new expiry is less than current one.
  # @return [Boolean] whether the timeout was set or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:102
  def expireat(key, unix_time, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # Get a key's expiry time specified as number of seconds from UNIX Epoch
  #
  # @param  [String] key
  # @return [Integer] expiry time specified as number of seconds from UNIX Epoch
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:116
  def expiretime(key); end

  # Find all keys matching the given pattern.
  #
  # @param [String] pattern
  # @return [Array<String>]
  #
  # See the [Redis Server KEYS documentation](https://redis.io/docs/latest/commands/keys/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:291
  def keys(pattern = T.unsafe(nil)); end

  # Transfer a key from the connected instance to another instance.
  #
  # @param [String, Array<String>] key
  # @param [Hash] options
  #   - `:host => String`: host of instance to migrate to
  #   - `:port => Integer`: port of instance to migrate to
  #   - `:db => Integer`: database to migrate to (default: same as source)
  #   - `:timeout => Integer`: timeout (default: same as connection timeout)
  #   - `:copy => Boolean`: Do not remove the key from the local instance.
  #   - `:replace => Boolean`: Replace existing key on the remote instance.
  # @return [String] `"OK"`
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:234
  def migrate(key, options); end

  # Move a key to another database.
  #
  # @example Move a key to another database
  #   redis.set "foo", "bar"
  #     # => "OK"
  #   redis.move "foo", 2
  #     # => true
  #   redis.exists "foo"
  #     # => false
  #   redis.select 2
  #     # => "OK"
  #   redis.exists "foo"
  #     # => true
  #   redis.get "foo"
  #     # => "bar"
  #
  # @param [String] key
  # @param [Integer] db
  # @return [Boolean] whether the key was moved or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:320
  def move(key, db); end

  # pkg:gem/redis#lib/redis/commands/keys.rb:357
  def object(*args); end

  # Remove the expiration from a key.
  #
  # @param [String] key
  # @return [Boolean] whether the timeout was removed or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:68
  def persist(key); end

  # Set a key's time to live in milliseconds.
  #
  # @param [String] key
  # @param [Integer] milliseconds time to live
  # @param [Hash] options
  #   - `:nx => true`: Set expiry only when the key has no expiry.
  #   - `:xx => true`: Set expiry only when the key has an existing expiry.
  #   - `:gt => true`: Set expiry only when the new expiry is greater than current one.
  #   - `:lt => true`: Set expiry only when the new expiry is less than current one.
  # @return [Boolean] whether the timeout was set or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:146
  def pexpire(key, milliseconds, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # @param [String] key
  # @param [Integer] ms_unix_time expiry time specified as number of milliseconds from UNIX Epoch.
  # @param [Hash] options
  #   - `:nx => true`: Set expiry only when the key has no expiry.
  #   - `:xx => true`: Set expiry only when the key has an existing expiry.
  #   - `:gt => true`: Set expiry only when the new expiry is greater than current one.
  #   - `:lt => true`: Set expiry only when the new expiry is less than current one.
  # @return [Boolean] whether the timeout was set or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:166
  def pexpireat(key, ms_unix_time, nx: T.unsafe(nil), xx: T.unsafe(nil), gt: T.unsafe(nil), lt: T.unsafe(nil)); end

  # Get a key's expiry time specified as number of milliseconds from UNIX Epoch
  #
  # @param  [String] key
  # @return [Integer] expiry time specified as number of milliseconds from UNIX Epoch
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:180
  def pexpiretime(key); end

  # Get the time to live (in milliseconds) for a key.
  #
  # @param [String] key
  # @return [Integer] remaining time to live in milliseconds
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:195
  def pttl(key); end

  # Return a random key from the keyspace.
  #
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:364
  def randomkey; end

  # Rename a key. If the new key already exists it is overwritten.
  #
  # @param [String] old_name
  # @param [String] new_name
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:373
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  #
  # @param [String] old_name
  # @param [String] new_name
  # @return [Boolean] whether the key was renamed or not
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:382
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  #
  # @param [String] key
  # @param [String] ttl
  # @param [String] serialized_value
  # @param [Hash] options
  #   - `:replace => Boolean`: if false, raises an error if key already exists
  # @raise [Redis::CommandError]
  # @return [String] `"OK"`
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:216
  def restore(key, ttl, serialized_value, replace: T.unsafe(nil)); end

  # Scan the keyspace
  #
  # @example Retrieve the first batch of keys
  #   redis.scan(0)
  #     # => ["4", ["key:21", "key:47", "key:42"]]
  # @example Retrieve a batch of keys matching a pattern
  #   redis.scan(4, :match => "key:1?")
  #     # => ["92", ["key:13", "key:18"]]
  # @example Retrieve a batch of keys of a certain type
  #   redis.scan(92, :type => "zset")
  #     # => ["173", ["sortedset:14", "sortedset:78"]]
  #
  # @param [String, Integer] cursor the cursor of the iteration
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #   - `:type => String`: return keys only of the given type
  #
  # @return [String, Array<String>] the next cursor and all found keys
  #
  # See the [Redis Server SCAN documentation](https://redis.io/docs/latest/commands/scan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:27
  def scan(cursor, **options); end

  # Scan the keyspace
  #
  # @example Retrieve all of the keys (with possible duplicates)
  #   redis.scan_each.to_a
  #     # => ["key:21", "key:47", "key:42"]
  # @example Execute block for each key matching a pattern
  #   redis.scan_each(:match => "key:1?") {|key| puts key}
  #     # => key:13
  #     # => key:18
  # @example Execute block for each key of a type
  #   redis.scan_each(:type => "hash") {|key| puts redis.type(key)}
  #     # => "hash"
  #     # => "hash"
  #
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #   - `:type => String`: return keys only of the given type
  #
  # @return [Enumerator] an enumerator for all found keys
  #
  # See the [Redis Server SCAN documentation](https://redis.io/docs/latest/commands/scan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:53
  def scan_each(**options, &block); end

  # Sort the elements in a list, set or sorted set.
  #
  # @example Retrieve the first 2 elements from an alphabetically sorted "list"
  #   redis.sort("list", :order => "alpha", :limit => [0, 2])
  #     # => ["a", "b"]
  # @example Store an alphabetically descending list in "target"
  #   redis.sort("list", :order => "desc alpha", :store => "target")
  #     # => 26
  #
  # @param [String] key
  # @param [Hash] options
  #   - `:by => String`: use external key to sort elements by
  #   - `:limit => [offset, count]`: skip `offset` elements, return a maximum
  #   of `count` elements
  #   - `:get => [String, Array<String>]`: single key or array of keys to
  #   retrieve per element in the result
  #   - `:order => String`: combination of `ASC`, `DESC` and optionally `ALPHA`
  #   - `:store => String`: key to store the result at
  #
  # @return [Array<String>, Array<Array<String>>, Integer]
  #   - when `:get` is not specified, or holds a single element, an array of elements
  #   - when `:get` is specified, and holds more than one element, an array of
  #   elements where every element is an array with the result for every
  #   element specified in `:get`
  #   - when `:store` is specified, the number of elements in the stored result
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:411
  def sort(key, by: T.unsafe(nil), limit: T.unsafe(nil), get: T.unsafe(nil), order: T.unsafe(nil), store: T.unsafe(nil)); end

  # Get the time to live (in seconds) for a key.
  #
  # @param [String] key
  # @return [Integer] remaining time to live in seconds.
  #
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:132
  def ttl(key); end

  # Determine the type stored at key.
  #
  # @param [String] key
  # @return [String] `string`, `list`, `set`, `zset`, `hash` or `none`
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:441
  def type(key); end

  # Unlink one or more keys.
  #
  # @param [String, Array<String>] keys
  # @return [Integer] number of keys that were unlinked
  #
  # pkg:gem/redis#lib/redis/commands/keys.rb:263
  def unlink(*keys); end

  private

  # pkg:gem/redis#lib/redis/commands/keys.rb:447
  def _scan(command, cursor, args, match: T.unsafe(nil), count: T.unsafe(nil), type: T.unsafe(nil), &block); end
end

# pkg:gem/redis#lib/redis/commands/lists.rb:5
module Redis::Commands::Lists
  # Remove the first/last element in a list and append/prepend it
  # to another list and return it, or block until one is available.
  #
  # @example With timeout
  #   element = redis.blmove("foo", "bar", "LEFT", "RIGHT", timeout: 5)
  #     # => nil on timeout
  #     # => "element" on success
  # @example Without timeout
  #   element = redis.blmove("foo", "bar", "LEFT", "RIGHT")
  #     # => "element"
  #
  # @param [String] source source key
  # @param [String] destination destination key
  # @param [String, Symbol] where_source from where to remove the element from the source list
  #     e.g. 'LEFT' - from head, 'RIGHT' - from tail
  # @param [String, Symbol] where_destination where to push the element to the source list
  #     e.g. 'LEFT' - to head, 'RIGHT' - to tail
  # @param [Hash] options
  #   - `:timeout => [Float, Integer]`: timeout in seconds, defaults to no timeout
  #
  # @return [nil, String] the element, or nil when the source key does not exist or the timeout expired
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:55
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # Pops one or more elements from the first non-empty list key from the list
  # of provided key names. If lists are empty, blocks until timeout has passed.
  #
  # @example Popping a element
  #   redis.blmpop(1.0, 'list')
  #   #=> ['list', ['a']]
  # @example With count option
  #   redis.blmpop(1.0, 'list', count: 2)
  #   #=> ['list', ['a', 'b']]
  #
  # @params timeout [Float] a float value specifying the maximum number of seconds to block) elapses.
  #   A timeout of zero can be used to block indefinitely.
  # @params key [String, Array<String>] one or more keys with lists
  # @params modifier [String]
  #  - when `"LEFT"` - the elements popped are those from the left of the list
  #  - when `"RIGHT"` - the elements popped are those from the right of the list
  # @params count [Integer] a number of elements to pop
  #
  # @return [Array<String, Array<String, Float>>] list of popped elements or nil
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:205
  def blmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is available.
  #
  # @example With timeout
  #   list, element = redis.blpop("list", :timeout => 5)
  #     # => nil on timeout
  #     # => ["list", "element"] on success
  # @example Without timeout
  #   list, element = redis.blpop("list")
  #     # => ["list", "element"]
  # @example Blocking pop on multiple lists
  #   list, element = redis.blpop(["list", "another_list"])
  #     # => ["list", "element"]
  #
  # @param [String, Array<String>] keys one or more keys to perform the
  #   blocking pop on
  # @param [Hash] options
  #   - `:timeout => [Float, Integer]`: timeout in seconds, defaults to no timeout
  #
  # @return [nil, [String, String]]
  #   - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:150
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is available.
  #
  # @param [String, Array<String>] keys one or more keys to perform the
  #   blocking pop on
  # @param [Hash] options
  #   - `:timeout => [Float, Integer]`: timeout in seconds, defaults to no timeout
  #
  # @return [nil, [String, String]]
  #   - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  #
  # @see #blpop
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:166
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  #
  # @param [String] source source key
  # @param [String] destination destination key
  # @param [Hash] options
  #   - `:timeout => [Float, Integer]`: timeout in seconds, defaults to no timeout
  #
  # @return [nil, String]
  #   - `nil` when the operation timed out
  #   - the element was popped and pushed otherwise
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:181
  def brpoplpush(source, destination, timeout: T.unsafe(nil)); end

  # Get an element from a list by its index.
  #
  # @param [String] key
  # @param [Integer] index
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:245
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  #
  # @param [String] key
  # @param [String, Symbol] where `BEFORE` or `AFTER`
  # @param [String] pivot reference element
  # @param [String] value
  # @return [Integer] length of the list after the insert operation, or `-1`
  #   when the element `pivot` was not found
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:257
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  #
  # @param [String] key
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:10
  def llen(key); end

  # Remove the first/last element in a list, append/prepend it to another list and return it.
  #
  # @param [String] source source key
  # @param [String] destination destination key
  # @param [String, Symbol] where_source from where to remove the element from the source list
  #     e.g. 'LEFT' - from head, 'RIGHT' - from tail
  # @param [String, Symbol] where_destination where to push the element to the source list
  #     e.g. 'LEFT' - to head, 'RIGHT' - to tail
  #
  # @return [nil, String] the element, or nil when the source key does not exist
  #
  # @note This command comes in place of the now deprecated RPOPLPUSH.
  #     Doing LMOVE RIGHT LEFT is equivalent.
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:27
  def lmove(source, destination, where_source, where_destination); end

  # Pops one or more elements from the first non-empty list key from the list
  # of provided key names.
  #
  # @example Popping a element
  #   redis.lmpop('list')
  #   #=> ['list', ['a']]
  # @example With count option
  #   redis.lmpop('list', count: 2)
  #   #=> ['list', ['a', 'b']]
  #
  # @params key [String, Array<String>] one or more keys with lists
  # @params modifier [String]
  #  - when `"LEFT"` - the elements popped are those from the left of the list
  #  - when `"RIGHT"` - the elements popped are those from the right of the list
  # @params count [Integer] a number of elements to pop
  #
  # @return [Array<String, Array<String, Float>>] list of popped elements or nil
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:231
  def lmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Remove and get the first elements in a list.
  #
  # @param [String] key
  # @param [Integer] count number of elements to remove
  # @return [nil, String, Array<String>] the values of the first elements
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:103
  def lpop(key, count = T.unsafe(nil)); end

  # Prepend one or more values to a list, creating the list if it doesn't exist
  #
  # @param [String] key
  # @param [String, Array<String>] value string value, or array of string values to push
  # @return [Integer] the length of the list after the push operation
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:67
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  #
  # @param [String] key
  # @param [String] value
  # @return [Integer] the length of the list after the push operation
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:76
  def lpushx(key, value); end

  # Get a range of elements from a list.
  #
  # @param [String] key
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @return [Array<String>]
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:267
  def lrange(key, start, stop); end

  # Remove elements from a list.
  #
  # @param [String] key
  # @param [Integer] count number of elements to remove. Use a positive
  #   value to remove the first `count` occurrences of `value`. A negative
  #   value to remove the last `count` occurrences of `value`. Or zero, to
  #   remove all occurrences of `value` from the list.
  # @param [String] value
  # @return [Integer] the number of removed elements
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:280
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  #
  # @param [String] key
  # @param [Integer] index
  # @param [String] value
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:290
  def lset(key, index, value); end

  # Trim a list to the specified range.
  #
  # @param [String] key
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:300
  def ltrim(key, start, stop); end

  # Remove and get the last elements in a list.
  #
  # @param [String] key
  # @param [Integer] count number of elements to remove
  # @return [nil, String, Array<String>] the values of the last elements
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:114
  def rpop(key, count = T.unsafe(nil)); end

  # Remove the last element in a list, append it to another list and return it.
  #
  # @param [String] source source key
  # @param [String] destination destination key
  # @return [nil, String] the element, or nil when the source key does not exist
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:125
  def rpoplpush(source, destination); end

  # Append one or more values to a list, creating the list if it doesn't exist
  #
  # @param [String] key
  # @param [String, Array<String>] value string value, or array of string values to push
  # @return [Integer] the length of the list after the push operation
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:85
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  #
  # @param [String] key
  # @param [String] value
  # @return [Integer] the length of the list after the push operation
  #
  # pkg:gem/redis#lib/redis/commands/lists.rb:94
  def rpushx(key, value); end

  private

  # pkg:gem/redis#lib/redis/commands/lists.rb:306
  def _bpop(cmd, args, &blk); end

  # pkg:gem/redis#lib/redis/commands/lists.rb:323
  def _normalize_move_wheres(where_source, where_destination); end
end

# pkg:gem/redis#lib/redis/commands.rb:194
Redis::Commands::Noop = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands.rb:65
Redis::Commands::Pairify = T.let(T.unsafe(nil), Proc)

# pkg:gem/redis#lib/redis/commands/pubsub.rb:5
module Redis::Commands::Pubsub
  # Listen for messages published to channels matching the given patterns.
  # See the [Redis Server PSUBSCRIBE documentation](https://redis.io/docs/latest/commands/psubscribe/)
  # for further details
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:34
  def psubscribe(*channels, &block); end

  # Listen for messages published to channels matching the given patterns.
  # Throw a timeout error if there is no messages for a timeout period.
  # See the [Redis Server PSUBSCRIBE documentation](https://redis.io/docs/latest/commands/psubscribe/)
  # for further details
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:42
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # Post a message to a channel.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:7
  def publish(channel, message); end

  # Inspect the state of the Pub/Sub subsystem.
  # Possible subcommands: channels, numsub, numpat.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:55
  def pubsub(subcommand, *args); end

  # Stop listening for messages posted to channels matching the given patterns.
  # See the [Redis Server PUNSUBSCRIBE documentation](https://redis.io/docs/latest/commands/punsubscribe/)
  # for further details
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:49
  def punsubscribe(*channels); end

  # Post a message to a channel in a shard.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:60
  def spublish(channel, message); end

  # Listen for messages published to the given channels in a shard.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:65
  def ssubscribe(*channels, &block); end

  # Listen for messages published to the given channels in a shard.
  # Throw a timeout error if there is no messages for a timeout period.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:71
  def ssubscribe_with_timeout(timeout, *channels, &block); end

  # Listen for messages published to the given channels.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:16
  def subscribe(*channels, &block); end

  # Listen for messages published to the given channels. Throw a timeout error
  # if there is no messages for a timeout period.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:22
  def subscribe_with_timeout(timeout, *channels, &block); end

  # pkg:gem/redis#lib/redis/commands/pubsub.rb:11
  def subscribed?; end

  # Stop listening for messages posted to the given channels in a shard.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:76
  def sunsubscribe(*channels); end

  # Stop listening for messages posted to the given channels.
  #
  # pkg:gem/redis#lib/redis/commands/pubsub.rb:27
  def unsubscribe(*channels); end
end

# pkg:gem/redis#lib/redis/commands/scripting.rb:5
module Redis::Commands::Scripting
  # Evaluate Lua script.
  #
  # @example EVAL without KEYS nor ARGV
  #   redis.eval("return 1")
  #     # => 1
  # @example EVAL with KEYS and ARGV as array arguments
  #   redis.eval("return { KEYS, ARGV }", ["k1", "k2"], ["a1", "a2"])
  #     # => [["k1", "k2"], ["a1", "a2"]]
  # @example EVAL with KEYS and ARGV in a hash argument
  #   redis.eval("return { KEYS, ARGV }", :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #     # => [["k1", "k2"], ["a1", "a2"]]
  #
  # @param [Array<String>] keys optional array with keys to pass to the script
  # @param [Array<String>] argv optional array with arguments to pass to the script
  # @param [Hash] options
  #   - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  #
  # @see #script
  # @see #evalsha
  #
  # pkg:gem/redis#lib/redis/commands/scripting.rb:71
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  #
  # @example EVALSHA without KEYS nor ARGV
  #   redis.evalsha(sha)
  #     # => <depends on script>
  # @example EVALSHA with KEYS and ARGV as array arguments
  #   redis.evalsha(sha, ["k1", "k2"], ["a1", "a2"])
  #     # => <depends on script>
  # @example EVALSHA with KEYS and ARGV in a hash argument
  #   redis.evalsha(sha, :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #     # => <depends on script>
  #
  # @param [Array<String>] keys optional array with keys to pass to the script
  # @param [Array<String>] argv optional array with arguments to pass to the script
  # @param [Hash] options
  #   - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  #
  # @see #script
  # @see #eval
  #
  # pkg:gem/redis#lib/redis/commands/scripting.rb:96
  def evalsha(*args); end

  # Control remote script registry.
  #
  # @example Load a script
  #   sha = redis.script(:load, "return 1")
  #     # => <sha of this script>
  # @example Check if a script exists
  #   redis.script(:exists, sha)
  #     # => true
  # @example Check if multiple scripts exist
  #   redis.script(:exists, [sha, other_sha])
  #     # => [true, false]
  # @example Flush the script registry
  #   redis.script(:flush)
  #     # => "OK"
  # @example Kill a running script
  #   redis.script(:kill)
  #     # => "OK"
  #
  # @param [String] subcommand e.g. `exists`, `flush`, `load`, `kill`
  # @param [Array<String>] args depends on subcommand
  # @return [String, Boolean, Array<Boolean>, ...] depends on subcommand
  #
  # @see #eval
  # @see #evalsha
  #
  # pkg:gem/redis#lib/redis/commands/scripting.rb:30
  def script(subcommand, *args); end

  private

  # pkg:gem/redis#lib/redis/commands/scripting.rb:102
  def _eval(cmd, args); end
end

# pkg:gem/redis#lib/redis/commands/server.rb:5
module Redis::Commands::Server
  # Asynchronously rewrite the append-only file.
  #
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:9
  def bgrewriteaof; end

  # Asynchronously save the dataset to disk.
  #
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:16
  def bgsave; end

  # Manage client connections.
  #
  # @param [String, Symbol] subcommand e.g. `kill`, `list`, `getname`, `setname`
  # @return [String, Hash] depends on subcommand
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:39
  def client(subcommand, *args); end

  # Get or set server configuration parameters.
  #
  # @param [Symbol] action e.g. `:get`, `:set`, `:resetstat`
  # @return [String, Hash] string reply, or hash when retrieving more than one
  #   property with `CONFIG GET`
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:25
  def config(action, *args); end

  # Return the number of keys in the selected database.
  #
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:55
  def dbsize; end

  # pkg:gem/redis#lib/redis/commands/server.rb:183
  def debug(*args); end

  # Remove all keys from all databases.
  #
  # @param [Hash] options
  #   - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:64
  def flushall(options = T.unsafe(nil)); end

  # Remove all keys from the current database.
  #
  # @param [Hash] options
  #   - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:77
  def flushdb(options = T.unsafe(nil)); end

  # Get information and statistics about the server.
  #
  # @param [String, Symbol] cmd e.g. "commandstats"
  # @return [Hash<String, String>]
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:89
  def info(cmd = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  #
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:110
  def lastsave; end

  # Listen for all requests received by the server in real time.
  #
  # There is no way to interrupt this command.
  #
  # @yield a block to be called for every line of output
  # @yieldparam [String] line timestamp and command that was executed
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:120
  def monitor; end

  # Synchronously save the dataset to disk.
  #
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:133
  def save; end

  # Synchronously save the dataset to disk and then shut down the server.
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:138
  def shutdown; end

  # Make the server a slave of another instance, or promote it as master.
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:150
  def slaveof(host, port); end

  # Interact with the slowlog (get, len, reset)
  #
  # @param [String] subcommand e.g. `get`, `len`, `reset`
  # @param [Integer] length maximum number of entries to return
  # @return [Array<String>, Integer, String] depends on subcommand
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:159
  def slowlog(subcommand, length = T.unsafe(nil)); end

  # Internal command used for replication.
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:166
  def sync; end

  # Return the server time.
  #
  # @example
  #   r.time # => [ 1333093196, 606806 ]
  #
  # @return [Array<Integer>] tuple of seconds since UNIX epoch and
  #   microseconds in the current second
  #
  # pkg:gem/redis#lib/redis/commands/server.rb:177
  def time; end
end

# pkg:gem/redis#lib/redis/commands/sets.rb:5
module Redis::Commands::Sets
  # Add one or more members to a set.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member, or array of members
  # @return [Integer] The number of members that were successfully added
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:19
  def sadd(key, *members); end

  # Add one or more members to a set.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member, or array of members
  # @return [Boolean] Wether at least one member was successfully added.
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:29
  def sadd?(key, *members); end

  # Get the number of members in a set.
  #
  # @param [String] key
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:10
  def scard(key); end

  # Subtract multiple sets.
  #
  # @param [String, Array<String>] keys keys pointing to sets to subtract
  # @return [Array<String>] members in the difference
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:123
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  #
  # @param [String] destination destination key
  # @param [String, Array<String>] keys keys pointing to sets to subtract
  # @return [Integer] number of elements in the resulting set
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:133
  def sdiffstore(destination, *keys); end

  # Intersect multiple sets.
  #
  # @param [String, Array<String>] keys keys pointing to sets to intersect
  # @return [Array<String>] members in the intersection
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:142
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  #
  # @param [String] destination destination key
  # @param [String, Array<String>] keys keys pointing to sets to intersect
  # @return [Integer] number of elements in the resulting set
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:152
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  #
  # @param [String] key
  # @param [String] member
  # @return [Boolean]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:95
  def sismember(key, member); end

  # Get all the members in a set.
  #
  # @param [String] key
  # @return [Array<String>]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:115
  def smembers(key); end

  # Determine if multiple values are members of a set.
  #
  # @param [String] key
  # @param [String, Array<String>] members
  # @return [Array<Boolean>]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:104
  def smismember(key, *members); end

  # Move a member from one set to another.
  #
  # @param [String] source source key
  # @param [String] destination destination key
  # @param [String] member member to move from `source` to `destination`
  # @return [Boolean]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:86
  def smove(source, destination, member); end

  # Remove and return one or more random member from a set.
  #
  # @param [String] key
  # @return [String]
  # @param [Integer] count
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:59
  def spop(key, count = T.unsafe(nil)); end

  # Get one or more random members from a set.
  #
  # @param [String] key
  # @param [Integer] count
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:72
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member, or array of members
  # @return [Integer] The number of members that were successfully removed
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:39
  def srem(key, *members); end

  # Remove one or more members from a set.
  #
  # @param [String] key
  # @param [String, Array<String>] member one member, or array of members
  # @return [Boolean] Wether at least one member was successfully removed.
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:49
  def srem?(key, *members); end

  # Scan a set
  #
  # @example Retrieve the first batch of keys in a set
  #   redis.sscan("set", 0)
  #
  # @param [String, Integer] cursor the cursor of the iteration
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [String, Array<String>] the next cursor and all found members
  #
  # See the [Redis Server SSCAN documentation](https://redis.io/docs/latest/commands/sscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:189
  def sscan(key, cursor, **options); end

  # Scan a set
  #
  # @example Retrieve all of the keys in a set
  #   redis.sscan_each("set").to_a
  #   # => ["key1", "key2", "key3"]
  #
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [Enumerator] an enumerator for all keys in the set
  #
  # See the [Redis Server SSCAN documentation](https://redis.io/docs/latest/commands/sscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:206
  def sscan_each(key, **options, &block); end

  # Add multiple sets.
  #
  # @param [String, Array<String>] keys keys pointing to sets to unify
  # @return [Array<String>] members in the union
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:161
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  #
  # @param [String] destination destination key
  # @param [String, Array<String>] keys keys pointing to sets to unify
  # @return [Integer] number of elements in the resulting set
  #
  # pkg:gem/redis#lib/redis/commands/sets.rb:171
  def sunionstore(destination, *keys); end
end

# pkg:gem/redis#lib/redis/commands/sorted_sets.rb:5
module Redis::Commands::SortedSets
  # Removes and returns up to count members with scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.bzmpop('zset')
  #   #=> ['zset', ['a', 1.0]]
  # @example With count option
  #   redis.bzmpop('zset', count: 2)
  #   #=> ['zset', [['a', 1.0], ['b', 2.0]]
  #
  # @params timeout [Float] a float value specifying the maximum number of seconds to block) elapses.
  #   A timeout of zero can be used to block indefinitely.
  # @params key [String, Array<String>] one or more keys with sorted sets
  # @params modifier [String]
  #  - when `"MIN"` - the elements popped are those with lowest scores
  #  - when `"MAX"` - the elements popped are those with the highest scores
  # @params count [Integer] a number of members to pop
  #
  # @return [Array<String, Array<String, Float>>] list of popped elements and scores
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:188
  def bzmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Removes and returns up to count members with the highest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmax('zset', 1)
  #   #=> ['zset', 'b', 2.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmax('zset1', 'zset2', 1)
  #   #=> ['zset1', 'b', 2.0]
  #
  # @params keys [Array<String>] one or multiple keys of the sorted sets
  # @params timeout [Integer] the maximum number of seconds to block
  #
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:251
  def bzpopmax(*args); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmin('zset', 1)
  #   #=> ['zset', 'a', 1.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmin('zset1', 'zset2', 1)
  #   #=> ['zset1', 'a', 1.0]
  #
  # @params keys [Array<String>] one or multiple keys of the sorted sets
  # @params timeout [Integer] the maximum number of seconds to block
  #
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:272
  def bzpopmin(*args); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  #
  # @example Add a single `[score, member]` pair to a sorted set
  #   redis.zadd("zset", 32.0, "member")
  # @example Add an array of `[score, member]` pairs to a sorted set
  #   redis.zadd("zset", [[32.0, "a"], [64.0, "b"]])
  #
  # @param [String] key
  # @param [[Float, String], Array<[Float, String]>] args
  #   - a single `[score, member]` pair
  #   - an array of `[score, member]` pairs
  # @param [Hash] options
  #   - `:xx => true`: Only update elements that already exist (never
  #   add elements)
  #   - `:nx => true`: Don't update already existing elements (always
  #   add new elements)
  #   - `:lt => true`: Only update existing elements if the new score
  #   is less than the current score
  #   - `:gt => true`: Only update existing elements if the new score
  #   is greater than the current score
  #   - `:ch => true`: Modify the return value from the number of new
  #   elements added, to the total number of elements changed (CH is an
  #   abbreviation of changed); changed elements are new elements added
  #   and elements already existing for which the score was updated
  #   - `:incr => true`: When this option is specified ZADD acts like
  #   ZINCRBY; only one score-element pair can be specified in this mode
  #
  # @return [Boolean, Integer, Float]
  #   - `Boolean` when a single pair is specified, holding whether or not it was
  #   **added** to the sorted set.
  #   - `Integer` when an array of pairs is specified, holding the number of
  #   pairs that were **added** to the sorted set.
  #   - `Float` when option :incr is specified, holding the score of the member
  #   after incrementing it.
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:53
  def zadd(key, *args, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil), ch: T.unsafe(nil), incr: T.unsafe(nil)); end

  # Get the number of members in a sorted set.
  #
  # @example
  #   redis.zcard("zset")
  #     # => 4
  #
  # @param [String] key
  # @return [Integer]
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:14
  def zcard(key); end

  # Count the members in a sorted set with scores within the given values.
  #
  # @example Count members with score `>= 5` and `< 100`
  #   redis.zcount("zset", "5", "(100")
  #     # => 2
  # @example Count members with scores `> 5`
  #   redis.zcount("zset", "(5", "+inf")
  #     # => 2
  #
  # @param [String] key
  # @param [String] min
  #   - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param [String] max
  #   - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Integer] number of members in within the specified range
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:712
  def zcount(key, min, max); end

  # Return the difference between the first and all successive input sorted sets
  #
  # @example
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiff("zsetA", "zsetB")
  #     => ["v1"]
  # @example With scores
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiff("zsetA", "zsetB", :with_scores => true)
  #     => [["v1", 1.0]]
  #
  # @param [String, Array<String>] keys one or more keys to compute the difference
  # @param [Hash] options
  #   - `:with_scores => true`: include scores in output
  #
  # @return [Array<String>, Array<[String, Float]>]
  #   - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:821
  def zdiff(*keys, with_scores: T.unsafe(nil)); end

  # Compute the difference between the first and all successive input sorted sets
  # and store the resulting sorted set in a new key
  #
  # @example
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiffstore("zsetA", "zsetB")
  #     # => 1
  #
  # @param [String] destination destination key
  # @param [Array<String>] keys source keys
  # @return [Integer] number of elements in the resulting sorted set
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:837
  def zdiffstore(*args, **_arg1); end

  # Increment the score of a member in a sorted set.
  #
  # @example
  #   redis.zincrby("zset", 32.0, "a")
  #     # => 64.0
  #
  # @param [String] key
  # @param [Float] increment
  # @param [String] member
  # @return [Float] score of the member after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:86
  def zincrby(key, increment, member); end

  # Return the intersection of multiple sorted sets
  #
  # @example Retrieve the intersection of `2*zsetA` and `1*zsetB`
  #   redis.zinter("zsetA", "zsetB", :weights => [2.0, 1.0])
  #     # => ["v1", "v2"]
  # @example Retrieve the intersection of `2*zsetA` and `1*zsetB`, and their scores
  #   redis.zinter("zsetA", "zsetB", :weights => [2.0, 1.0], :with_scores => true)
  #     # => [["v1", 3.0], ["v2", 6.0]]
  #
  # @param [String, Array<String>] keys one or more keys to intersect
  # @param [Hash] options
  #   - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  #   - `:with_scores => true`: include scores in output
  #
  # @return [Array<String>, Array<[String, Float]>]
  #   - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:735
  def zinter(*args, **_arg1); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  #
  # @example Compute the intersection of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zinterstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #     # => 4
  #
  # @param [String] destination destination key
  # @param [Array<String>] keys source keys
  # @param [Hash] options
  #   - `:weights => [Array<Float>]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max)
  # @return [Integer] number of elements in the resulting sorted set
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:754
  def zinterstore(*args, **_arg1); end

  # Count the members, with the same score in a sorted set, within the given lexicographical range.
  #
  # @example Count members matching a
  #   redis.zlexcount("zset", "[a", "[a\xff")
  #     # => 1
  # @example Count members matching a-z
  #   redis.zlexcount("zset", "[a", "[z\xff")
  #     # => 26
  #
  # @param [String] key
  # @param [String] min
  #   - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param [String] max
  #   - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  #
  # @return [Integer] number of members within the specified lexicographical range
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:543
  def zlexcount(key, min, max); end

  # Removes and returns up to count members with scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zmpop('zset')
  #   #=> ['zset', ['a', 1.0]]
  # @example With count option
  #   redis.zmpop('zset', count: 2)
  #   #=> ['zset', [['a', 1.0], ['b', 2.0]]
  #
  # @params key [String, Array<String>] one or more keys with sorted sets
  # @params modifier [String]
  #  - when `"MIN"` - the elements popped are those with lowest scores
  #  - when `"MAX"` - the elements popped are those with the highest scores
  # @params count [Integer] a number of members to pop
  #
  # @return [Array<String, Array<String, Float>>] list of popped elements and scores
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:220
  def zmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Get the scores associated with the given members in a sorted set.
  #
  # @example Get the scores for members "a" and "b"
  #   redis.zmscore("zset", "a", "b")
  #     # => [32.0, 48.0]
  #
  # @param [String] key
  # @param [String, Array<String>] members
  # @return [Array<Float>] scores of the members
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:300
  def zmscore(key, *members); end

  # Removes and returns up to count members with the highest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmax('zset')
  #   #=> ['b', 2.0]
  # @example With count option
  #   redis.zpopmax('zset', 2)
  #   #=> [['b', 2.0], ['a', 1.0]]
  #
  # @params key [String] a key of the sorted set
  # @params count [Integer] a number of members
  #
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:138
  def zpopmax(key, count = T.unsafe(nil)); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmin('zset')
  #   #=> ['a', 1.0]
  # @example With count option
  #   redis.zpopmin('zset', 2)
  #   #=> [['a', 1.0], ['b', 2.0]]
  #
  # @params key [String] a key of the sorted set
  # @params count [Integer] a number of members
  #
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:161
  def zpopmin(key, count = T.unsafe(nil)); end

  # Get one or more random members from a sorted set.
  #
  # @example Get one random member
  #   redis.zrandmember("zset")
  #     # => "a"
  # @example Get multiple random members
  #   redis.zrandmember("zset", 2)
  #     # => ["a", "b"]
  # @example Get multiple random members with scores
  #   redis.zrandmember("zset", 2, with_scores: true)
  #     # => [["a", 2.0], ["b", 3.0]]
  #
  # @param [String] key
  # @param [Integer] count
  # @param [Hash] options
  #   - `:with_scores => true`: include scores in output
  #
  # @return [nil, String, Array<String>, Array<[String, Float]>]
  #   - when `key` does not exist or set is empty, `nil`
  #   - when `count` is not specified, a member
  #   - when `count` is specified and `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:328
  def zrandmember(key, count = T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by index, score or lexicographical ordering.
  #
  # @example Retrieve all members from a sorted set, by index
  #   redis.zrange("zset", 0, -1)
  #     # => ["a", "b"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrange("zset", 0, -1, :with_scores => true)
  #     # => [["a", 32.0], ["b", 64.0]]
  #
  # @param [String] key
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @param [Hash] options
  #   - `:by_score => false`: return members by score
  #   - `:by_lex => false`: return members by lexicographical ordering
  #   - `:rev => false`: reverse the ordering, from highest to lowest
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  #   - `:with_scores => true`: include scores in output
  #
  # @return [Array<String>, Array<[String, Float]>]
  #   - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:367
  def zrange(key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by lexicographical ordering
  #
  # @example Retrieve members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff")
  #     # => ["aaren", "aarika", "abagael", "abby"]
  # @example Retrieve the first 2 members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #     # => ["aaren", "aarika"]
  #
  # @param [String] key
  # @param [String] min
  #   - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param [String] max
  #   - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  # @param [Hash] options
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  #
  # @return [Array<String>, Array<[String, Float]>]
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:568
  def zrangebylex(key, min, max, limit: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score.
  #
  # @example Retrieve members with score `>= 5` and `< 100`
  #   redis.zrangebyscore("zset", "5", "(100")
  #     # => ["a", "b"]
  # @example Retrieve the first 2 members with score `>= 0`
  #   redis.zrangebyscore("zset", "0", "+inf", :limit => [0, 2])
  #     # => ["a", "b"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrangebyscore("zset", "(5", "+inf", :with_scores => true)
  #     # => [["a", 32.0], ["b", 64.0]]
  #
  # @param [String] key
  # @param [String] min
  #   - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param [String] max
  #   - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @param [Hash] options
  #   - `:with_scores => true`: include scores in output
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  #
  # @return [Array<String>, Array<[String, Float]>]
  #   - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:628
  def zrangebyscore(key, min, max, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Select a range of members in a sorted set, by index, score or lexicographical ordering
  # and store the resulting sorted set in a new key.
  #
  # @example
  #   redis.zadd("foo", [[1.0, "s1"], [2.0, "s2"], [3.0, "s3"]])
  #   redis.zrangestore("bar", "foo", 0, 1)
  #     # => 2
  #   redis.zrange("bar", 0, -1)
  #     # => ["s1", "s2"]
  #
  # @return [Integer] the number of elements in the resulting sorted set
  # @see #zrange
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:409
  def zrangestore(dest_key, src_key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Determine the index of a member in a sorted set.
  #
  # @example Retrieve member rank
  #   redis.zrank("zset", "a")
  #     # => 3
  # @example Retrieve member rank with their score
  #   redis.zrank("zset", "a", :with_score => true)
  #     # => [3, 32.0]
  #
  # @param [String] key
  # @param [String] member
  #
  # @return [Integer, [Integer, Float]]
  #   - when `:with_score` is not specified, an Integer
  #   - when `:with_score` is specified, a `[rank, score]` pair
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:470
  def zrank(key, member, withscore: T.unsafe(nil), with_score: T.unsafe(nil)); end

  # Remove one or more members from a sorted set.
  #
  # @example Remove a single member from a sorted set
  #   redis.zrem("zset", "a")
  # @example Remove an array of members from a sorted set
  #   redis.zrem("zset", ["a", "b"])
  #
  # @param [String] key
  # @param [String, Array<String>] member
  #   - a single member
  #   - an array of members
  #
  # @return [Boolean, Integer]
  #   - `Boolean` when a single member is specified, holding whether or not it
  #   was removed from the sorted set
  #   - `Integer` when an array of pairs is specified, holding the number of
  #   members that were removed to the sorted set
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:107
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  #
  # @example Remove first 5 members
  #   redis.zremrangebyrank("zset", 0, 4)
  #     # => 5
  # @example Remove last 5 members
  #   redis.zremrangebyrank("zset", -5, -1)
  #     # => 5
  #
  # @param [String] key
  # @param [Integer] start start index
  # @param [Integer] stop stop index
  # @return [Integer] number of members that were removed
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:521
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  #
  # @example Remove members with score `>= 5` and `< 100`
  #   redis.zremrangebyscore("zset", "5", "(100")
  #     # => 2
  # @example Remove members with scores `> 5`
  #   redis.zremrangebyscore("zset", "(5", "+inf")
  #     # => 2
  #
  # @param [String] key
  # @param [String] min
  #   - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param [String] max
  #   - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Integer] number of members that were removed
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:691
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  #
  # @example Retrieve all members from a sorted set
  #   redis.zrevrange("zset", 0, -1)
  #     # => ["b", "a"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrevrange("zset", 0, -1, :with_scores => true)
  #     # => [["b", 64.0], ["a", 32.0]]
  #
  # @see #zrange
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:444
  def zrevrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by reversed lexicographical ordering.
  # Apart from the reversed ordering, #zrevrangebylex is similar to #zrangebylex.
  #
  # @example Retrieve members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff")
  #     # => ["abbygail", "abby", "abagael", "aaren"]
  # @example Retrieve the last 2 members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #     # => ["abbygail", "abby"]
  #
  # @see #zrangebylex
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:590
  def zrevrangebylex(key, max, min, limit: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  #
  # @example Retrieve members with score `< 100` and `>= 5`
  #   redis.zrevrangebyscore("zset", "(100", "5")
  #     # => ["b", "a"]
  # @example Retrieve the first 2 members with score `<= 0`
  #   redis.zrevrangebyscore("zset", "0", "-inf", :limit => [0, 2])
  #     # => ["b", "a"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrevrangebyscore("zset", "+inf", "(5", :with_scores => true)
  #     # => [["b", 64.0], ["a", 32.0]]
  #
  # @see #zrangebyscore
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:658
  def zrevrangebyscore(key, max, min, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  #
  # @example Retrieve member rank
  #   redis.zrevrank("zset", "a")
  #     # => 3
  # @example Retrieve member rank with their score
  #   redis.zrevrank("zset", "a", :with_score => true)
  #     # => [3, 32.0]
  #
  # @param [String] key
  # @param [String] member
  #
  # @return [Integer, [Integer, Float]]
  #   - when `:with_score` is not specified, an Integer
  #   - when `:with_score` is specified, a `[rank, score]` pair
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:497
  def zrevrank(key, member, withscore: T.unsafe(nil), with_score: T.unsafe(nil)); end

  # Scan a sorted set
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.zscan("zset", 0)
  #
  # @param [String, Integer] cursor the cursor of the iteration
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [String, Array<[String, Float]>] the next cursor and all found
  #   members and scores
  #
  # See the [Redis Server ZSCAN documentation](https://redis.io/docs/latest/commands/zscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:856
  def zscan(key, cursor, **options); end

  # Scan a sorted set
  #
  # @example Retrieve all of the members/scores in a sorted set
  #   redis.zscan_each("zset").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  #
  # @param [Hash] options
  #   - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #
  # @return [Enumerator] an enumerator for all found scores and members
  #
  # See the [Redis Server ZSCAN documentation](https://redis.io/docs/latest/commands/zscan/) for further details
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:875
  def zscan_each(key, **options, &block); end

  # Get the score associated with the given member in a sorted set.
  #
  # @example Get the score for member "a"
  #   redis.zscore("zset", "a")
  #     # => 32.0
  #
  # @param [String] key
  # @param [String] member
  # @return [Float] score of the member
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:287
  def zscore(key, member); end

  # Return the union of multiple sorted sets
  #
  # @example Retrieve the union of `2*zsetA` and `1*zsetB`
  #   redis.zunion("zsetA", "zsetB", :weights => [2.0, 1.0])
  #     # => ["v1", "v2"]
  # @example Retrieve the union of `2*zsetA` and `1*zsetB`, and their scores
  #   redis.zunion("zsetA", "zsetB", :weights => [2.0, 1.0], :with_scores => true)
  #     # => [["v1", 3.0], ["v2", 6.0]]
  #
  # @param [String, Array<String>] keys one or more keys to union
  # @param [Hash] options
  #   - `:weights => [Array<Float>]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max)
  #   - `:with_scores => true`: include scores in output
  #
  # @return [Array<String>, Array<[String, Float]>]
  #   - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:778
  def zunion(*args, **_arg1); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  #
  # @example Compute the union of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zunionstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #     # => 8
  #
  # @param [String] destination destination key
  # @param [Array<String>] keys source keys
  # @param [Hash] options
  #   - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  # @return [Integer] number of elements in the resulting sorted set
  #
  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:796
  def zunionstore(*args, **_arg1); end

  private

  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:888
  def _zsets_operation(cmd, *keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/commands/sorted_sets.rb:907
  def _zsets_operation_store(cmd, destination, keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil)); end
end

# pkg:gem/redis#lib/redis/commands/streams.rb:5
module Redis::Commands::Streams
  # Removes one or multiple entries from the pending entries list of a stream consumer group.
  #
  # @example With a entry id
  #   redis.xack('mystream', 'mygroup', '1526569495631-0')
  # @example With splatted entry ids
  #   redis.xack('mystream', 'mygroup', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xack('mystream', 'mygroup', %w[0-1 0-2])
  #
  # @param key   [String]        the stream key
  # @param group [String]        the consumer group name
  # @param ids   [Array<String>] one or multiple entry ids
  #
  # @return [Integer] the number of entries successfully acknowledged
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:273
  def xack(key, group, *ids); end

  # Add new entry to the stream.
  #
  # @example Without options
  #   redis.xadd('mystream', f1: 'v1', f2: 'v2')
  # @example With options
  #   redis.xadd('mystream', { f1: 'v1', f2: 'v2' }, id: '0-0', maxlen: 1000, approximate: true, nomkstream: true)
  #
  # @param key   [String] the stream key
  # @param entry [Hash]   one or multiple field-value pairs
  # @param opts  [Hash]   several options for `XADD` command
  #
  # @option opts [String]  :id          the entry id, default value is `*`, it means auto generation
  # @option opts [Integer] :maxlen      max length of entries to keep
  # @option opts [Integer] :minid       min id of entries to keep
  # @option opts [Boolean] :approximate whether to add `~` modifier of maxlen/minid or not
  # @option opts [Boolean] :nomkstream  whether to add NOMKSTREAM, default is not to add
  #
  # @return [String] the entry id
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:50
  def xadd(key, entry, approximate: T.unsafe(nil), maxlen: T.unsafe(nil), minid: T.unsafe(nil), nomkstream: T.unsafe(nil), id: T.unsafe(nil)); end

  # Transfers ownership of pending stream entries that match the specified criteria.
  #
  # @example Claim next pending message stuck > 5 minutes  and mark as retry
  #   redis.xautoclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0')
  # @example Claim 50 next pending messages stuck > 5 minutes  and mark as retry
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0', count: 50)
  # @example Claim next pending message stuck > 5 minutes and don't mark as retry
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0', justid: true)
  # @example Claim next pending message after this id stuck > 5 minutes  and mark as retry
  #   redis.xautoclaim('mystream', 'mygroup', 'consumer1', 3600000, '1641321233-0')
  #
  # @param key           [String]        the stream key
  # @param group         [String]        the consumer group name
  # @param consumer      [String]        the consumer name
  # @param min_idle_time [Integer]       the number of milliseconds
  # @param start         [String]        entry id to start scanning from or 0-0 for everything
  # @param count         [Integer]       number of messages to claim (default 1)
  # @param justid        [Boolean]       whether to fetch just an array of entry ids or not.
  #                                      Does not increment retry count when true
  #
  # @return [Hash{String => Hash}] the entries successfully claimed
  # @return [Array<String>]        the entry ids successfully claimed if justid option is `true`
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:343
  def xautoclaim(key, group, consumer, min_idle_time, start, count: T.unsafe(nil), justid: T.unsafe(nil)); end

  # Changes the ownership of a pending entry
  #
  # @example With splatted entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2])
  # @example With idle option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], idle: 1000)
  # @example With time option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], time: 1542866959000)
  # @example With retrycount option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], retrycount: 10)
  # @example With force option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], force: true)
  # @example With justid option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], justid: true)
  #
  # @param key           [String]        the stream key
  # @param group         [String]        the consumer group name
  # @param consumer      [String]        the consumer name
  # @param min_idle_time [Integer]       the number of milliseconds
  # @param ids           [Array<String>] one or multiple entry ids
  # @param opts          [Hash]          several options for `XCLAIM` command
  #
  # @option opts [Integer] :idle       the number of milliseconds as last time it was delivered of the entry
  # @option opts [Integer] :time       the number of milliseconds as a specific Unix Epoch time
  # @option opts [Integer] :retrycount the number of retry counter
  # @option opts [Boolean] :force      whether to create the pending entry to the pending entries list or not
  # @option opts [Boolean] :justid     whether to fetch just an array of entry ids or not
  #
  # @return [Hash{String => Hash}] the entries successfully claimed
  # @return [Array<String>]        the entry ids successfully claimed if justid option is `true`
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:310
  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  # Delete entries by entry ids.
  #
  # @example With splatted entry ids
  #   redis.xdel('mystream', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xdel('mystream', ['0-1', '0-2'])
  #
  # @param key [String]        the stream key
  # @param ids [Array<String>] one or multiple entry ids
  #
  # @return [Integer] the number of entries actually deleted
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:113
  def xdel(key, *ids); end

  # Manages the consumer group of the stream.
  #
  # @example With `create` subcommand
  #   redis.xgroup(:create, 'mystream', 'mygroup', '$')
  # @example With `setid` subcommand
  #   redis.xgroup(:setid, 'mystream', 'mygroup', '$')
  # @example With `destroy` subcommand
  #   redis.xgroup(:destroy, 'mystream', 'mygroup')
  # @example With `delconsumer` subcommand
  #   redis.xgroup(:delconsumer, 'mystream', 'mygroup', 'consumer1')
  #
  # @param subcommand     [String] `create` `setid` `destroy` `delconsumer`
  # @param key            [String] the stream key
  # @param group          [String] the consumer group name
  # @param id_or_consumer [String]
  #   * the entry id or `$`, required if subcommand is `create` or `setid`
  #   * the consumer name, required if subcommand is `delconsumer`
  # @param mkstream [Boolean] whether to create an empty stream automatically or not
  #
  # @return [String] `OK` if subcommand is `create` or `setid`
  # @return [Integer] effected count if subcommand is `destroy` or `delconsumer`
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:221
  def xgroup(subcommand, key, group, id_or_consumer = T.unsafe(nil), mkstream: T.unsafe(nil)); end

  # Returns the stream information each subcommand.
  #
  # @example stream
  #   redis.xinfo(:stream, 'mystream')
  # @example groups
  #   redis.xinfo(:groups, 'mystream')
  # @example consumers
  #   redis.xinfo(:consumers, 'mystream', 'mygroup')
  #
  # @param subcommand [String] e.g. `stream` `groups` `consumers`
  # @param key        [String] the stream key
  # @param group      [String] the consumer group name, required if subcommand is `consumers`
  #
  # @return [Hash]        information of the stream if subcommand is `stream`
  # @return [Array<Hash>] information of the consumer groups if subcommand is `groups`
  # @return [Array<Hash>] information of the consumers if subcommand is `consumers`
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:22
  def xinfo(subcommand, key, group = T.unsafe(nil)); end

  # Returns the number of entries inside a stream.
  #
  # @example With key
  #   redis.xlen('mystream')
  #
  # @param key [String] the stream key
  #
  # @return [Integer] the number of entries
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:172
  def xlen(key); end

  # Fetches not acknowledging pending entries
  #
  # @example With key and group
  #   redis.xpending('mystream', 'mygroup')
  # @example With range options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10)
  # @example With range and idle time options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10, idle: 9000)
  # @example With range and consumer options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10, 'consumer1')
  #
  # @param key      [String]  the stream key
  # @param group    [String]  the consumer group name
  # @param start    [String]  start first entry id of range
  # @param end      [String]  end   last entry id of range
  # @param count    [Integer] count the number of entries as limit
  # @param consumer [String]  the consumer name
  #
  # @option opts [Integer] :idle       pending message minimum idle time in milliseconds
  #
  # @return [Hash]        the summary of pending entries
  # @return [Array<Hash>] the pending entries details if options were specified
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:375
  def xpending(key, group, *args, idle: T.unsafe(nil)); end

  # Fetches entries of the stream in ascending order.
  #
  # @example Without options
  #   redis.xrange('mystream')
  # @example With a specific start
  #   redis.xrange('mystream', '0-1')
  # @example With a specific start and end
  #   redis.xrange('mystream', '0-1', '0-3')
  # @example With count options
  #   redis.xrange('mystream', count: 10)
  #
  # @param key [String]  the stream key
  # @param start [String]  first entry id of range, default value is `-`
  # @param end [String]  last entry id of range, default value is `+`
  # @param count [Integer] the number of entries as limit
  #
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:135
  def xrange(key, start = T.unsafe(nil), range_end = T.unsafe(nil), count: T.unsafe(nil)); end

  # Fetches entries from one or multiple streams. Optionally blocking.
  #
  # @example With a key
  #   redis.xread('mystream', '0-0')
  # @example With multiple keys
  #   redis.xread(%w[mystream1 mystream2], %w[0-0 0-0])
  # @example With count option
  #   redis.xread('mystream', '0-0', count: 2)
  # @example With block option
  #   redis.xread('mystream', '$', block: 1000)
  #
  # @param keys  [Array<String>] one or multiple stream keys
  # @param ids   [Array<String>] one or multiple entry ids
  # @param count [Integer]       the number of entries as limit per stream
  # @param block [Integer]       the number of milliseconds as blocking timeout
  #
  # @return [Hash{String => Hash{String => Hash}}] the entries
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:193
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # Fetches a subset of the entries from one or multiple streams related with the consumer group.
  # Optionally blocking.
  #
  # @example With a key
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>')
  # @example With multiple keys
  #   redis.xreadgroup('mygroup', 'consumer1', %w[mystream1 mystream2], %w[> >])
  # @example With count option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', count: 2)
  # @example With block option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', block: 1000)
  # @example With noack option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', noack: true)
  #
  # @param group    [String]        the consumer group name
  # @param consumer [String]        the consumer name
  # @param keys     [Array<String>] one or multiple stream keys
  # @param ids      [Array<String>] one or multiple entry ids
  # @param opts     [Hash]          several options for `XREADGROUP` command
  #
  # @option opts [Integer] :count the number of entries as limit
  # @option opts [Integer] :block the number of milliseconds as blocking timeout
  # @option opts [Boolean] :noack whether message loss is acceptable or not
  #
  # @return [Hash{String => Hash{String => Hash}}] the entries
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:251
  def xreadgroup(group, consumer, keys, ids, count: T.unsafe(nil), block: T.unsafe(nil), noack: T.unsafe(nil)); end

  # Fetches entries of the stream in descending order.
  #
  # @example Without options
  #   redis.xrevrange('mystream')
  # @example With a specific end
  #   redis.xrevrange('mystream', '0-3')
  # @example With a specific end and start
  #   redis.xrevrange('mystream', '0-3', '0-1')
  # @example With count options
  #   redis.xrevrange('mystream', count: 10)
  #
  # @param key [String]  the stream key
  # @param end [String]  first entry id of range, default value is `+`
  # @param start [String]  last entry id of range, default value is `-`
  # @params count [Integer] the number of entries as limit
  #
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:158
  def xrevrange(key, range_end = T.unsafe(nil), start = T.unsafe(nil), count: T.unsafe(nil)); end

  # Trims older entries of the stream if needed.
  #
  # @example Without options
  #   redis.xtrim('mystream', 1000)
  # @example With options
  #   redis.xtrim('mystream', 1000, approximate: true)
  # @example With strategy
  #   redis.xtrim('mystream', '1-0', strategy: 'MINID')
  #
  # @overload xtrim(key, maxlen, strategy: 'MAXLEN', approximate: true)
  #   @param key         [String]  the stream key
  #   @param maxlen      [Integer] max length of entries
  #   @param strategy    [String]  the limit strategy, must be MAXLEN
  #   @param approximate [Boolean] whether to add `~` modifier of maxlen or not
  #   @param limit       [Integer] maximum count of entries to be evicted
  # @overload xtrim(key, minid, strategy: 'MINID', approximate: true)
  #   @param key         [String]  the stream key
  #   @param minid       [String]  minimum id of entries
  #   @param strategy    [String]  the limit strategy, must be MINID
  #   @param approximate [Boolean] whether to add `~` modifier of minid or not
  #   @param limit       [Integer] maximum count of entries to be evicted
  #
  # @return [Integer] the number of entries actually deleted
  #
  # pkg:gem/redis#lib/redis/commands/streams.rb:92
  def xtrim(key, len_or_id, strategy: T.unsafe(nil), approximate: T.unsafe(nil), limit: T.unsafe(nil)); end

  private

  # pkg:gem/redis#lib/redis/commands/streams.rb:392
  def _xread(args, keys, ids, blocking_timeout_msec); end
end

# pkg:gem/redis#lib/redis/commands/strings.rb:5
module Redis::Commands::Strings
  # Append a value to a key.
  #
  # @param [String] key
  # @param [String] value value to append
  # @return [Integer] length of the string after appending
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:255
  def append(key, value); end

  # Decrement the integer value of a key by one.
  #
  # @example
  #   redis.decr("value")
  #     # => 4
  #
  # @param [String] key
  # @return [Integer] value after decrementing it
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:14
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  #
  # @example
  #   redis.decrby("value", 5)
  #     # => 0
  #
  # @param [String] key
  # @param [Integer] decrement
  # @return [Integer] value after decrementing it
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:27
  def decrby(key, decrement); end

  # Get the value of a key.
  #
  # @param [String] key
  # @return [String]
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:190
  def get(key); end

  # Get the value of key and delete the key. This command is similar to GET,
  # except for the fact that it also deletes the key on success.
  #
  # @param [String] key
  # @return [String] the old value stored in the key, or `nil` if the key
  #   did not exist
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:275
  def getdel(key); end

  # Get the value of key and optionally set its expiration. GETEX is similar to
  # GET, but is a write command with additional options. When no options are
  # provided, GETEX behaves like GET.
  #
  # @param [String] key
  # @param [Hash] options
  #   - `:ex => Integer`: Set the specified expire time, in seconds.
  #   - `:px => Integer`: Set the specified expire time, in milliseconds.
  #   - `:exat => true`: Set the specified Unix time at which the key will
  #      expire, in seconds.
  #   - `:pxat => true`: Set the specified Unix time at which the key will
  #      expire, in milliseconds.
  #   - `:persist => true`: Remove the time to live associated with the key.
  # @return [String] The value of key, or nil when key does not exist.
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:293
  def getex(key, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), persist: T.unsafe(nil)); end

  # Get a substring of the string stored at a key.
  #
  # @param [String] key
  # @param [Integer] start zero-based start offset
  # @param [Integer] stop zero-based end offset. Use -1 for representing
  #   the end of the string
  # @return [Integer] `0` or `1`
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:246
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  #
  # @param [String] key
  # @param [String] value value to replace the current value with
  # @return [String] the old value stored in the key, or `nil` if the key
  #   did not exist
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:265
  def getset(key, value); end

  # Increment the integer value of a key by one.
  #
  # @example
  #   redis.incr("value")
  #     # => 6
  #
  # @param [String] key
  # @return [Integer] value after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:39
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  #
  # @example
  #   redis.incrby("value", 5)
  #     # => 10
  #
  # @param [String] key
  # @param [Integer] increment
  # @return [Integer] value after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:52
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  #
  # @example
  #   redis.incrbyfloat("value", 1.23)
  #     # => 1.23
  #
  # @param [String] key
  # @param [Float] increment
  # @return [Float] value after incrementing it
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:65
  def incrbyfloat(key, increment); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mapped_mget("key1", "key2")
  #     # => { "key1" => "v1", "key2" => "v2" }
  #
  # @param [Array<String>] keys array of keys
  # @return [Hash] a hash mapping the specified keys to their values
  #
  # @see #mget
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:219
  def mapped_mget(*keys); end

  # Set one or more values.
  #
  # @example
  #   redis.mapped_mset({ "f1" => "v1", "f2" => "v2" })
  #     # => "OK"
  #
  # @param [Hash] hash keys mapping to values
  # @return [String] `"OK"`
  #
  # @see #mset
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:154
  def mapped_mset(hash); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.mapped_msetnx({ "key1" => "v1", "key2" => "v2" })
  #     # => true
  #
  # @param [Hash] hash keys mapping to values
  # @return [Boolean] whether or not all values were set
  #
  # @see #msetnx
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:182
  def mapped_msetnx(hash); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mget("key1", "key2")
  #     # => ["v1", "v2"]
  #
  # @param [Array<String>] keys
  # @return [Array<String>] an array of values for the specified keys
  #
  # @see #mapped_mget
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:204
  def mget(*keys, &blk); end

  # Set one or more values.
  #
  # @example
  #   redis.mset("key1", "v1", "key2", "v2")
  #     # => "OK"
  #
  # @param [Array<String>] args array of keys and values
  # @return [String] `"OK"`
  #
  # @see #mapped_mset
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:140
  def mset(*args); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.msetnx("key1", "v1", "key2", "v2")
  #     # => true
  #
  # @param [Array<String>] args array of keys and values
  # @return [Boolean] whether or not all values were set
  #
  # @see #mapped_msetnx
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:168
  def msetnx(*args); end

  # Set the time to live in milliseconds of a key.
  #
  # @param [String] key
  # @param [Integer] ttl
  # @param [String] value
  # @return [String] `"OK"`
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:117
  def psetex(key, ttl, value); end

  # Set the string value of a key.
  #
  # @param [String] key
  # @param [String] value
  # @param [Hash] options
  #   - `:ex => Integer`: Set the specified expire time, in seconds.
  #   - `:px => Integer`: Set the specified expire time, in milliseconds.
  #   - `:exat => Integer` : Set the specified Unix time at which the key will expire, in seconds.
  #   - `:pxat => Integer` : Set the specified Unix time at which the key will expire, in milliseconds.
  #   - `:nx => true`: Only set the key if it does not already exist.
  #   - `:xx => true`: Only set the key if it already exist.
  #   - `:keepttl => true`: Retain the time to live associated with the key.
  #   - `:get => true`: Return the old string stored at key, or nil if key did not exist.
  # @return [String, Boolean] `"OK"` or true, false if `:nx => true` or `:xx => true`
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:83
  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil), get: T.unsafe(nil)); end

  # Set the time to live in seconds of a key.
  #
  # @param [String] key
  # @param [Integer] ttl
  # @param [String] value
  # @return [String] `"OK"`
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:107
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  #
  # @param [String] key
  # @param [String] value
  # @return [Boolean] whether the key was set or not
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:126
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  #
  # @param [String] key
  # @param [Integer] offset byte offset
  # @param [String] value
  # @return [Integer] length of the string after it was modified
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:235
  def setrange(key, offset, value); end

  # Get the length of the value stored in a key.
  #
  # @param [String] key
  # @return [Integer] the length of the value stored in the key, or 0
  #   if the key does not exist
  #
  # pkg:gem/redis#lib/redis/commands/strings.rb:309
  def strlen(key); end
end

# pkg:gem/redis#lib/redis/commands/transactions.rb:5
module Redis::Commands::Transactions
  # Discard all commands issued after MULTI.
  #
  # @return [String] `"OK"`
  #
  # @see #multi
  # @see #exec
  #
  # pkg:gem/redis#lib/redis/commands/transactions.rb:110
  def discard; end

  # Execute all commands issued after MULTI.
  #
  # Only call this method when `#multi` was called **without** a block.
  #
  # @return [nil, Array<...>]
  #   - when commands were not executed, `nil`
  #   - when commands were executed, an array with their replies
  #
  # @see #multi
  # @see #discard
  #
  # pkg:gem/redis#lib/redis/commands/transactions.rb:100
  def exec; end

  # Mark the start of a transaction block.
  #
  # @example With a block
  #   redis.multi do |multi|
  #     multi.set("key", "value")
  #     multi.incr("counter")
  #   end # => ["OK", 6]
  #
  # @yield [multi] the commands that are called inside this block are cached
  #   and written to the server upon returning from it
  # @yieldparam [Redis] multi `self`
  #
  # @return [Array<...>]
  #   - an array with replies
  #
  # @see #watch
  # @see #unwatch
  #
  # pkg:gem/redis#lib/redis/commands/transactions.rb:23
  def multi; end

  # Forget about all watched keys.
  #
  # @return [String] `OK`
  #
  # @see #watch
  # @see #multi
  #
  # pkg:gem/redis#lib/redis/commands/transactions.rb:86
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  #
  # Using a block is optional, but is necessary for thread-safety.
  #
  # An `#unwatch` is automatically issued if an exception is raised within the
  # block that is a subclass of StandardError and is not a ConnectionError.
  #
  # @example With a block
  #   redis.watch("key") do
  #     if redis.get("key") == "some value"
  #       redis.multi do |multi|
  #         multi.set("key", "other value")
  #         multi.incr("counter")
  #       end
  #     else
  #       redis.unwatch
  #     end
  #   end
  #     # => ["OK", 6]
  #
  # @example Without a block
  #   redis.watch("key")
  #     # => "OK"
  #
  # @param [String, Array<String>] keys one or more keys to watch
  # @return [Object] if using a block, returns the return value of the block
  # @return [String] if not using a block, returns `OK`
  #
  # @see #unwatch
  # @see #multi
  #
  # pkg:gem/redis#lib/redis/commands/transactions.rb:61
  def watch(*keys); end
end

# soft-deprecated
# We added this back for older sidekiq releases
#
# pkg:gem/redis#lib/redis.rb:27
module Redis::Connection
  class << self
    # pkg:gem/redis#lib/redis.rb:29
    def drivers; end
  end
end

# Raised when connection to a Redis server is lost.
#
# pkg:gem/redis#lib/redis/errors.rb:41
class Redis::ConnectionError < ::Redis::BaseConnectionError; end

# pkg:gem/redis#lib/redis.rb:9
class Redis::Deprecated < ::StandardError; end

# pkg:gem/redis#lib/redis/distributed.rb:6
class Redis::Distributed
  # pkg:gem/redis#lib/redis/distributed.rb:20
  def initialize(node_configs, options = T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/distributed.rb:410
  def [](key); end

  # pkg:gem/redis#lib/redis/distributed.rb:414
  def []=(key, value); end

  # pkg:gem/redis#lib/redis/distributed.rb:476
  def _bpop(cmd, args); end

  # pkg:gem/redis#lib/redis/distributed.rb:1042
  def _eval(cmd, args); end

  # pkg:gem/redis#lib/redis/distributed.rb:41
  def add_node(options); end

  # Append a value to a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:378
  def append(key, value); end

  # Asynchronously save the dataset to disk.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:74
  def bgsave; end

  # Count the number of set bits in a range of the string value stored at key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:383
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil), scale: T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:388
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:396
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil), scale: T.unsafe(nil)); end

  # Remove the first/last element in a list and append/prepend it
  # to another list and return it, or block until one is available.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:432
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # Iterate over keys, blocking and removing elements from the first non empty liist found.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:556
  def blmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is
  # available.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:495
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is
  # available.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:513
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:519
  def brpoplpush(source, destination, **options); end

  # Iterate over keys, blocking and removing members from the first non empty sorted set found.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:722
  def bzmpop(timeout, *keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/distributed.rb:499
  def bzpopmax(*args); end

  # pkg:gem/redis#lib/redis/distributed.rb:505
  def bzpopmin(*args); end

  # pkg:gem/redis#lib/redis/distributed.rb:69
  def close; end

  # Copy a value from one key to another.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:226
  def copy(source, destination, **options); end

  # Return the number of keys in the selected database.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:79
  def dbsize; end

  # Decrement the integer value of a key by one.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:266
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:271
  def decrby(key, decrement); end

  # Delete a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:179
  def del(*args); end

  # Discard all commands issued after MULTI.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1009
  def discard; end

  # Return a serialized version of the value stored at a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:164
  def dump(key); end

  # pkg:gem/redis#lib/redis/distributed.rb:1069
  def dup; end

  # Echo the given string.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:60
  def echo(value); end

  # Evaluate Lua script.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1056
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1061
  def evalsha(*args); end

  # Execute all commands issued after MULTI.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1000
  def exec; end

  # Determine if a key exists.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:197
  def exists(*args); end

  # Determine if any of the keys exists.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:206
  def exists?(*args); end

  # Set a key's time to live in seconds.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:124
  def expire(key, seconds, **kwargs); end

  # Set the expiration for a key as a UNIX timestamp.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:129
  def expireat(key, unix_time, **kwargs); end

  # Get the expiration for a key as a UNIX timestamp.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:134
  def expiretime(key); end

  # Remove all keys from all databases.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:84
  def flushall; end

  # Remove all keys from the current database.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:89
  def flushdb; end

  # Get the value of a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:329
  def get(key); end

  # Returns the bit value at offset in the string value stored at key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:373
  def getbit(key, offset); end

  # Get the value of a key and delete it.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:334
  def getdel(key); end

  # Get the value of a key and sets its time to live based on options.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:339
  def getex(key, **options); end

  # Get a substring of the string stored at a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:363
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:401
  def getset(key, value); end

  # Delete one or more hash fields.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:886
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:892
  def hexists(key, field); end

  # Get the value of a hash field.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:866
  def hget(key, field); end

  # Get all the fields and values in a hash.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:917
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:897
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:902
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:907
  def hkeys(key); end

  # Get the number of fields in a hash.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:842
  def hlen(key); end

  # Get the values of all the given hash fields.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:871
  def hmget(key, *fields); end

  # Set multiple hash fields to multiple values.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:857
  def hmset(key, *attrs); end

  # pkg:gem/redis#lib/redis/distributed.rb:881
  def hrandfield(key, count = T.unsafe(nil), **options); end

  # Set multiple hash fields to multiple values.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:847
  def hset(key, *attrs); end

  # Set the value of a hash field, only if the field does not exist.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:852
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:912
  def hvals(key); end

  # Increment the integer value of a key by one.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:276
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:281
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:286
  def incrbyfloat(key, increment); end

  # Get information and statistics about the server.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:94
  def info(cmd = T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/distributed.rb:1065
  def inspect; end

  # Find all keys matching the given pattern.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:216
  def keys(glob = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:99
  def lastsave; end

  # Get an element from a list by its index.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:526
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:531
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:419
  def llen(key); end

  # Remove the first/last element in a list, append/prepend it to another list and return it.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:424
  def lmove(source, destination, where_source, where_destination); end

  # Iterate over keys, removing elements from the first non list found.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:563
  def lmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Remove and get the first elements in a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:459
  def lpop(key, count = T.unsafe(nil)); end

  # Prepend one or more values to a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:439
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:444
  def lpushx(key, value); end

  # Get a range of elements from a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:536
  def lrange(key, start, stop); end

  # Remove elements from a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:541
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:546
  def lset(key, index, value); end

  # Trim a list to the specified range.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:551
  def ltrim(key, start, stop); end

  # pkg:gem/redis#lib/redis/distributed.rb:876
  def mapped_hmget(key, *fields); end

  # pkg:gem/redis#lib/redis/distributed.rb:861
  def mapped_hmset(key, hash); end

  # Get the values of all the given keys as a Hash.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:350
  def mapped_mget(*keys); end

  # pkg:gem/redis#lib/redis/distributed.rb:315
  def mapped_mset(_hash); end

  # pkg:gem/redis#lib/redis/distributed.rb:324
  def mapped_msetnx(_hash); end

  # Get the values of all the given keys as an Array.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:344
  def mget(*keys); end

  # Transfer a key from the connected instance to another instance.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:174
  def migrate(_key, _options); end

  # Listen for all requests received by the server in real time.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:104
  def monitor; end

  # Move a key to another database.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:221
  def move(key, db); end

  # Set multiple keys to multiple values.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:311
  def mset(*_arg0); end

  # Set multiple keys to multiple values, only if none of the keys exist.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:320
  def msetnx(*_arg0); end

  # Mark the start of a transaction block.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:993
  def multi(&block); end

  # pkg:gem/redis#lib/redis/distributed.rb:30
  def node_for(key); end

  # pkg:gem/redis#lib/redis/distributed.rb:37
  def nodes; end

  # Remove the expiration from a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:119
  def persist(key); end

  # Set a key's time to live in milliseconds.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:144
  def pexpire(key, milliseconds, **kwarg); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:149
  def pexpireat(key, ms_unix_time, **kwarg); end

  # Get the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:154
  def pexpiretime(key); end

  # Add one or more members to a HyperLogLog structure.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1023
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1028
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1036
  def pfmerge(dest_key, *source_key); end

  # Ping the server.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:55
  def ping; end

  # pkg:gem/redis#lib/redis/distributed.rb:988
  def pipelined; end

  # Set the time to live in milliseconds of a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:301
  def psetex(key, ttl, value); end

  # Listen for messages published to channels matching the given patterns.
  # See the [Redis Server PSUBSCRIBE documentation](https://redis.io/docs/latest/commands/psubscribe/)
  # for further details
  #
  # pkg:gem/redis#lib/redis/distributed.rb:953
  def psubscribe(*channels, &block); end

  # Get the time to live (in milliseconds) for a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:159
  def pttl(key); end

  # Post a message to a channel.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:922
  def publish(channel, message); end

  # Stop listening for messages posted to channels matching the given
  # patterns.
  # See the [Redis Server PUNSUBSCRIBE documentation](https://redis.io/docs/latest/commands/punsubscribe/)
  # for further details
  #
  # pkg:gem/redis#lib/redis/distributed.rb:961
  def punsubscribe(*channels); end

  # Close the connection.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:65
  def quit; end

  # Return a random key from the keyspace.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:233
  def randomkey; end

  # Rename a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:238
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:245
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:169
  def restore(key, ttl, serialized_value, **options); end

  # pkg:gem/redis#lib/redis/distributed.rb:18
  def ring; end

  # Remove and get the last elements in a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:464
  def rpop(key, count = T.unsafe(nil)); end

  # Remove the last element in a list, append it to another list and return
  # it.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:470
  def rpoplpush(source, destination); end

  # Append one or more values to a list.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:449
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:454
  def rpushx(key, value); end

  # Add one or more members to a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:575
  def sadd(key, *members); end

  # Add one or more members to a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:580
  def sadd?(key, *members); end

  # Synchronously save the dataset to disk.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:109
  def save; end

  # Get the number of members in a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:570
  def scard(key); end

  # Control remote script registry.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:1018
  def script(subcommand, *args); end

  # Subtract multiple sets.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:637
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:645
  def sdiffstore(destination, *keys); end

  # Change the selected database for the current connection.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:50
  def select(db); end

  # Set the string value of a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:291
  def set(key, value, **options); end

  # Sets or clears the bit at offset in the string value stored at key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:368
  def setbit(key, offset, value); end

  # Set the time to live in seconds of a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:296
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:306
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:358
  def setrange(key, offset, value); end

  # Intersect multiple sets.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:653
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:661
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:612
  def sismember(key, member); end

  # Get all the members in a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:622
  def smembers(key); end

  # Determine if multiple values are members of a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:617
  def smismember(key, *members); end

  # Move a member from one set to another.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:605
  def smove(source, destination, member); end

  # Sort the elements in a list, set or sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:252
  def sort(key, **options); end

  # Remove and return a random member from a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:595
  def spop(key, count = T.unsafe(nil)); end

  # Get a random member from a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:600
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:585
  def srem(key, *members); end

  # Remove one or more members from a set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:590
  def srem?(key, *members); end

  # Scan a set
  #
  # pkg:gem/redis#lib/redis/distributed.rb:627
  def sscan(key, cursor, **options); end

  # Scan a set and return an enumerator
  #
  # pkg:gem/redis#lib/redis/distributed.rb:632
  def sscan_each(key, **options, &block); end

  # Get the length of the value stored in a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:406
  def strlen(key); end

  # Listen for messages published to the given channels.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:931
  def subscribe(channel, *channels, &block); end

  # pkg:gem/redis#lib/redis/distributed.rb:926
  def subscribed?; end

  # Add multiple sets.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:669
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:677
  def sunionstore(destination, *keys); end

  # Get server time: an UNIX timestamp and the elapsed microseconds in the current second.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:114
  def time; end

  # Get the time to live (in seconds) for a key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:139
  def ttl(key); end

  # Determine the type stored at key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:261
  def type(key); end

  # Unlink keys.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:188
  def unlink(*args); end

  # Stop listening for messages posted to the given channels.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:944
  def unsubscribe(*channels); end

  # Forget about all watched keys.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:980
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:966
  def watch(*keys, &block); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:691
  def zadd(key, *args, **_arg2); end

  # Get the number of members in a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:685
  def zcard(key); end

  # Get the number of members in a particular score range.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:787
  def zcount(key, min, max); end

  # Return the difference between the first and all successive input sorted sets.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:825
  def zdiff(*keys, **options); end

  # Compute the difference between the first and all successive input sorted sets
  # and store the resulting sorted set in a new key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:834
  def zdiffstore(destination, *keys, **options); end

  # Increment the score of a member in a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:697
  def zincrby(key, increment, member); end

  # Get the intersection of multiple sorted sets
  #
  # pkg:gem/redis#lib/redis/distributed.rb:792
  def zinter(*keys, **options); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:801
  def zinterstore(destination, *keys, **options); end

  # Iterate over keys, removing members from the first non empty sorted set found.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:729
  def zmpop(*keys, modifier: T.unsafe(nil), count: T.unsafe(nil)); end

  # Get the scores associated with the given members in a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:717
  def zmscore(key, *members); end

  # Get one or more random members from a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:712
  def zrandmember(key, count = T.unsafe(nil), **options); end

  # Return a range of members in a sorted set, by index, score or lexicographical ordering.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:736
  def zrange(key, start, stop, **options); end

  # Return a range of members in a sorted set, by score.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:771
  def zrangebyscore(key, min, max, **options); end

  # Select a range of members in a sorted set, by index, score or lexicographical ordering
  # and store the resulting sorted set in a new key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:742
  def zrangestore(dest_key, src_key, start, stop, **options); end

  # Determine the index of a member in a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:755
  def zrank(key, member, **options); end

  # Remove one or more members from a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:702
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:766
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:782
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:750
  def zrevrange(key, start, stop, **options); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:777
  def zrevrangebyscore(key, max, min, **options); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:761
  def zrevrank(key, member, **options); end

  # Get the score associated with the given member in a sorted set.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:707
  def zscore(key, member); end

  # Return the union of multiple sorted sets.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:809
  def zunion(*keys, **options); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  #
  # pkg:gem/redis#lib/redis/distributed.rb:817
  def zunionstore(destination, *keys, **options); end

  protected

  # pkg:gem/redis#lib/redis/distributed.rb:1090
  def ensure_same_node(command, keys); end

  # pkg:gem/redis#lib/redis/distributed.rb:1085
  def key_tag(key); end

  # pkg:gem/redis#lib/redis/distributed.rb:1081
  def node_index_for(key); end

  # pkg:gem/redis#lib/redis/distributed.rb:1075
  def on_each_node(command, *args); end
end

# pkg:gem/redis#lib/redis/distributed.rb:7
class Redis::Distributed::CannotDistribute < ::RuntimeError
  # pkg:gem/redis#lib/redis/distributed.rb:8
  def initialize(command); end

  # pkg:gem/redis#lib/redis/distributed.rb:12
  def message; end
end

# pkg:gem/redis#lib/redis/pipeline.rb:80
class Redis::Future < ::BasicObject
  # pkg:gem/redis#lib/redis/pipeline.rb:83
  def initialize(command, coerce, exception); end

  # pkg:gem/redis#lib/redis/pipeline.rb:94
  def _set(object); end

  # pkg:gem/redis#lib/redis/pipeline.rb:108
  def class; end

  # pkg:gem/redis#lib/redis/pipeline.rb:90
  def inspect; end

  # pkg:gem/redis#lib/redis/pipeline.rb:104
  def is_a?(other); end

  # pkg:gem/redis#lib/redis/pipeline.rb:99
  def value; end
end

# pkg:gem/redis#lib/redis/pipeline.rb:81
Redis::Future::FutureNotReady = T.let(T.unsafe(nil), Redis::FutureNotReady)

# pkg:gem/redis#lib/redis/pipeline.rb:74
class Redis::FutureNotReady < ::RuntimeError
  # pkg:gem/redis#lib/redis/pipeline.rb:75
  def initialize; end
end

# pkg:gem/redis#lib/redis/hash_ring.rb:7
class Redis::HashRing
  # nodes is a list of objects that have a proper to_s representation.
  # replicas indicates how many virtual points should be used pr. node,
  # replicas are required to improve the distribution.
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:15
  def initialize(nodes = T.unsafe(nil), replicas = T.unsafe(nil)); end

  # Adds a `node` to the hash ring (including a number of replicas).
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:26
  def add_node(node); end

  # get the node in the hash ring for this key
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:46
  def get_node(key); end

  # pkg:gem/redis#lib/redis/hash_ring.rb:52
  def iter_nodes(key); end

  # this is the default in libmemcached
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:10
  def nodes; end

  # pkg:gem/redis#lib/redis/hash_ring.rb:36
  def remove_node(node); end

  # this is the default in libmemcached
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:10
  def replicas; end

  # this is the default in libmemcached
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:10
  def ring; end

  # this is the default in libmemcached
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:10
  def sorted_keys; end

  private

  # Find the closest index in HashRing with value <= the given value
  #
  # pkg:gem/redis#lib/redis/hash_ring.rb:73
  def binary_search(ary, value); end

  # pkg:gem/redis#lib/redis/hash_ring.rb:64
  def hash_for(key); end

  # pkg:gem/redis#lib/redis/hash_ring.rb:68
  def server_hash_for(key); end
end

# pkg:gem/redis#lib/redis/hash_ring.rb:8
Redis::HashRing::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)

# Raised when the connection was inherited by a child process.
#
# pkg:gem/redis#lib/redis/errors.rb:49
class Redis::InheritedError < ::Redis::BaseConnectionError; end

# Raised when client options are invalid.
#
# pkg:gem/redis#lib/redis/errors.rb:57
class Redis::InvalidClientOptionError < ::Redis::BaseError; end

# pkg:gem/redis#lib/redis/pipeline.rb:59
class Redis::MultiConnection < ::Redis::PipelinedConnection
  # pkg:gem/redis#lib/redis/pipeline.rb:60
  def multi; end

  private

  # Blocking commands inside transaction behave like non-blocking.
  # It shouldn't be done though.
  # https://redis.io/commands/blpop/#blpop-inside-a-multi--exec-transaction
  #
  # pkg:gem/redis#lib/redis/pipeline.rb:69
  def send_blocking_command(command, _timeout, &block); end
end

# pkg:gem/redis#lib/redis/pipeline.rb:113
class Redis::MultiFuture < ::Redis::Future
  # pkg:gem/redis#lib/redis/pipeline.rb:114
  def initialize(futures); end

  # pkg:gem/redis#lib/redis/pipeline.rb:120
  def _set(replies); end
end

# pkg:gem/redis#lib/redis/errors.rb:29
class Redis::OutOfMemoryError < ::Redis::CommandError; end

# pkg:gem/redis#lib/redis/errors.rb:23
class Redis::PermissionError < ::Redis::CommandError; end

# pkg:gem/redis#lib/redis/pipeline.rb:6
class Redis::PipelinedConnection
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  # pkg:gem/redis#lib/redis/pipeline.rb:9
  def initialize(pipeline, futures = T.unsafe(nil), exception: T.unsafe(nil)); end

  # pkg:gem/redis#lib/redis/pipeline.rb:7
  def db; end

  # pkg:gem/redis#lib/redis/pipeline.rb:7
  def db=(_arg0); end

  # pkg:gem/redis#lib/redis/pipeline.rb:21
  def multi; end

  # pkg:gem/redis#lib/redis/pipeline.rb:17
  def pipelined; end

  private

  # pkg:gem/redis#lib/redis/pipeline.rb:49
  def send_blocking_command(command, timeout, &block); end

  # pkg:gem/redis#lib/redis/pipeline.rb:40
  def send_command(command, &block); end

  # pkg:gem/redis#lib/redis/pipeline.rb:36
  def synchronize; end
end

# Raised by the connection when a protocol error occurs.
#
# pkg:gem/redis#lib/redis/errors.rb:9
class Redis::ProtocolError < ::Redis::BaseError
  # pkg:gem/redis#lib/redis/errors.rb:10
  def initialize(reply_type); end
end

# Generally raised during Redis failover scenarios
#
# pkg:gem/redis#lib/redis/errors.rb:53
class Redis::ReadOnlyError < ::Redis::BaseConnectionError; end

# pkg:gem/redis#lib/redis.rb:37
Redis::SERVER_URL_OPTIONS = T.let(T.unsafe(nil), Array)

# pkg:gem/redis#lib/redis/subscribe.rb:4
class Redis::SubscribedClient
  # pkg:gem/redis#lib/redis/subscribe.rb:5
  def initialize(client); end

  # pkg:gem/redis#lib/redis/subscribe.rb:10
  def call_v(command); end

  # pkg:gem/redis#lib/redis/subscribe.rb:52
  def close; end

  # pkg:gem/redis#lib/redis/subscribe.rb:24
  def psubscribe(*channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:28
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:44
  def punsubscribe(*channels); end

  # pkg:gem/redis#lib/redis/subscribe.rb:32
  def ssubscribe(*channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:36
  def ssubscribe_with_timeout(timeout, *channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:16
  def subscribe(*channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:20
  def subscribe_with_timeout(timeout, *channels, &block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:48
  def sunsubscribe(*channels); end

  # pkg:gem/redis#lib/redis/subscribe.rb:40
  def unsubscribe(*channels); end

  protected

  # pkg:gem/redis#lib/redis/subscribe.rb:58
  def subscription(start, stop, channels, block, timeout = T.unsafe(nil)); end
end

# pkg:gem/redis#lib/redis/subscribe.rb:82
class Redis::Subscription
  # pkg:gem/redis#lib/redis/subscribe.rb:85
  def initialize; end

  # pkg:gem/redis#lib/redis/subscribe.rb:83
  def callbacks; end

  # pkg:gem/redis#lib/redis/subscribe.rb:98
  def message(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:110
  def pmessage(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:102
  def psubscribe(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:106
  def punsubscribe(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:122
  def smessage(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:114
  def ssubscribe(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:90
  def subscribe(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:118
  def sunsubscribe(&block); end

  # pkg:gem/redis#lib/redis/subscribe.rb:94
  def unsubscribe(&block); end
end

# pkg:gem/redis#lib/redis/errors.rb:60
class Redis::SubscriptionError < ::Redis::BaseError; end

# Raised when performing I/O times out.
#
# pkg:gem/redis#lib/redis/errors.rb:45
class Redis::TimeoutError < ::Redis::BaseConnectionError; end

# pkg:gem/redis#lib/redis/version.rb:4
Redis::VERSION = T.let(T.unsafe(nil), String)

# pkg:gem/redis#lib/redis/errors.rb:26
class Redis::WrongTypeError < ::Redis::CommandError; end
