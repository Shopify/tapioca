# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prism` gem.
# Please instead update this file by running `bin/tapioca gem prism`.


# typed: strict

# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/dsl.rbi.erb
# if you are looking to modify the template
# =end
# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/node.rbi.erb
# if you are looking to modify the template
# =end
# =begin
# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/rbi/prism/visitor.rbi.erb
# if you are looking to modify the template
# =end

# We keep these shims in here because our client libraries might not have parser
# in their bundle.
module Parser; end

class Parser::Base; end

# pkg:gem/prism#lib/prism/translation/parser.rb:30
class Parser::Diagnostic; end

# The Prism Ruby parser.
#
# "Parsing Ruby is suddenly manageable!"
#   - You, hopefully
#
# pkg:gem/prism#lib/prism.rb:9
module Prism
  class << self
    # Mirror the Prism.dump API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def dump(*_arg0); end

    # Mirror the Prism.dump_file API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def dump_file(*_arg0); end

    # Mirror the Prism.lex API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def lex(*_arg0); end

    # :call-seq:
    #   Prism::lex_compat(source, **options) -> LexCompat::Result
    #
    # Returns a parse result whose value is an array of tokens that closely
    # resembles the return value of Ripper::lex. The main difference is that the
    # `:on_sp` token is not emitted.
    #
    # For supported options, see Prism::parse.
    #
    # pkg:gem/prism#lib/prism.rb:68
    sig { params(source: String, options: T::Hash[Symbol, T.untyped]).returns(Prism::LexCompat::Result) }
    def lex_compat(source, **options); end

    # Mirror the Prism.lex_file API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def lex_file(*_arg0); end

    # :call-seq:
    #   Prism::lex_ripper(source) -> Array
    #
    # This lexes with the Ripper lex. It drops any space events but otherwise
    # returns the same tokens. Raises SyntaxError if the syntax in source is
    # invalid.
    #
    # pkg:gem/prism#lib/prism.rb:78
    sig { params(source: String).returns(T::Array[T.untyped]) }
    def lex_ripper(source); end

    # :call-seq:
    #   Prism::load(source, serialized, freeze) -> ParseResult
    #
    # Load the serialized AST using the source as a reference into a tree.
    #
    # pkg:gem/prism#lib/prism.rb:86
    sig { params(source: String, serialized: String, freeze: T.nilable(T::Boolean)).returns(Prism::ParseResult) }
    def load(source, serialized, freeze = T.unsafe(nil)); end

    # Mirror the Prism.parse API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse(*_arg0); end

    # Mirror the Prism.parse_comments API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_comments(*_arg0); end

    # Mirror the Prism.parse_failure? API by using the serialization API.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_failure?(*_arg0); end

    # Mirror the Prism.parse_file API by using the serialization API. This uses
    # native strings instead of Ruby strings because it allows us to use mmap
    # when it is available.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_file(*_arg0); end

    # Mirror the Prism.parse_file_comments API by using the serialization
    # API. This uses native strings instead of Ruby strings because it allows us
    # to use mmap when it is available.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_file_comments(*_arg0); end

    # Mirror the Prism.parse_file_failure? API by using the serialization API.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_file_failure?(*_arg0); end

    # Mirror the Prism.parse_file_success? API by using the serialization API.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_file_success?(*_arg0); end

    # Mirror the Prism.parse_lex API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_lex(*_arg0); end

    # Mirror the Prism.parse_lex_file API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_lex_file(*_arg0); end

    # Mirror the Prism.parse_stream API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_stream(*_arg0); end

    # Mirror the Prism.parse_success? API by using the serialization API.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def parse_success?(*_arg0); end

    # Mirror the Prism.profile API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def profile(*_arg0); end

    # Mirror the Prism.profile_file API by using the serialization API.
    #
    # pkg:gem/prism#lib/prism.rb:105
    def profile_file(*_arg0); end

    # Create a new scope with the given locals and forwarding options that is
    # suitable for passing into one of the Prism.* methods that accepts the
    # `scopes` option.
    #
    # pkg:gem/prism#lib/prism/parse_result.rb:895
    sig { params(locals: T::Array[Symbol], forwarding: T::Array[Symbol]).returns(Prism::Scope) }
    def scope(locals: T.unsafe(nil), forwarding: T.unsafe(nil)); end
  end
end

# Specialized version of Prism::Source for source code that includes ASCII
# characters only. This class is used to apply performance optimizations that
# cannot be applied to sources that include multibyte characters.
#
# In the extremely rare case that a source includes multi-byte characters but
# is marked as binary because of a magic encoding comment and it cannot be
# eagerly converted to UTF-8, this class will be used as well. This is because
# at that point we will treat everything as single-byte characters.
#
# pkg:gem/prism#lib/prism/parse_result.rb:241
class Prism::ASCIISource < ::Prism::Source
  # Return the column number in characters for the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:248
  sig { params(byte_offset: Integer).returns(Integer) }
  def character_column(byte_offset); end

  # Return the character offset for the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:243
  sig { params(byte_offset: Integer).returns(Integer) }
  def character_offset(byte_offset); end

  # Returns a cache that is the identity function in order to maintain the
  # same interface. We can do this because code units are always equivalent to
  # byte offsets for ASCII-only sources.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:265
  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  # Specialized version of `code_units_column` that does not depend on
  # `code_units_offset`, which is a more expensive operation. This is
  # essentially the same as `Prism::Source#column`.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:272
  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_column(byte_offset, encoding); end

  # Returns the offset from the start of the file for the given byte offset
  # counting in code units for the given encoding.
  #
  # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
  # concept of code units that differs from the number of characters in other
  # encodings, it is not captured here.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:258
  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_offset(byte_offset, encoding); end
end

# Represents the use of the `alias` keyword to alias a global variable.
#
#     alias $foo $bar
#     ^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:319
class Prism::AliasGlobalVariableNode < ::Prism::Node
  # Initialize a new AliasGlobalVariableNode node.
  #
  # @return [AliasGlobalVariableNode] a new instance of AliasGlobalVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:321
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:414
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:332
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:337
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:347
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:342
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode, ?old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode, ?keyword_loc: Location) -> AliasGlobalVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:352
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasGlobalVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:357
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode, old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:360
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:398
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:393
  sig { returns(String) }
  def keyword; end

  # The location of the `alias` keyword.
  #
  #     alias $foo $bar
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:380
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Represents the new name of the global variable that can be used after aliasing.
  #
  #     alias $foo $bar
  #           ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:368
  sig { returns(T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)) }
  def new_name; end

  # Represents the old name of the global variable that can be used before aliasing.
  #
  #     alias $foo $bar
  #                ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:374
  sig do
    returns(T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode))
  end
  def old_name; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:388
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:403
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:408
    def type; end
  end
end

# Represents the use of the `alias` keyword to alias a method.
#
#     alias foo bar
#     ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:426
class Prism::AliasMethodNode < ::Prism::Node
  # Initialize a new AliasMethodNode node.
  #
  # @return [AliasMethodNode] a new instance of AliasMethodNode
  #
  # pkg:gem/prism#lib/prism/node.rb:428
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:533
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:439
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:444
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:454
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:449
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: SymbolNode | InterpolatedSymbolNode, ?old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode, ?keyword_loc: Location) -> AliasMethodNode
  #
  # pkg:gem/prism#lib/prism/node.rb:459
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasMethodNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:464
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, new_name: SymbolNode | InterpolatedSymbolNode, old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:467
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:517
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:512
  sig { returns(String) }
  def keyword; end

  # Represents the location of the `alias` keyword.
  #
  #     alias foo bar
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:499
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Represents the new name of the method that will be aliased.
  #
  #     alias foo bar
  #           ^^^
  #
  #     alias :foo :bar
  #           ^^^^
  #
  #     alias :"#{foo}" :"#{bar}"
  #           ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:481
  sig { returns(T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)) }
  def new_name; end

  # Represents the old name of the method that will be aliased.
  #
  #     alias foo bar
  #               ^^^
  #
  #     alias :foo :bar
  #                ^^^^
  #
  #     alias :"#{foo}" :"#{bar}"
  #                     ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:493
  sig do
    returns(T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode))
  end
  def old_name; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:507
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:522
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:527
    def type; end
  end
end

# Represents an alternation pattern in pattern matching.
#
#     foo => bar | baz
#            ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:545
class Prism::AlternationPatternNode < ::Prism::Node
  # Initialize a new AlternationPatternNode node.
  #
  # @return [AlternationPatternNode] a new instance of AlternationPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:547
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:640
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:558
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:563
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:573
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:568
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AlternationPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:578
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AlternationPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:583
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:586
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:624
  sig { override.returns(String) }
  def inspect; end

  # Represents the left side of the expression.
  #
  #     foo => bar | baz
  #            ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:594
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:619
  sig { returns(String) }
  def operator; end

  # Represents the alternation operator location.
  #
  #     foo => bar | baz
  #                ^
  #
  # pkg:gem/prism#lib/prism/node.rb:606
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right side of the expression.
  #
  #     foo => bar | baz
  #                  ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:600
  sig { returns(Prism::Node) }
  def right; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:614
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:629
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:634
    def type; end
  end
end

# Represents the use of the `&&` operator or the `and` keyword.
#
#     left and right
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:652
class Prism::AndNode < ::Prism::Node
  # Initialize a new AndNode node.
  #
  # @return [AndNode] a new instance of AndNode
  #
  # pkg:gem/prism#lib/prism/node.rb:654
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:753
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:665
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:670
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:680
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:675
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AndNode
  #
  # pkg:gem/prism#lib/prism/node.rb:685
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AndNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:690
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:693
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:737
  sig { override.returns(String) }
  def inspect; end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left and right
  #     ^^^^
  #
  #     1 && 2
  #     ^
  #
  # pkg:gem/prism#lib/prism/node.rb:704
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:732
  sig { returns(String) }
  def operator; end

  # The location of the `and` keyword or the `&&` operator.
  #
  #     left and right
  #          ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:719
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right side of the expression.
  #
  #     left && right
  #             ^^^^^
  #
  #     1 and 2
  #           ^
  #
  # pkg:gem/prism#lib/prism/node.rb:713
  sig { returns(Prism::Node) }
  def right; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:727
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:742
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:747
    def type; end
  end
end

# Represents a set of arguments to a method or a keyword.
#
#     return foo, bar, baz
#            ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:765
class Prism::ArgumentsNode < ::Prism::Node
  # Initialize a new ArgumentsNode node.
  #
  # @return [ArgumentsNode] a new instance of ArgumentsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:767
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).void
  end
  def initialize(source, node_id, location, flags, arguments); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:856
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:776
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # The list of arguments, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo(bar, baz)
  #         ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:837
  sig { returns(T::Array[Prism::Node]) }
  def arguments; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:781
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:791
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:786
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def contains_forwarding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:809
  sig { returns(T::Boolean) }
  def contains_forwarding?; end

  # def contains_keyword_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:819
  sig { returns(T::Boolean) }
  def contains_keyword_splat?; end

  # def contains_keywords?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:814
  sig { returns(T::Boolean) }
  def contains_keywords?; end

  # def contains_multiple_splats?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:829
  sig { returns(T::Boolean) }
  def contains_multiple_splats?; end

  # def contains_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:824
  sig { returns(T::Boolean) }
  def contains_splat?; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: Array[Prism::node]) -> ArgumentsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:796
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).returns(Prism::ArgumentsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:801
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: Array[Prism::node] }
  #
  # pkg:gem/prism#lib/prism/node.rb:804
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:840
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:845
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:850
    def type; end
  end
end

# Flags for arguments nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18669
module Prism::ArgumentsNodeFlags; end

# if the arguments contain forwarding
#
# pkg:gem/prism#lib/prism/node.rb:18671
Prism::ArgumentsNodeFlags::CONTAINS_FORWARDING = T.let(T.unsafe(nil), Integer)

# if the arguments contain keywords
#
# pkg:gem/prism#lib/prism/node.rb:18674
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORDS = T.let(T.unsafe(nil), Integer)

# if the arguments contain a keyword splat
#
# pkg:gem/prism#lib/prism/node.rb:18677
Prism::ArgumentsNodeFlags::CONTAINS_KEYWORD_SPLAT = T.let(T.unsafe(nil), Integer)

# if the arguments contain multiple splats
#
# pkg:gem/prism#lib/prism/node.rb:18683
Prism::ArgumentsNodeFlags::CONTAINS_MULTIPLE_SPLATS = T.let(T.unsafe(nil), Integer)

# if the arguments contain a splat
#
# pkg:gem/prism#lib/prism/node.rb:18680
Prism::ArgumentsNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
#
#     [1, 2, 3]
#     ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:868
class Prism::ArrayNode < ::Prism::Node
  # Initialize a new ArrayNode node.
  #
  # @return [ArrayNode] a new instance of ArrayNode
  #
  # pkg:gem/prism#lib/prism/node.rb:870
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, elements, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:996
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:881
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:886
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:975
  sig { returns(T.nilable(String)) }
  def closing; end

  # Represents the optional source location for the closing token.
  #
  #     [1,2,3]                 # "]"
  #     %w[foo bar baz]         # "]"
  #     %I(apple orange banana) # ")"
  #     foo = 1, 2, 3           # nil
  #
  # pkg:gem/prism#lib/prism/node.rb:951
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:896
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:891
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def contains_splat?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:914
  sig { returns(T::Boolean) }
  def contains_splat?; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayNode
  #
  # pkg:gem/prism#lib/prism/node.rb:901
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:906
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, elements: Array[Prism::node], opening_loc: Location?, closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:909
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Represent the list of zero or more [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression) within the array.
  #
  # pkg:gem/prism#lib/prism/node.rb:919
  sig { returns(T::Array[Prism::Node]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:980
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:970
  sig { returns(T.nilable(String)) }
  def opening; end

  # Represents the optional source location for the opening token.
  #
  #     [1,2,3]                 # "["
  #     %w[foo bar baz]         # "%w["
  #     %I(apple orange banana) # "%I("
  #     foo = 1, 2, 3           # nil
  #
  # pkg:gem/prism#lib/prism/node.rb:927
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:965
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:941
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:985
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:990
    def type; end
  end
end

# Flags for array nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18687
module Prism::ArrayNodeFlags; end

# if array contains splat nodes
#
# pkg:gem/prism#lib/prism/node.rb:18689
Prism::ArrayNodeFlags::CONTAINS_SPLAT = T.let(T.unsafe(nil), Integer)

# Represents an array pattern in pattern matching.
#
#     foo in 1, 2
#     ^^^^^^^^^^^
#
#     foo in [1, 2]
#     ^^^^^^^^^^^^^
#
#     foo in *bar
#     ^^^^^^^^^^^
#
#     foo in Bar[]
#     ^^^^^^^^^^^^
#
#     foo in Bar[1, 2, 3]
#     ^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1022
class Prism::ArrayPatternNode < ::Prism::Node
  # Initialize a new ArrayPatternNode node.
  #
  # @return [ArrayPatternNode] a new instance of ArrayPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1024
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, requireds, rest, posts, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1176
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1038
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1043
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:1155
  sig { returns(T.nilable(String)) }
  def closing; end

  # Represents the closing location of the array pattern.
  #
  #     foo in [1, 2]
  #                 ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1131
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1058
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1048
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Represents the optional constant preceding the Array
  #
  #     foo in Bar[]
  #            ^^^
  #
  #     foo in Bar[1, 2, 3]
  #            ^^^
  #
  #     foo in Bar::Baz[1, 2, 3]
  #            ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1085
  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantPathNode | ConstantReadNode | nil, ?requireds: Array[Prism::node], ?rest: Prism::node?, ?posts: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1063
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1068
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantPathNode | ConstantReadNode | nil, requireds: Array[Prism::node], rest: Prism::node?, posts: Array[Prism::node], opening_loc: Location?, closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:1071
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1160
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:1150
  sig { returns(T.nilable(String)) }
  def opening; end

  # Represents the opening location of the array pattern.
  #
  #     foo in [1, 2]
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1109
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Represents the elements after the rest element of the array pattern.
  #
  #     foo in *bar, baz
  #                  ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1103
  sig { returns(T::Array[Prism::Node]) }
  def posts; end

  # Represents the required elements of the array pattern.
  #
  #     foo in [1, 2]
  #             ^  ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1091
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # Represents the rest element of the array pattern.
  #
  #     foo in *bar
  #            ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1097
  sig { returns(T.nilable(Prism::Node)) }
  def rest; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1145
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1123
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1165
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1170
    def type; end
  end
end

# Represents a hash key/value pair.
#
#     { a => b }
#       ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1193
class Prism::AssocNode < ::Prism::Node
  # Initialize a new AssocNode node.
  #
  # @return [AssocNode] a new instance of AssocNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1195
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, key, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1303
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1206
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1211
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1221
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1216
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?key: Prism::node, ?value: Prism::node, ?operator_loc: Location?) -> AssocNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1226
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).returns(Prism::AssocNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1231
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, key: Prism::node, value: Prism::node, operator_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:1234
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1287
  sig { override.returns(String) }
  def inspect; end

  # The key of the association. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { a: b }
  #       ^
  #
  #     { foo => bar }
  #       ^^^
  #
  #     { def a; end => 1 }
  #       ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1248
  sig { returns(Prism::Node) }
  def key; end

  # def operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:1282
  sig { returns(T.nilable(String)) }
  def operator; end

  # The location of the `=>` operator, if present.
  #
  #     { foo => bar }
  #           ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1263
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1277
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1292
  sig { override.returns(Symbol) }
  def type; end

  # The value of the association, if present. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     { foo => bar }
  #              ^^^
  #
  #     { x: 1 }
  #          ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1257
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1297
    def type; end
  end
end

# Represents a splat in a hash literal.
#
#     { **foo }
#       ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1315
class Prism::AssocSplatNode < ::Prism::Node
  # Initialize a new AssocSplatNode node.
  #
  # @return [AssocSplatNode] a new instance of AssocSplatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1317
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1405
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1327
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1332
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1344
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1337
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node?, ?operator_loc: Location) -> AssocSplatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1349
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::AssocSplatNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1354
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:1357
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1389
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1384
  sig { returns(String) }
  def operator; end

  # The location of the `**` operator.
  #
  #     { **x }
  #       ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1371
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1379
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1394
  sig { override.returns(Symbol) }
  def type; end

  # The value to be splatted, if present. Will be missing when keyword rest argument forwarding is used.
  #
  #     { **foo }
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1365
  sig { returns(T.nilable(Prism::Node)) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1399
    def type; end
  end
end

# The FFI backend is used on other Ruby implementations.
#
# pkg:gem/prism#lib/prism.rb:103
Prism::BACKEND = T.let(T.unsafe(nil), Symbol)

# Represents reading a reference to a field in the previous match.
#
#     $'
#     ^^
#
# pkg:gem/prism#lib/prism/node.rb:1416
class Prism::BackReferenceReadNode < ::Prism::Node
  # Initialize a new BackReferenceReadNode node.
  #
  # @return [BackReferenceReadNode] a new instance of BackReferenceReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1418
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1483
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1427
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1432
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1442
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1437
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BackReferenceReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1447
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BackReferenceReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1452
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:1455
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1467
  sig { override.returns(String) }
  def inspect; end

  # The name of the back-reference variable, including the leading `$`.
  #
  #     $& # name `:$&`
  #
  #     $+ # name `:$+`
  #
  # pkg:gem/prism#lib/prism/node.rb:1464
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1472
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1477
    def type; end
  end
end

# A class that knows how to walk down the tree. None of the individual visit
# methods are implemented on this visitor, so it forces the consumer to
# implement each one that they need. For a default implementation that
# continues walking the tree, see the Visitor class.
#
# pkg:gem/prism#lib/prism/visitor.rb:17
class Prism::BasicVisitor
  # Calls `accept` on the given node if it is not `nil`, which in turn should
  # call back into this visitor by calling the appropriate `visit_*` method.
  #
  # pkg:gem/prism#lib/prism/visitor.rb:20
  sig { params(node: T.nilable(Prism::Node)).void }
  def visit(node); end

  # Visits each node in `nodes` by calling `accept` on each one.
  #
  # pkg:gem/prism#lib/prism/visitor.rb:26
  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).void }
  def visit_all(nodes); end

  # Visits the child nodes of `node` by calling `accept` on each one.
  #
  # pkg:gem/prism#lib/prism/visitor.rb:32
  sig { params(node: Prism::Node).void }
  def visit_child_nodes(node); end
end

# Represents a begin statement.
#
#     begin
#       foo
#     end
#     ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1495
class Prism::BeginNode < ::Prism::Node
  # Initialize a new BeginNode node.
  #
  # @return [BeginNode] a new instance of BeginNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1497
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1643
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1511
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def begin_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:1617
  sig { returns(T.nilable(String)) }
  def begin_keyword; end

  # Represents the location of the `begin` keyword.
  #
  #     begin x end
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1552
  sig { returns(T.nilable(Prism::Location)) }
  def begin_keyword_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1516
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1531
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1521
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?begin_keyword_loc: Location?, ?statements: StatementsNode?, ?rescue_clause: RescueNode?, ?else_clause: ElseNode?, ?ensure_clause: EnsureNode?, ?end_keyword_loc: Location?) -> BeginNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1536
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::BeginNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1541
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:1544
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Represents the else clause within the begin block.
  #
  #     begin x; rescue y; else z; end
  #                        ^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1586
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:1622
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # Represents the location of the `end` keyword.
  #
  #     begin x end
  #             ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1598
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # Represents the ensure clause within the begin block.
  #
  #     begin x; ensure y; end
  #              ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1592
  sig { returns(T.nilable(Prism::EnsureNode)) }
  def ensure_clause; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1627
  sig { override.returns(String) }
  def inspect; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:80
  def newline_flag!(lines); end

  # Represents the rescue clause within the begin block.
  #
  #     begin x; rescue y; end
  #              ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1580
  sig { returns(T.nilable(Prism::RescueNode)) }
  def rescue_clause; end

  # Save the begin_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1566
  def save_begin_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1612
  def save_end_keyword_loc(repository); end

  # Represents the statements within the begin block.
  #
  #     begin x end
  #           ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1574
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1632
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1637
    def type; end
  end
end

# Represents a block argument using `&`.
#
#     bar(&args)
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1658
class Prism::BlockArgumentNode < ::Prism::Node
  # Initialize a new BlockArgumentNode node.
  #
  # @return [BlockArgumentNode] a new instance of BlockArgumentNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1660
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, expression, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1748
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1670
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1675
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1687
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1680
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node?, ?operator_loc: Location) -> BlockArgumentNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1692
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::BlockArgumentNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1697
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:1700
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The expression that is being passed as a block argument. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo(&args)
  #         ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1708
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1732
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1727
  sig { returns(String) }
  def operator; end

  # Represents the location of the `&` operator.
  #
  #     foo(&args)
  #         ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1714
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1722
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1737
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1742
    def type; end
  end
end

# Represents a block local variable.
#
#     a { |; b| }
#            ^
#
# pkg:gem/prism#lib/prism/node.rb:1759
class Prism::BlockLocalVariableNode < ::Prism::Node
  # Initialize a new BlockLocalVariableNode node.
  #
  # @return [BlockLocalVariableNode] a new instance of BlockLocalVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1761
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1830
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1770
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1775
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1785
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1780
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BlockLocalVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1790
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BlockLocalVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1795
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:1798
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1814
  sig { override.returns(String) }
  def inspect; end

  # The name of the block local variable.
  #
  #     a { |; b| } # name `:b`
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1811
  sig { returns(Symbol) }
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:1803
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1819
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1824
    def type; end
  end
end

# Represents a block of ruby code.
#
#     [1, 2, 3].each { |i| puts x }
#                    ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:1841
class Prism::BlockNode < ::Prism::Node
  # Initialize a new BlockNode node.
  #
  # @return [BlockNode] a new instance of BlockNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1843
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, locals, parameters, body, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:1972
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:1856
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # The body of the block.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                          ^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1911
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1861
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1951
  sig { returns(String) }
  def closing; end

  # Represents the location of the closing `|`.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1933
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:1874
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:1866
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, ?body: StatementsNode | BeginNode | nil, ?opening_loc: Location, ?closing_loc: Location) -> BlockNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1879
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::BlockNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:1884
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, body: StatementsNode | BeginNode | nil, opening_loc: Location, closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:1887
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1956
  sig { override.returns(String) }
  def inspect; end

  # The local variables declared in the block.
  #
  #     [1, 2, 3].each { |i| puts x } # locals: [:i]
  #                       ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1895
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:1946
  sig { returns(String) }
  def opening; end

  # Represents the location of the opening `|`.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                      ^
  #
  # pkg:gem/prism#lib/prism/node.rb:1917
  sig { returns(Prism::Location) }
  def opening_loc; end

  # The parameters of the block.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                      ^^^
  #     [1, 2, 3].each { puts _1 }
  #                    ^^^^^^^^^^^
  #     [1, 2, 3].each { puts it }
  #                    ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:1905
  sig { returns(T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode))) }
  def parameters; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1941
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:1925
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:1961
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:1966
    def type; end
  end
end

# Represents a block parameter of a method, block, or lambda definition.
#
#     def a(&b)
#           ^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:1988
class Prism::BlockParameterNode < ::Prism::Node
  # Initialize a new BlockParameterNode node.
  #
  # @return [BlockParameterNode] a new instance of BlockParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:1990
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:2106
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2001
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2006
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2016
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2011
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> BlockParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2021
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::BlockParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2026
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:2029
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2090
  sig { override.returns(String) }
  def inspect; end

  # The name of the block parameter.
  #
  #     def a(&b) # name `:b`
  #            ^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2043
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # Represents the location of the block parameter name.
  #
  #     def a(&b)
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2049
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2085
  sig { returns(String) }
  def operator; end

  # Represents the location of the `&` operator.
  #
  #     def a(&b)
  #           ^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2072
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2034
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2063
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2080
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:2095
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:2100
    def type; end
  end
end

# Represents a block's parameters declaration.
#
#     -> (a, b = 1; local) { }
#        ^^^^^^^^^^^^^^^^^
#
#     foo do |a, b = 1; local|
#            ^^^^^^^^^^^^^^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:2123
class Prism::BlockParametersNode < ::Prism::Node
  # Initialize a new BlockParametersNode node.
  #
  # @return [BlockParametersNode] a new instance of BlockParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2125
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, parameters, locals, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:2271
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2137
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2142
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2250
  sig { returns(T.nilable(String)) }
  def closing; end

  # Represents the closing location of the block parameters.
  #
  #     -> (a, b = 1; local) { }
  #                        ^
  #
  #     foo do |a, b = 1; local|
  #                            ^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2226
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2155
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2147
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parameters: ParametersNode?, ?locals: Array[BlockLocalVariableNode], ?opening_loc: Location?, ?closing_loc: Location?) -> BlockParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2160
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::BlockParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2165
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parameters: ParametersNode?, locals: Array[BlockLocalVariableNode], opening_loc: Location?, closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:2168
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2255
  sig { override.returns(String) }
  def inspect; end

  # Represents the local variables of the block.
  #
  #     -> (a, b = 1; local) { }
  #                   ^^^^^
  #
  #     foo do |a, b = 1; local|
  #                       ^^^^^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2190
  sig { returns(T::Array[Prism::BlockLocalVariableNode]) }
  def locals; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2245
  sig { returns(T.nilable(String)) }
  def opening; end

  # Represents the opening location of the block parameters.
  #
  #     -> (a, b = 1; local) { }
  #        ^
  #
  #     foo do |a, b = 1; local|
  #            ^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2200
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Represents the parameters of the block.
  #
  #     -> (a, b = 1; local) { }
  #         ^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #             ^^^^^^^^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:2180
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2240
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2214
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:2260
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:2265
    def type; end
  end
end

# Represents the use of the `break` keyword.
#
#     break foo
#     ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:2285
class Prism::BreakNode < ::Prism::Node
  # Initialize a new BreakNode node.
  #
  # @return [BreakNode] a new instance of BreakNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2287
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:2375
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2297
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # The arguments to the break statement, if present. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     break foo
  #           ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2335
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2302
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2314
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2307
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> BreakNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2319
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::BreakNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2324
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: ArgumentsNode?, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:2327
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2359
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2354
  sig { returns(String) }
  def keyword; end

  # The location of the `break` keyword.
  #
  #     break foo
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2341
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2349
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:2364
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:2369
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call.
#
#     foo.bar &&= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:2386
class Prism::CallAndWriteNode < ::Prism::Node
  # Initialize a new CallAndWriteNode node.
  #
  # @return [CallAndWriteNode] a new instance of CallAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2388
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:2574
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2403
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2449
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2543
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # Represents the location of the call operator.
  #
  #     foo.bar &&= value
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2468
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2408
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2421
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2413
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2426
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2431
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:2434
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2454
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2558
  sig { override.returns(String) }
  def inspect; end

  # def message: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2548
  sig { returns(T.nilable(String)) }
  def message; end

  # Represents the location of the message.
  #
  #     foo.bar &&= value
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2490
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2553
  sig { returns(String) }
  def operator; end

  # Represents the location of the operator.
  #
  #     foo.bar &&= value
  #             ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2524
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the name of the method being called.
  #
  #     foo.bar &&= value # read_name `:bar`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2512
  sig { returns(Symbol) }
  def read_name; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar &&= value
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2462
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2439
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2482
  def save_call_operator_loc(repository); end

  # Save the message_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2504
  def save_message_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2532
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:2563
  sig { override.returns(Symbol) }
  def type; end

  # Represents the value being assigned.
  #
  #     foo.bar &&= value
  #                 ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2540
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2444
  sig { returns(T::Boolean) }
  def variable_call?; end

  # Represents the name of the method being written to.
  #
  #     foo.bar &&= value # write_name `:bar=`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2518
  sig { returns(Symbol) }
  def write_name; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:2568
    def type; end
  end
end

# Represents a method call, in all of the various forms that can take.
#
#     foo
#     ^^^
#
#     foo()
#     ^^^^^
#
#     +foo
#     ^^^^
#
#     foo + bar
#     ^^^^^^^^^
#
#     foo.bar
#     ^^^^^^^
#
#     foo&.bar
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:2606
class Prism::CallNode < ::Prism::Node
  # Initialize a new CallNode node.
  #
  # @return [CallNode] a new instance of CallNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2608
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, equal_loc, block); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:2868
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2625
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Represents the arguments to the method call. These can be any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo(bar)
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2771
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2672
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # Represents the block that is being passed to the method.
  #
  #     foo { |a| a }
  #         ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2824
  sig { returns(T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))) }
  def block; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2827
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # Represents the location of the call operator.
  #
  #     foo.bar
  #        ^
  #
  #     foo&.bar
  #        ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2700
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2630
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2842
  sig { returns(T.nilable(String)) }
  def closing; end

  # Represents the location of the right parenthesis.
  #
  #     foo(bar)
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2777
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2644
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2635
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?name: Symbol, ?message_loc: Location?, ?opening_loc: Location?, ?arguments: ArgumentsNode?, ?closing_loc: Location?, ?equal_loc: Location?, ?block: BlockNode | BlockArgumentNode | nil) -> CallNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2649
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::CallNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2654
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, name: Symbol, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, equal_loc: Location?, block: BlockNode | BlockArgumentNode | nil }
  #
  # pkg:gem/prism#lib/prism/node.rb:2657
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def equal: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2847
  sig { returns(T.nilable(String)) }
  def equal; end

  # Represents the location of the equal sign, in the case that this is an attribute write.
  #
  #     foo.bar = value
  #             ^
  #
  #     foo[bar] = value
  #              ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2802
  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # When a call node has the attribute_write flag set, it means that the call
  # is using the attribute write syntax. This is either a method call to []=
  # or a method call to a method that ends with =. Either way, the = sign is
  # present in the source.
  #
  # Prism returns the message_loc _without_ the = sign attached, because there
  # can be any amount of space between the message and the = sign. However,
  # sometimes you want the location of the full message including the inner
  # space and the = sign. This method provides that.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:334
  sig { returns(T.nilable(Prism::Location)) }
  def full_message_loc; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2677
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:2852
  sig { override.returns(String) }
  def inspect; end

  # def message: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2832
  sig { returns(T.nilable(String)) }
  def message; end

  # Represents the location of the message.
  #
  #     foo.bar
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2728
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # Represents the name of the method being called.
  #
  #     foo.bar # name `:foo`
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2722
  sig { returns(Symbol) }
  def name; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:2837
  sig { returns(T.nilable(String)) }
  def opening; end

  # Represents the location of the left parenthesis.
  #     foo(bar)
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2749
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar
  #     ^^^
  #
  #     +foo
  #      ^^^
  #
  #     foo + bar
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2691
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2662
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2714
  def save_call_operator_loc(repository); end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2791
  def save_closing_loc(repository); end

  # Save the equal_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2816
  def save_equal_loc(repository); end

  # Save the message_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2742
  def save_message_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2763
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:2857
  sig { override.returns(Symbol) }
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2667
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:2862
    def type; end
  end
end

# Flags for call nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18693
module Prism::CallNodeFlags; end

# a call that is an attribute write, so the value being written should be returned
#
# pkg:gem/prism#lib/prism/node.rb:18701
Prism::CallNodeFlags::ATTRIBUTE_WRITE = T.let(T.unsafe(nil), Integer)

# a call that ignores method visibility
#
# pkg:gem/prism#lib/prism/node.rb:18704
Prism::CallNodeFlags::IGNORE_VISIBILITY = T.let(T.unsafe(nil), Integer)

# &. operator
#
# pkg:gem/prism#lib/prism/node.rb:18695
Prism::CallNodeFlags::SAFE_NAVIGATION = T.let(T.unsafe(nil), Integer)

# a call that could have been a local variable
#
# pkg:gem/prism#lib/prism/node.rb:18698
Prism::CallNodeFlags::VARIABLE_CALL = T.let(T.unsafe(nil), Integer)

# Represents the use of an assignment operator on a call.
#
#     foo.bar += baz
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:2887
class Prism::CallOperatorWriteNode < ::Prism::Node
  # Initialize a new CallOperatorWriteNode node.
  #
  # @return [CallOperatorWriteNode] a new instance of CallOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2889
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, binary_operator, binary_operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3077
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:2905
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2951
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # Represents the binary operator being used.
  #
  #     foo.bar += value # binary_operator `:+`
  #             ^
  #
  # pkg:gem/prism#lib/prism/node.rb:3026
  sig { returns(Symbol) }
  def binary_operator; end

  # Represents the location of the binary operator.
  #
  #     foo.bar += value
  #             ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3032
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:3051
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # Represents the location of the call operator.
  #
  #     foo.bar += value
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:2970
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2910
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:2923
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:2915
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> CallOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:2928
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:2933
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, binary_operator: Symbol, binary_operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:2936
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2956
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3061
  sig { override.returns(String) }
  def inspect; end

  # def message: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:3056
  sig { returns(T.nilable(String)) }
  def message; end

  # Represents the location of the message.
  #
  #     foo.bar += value
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2992
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:342
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:349
  def operator_loc; end

  # Represents the name of the method being called.
  #
  #     foo.bar += value # read_name `:bar`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3014
  sig { returns(Symbol) }
  def read_name; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar += value
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:2964
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2941
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3040
  def save_binary_operator_loc(repository); end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:2984
  def save_call_operator_loc(repository); end

  # Save the message_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3006
  def save_message_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3066
  sig { override.returns(Symbol) }
  def type; end

  # Represents the value being assigned.
  #
  #     foo.bar += value
  #                ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3048
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:2946
  sig { returns(T::Boolean) }
  def variable_call?; end

  # Represents the name of the method being written to.
  #
  #     foo.bar += value # write_name `:bar=`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3020
  sig { returns(Symbol) }
  def write_name; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3071
    def type; end
  end
end

# Represents the use of the `||=` operator on a call.
#
#     foo.bar ||= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3095
class Prism::CallOrWriteNode < ::Prism::Node
  # Initialize a new CallOrWriteNode node.
  #
  # @return [CallOrWriteNode] a new instance of CallOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3097
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3283
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3112
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3158
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:3252
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # Represents the location of the call operator.
  #
  #     foo.bar ||= value
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:3177
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3117
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3130
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3122
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3135
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3140
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:3143
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3163
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3267
  sig { override.returns(String) }
  def inspect; end

  # def message: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:3257
  sig { returns(T.nilable(String)) }
  def message; end

  # Represents the location of the message.
  #
  #     foo.bar ||= value
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3199
  sig { returns(T.nilable(Prism::Location)) }
  def message_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3262
  sig { returns(String) }
  def operator; end

  # Represents the location of the operator.
  #
  #     foo.bar ||= value
  #             ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3233
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the name of the method being called.
  #
  #     foo.bar ||= value # read_name `:bar`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3221
  sig { returns(Symbol) }
  def read_name; end

  # The object that the method is being called on. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar ||= value
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3171
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3148
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3191
  def save_call_operator_loc(repository); end

  # Save the message_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3213
  def save_message_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3241
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3272
  sig { override.returns(Symbol) }
  def type; end

  # Represents the value being assigned.
  #
  #     foo.bar ||= value
  #                 ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3249
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3153
  sig { returns(T::Boolean) }
  def variable_call?; end

  # Represents the name of the method being written to.
  #
  #     foo.bar ||= value # write_name `:bar=`
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3227
  sig { returns(Symbol) }
  def write_name; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3277
    def type; end
  end
end

# Represents assigning to a method call.
#
#     foo.bar, = 1
#     ^^^^^^^
#
#     begin
#     rescue => foo.bar
#               ^^^^^^^
#     end
#
#     for foo.bar in baz do end
#         ^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3308
class Prism::CallTargetNode < ::Prism::Node
  # Initialize a new CallTargetNode node.
  #
  # @return [CallTargetNode] a new instance of CallTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3310
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3445
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3322
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3365
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # def call_operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3419
  sig { returns(String) }
  def call_operator; end

  # Represents the location of the call operator.
  #
  #     foo.bar = 1
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:3384
  sig { returns(Prism::Location) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3327
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3337
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3332
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?call_operator_loc: Location, ?name: Symbol, ?message_loc: Location) -> CallTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3342
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).returns(Prism::CallTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3347
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node, call_operator_loc: Location, name: Symbol, message_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:3350
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3370
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3429
  sig { override.returns(String) }
  def inspect; end

  # def message: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3424
  sig { returns(String) }
  def message; end

  # Represents the location of the message.
  #
  #     foo.bar = 1
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3406
  sig { returns(Prism::Location) }
  def message_loc; end

  # Represents the name of the method being called.
  #
  #     foo.bar = 1 # name `:foo`
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3400
  sig { returns(Symbol) }
  def name; end

  # The object that the method is being called on. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo.bar = 1
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3378
  sig { returns(Prism::Node) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3355
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3392
  def save_call_operator_loc(repository); end

  # Save the message_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3414
  def save_message_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3434
  sig { override.returns(Symbol) }
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:3360
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3439
    def type; end
  end
end

# Represents assigning to a local variable in pattern matching.
#
#     foo => [bar => baz]
#            ^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3459
class Prism::CapturePatternNode < ::Prism::Node
  # Initialize a new CapturePatternNode node.
  #
  # @return [CapturePatternNode] a new instance of CapturePatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3461
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, target, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3554
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3472
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3477
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3487
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3482
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?target: LocalVariableTargetNode, ?operator_loc: Location) -> CapturePatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3492
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).returns(Prism::CapturePatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3497
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, target: LocalVariableTargetNode, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:3500
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3538
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3533
  sig { returns(String) }
  def operator; end

  # Represents the location of the `=>` operator.
  #
  #     foo => bar
  #         ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3520
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3528
  def save_operator_loc(repository); end

  # Represents the target of the capture.
  #
  #     foo => bar
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3514
  sig { returns(Prism::LocalVariableTargetNode) }
  def target; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3543
  sig { override.returns(Symbol) }
  def type; end

  # Represents the value to capture.
  #
  #     foo => bar
  #            ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3508
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3548
    def type; end
  end
end

# Represents the use of a case statement for pattern matching.
#
#     case true
#     in false
#     end
#     ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3568
class Prism::CaseMatchNode < ::Prism::Node
  # Initialize a new CaseMatchNode node.
  #
  # @return [CaseMatchNode] a new instance of CaseMatchNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3570
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3696
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3583
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3670
  sig { returns(String) }
  def case_keyword; end

  # Represents the location of the `case` keyword.
  #
  #     case true; in false; end
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3641
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3588
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3602
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3593
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Represents the conditions of the case match.
  #
  #     case true; in false; end
  #                ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3629
  sig { returns(T::Array[Prism::InNode]) }
  def conditions; end

  # Returns the else clause of the case match node. This method is deprecated
  # in favor of #else_clause.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:470
  def consequent; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[InNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseMatchNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3607
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseMatchNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3612
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, predicate: Prism::node?, conditions: Array[InNode], else_clause: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:3615
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Represents the else clause of the case match.
  #
  #     case true; in false; else; end
  #                          ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3635
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3675
  sig { returns(String) }
  def end_keyword; end

  # Represents the location of the `end` keyword.
  #
  #     case true; in false; end
  #                          ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3657
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3680
  sig { override.returns(String) }
  def inspect; end

  # Represents the predicate of the case match. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     case true; in false; end
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3623
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Save the case_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3649
  def save_case_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3665
  def save_end_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3685
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3690
    def type; end
  end
end

# Represents the use of a case statement.
#
#     case true
#     when false
#     end
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3713
class Prism::CaseNode < ::Prism::Node
  # Initialize a new CaseNode node.
  #
  # @return [CaseNode] a new instance of CaseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3715
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:3841
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3728
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def case_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3815
  sig { returns(String) }
  def case_keyword; end

  # Represents the location of the `case` keyword.
  #
  #     case true; when false; end
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3786
  sig { returns(Prism::Location) }
  def case_keyword_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3733
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3747
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3738
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Represents the conditions of the case statement.
  #
  #     case true; when false; end
  #                ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3774
  sig { returns(T::Array[Prism::WhenNode]) }
  def conditions; end

  # Returns the else clause of the case node. This method is deprecated in
  # favor of #else_clause.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:479
  def consequent; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[WhenNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3752
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3757
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, predicate: Prism::node?, conditions: Array[WhenNode], else_clause: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:3760
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Represents the else clause of the case statement.
  #
  #     case true; when false; else; end
  #                            ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3780
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3820
  sig { returns(String) }
  def end_keyword; end

  # Represents the location of the `end` keyword.
  #
  #     case true; when false; end
  #                            ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3802
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3825
  sig { override.returns(String) }
  def inspect; end

  # Represents the predicate of the case statement. This can be either `nil` or any [non-void expressions](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     case true; when false; end
  #          ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3768
  sig { returns(T.nilable(Prism::Node)) }
  def predicate; end

  # Save the case_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3794
  def save_case_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3810
  def save_end_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:3830
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:3835
    def type; end
  end
end

# Represents a class declaration involving the `class` keyword.
#
#     class Foo end
#     ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:3856
class Prism::ClassNode < ::Prism::Node
  # Initialize a new ClassNode node.
  #
  # @return [ClassNode] a new instance of ClassNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3858
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4020
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:3874
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Represents the body of the class.
  #
  #     class Foo
  #       foo
  #       ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3965
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3879
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3989
  sig { returns(String) }
  def class_keyword; end

  # Represents the location of the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3917
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:3893
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:3884
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # attr_reader constant_path: ConstantReadNode | ConstantPathNode | CallNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3930
  sig { returns(T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode)) }
  def constant_path; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | CallNode, ?inheritance_operator_loc: Location?, ?superclass: Prism::node?, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location, ?name: Symbol) -> ClassNode
  #
  # pkg:gem/prism#lib/prism/node.rb:3898
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ClassNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:3903
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], class_keyword_loc: Location, constant_path: ConstantReadNode | ConstantPathNode | CallNode, inheritance_operator_loc: Location?, superclass: Prism::node?, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:3906
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:3999
  sig { returns(String) }
  def end_keyword; end

  # Represents the location of the `end` keyword.
  #
  #     class Foo end
  #               ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3971
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inheritance_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:3994
  sig { returns(T.nilable(String)) }
  def inheritance_operator; end

  # Represents the location of the `<` operator.
  #
  #     class Foo < Bar
  #               ^
  #
  # pkg:gem/prism#lib/prism/node.rb:3936
  sig { returns(T.nilable(Prism::Location)) }
  def inheritance_operator_loc; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4004
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:3911
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # The name of the class.
  #
  #     class Foo end # name `:Foo`
  #
  # pkg:gem/prism#lib/prism/node.rb:3986
  sig { returns(Symbol) }
  def name; end

  # Save the class_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3925
  def save_class_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3979
  def save_end_keyword_loc(repository); end

  # Save the inheritance_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:3950
  def save_inheritance_operator_loc(repository); end

  # Represents the superclass of the class.
  #
  #     class Foo < Bar
  #                 ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:3958
  sig { returns(T.nilable(Prism::Node)) }
  def superclass; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4009
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4014
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a class variable.
#
#     @@target &&= value
#     ^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4038
class Prism::ClassVariableAndWriteNode < ::Prism::Node
  # Initialize a new ClassVariableAndWriteNode node.
  #
  # @return [ClassVariableAndWriteNode] a new instance of ClassVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4040
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4150
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4052
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4057
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4067
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4062
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4072
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4077
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:4080
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:165
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4134
  sig { override.returns(String) }
  def inspect; end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@target &&= value # name `:@@target`
  #     ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4088
  sig { returns(Symbol) }
  def name; end

  # Represents the location of the variable name.
  #
  #     @@target &&= value
  #     ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4094
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4129
  sig { returns(String) }
  def operator; end

  # Represents the location of the `&&=` operator.
  #
  #     @@target &&= value
  #              ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4110
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4102
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4118
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4139
  sig { override.returns(Symbol) }
  def type; end

  # Represents the value being assigned. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     @@target &&= value
  #                  ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4126
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4144
    def type; end
  end
end

# Represents assigning to a class variable using an operator that isn't `=`.
#
#     @@target += value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4163
class Prism::ClassVariableOperatorWriteNode < ::Prism::Node
  # Initialize a new ClassVariableOperatorWriteNode node.
  #
  # @return [ClassVariableOperatorWriteNode] a new instance of ClassVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4165
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4262
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4178
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4243
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4227
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4183
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4193
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4188
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ClassVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4198
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ClassVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4203
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:4206
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:177
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4246
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4211
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4214
  sig { returns(Prism::Location) }
  def name_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:358
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:365
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4235
  def save_binary_operator_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4222
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4251
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:4240
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4256
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a class variable.
#
#     @@target ||= value
#     ^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4276
class Prism::ClassVariableOrWriteNode < ::Prism::Node
  # Initialize a new ClassVariableOrWriteNode node.
  #
  # @return [ClassVariableOrWriteNode] a new instance of ClassVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4278
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4376
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4290
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4295
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4305
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4300
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4310
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4315
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:4318
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:171
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4360
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4323
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4326
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4355
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4339
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4334
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4347
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4365
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:4352
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4370
    def type; end
  end
end

# Represents referencing a class variable.
#
#     @@foo
#     ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4389
class Prism::ClassVariableReadNode < ::Prism::Node
  # Initialize a new ClassVariableReadNode node.
  #
  # @return [ClassVariableReadNode] a new instance of ClassVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4391
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4456
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4400
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4405
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4415
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4410
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4420
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4425
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:4428
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4440
  sig { override.returns(String) }
  def inspect; end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@abc   # name `:@@abc`
  #
  #     @@_test # name `:@@_test`
  #
  # pkg:gem/prism#lib/prism/node.rb:4437
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4445
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4450
    def type; end
  end
end

# Represents writing to a class variable in a context that doesn't have an explicit value.
#
#     @@foo, @@bar = baz
#     ^^^^^  ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4466
class Prism::ClassVariableTargetNode < ::Prism::Node
  # Initialize a new ClassVariableTargetNode node.
  #
  # @return [ClassVariableTargetNode] a new instance of ClassVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4468
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4529
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4477
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4482
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4492
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4487
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4497
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4502
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:4505
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4513
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4510
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4518
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4523
    def type; end
  end
end

# Represents writing to a class variable.
#
#     @@foo = 1
#     ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4539
class Prism::ClassVariableWriteNode < ::Prism::Node
  # Initialize a new ClassVariableWriteNode node.
  #
  # @return [ClassVariableWriteNode] a new instance of ClassVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4541
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4655
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4553
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4558
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4568
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4563
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ClassVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4573
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ClassVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4578
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:4581
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4639
  sig { override.returns(String) }
  def inspect; end

  # The name of the class variable, which is a `@@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @@abc = 123     # name `@@abc`
  #
  #     @@_test = :test # name `@@_test`
  #
  # pkg:gem/prism#lib/prism/node.rb:4590
  sig { returns(Symbol) }
  def name; end

  # The location of the variable name.
  #
  #     @@foo = :bar
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4596
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4634
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     @@foo = :bar
  #           ^
  #
  # pkg:gem/prism#lib/prism/node.rb:4621
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4604
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4629
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4644
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the class variable. This can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     @@foo = :bar
  #             ^^^^
  #
  #     @@_xyz = 123
  #              ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:4615
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4649
    def type; end
  end
end

# A cache that can be used to quickly compute code unit offsets from byte
# offsets. It purposefully provides only a single #[] method to access the
# cache in order to minimize surface area.
#
# Note that there are some known issues here that may or may not be addressed
# in the future:
#
# * The first is that there are issues when the cache computes values that are
#   not on character boundaries. This can result in subsequent computations
#   being off by one or more code units.
# * The second is that this cache is currently unbounded. In theory we could
#   introduce some kind of LRU cache to limit the number of entries, but this
#   has not yet been implemented.
#
# pkg:gem/prism#lib/prism/parse_result.rb:177
class Prism::CodeUnitsCache
  # Initialize a new cache with the given source and encoding.
  #
  # @return [CodeUnitsCache] a new instance of CodeUnitsCache
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:203
  sig { params(source: String, encoding: Encoding).void }
  def initialize(source, encoding); end

  # Retrieve the code units offset from the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:217
  sig { params(byte_offset: Integer).returns(Integer) }
  def [](byte_offset); end
end

# pkg:gem/prism#lib/prism/parse_result.rb:189
class Prism::CodeUnitsCache::LengthCounter
  # @return [LengthCounter] a new instance of LengthCounter
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:190
  def initialize(source, encoding); end

  # pkg:gem/prism#lib/prism/parse_result.rb:195
  def count(byte_offset, byte_length); end
end

# pkg:gem/prism#lib/prism/parse_result.rb:178
class Prism::CodeUnitsCache::UTF16Counter
  # @return [UTF16Counter] a new instance of UTF16Counter
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:179
  def initialize(source, encoding); end

  # pkg:gem/prism#lib/prism/parse_result.rb:184
  def count(byte_offset, byte_length); end
end

# This represents a comment that was encountered during parsing. It is the
# base class for all comment types.
#
# pkg:gem/prism#lib/prism/parse_result.rb:512
class Prism::Comment
  abstract!

  # Create a new comment object with the given location.
  #
  # @return [Comment] a new instance of Comment
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:517
  sig { params(location: Prism::Location).void }
  def initialize(location); end

  # Implement the hash pattern matching interface for Comment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:522
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The location of this comment in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:514
  sig { returns(Prism::Location) }
  def location; end

  # Returns the content of the comment by slicing it from the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:527
  sig { returns(String) }
  def slice; end

  sig { abstract.returns(T::Boolean) }
  def trailing?; end
end

# A compiler is a visitor that returns the value of each node as it visits.
# This is as opposed to a visitor which will only walk the tree. This can be
# useful when you are trying to compile a tree into a different format.
#
# For example, to build a representation of the tree as s-expressions, you
# could write:
#
#     class SExpressions < Prism::Compiler
#       def visit_arguments_node(node) = [:arguments, super]
#       def visit_call_node(node) = [:call, super]
#       def visit_integer_node(node) = [:integer]
#       def visit_program_node(node) = [:program, super]
#     end
#
#     Prism.parse("1 + 2").value.accept(SExpressions.new)
#     # => [:program, [[[:call, [[:integer], [:arguments, [[:integer]]]]]]]]
#
# pkg:gem/prism#lib/prism/compiler.rb:30
class Prism::Compiler < ::Prism::Visitor
  # Visit an individual node.
  #
  # pkg:gem/prism#lib/prism/compiler.rb:32
  sig { params(node: T.nilable(Prism::Node)).returns(T.untyped) }
  def visit(node); end

  # Compile a AliasGlobalVariableNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:47
  def visit_alias_global_variable_node(node); end

  # Compile a AliasMethodNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:52
  def visit_alias_method_node(node); end

  # Visit a list of nodes.
  #
  # pkg:gem/prism#lib/prism/compiler.rb:37
  sig { params(nodes: T::Array[T.nilable(Prism::Node)]).returns(T::Array[T.untyped]) }
  def visit_all(nodes); end

  # Compile a AlternationPatternNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:57
  def visit_alternation_pattern_node(node); end

  # Compile a AndNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:62
  def visit_and_node(node); end

  # Compile a ArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:67
  def visit_arguments_node(node); end

  # Compile a ArrayNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:72
  def visit_array_node(node); end

  # Compile a ArrayPatternNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:77
  def visit_array_pattern_node(node); end

  # Compile a AssocNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:82
  def visit_assoc_node(node); end

  # Compile a AssocSplatNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:87
  def visit_assoc_splat_node(node); end

  # Compile a BackReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:92
  def visit_back_reference_read_node(node); end

  # Compile a BeginNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:97
  def visit_begin_node(node); end

  # Compile a BlockArgumentNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:102
  def visit_block_argument_node(node); end

  # Compile a BlockLocalVariableNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:107
  def visit_block_local_variable_node(node); end

  # Compile a BlockNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:112
  def visit_block_node(node); end

  # Compile a BlockParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:117
  def visit_block_parameter_node(node); end

  # Compile a BlockParametersNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:122
  def visit_block_parameters_node(node); end

  # Compile a BreakNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:127
  def visit_break_node(node); end

  # Compile a CallAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:132
  def visit_call_and_write_node(node); end

  # Compile a CallNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:137
  def visit_call_node(node); end

  # Compile a CallOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:142
  def visit_call_operator_write_node(node); end

  # Compile a CallOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:147
  def visit_call_or_write_node(node); end

  # Compile a CallTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:152
  def visit_call_target_node(node); end

  # Compile a CapturePatternNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:157
  def visit_capture_pattern_node(node); end

  # Compile a CaseMatchNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:162
  def visit_case_match_node(node); end

  # Compile a CaseNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:167
  def visit_case_node(node); end

  # Visit the child nodes of the given node.
  #
  # pkg:gem/prism#lib/prism/compiler.rb:42
  sig { params(node: Prism::Node).returns(T::Array[T.untyped]) }
  def visit_child_nodes(node); end

  # Compile a ClassNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:172
  def visit_class_node(node); end

  # Compile a ClassVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:177
  def visit_class_variable_and_write_node(node); end

  # Compile a ClassVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:182
  def visit_class_variable_operator_write_node(node); end

  # Compile a ClassVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:187
  def visit_class_variable_or_write_node(node); end

  # Compile a ClassVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:192
  def visit_class_variable_read_node(node); end

  # Compile a ClassVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:197
  def visit_class_variable_target_node(node); end

  # Compile a ClassVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:202
  def visit_class_variable_write_node(node); end

  # Compile a ConstantAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:207
  def visit_constant_and_write_node(node); end

  # Compile a ConstantOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:212
  def visit_constant_operator_write_node(node); end

  # Compile a ConstantOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:217
  def visit_constant_or_write_node(node); end

  # Compile a ConstantPathAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:222
  def visit_constant_path_and_write_node(node); end

  # Compile a ConstantPathNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:227
  def visit_constant_path_node(node); end

  # Compile a ConstantPathOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:232
  def visit_constant_path_operator_write_node(node); end

  # Compile a ConstantPathOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:237
  def visit_constant_path_or_write_node(node); end

  # Compile a ConstantPathTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:242
  def visit_constant_path_target_node(node); end

  # Compile a ConstantPathWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:247
  def visit_constant_path_write_node(node); end

  # Compile a ConstantReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:252
  def visit_constant_read_node(node); end

  # Compile a ConstantTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:257
  def visit_constant_target_node(node); end

  # Compile a ConstantWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:262
  def visit_constant_write_node(node); end

  # Compile a DefNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:267
  def visit_def_node(node); end

  # Compile a DefinedNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:272
  def visit_defined_node(node); end

  # Compile a ElseNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:277
  def visit_else_node(node); end

  # Compile a EmbeddedStatementsNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:282
  def visit_embedded_statements_node(node); end

  # Compile a EmbeddedVariableNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:287
  def visit_embedded_variable_node(node); end

  # Compile a EnsureNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:292
  def visit_ensure_node(node); end

  # Compile a FalseNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:297
  def visit_false_node(node); end

  # Compile a FindPatternNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:302
  def visit_find_pattern_node(node); end

  # Compile a FlipFlopNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:307
  def visit_flip_flop_node(node); end

  # Compile a FloatNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:312
  def visit_float_node(node); end

  # Compile a ForNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:317
  def visit_for_node(node); end

  # Compile a ForwardingArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:322
  def visit_forwarding_arguments_node(node); end

  # Compile a ForwardingParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:327
  def visit_forwarding_parameter_node(node); end

  # Compile a ForwardingSuperNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:332
  def visit_forwarding_super_node(node); end

  # Compile a GlobalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:337
  def visit_global_variable_and_write_node(node); end

  # Compile a GlobalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:342
  def visit_global_variable_operator_write_node(node); end

  # Compile a GlobalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:347
  def visit_global_variable_or_write_node(node); end

  # Compile a GlobalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:352
  def visit_global_variable_read_node(node); end

  # Compile a GlobalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:357
  def visit_global_variable_target_node(node); end

  # Compile a GlobalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:362
  def visit_global_variable_write_node(node); end

  # Compile a HashNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:367
  def visit_hash_node(node); end

  # Compile a HashPatternNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:372
  def visit_hash_pattern_node(node); end

  # Compile a IfNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:377
  def visit_if_node(node); end

  # Compile a ImaginaryNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:382
  def visit_imaginary_node(node); end

  # Compile a ImplicitNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:387
  def visit_implicit_node(node); end

  # Compile a ImplicitRestNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:392
  def visit_implicit_rest_node(node); end

  # Compile a InNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:397
  def visit_in_node(node); end

  # Compile a IndexAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:402
  def visit_index_and_write_node(node); end

  # Compile a IndexOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:407
  def visit_index_operator_write_node(node); end

  # Compile a IndexOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:412
  def visit_index_or_write_node(node); end

  # Compile a IndexTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:417
  def visit_index_target_node(node); end

  # Compile a InstanceVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:422
  def visit_instance_variable_and_write_node(node); end

  # Compile a InstanceVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:427
  def visit_instance_variable_operator_write_node(node); end

  # Compile a InstanceVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:432
  def visit_instance_variable_or_write_node(node); end

  # Compile a InstanceVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:437
  def visit_instance_variable_read_node(node); end

  # Compile a InstanceVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:442
  def visit_instance_variable_target_node(node); end

  # Compile a InstanceVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:447
  def visit_instance_variable_write_node(node); end

  # Compile a IntegerNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:452
  def visit_integer_node(node); end

  # Compile a InterpolatedMatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:457
  def visit_interpolated_match_last_line_node(node); end

  # Compile a InterpolatedRegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:462
  def visit_interpolated_regular_expression_node(node); end

  # Compile a InterpolatedStringNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:467
  def visit_interpolated_string_node(node); end

  # Compile a InterpolatedSymbolNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:472
  def visit_interpolated_symbol_node(node); end

  # Compile a InterpolatedXStringNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:477
  def visit_interpolated_x_string_node(node); end

  # Compile a ItLocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:482
  def visit_it_local_variable_read_node(node); end

  # Compile a ItParametersNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:487
  def visit_it_parameters_node(node); end

  # Compile a KeywordHashNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:492
  def visit_keyword_hash_node(node); end

  # Compile a KeywordRestParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:497
  def visit_keyword_rest_parameter_node(node); end

  # Compile a LambdaNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:502
  def visit_lambda_node(node); end

  # Compile a LocalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:507
  def visit_local_variable_and_write_node(node); end

  # Compile a LocalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:512
  def visit_local_variable_operator_write_node(node); end

  # Compile a LocalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:517
  def visit_local_variable_or_write_node(node); end

  # Compile a LocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:522
  def visit_local_variable_read_node(node); end

  # Compile a LocalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:527
  def visit_local_variable_target_node(node); end

  # Compile a LocalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:532
  def visit_local_variable_write_node(node); end

  # Compile a MatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:537
  def visit_match_last_line_node(node); end

  # Compile a MatchPredicateNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:542
  def visit_match_predicate_node(node); end

  # Compile a MatchRequiredNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:547
  def visit_match_required_node(node); end

  # Compile a MatchWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:552
  def visit_match_write_node(node); end

  # Compile a MissingNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:557
  def visit_missing_node(node); end

  # Compile a ModuleNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:562
  def visit_module_node(node); end

  # Compile a MultiTargetNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:567
  def visit_multi_target_node(node); end

  # Compile a MultiWriteNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:572
  def visit_multi_write_node(node); end

  # Compile a NextNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:577
  def visit_next_node(node); end

  # Compile a NilNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:582
  def visit_nil_node(node); end

  # Compile a NoKeywordsParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:587
  def visit_no_keywords_parameter_node(node); end

  # Compile a NumberedParametersNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:592
  def visit_numbered_parameters_node(node); end

  # Compile a NumberedReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:597
  def visit_numbered_reference_read_node(node); end

  # Compile a OptionalKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:602
  def visit_optional_keyword_parameter_node(node); end

  # Compile a OptionalParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:607
  def visit_optional_parameter_node(node); end

  # Compile a OrNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:612
  def visit_or_node(node); end

  # Compile a ParametersNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:617
  def visit_parameters_node(node); end

  # Compile a ParenthesesNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:622
  def visit_parentheses_node(node); end

  # Compile a PinnedExpressionNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:627
  def visit_pinned_expression_node(node); end

  # Compile a PinnedVariableNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:632
  def visit_pinned_variable_node(node); end

  # Compile a PostExecutionNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:637
  def visit_post_execution_node(node); end

  # Compile a PreExecutionNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:642
  def visit_pre_execution_node(node); end

  # Compile a ProgramNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:647
  def visit_program_node(node); end

  # Compile a RangeNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:652
  def visit_range_node(node); end

  # Compile a RationalNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:657
  def visit_rational_node(node); end

  # Compile a RedoNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:662
  def visit_redo_node(node); end

  # Compile a RegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:667
  def visit_regular_expression_node(node); end

  # Compile a RequiredKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:672
  def visit_required_keyword_parameter_node(node); end

  # Compile a RequiredParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:677
  def visit_required_parameter_node(node); end

  # Compile a RescueModifierNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:682
  def visit_rescue_modifier_node(node); end

  # Compile a RescueNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:687
  def visit_rescue_node(node); end

  # Compile a RestParameterNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:692
  def visit_rest_parameter_node(node); end

  # Compile a RetryNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:697
  def visit_retry_node(node); end

  # Compile a ReturnNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:702
  def visit_return_node(node); end

  # Compile a SelfNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:707
  def visit_self_node(node); end

  # Compile a ShareableConstantNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:712
  def visit_shareable_constant_node(node); end

  # Compile a SingletonClassNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:717
  def visit_singleton_class_node(node); end

  # Compile a SourceEncodingNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:722
  def visit_source_encoding_node(node); end

  # Compile a SourceFileNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:727
  def visit_source_file_node(node); end

  # Compile a SourceLineNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:732
  def visit_source_line_node(node); end

  # Compile a SplatNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:737
  def visit_splat_node(node); end

  # Compile a StatementsNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:742
  def visit_statements_node(node); end

  # Compile a StringNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:747
  def visit_string_node(node); end

  # Compile a SuperNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:752
  def visit_super_node(node); end

  # Compile a SymbolNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:757
  def visit_symbol_node(node); end

  # Compile a TrueNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:762
  def visit_true_node(node); end

  # Compile a UndefNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:767
  def visit_undef_node(node); end

  # Compile a UnlessNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:772
  def visit_unless_node(node); end

  # Compile a UntilNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:777
  def visit_until_node(node); end

  # Compile a WhenNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:782
  def visit_when_node(node); end

  # Compile a WhileNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:787
  def visit_while_node(node); end

  # Compile a XStringNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:792
  def visit_x_string_node(node); end

  # Compile a YieldNode node
  #
  # pkg:gem/prism#lib/prism/compiler.rb:797
  def visit_yield_node(node); end
end

# Represents the use of the `&&=` operator for assignment to a constant.
#
#     Target &&= value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4668
class Prism::ConstantAndWriteNode < ::Prism::Node
  # Initialize a new ConstantAndWriteNode node.
  #
  # @return [ConstantAndWriteNode] a new instance of ConstantAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4670
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4768
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4682
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4687
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4697
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4692
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4702
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4707
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:4710
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:183
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4752
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4715
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4718
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4747
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4731
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4726
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4739
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4757
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:4744
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4762
    def type; end
  end
end

# Represents assigning to a constant using an operator that isn't `=`.
#
#     Target += value
#     ^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4781
class Prism::ConstantOperatorWriteNode < ::Prism::Node
  # Initialize a new ConstantOperatorWriteNode node.
  #
  # @return [ConstantOperatorWriteNode] a new instance of ConstantOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4783
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4880
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4796
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4861
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4845
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4801
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4811
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4806
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4816
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4821
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:4824
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:195
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4864
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4829
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4832
  sig { returns(Prism::Location) }
  def name_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:374
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:381
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4853
  def save_binary_operator_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4840
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4869
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:4858
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4874
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant.
#
#     Target ||= value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:4894
class Prism::ConstantOrWriteNode < ::Prism::Node
  # Initialize a new ConstantOrWriteNode node.
  #
  # @return [ConstantOrWriteNode] a new instance of ConstantOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4896
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:4994
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:4908
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4913
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:4923
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:4918
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:4928
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:4933
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:4936
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:189
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4978
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:4941
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4944
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:4973
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:4957
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4952
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:4965
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:4983
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:4970
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:4988
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a constant path.
#
#     Parent::Child &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5007
class Prism::ConstantPathAndWriteNode < ::Prism::Node
  # Initialize a new ConstantPathAndWriteNode node.
  #
  # @return [ConstantPathAndWriteNode] a new instance of ConstantPathAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5009
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5093
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5020
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5025
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5035
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5030
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5040
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5045
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:5048
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5077
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5072
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:5056
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5064
  def save_operator_loc(repository); end

  # attr_reader target: ConstantPathNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5053
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5082
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:5069
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5087
    def type; end
  end
end

# Represents accessing a constant through a path of `::` operators.
#
#     Foo::Bar
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5105
class Prism::ConstantPathNode < ::Prism::Node
  # Initialize a new ConstantPathNode node.
  #
  # @return [ConstantPathNode] a new instance of ConstantPathNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5107
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5228
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5119
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Previously, we had a child node on this class that contained either a
  # constant read or a missing node. To not cause a breaking change, we
  # continue to supply that API.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:205
  def child; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5124
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5136
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5129
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5141
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5146
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parent: Prism::node?, name: Symbol?, delimiter_loc: Location, name_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:5149
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5207
  sig { returns(String) }
  def delimiter; end

  # The location of the `::` delimiter.
  #
  #     ::Foo
  #     ^^
  #
  #     One::Two
  #        ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5175
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:198
  sig { returns(String) }
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:176
  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5212
  sig { override.returns(String) }
  def inspect; end

  # The name of the constant being accessed. This could be `nil` in the event of a syntax error.
  #
  # pkg:gem/prism#lib/prism/node.rb:5166
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # The location of the name of the constant.
  #
  #     ::Foo
  #       ^^^
  #
  #     One::Two
  #          ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5194
  sig { returns(Prism::Location) }
  def name_loc; end

  # The left-hand node of the path, if present. It can be `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression). It will be `nil` when the constant lookup is at the root of the module tree.
  #
  #     Foo::Bar
  #     ^^^
  #
  #     self::Test
  #     ^^^^
  #
  #     a.b::C
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5163
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Save the delimiter_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5183
  def save_delimiter_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5202
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5217
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5222
    def type; end
  end
end

# An error class raised when dynamic parts are found while computing a
# constant path's full name. For example:
# Foo::Bar::Baz -> does not raise because all parts of the constant path are
# simple constants
# var::Bar::Baz -> raises because the first part of the constant path is a
# local variable
#
# pkg:gem/prism#lib/prism/node_ext.rb:167
class Prism::ConstantPathNode::DynamicPartsInConstantPathError < ::StandardError; end

# An error class raised when missing nodes are found while computing a
# constant path's full name. For example:
# Foo:: -> raises because the constant path is missing the last part
#
# pkg:gem/prism#lib/prism/node_ext.rb:172
class Prism::ConstantPathNode::MissingNodesInConstantPathError < ::StandardError; end

# Represents assigning to a constant path using an operator that isn't `=`.
#
#     Parent::Child += value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5241
class Prism::ConstantPathOperatorWriteNode < ::Prism::Node
  # Initialize a new ConstantPathOperatorWriteNode node.
  #
  # @return [ConstantPathOperatorWriteNode] a new instance of ConstantPathOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5243
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, target, binary_operator_loc, value, binary_operator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5326
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5255
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:5307
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:5291
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5260
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5270
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5265
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantPathOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5275
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantPathOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5280
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:5283
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5310
  sig { override.returns(String) }
  def inspect; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:390
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:397
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5299
  def save_binary_operator_loc(repository); end

  # attr_reader target: ConstantPathNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5288
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5315
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:5304
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5320
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a constant path.
#
#     Parent::Child ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5339
class Prism::ConstantPathOrWriteNode < ::Prism::Node
  # Initialize a new ConstantPathOrWriteNode node.
  #
  # @return [ConstantPathOrWriteNode] a new instance of ConstantPathOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5341
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5425
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5352
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5357
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5367
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5362
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5372
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5377
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:5380
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5409
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5404
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:5388
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5396
  def save_operator_loc(repository); end

  # attr_reader target: ConstantPathNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5385
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5414
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:5401
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5419
    def type; end
  end
end

# Represents writing to a constant path in a context that doesn't have an explicit value.
#
#     Foo::Foo, Bar::Bar = baz
#     ^^^^^^^^  ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5437
class Prism::ConstantPathTargetNode < ::Prism::Node
  # Initialize a new ConstantPathTargetNode node.
  #
  # @return [ConstantPathTargetNode] a new instance of ConstantPathTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5439
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5539
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5451
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Previously, we had a child node on this class that contained either a
  # constant read or a missing node. To not cause a breaking change, we
  # continue to supply that API.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:246
  def child; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5456
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5468
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5461
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5473
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5478
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parent: Prism::node?, name: Symbol?, delimiter_loc: Location, name_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:5481
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def delimiter: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5518
  sig { returns(String) }
  def delimiter; end

  # attr_reader delimiter_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:5492
  sig { returns(Prism::Location) }
  def delimiter_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns the full name of this constant path. For example: "Foo::Bar"
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:239
  sig { returns(String) }
  def full_name; end

  # Returns the list of parts for the full name of this constant path.
  # For example: [:Foo, :Bar]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:219
  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5523
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol?
  #
  # pkg:gem/prism#lib/prism/node.rb:5489
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:5505
  sig { returns(Prism::Location) }
  def name_loc; end

  # attr_reader parent: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:5486
  sig { returns(T.nilable(Prism::Node)) }
  def parent; end

  # Save the delimiter_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5500
  def save_delimiter_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5513
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5528
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5533
    def type; end
  end
end

# Represents writing to a constant path.
#
#     ::Foo = 1
#     ^^^^^^^^^
#
#     Foo::Bar = 1
#     ^^^^^^^^^^^^
#
#     ::Foo::Bar = 1
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5558
class Prism::ConstantPathWriteNode < ::Prism::Node
  # Initialize a new ConstantPathWriteNode node.
  #
  # @return [ConstantPathWriteNode] a new instance of ConstantPathWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5560
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5656
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5571
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5576
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5586
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5581
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5591
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5596
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:5599
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5640
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5635
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     ::ABC = 123
  #           ^
  #
  # pkg:gem/prism#lib/prism/node.rb:5616
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5624
  def save_operator_loc(repository); end

  # A node representing the constant path being written to.
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^
  #
  #     ::Foo = :abc
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5610
  sig { returns(Prism::ConstantPathNode) }
  def target; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5645
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the constant path. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     FOO::BAR = :abc
  #                ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5632
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5650
    def type; end
  end
end

# Represents referencing a constant.
#
#     Foo
#     ^^^
#
# pkg:gem/prism#lib/prism/node.rb:5668
class Prism::ConstantReadNode < ::Prism::Node
  # Initialize a new ConstantReadNode node.
  #
  # @return [ConstantReadNode] a new instance of ConstantReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5670
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5735
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5679
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5684
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5694
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5689
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5699
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5704
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:5707
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns the full name of this constant. For example: "Foo"
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:142
  sig { returns(String) }
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:137
  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5719
  sig { override.returns(String) }
  def inspect; end

  # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
  #
  #     X              # name `:X`
  #
  #     SOME_CONSTANT  # name `:SOME_CONSTANT`
  #
  # pkg:gem/prism#lib/prism/node.rb:5716
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5724
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5729
    def type; end
  end
end

# Represents writing to a constant in a context that doesn't have an explicit value.
#
#     Foo, Bar = baz
#     ^^^  ^^^
#
# pkg:gem/prism#lib/prism/node.rb:5745
class Prism::ConstantTargetNode < ::Prism::Node
  # Initialize a new ConstantTargetNode node.
  #
  # @return [ConstantTargetNode] a new instance of ConstantTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5747
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5808
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5756
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5761
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5771
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5766
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5776
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5781
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:5784
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns the full name of this constant. For example: "Foo"
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:265
  sig { returns(String) }
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:260
  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5792
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:5789
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5797
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5802
    def type; end
  end
end

# Represents writing to a constant.
#
#     Foo = 1
#     ^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5818
class Prism::ConstantWriteNode < ::Prism::Node
  # Initialize a new ConstantWriteNode node.
  #
  # @return [ConstantWriteNode] a new instance of ConstantWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5820
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:5934
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5832
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5837
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5847
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5842
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ConstantWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5852
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ConstantWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5857
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:5860
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns the full name of this constant. For example: "Foo"
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:155
  sig { returns(String) }
  def full_name; end

  # Returns the list of parts for the full name of this constant.
  # For example: [:Foo]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:150
  sig { returns(T::Array[Symbol]) }
  def full_name_parts; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5918
  sig { override.returns(String) }
  def inspect; end

  # The name of the [constant](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#constants).
  #
  #     Foo = :bar # name `:Foo`
  #
  #     XYZ = 1    # name `:XYZ`
  #
  # pkg:gem/prism#lib/prism/node.rb:5869
  sig { returns(Symbol) }
  def name; end

  # The location of the constant name.
  #
  #     FOO = 1
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5875
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:5913
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     FOO = :bar
  #         ^
  #
  # pkg:gem/prism#lib/prism/node.rb:5900
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5883
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:5908
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:5923
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the constant. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     FOO = :bar
  #           ^^^^
  #
  #     MyClass = Class.new
  #               ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:5894
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:5928
    def type; end
  end
end

# Raised when requested to parse as the currently running Ruby version but Prism has no support for it.
#
# pkg:gem/prism#lib/prism.rb:41
class Prism::CurrentVersionError < ::ArgumentError
  # Initialize a new exception for the given ruby version string.
  #
  # @return [CurrentVersionError] a new instance of CurrentVersionError
  #
  # pkg:gem/prism#lib/prism.rb:43
  def initialize(version); end
end

# The DSL module provides a set of methods that can be used to create prism
# nodes in a more concise manner. For example, instead of writing:
#
#     source = Prism::Source.for("[1]")
#
#     Prism::ArrayNode.new(
#       source,
#       0,
#       Prism::Location.new(source, 0, 3),
#       0,
#       [
#         Prism::IntegerNode.new(
#           source,
#           0,
#           Prism::Location.new(source, 1, 1),
#           Prism::IntegerBaseFlags::DECIMAL,
#           1
#         )
#       ],
#       Prism::Location.new(source, 0, 1),
#       Prism::Location.new(source, 2, 1)
#     )
#
# you could instead write:
#
#     class Builder
#       include Prism::DSL
#
#       attr_reader :default_source
#
#       def initialize
#         @default_source = source("[1]")
#       end
#
#       def build
#         array_node(
#           location: location(start_offset: 0, length: 3),
#           elements: [
#             integer_node(
#               location: location(start_offset: 1, length: 1),
#               flags: integer_base_flag(:decimal),
#               value: 1
#             )
#           ],
#           opening_loc: location(start_offset: 0, length: 1),
#           closing_loc: location(start_offset: 2, length: 1)
#         )
#       end
#     end
#
# This is mostly helpful in the context of generating trees programmatically.
#
# pkg:gem/prism#lib/prism/dsl.rb:64
module Prism::DSL
  extend ::Prism::DSL

  # Create a new AliasGlobalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:80
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode),
      old_name: T.any(Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::SymbolNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasGlobalVariableNode)
  end
  def alias_global_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new AliasMethodNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:85
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      new_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode),
      old_name: T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode, Prism::GlobalVariableReadNode, Prism::MissingNode),
      keyword_loc: Prism::Location
    ).returns(Prism::AliasMethodNode)
  end
  def alias_method_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new AlternationPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:90
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AlternationPatternNode)
  end
  def alternation_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new AndNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:95
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::AndNode)
  end
  def and_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new ArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:100
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T::Array[Prism::Node]
    ).returns(Prism::ArgumentsNode)
  end
  def arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Retrieve the value of one of the ArgumentsNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:835
  sig { params(name: Symbol).returns(Integer) }
  def arguments_node_flag(name); end

  # Create a new ArrayNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:105
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayNode)
  end
  def array_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Retrieve the value of one of the ArrayNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:847
  sig { params(name: Symbol).returns(Integer) }
  def array_node_flag(name); end

  # Create a new ArrayPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:110
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      requireds: T::Array[Prism::Node],
      rest: T.nilable(Prism::Node),
      posts: T::Array[Prism::Node],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::ArrayPatternNode)
  end
  def array_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new AssocNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:115
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      key: Prism::Node,
      value: Prism::Node,
      operator_loc: T.nilable(Prism::Location)
    ).returns(Prism::AssocNode)
  end
  def assoc_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new AssocSplatNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:120
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::AssocSplatNode)
  end
  def assoc_splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new BackReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:125
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BackReferenceReadNode)
  end
  def back_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new BeginNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:130
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      begin_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      rescue_clause: T.nilable(Prism::RescueNode),
      else_clause: T.nilable(Prism::ElseNode),
      ensure_clause: T.nilable(Prism::EnsureNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::BeginNode)
  end
  def begin_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new BlockArgumentNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:135
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::BlockArgumentNode)
  end
  def block_argument_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new BlockLocalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:140
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::BlockLocalVariableNode)
  end
  def block_local_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new BlockNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:145
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::BlockNode)
  end
  def block_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new BlockParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:150
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::BlockParameterNode)
  end
  def block_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new BlockParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:155
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parameters: T.nilable(Prism::ParametersNode),
      locals: T::Array[Prism::BlockLocalVariableNode],
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::BlockParametersNode)
  end
  def block_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new BreakNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:160
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::BreakNode)
  end
  def break_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new CallAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:165
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallAndWriteNode)
  end
  def call_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new CallNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:170
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      name: Symbol,
      message_loc: T.nilable(Prism::Location),
      opening_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::CallNode)
  end
  def call_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # Retrieve the value of one of the CallNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:855
  sig { params(name: Symbol).returns(Integer) }
  def call_node_flag(name); end

  # Create a new CallOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:175
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOperatorWriteNode)
  end
  def call_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new CallOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:180
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      message_loc: T.nilable(Prism::Location),
      read_name: Symbol,
      write_name: Symbol,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::CallOrWriteNode)
  end
  def call_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new CallTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:185
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      call_operator_loc: Prism::Location,
      name: Symbol,
      message_loc: Prism::Location
    ).returns(Prism::CallTargetNode)
  end
  def call_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  # Create a new CapturePatternNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:190
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      target: Prism::LocalVariableTargetNode,
      operator_loc: Prism::Location
    ).returns(Prism::CapturePatternNode)
  end
  def capture_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new CaseMatchNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:195
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::InNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseMatchNode)
  end
  def case_match_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new CaseNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:200
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      predicate: T.nilable(Prism::Node),
      conditions: T::Array[Prism::WhenNode],
      else_clause: T.nilable(Prism::ElseNode),
      case_keyword_loc: Prism::Location,
      end_keyword_loc: Prism::Location
    ).returns(Prism::CaseNode)
  end
  def case_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new ClassNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:205
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::CallNode),
      inheritance_operator_loc: T.nilable(Prism::Location),
      superclass: T.nilable(Prism::Node),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ClassNode)
  end
  def class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new ClassVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:210
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableAndWriteNode)
  end
  def class_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ClassVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:215
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ClassVariableOperatorWriteNode)
  end
  def class_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # Create a new ClassVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:220
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ClassVariableOrWriteNode)
  end
  def class_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ClassVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:225
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableReadNode)
  end
  def class_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new ClassVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:230
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ClassVariableTargetNode)
  end
  def class_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new ClassVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:235
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ClassVariableWriteNode)
  end
  def class_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new ConstantAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:240
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantAndWriteNode)
  end
  def constant_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ConstantOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:245
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantOperatorWriteNode)
  end
  def constant_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # Create a new ConstantOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:250
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantOrWriteNode)
  end
  def constant_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ConstantPathAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:255
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathAndWriteNode)
  end
  def constant_path_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ConstantPathNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:260
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathNode)
  end
  def constant_path_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # Create a new ConstantPathOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:265
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::ConstantPathOperatorWriteNode)
  end
  def constant_path_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # Create a new ConstantPathOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:270
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathOrWriteNode)
  end
  def constant_path_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ConstantPathTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:275
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      parent: T.nilable(Prism::Node),
      name: T.nilable(Symbol),
      delimiter_loc: Prism::Location,
      name_loc: Prism::Location
    ).returns(Prism::ConstantPathTargetNode)
  end
  def constant_path_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # Create a new ConstantPathWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:280
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      target: Prism::ConstantPathNode,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::ConstantPathWriteNode)
  end
  def constant_path_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ConstantReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:285
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantReadNode)
  end
  def constant_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new ConstantTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:290
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::ConstantTargetNode)
  end
  def constant_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new ConstantWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:295
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::ConstantWriteNode)
  end
  def constant_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new DefNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:300
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::DefNode)
  end
  def def_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new DefinedNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:305
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).returns(Prism::DefinedNode)
  end
  def defined_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new ElseNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:310
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::ElseNode)
  end
  def else_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new EmbeddedStatementsNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:315
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).returns(Prism::EmbeddedStatementsNode)
  end
  def embedded_statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new EmbeddedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:320
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).returns(Prism::EmbeddedVariableNode)
  end
  def embedded_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  # Retrieve the value of one of the EncodingFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:866
  sig { params(name: Symbol).returns(Integer) }
  def encoding_flag(name); end

  # Create a new EnsureNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:325
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).returns(Prism::EnsureNode)
  end
  def ensure_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new FalseNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:330
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::FalseNode)
  end
  def false_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new FindPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:335
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::FindPatternNode)
  end
  def find_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new FlipFlopNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:340
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::FlipFlopNode)
  end
  def flip_flop_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new FloatNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:345
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Float
    ).returns(Prism::FloatNode)
  end
  def float_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ForNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:350
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).returns(Prism::ForNode)
  end
  def for_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new ForwardingArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:355
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ForwardingArgumentsNode)
  end
  def forwarding_arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ForwardingParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:360
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ForwardingParameterNode)
  end
  def forwarding_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ForwardingSuperNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:365
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).returns(Prism::ForwardingSuperNode)
  end
  def forwarding_super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  # Create a new GlobalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:370
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableAndWriteNode)
  end
  def global_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new GlobalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:375
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::GlobalVariableOperatorWriteNode)
  end
  def global_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # Create a new GlobalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:380
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableOrWriteNode)
  end
  def global_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new GlobalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:385
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableReadNode)
  end
  def global_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new GlobalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:390
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableTargetNode)
  end
  def global_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new GlobalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:395
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::GlobalVariableWriteNode)
  end
  def global_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new HashNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:400
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).returns(Prism::HashNode)
  end
  def hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new HashPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:405
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::HashPatternNode)
  end
  def hash_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new IfNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:410
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::IfNode)
  end
  def if_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new ImaginaryNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:415
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).returns(Prism::ImaginaryNode)
  end
  def imaginary_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  # Create a new ImplicitNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:420
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).returns(Prism::ImplicitNode)
  end
  def implicit_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new ImplicitRestNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:425
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ImplicitRestNode)
  end
  def implicit_rest_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new InNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:430
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).returns(Prism::InNode)
  end
  def in_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  # Create a new IndexAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:435
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexAndWriteNode)
  end
  def index_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new IndexOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:440
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOperatorWriteNode)
  end
  def index_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new IndexOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:445
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOrWriteNode)
  end
  def index_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new IndexTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:450
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).returns(Prism::IndexTargetNode)
  end
  def index_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # Create a new InstanceVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:455
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableAndWriteNode)
  end
  def instance_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new InstanceVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:460
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::InstanceVariableOperatorWriteNode)
  end
  def instance_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # Create a new InstanceVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:465
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableOrWriteNode)
  end
  def instance_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new InstanceVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:470
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableReadNode)
  end
  def instance_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new InstanceVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:475
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableTargetNode)
  end
  def instance_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new InstanceVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:480
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::InstanceVariableWriteNode)
  end
  def instance_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Retrieve the value of one of the IntegerBaseFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:875
  sig { params(name: Symbol).returns(Integer) }
  def integer_base_flag(name); end

  # Create a new IntegerNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:485
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).returns(Prism::IntegerNode)
  end
  def integer_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new InterpolatedMatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:490
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedMatchLastLineNode)
  end
  def interpolated_match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new InterpolatedRegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:495
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedRegularExpressionNode)
  end
  def interpolated_regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new InterpolatedStringNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:500
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode, Prism::InterpolatedXStringNode, Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedStringNode)
  end
  def interpolated_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Retrieve the value of one of the InterpolatedStringNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:886
  sig { params(name: Symbol).returns(Integer) }
  def interpolated_string_node_flag(name); end

  # Create a new InterpolatedSymbolNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:505
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedSymbolNode)
  end
  def interpolated_symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new InterpolatedXStringNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:510
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedXStringNode)
  end
  def interpolated_x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new ItLocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:515
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ItLocalVariableReadNode)
  end
  def it_local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ItParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:520
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::ItParametersNode)
  end
  def it_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new KeywordHashNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:525
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).returns(Prism::KeywordHashNode)
  end
  def keyword_hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  # Retrieve the value of one of the KeywordHashNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:895
  sig { params(name: Symbol).returns(Integer) }
  def keyword_hash_node_flag(name); end

  # Create a new KeywordRestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:530
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::KeywordRestParameterNode)
  end
  def keyword_rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new LambdaNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:535
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).returns(Prism::LambdaNode)
  end
  def lambda_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  # Create a new LocalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:540
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableAndWriteNode)
  end
  def local_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # Create a new LocalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:545
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOperatorWriteNode)
  end
  def local_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  # Create a new LocalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:550
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOrWriteNode)
  end
  def local_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # Create a new LocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:555
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableReadNode)
  end
  def local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # Create a new LocalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:560
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableTargetNode)
  end
  def local_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # Create a new LocalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:565
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::LocalVariableWriteNode)
  end
  def local_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new Location object.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:75
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).returns(Prism::Location) }
  def location(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  # Retrieve the value of one of the LoopFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:903
  sig { params(name: Symbol).returns(Integer) }
  def loop_flag(name); end

  # Create a new MatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:570
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::MatchLastLineNode)
  end
  def match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # Create a new MatchPredicateNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:575
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchPredicateNode)
  end
  def match_predicate_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new MatchRequiredNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:580
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchRequiredNode)
  end
  def match_required_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new MatchWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:585
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).returns(Prism::MatchWriteNode)
  end
  def match_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  # Create a new MissingNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:590
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::MissingNode)
  end
  def missing_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ModuleNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:595
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ModuleNode)
  end
  def module_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new MultiTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:600
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::MultiTargetNode)
  end
  def multi_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  # Create a new MultiWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:605
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::MultiWriteNode)
  end
  def multi_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new NextNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:610
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::NextNode)
  end
  def next_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new NilNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:615
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::NilNode)
  end
  def nil_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new NoKeywordsParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:620
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).returns(Prism::NoKeywordsParameterNode)
  end
  def no_keywords_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new NumberedParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:625
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).returns(Prism::NumberedParametersNode)
  end
  def numbered_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  # Create a new NumberedReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:630
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).returns(Prism::NumberedReferenceReadNode)
  end
  def numbered_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  # Create a new OptionalKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:635
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalKeywordParameterNode)
  end
  def optional_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new OptionalParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:640
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalParameterNode)
  end
  def optional_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # Create a new OrNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:645
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::OrNode)
  end
  def or_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Retrieve the value of one of the ParameterFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:911
  sig { params(name: Symbol).returns(Integer) }
  def parameter_flag(name); end

  # Create a new ParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:650
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).returns(Prism::ParametersNode)
  end
  def parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  # Create a new ParenthesesNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:655
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::ParenthesesNode)
  end
  def parentheses_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Retrieve the value of one of the ParenthesesNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:919
  sig { params(name: Symbol).returns(Integer) }
  def parentheses_node_flag(name); end

  # Create a new PinnedExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:660
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).returns(Prism::PinnedExpressionNode)
  end
  def pinned_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  # Create a new PinnedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:665
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).returns(Prism::PinnedVariableNode)
  end
  def pinned_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new PostExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:670
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PostExecutionNode)
  end
  def post_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new PreExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:675
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PreExecutionNode)
  end
  def pre_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # Create a new ProgramNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:680
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).returns(Prism::ProgramNode)
  end
  def program_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  # Retrieve the value of one of the RangeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:927
  sig { params(name: Symbol).returns(Integer) }
  def range_flag(name); end

  # Create a new RangeNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:685
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::RangeNode)
  end
  def range_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new RationalNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:690
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).returns(Prism::RationalNode)
  end
  def rational_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  # Create a new RedoNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:695
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::RedoNode)
  end
  def redo_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Retrieve the value of one of the RegularExpressionFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:935
  sig { params(name: Symbol).returns(Integer) }
  def regular_expression_flag(name); end

  # Create a new RegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:700
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::RegularExpressionNode)
  end
  def regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # Create a new RequiredKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:705
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).returns(Prism::RequiredKeywordParameterNode)
  end
  def required_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # Create a new RequiredParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:710
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::RequiredParameterNode)
  end
  def required_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # Create a new RescueModifierNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:715
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).returns(Prism::RescueModifierNode)
  end
  def rescue_modifier_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  # Create a new RescueNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:720
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).returns(Prism::RescueNode)
  end
  def rescue_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  # Create a new RestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:725
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::RestParameterNode)
  end
  def rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # Create a new RetryNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:730
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::RetryNode)
  end
  def retry_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ReturnNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:735
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).returns(Prism::ReturnNode)
  end
  def return_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Create a new SelfNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:740
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SelfNode)
  end
  def self_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new ShareableConstantNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:745
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).returns(Prism::ShareableConstantNode)
  end
  def shareable_constant_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  # Retrieve the value of one of the ShareableConstantNodeFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:953
  sig { params(name: Symbol).returns(Integer) }
  def shareable_constant_node_flag(name); end

  # Create a new SingletonClassNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:750
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).returns(Prism::SingletonClassNode)
  end
  def singleton_class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new Source object.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:70
  sig { params(string: String).returns(Prism::Source) }
  def source(string); end

  # Create a new SourceEncodingNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:755
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SourceEncodingNode)
  end
  def source_encoding_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new SourceFileNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:760
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).returns(Prism::SourceFileNode)
  end
  def source_file_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  # Create a new SourceLineNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:765
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::SourceLineNode)
  end
  def source_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new SplatNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:770
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).returns(Prism::SplatNode)
  end
  def splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  # Create a new StatementsNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:775
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).returns(Prism::StatementsNode)
  end
  def statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  # Retrieve the value of one of the StringFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:963
  sig { params(name: Symbol).returns(Integer) }
  def string_flag(name); end

  # Create a new StringNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:780
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::StringNode)
  end
  def string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # Create a new SuperNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:785
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::SuperNode)
  end
  def super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # Retrieve the value of one of the SymbolFlags flags.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:974
  sig { params(name: Symbol).returns(Integer) }
  def symbol_flag(name); end

  # Create a new SymbolNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:790
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::SymbolNode)
  end
  def symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # Create a new TrueNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:795
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer
    ).returns(Prism::TrueNode)
  end
  def true_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # Create a new UndefNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:800
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).returns(Prism::UndefNode)
  end
  def undef_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # Create a new UnlessNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:805
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::UnlessNode)
  end
  def unless_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # Create a new UntilNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:810
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::UntilNode)
  end
  def until_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  # Create a new WhenNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:815
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhenNode)
  end
  def when_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  # Create a new WhileNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:820
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhileNode)
  end
  def while_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  # Create a new XStringNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:825
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::XStringNode)
  end
  def x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # Create a new YieldNode node.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:830
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::YieldNode)
  end
  def yield_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  private

  # The default location object that gets attached to nodes if no location is
  # specified, which uses the given source.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:993
  sig { returns(Prism::Location) }
  def default_location; end

  # The default node that gets attached to nodes if no node is specified for a
  # required node field.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:999
  sig { params(source: Prism::Source, location: Prism::Location).returns(Prism::Node) }
  def default_node(source, location); end

  # The default source object that gets attached to nodes and locations if no
  # source is specified.
  #
  # pkg:gem/prism#lib/prism/dsl.rb:987
  sig { returns(Prism::Source) }
  def default_source; end
end

# Represents a method definition.
#
#     def method
#     end
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:5948
class Prism::DefNode < ::Prism::Node
  # Initialize a new DefNode node.
  #
  # @return [DefNode] a new instance of DefNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5950
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6189
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:5970
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: StatementsNode | BeginNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:6029
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5975
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:5989
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:5980
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?receiver: Prism::node?, ?parameters: ParametersNode?, ?body: StatementsNode | BeginNode | nil, ?locals: Array[Symbol], ?def_keyword_loc: Location, ?operator_loc: Location?, ?lparen_loc: Location?, ?rparen_loc: Location?, ?equal_loc: Location?, ?end_keyword_loc: Location?) -> DefNode
  #
  # pkg:gem/prism#lib/prism/node.rb:5994
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      receiver: T.nilable(Prism::Node),
      parameters: T.nilable(Prism::ParametersNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      locals: T::Array[Symbol],
      def_keyword_loc: Prism::Location,
      operator_loc: T.nilable(Prism::Location),
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      equal_loc: T.nilable(Prism::Location),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::DefNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:5999
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, receiver: Prism::node?, parameters: ParametersNode?, body: StatementsNode | BeginNode | nil, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:6002
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def def_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6143
  sig { returns(String) }
  def def_keyword; end

  # attr_reader def_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6035
  sig { returns(Prism::Location) }
  def def_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6168
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6124
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  # def equal: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6163
  sig { returns(T.nilable(String)) }
  def equal; end

  # attr_reader equal_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6105
  sig { returns(T.nilable(Prism::Location)) }
  def equal_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6173
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:6032
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6153
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6067
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:6007
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6010
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6148
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6048
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader parameters: ParametersNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:6026
  sig { returns(T.nilable(Prism::ParametersNode)) }
  def parameters; end

  # attr_reader receiver: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:6023
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6158
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6086
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the def_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6043
  def save_def_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6138
  def save_end_keyword_loc(repository); end

  # Save the equal_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6119
  def save_equal_loc(repository); end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6081
  def save_lparen_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6018
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6062
  def save_operator_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6100
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6178
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6183
    def type; end
  end
end

# Represents the use of the `defined?` keyword.
#
#     defined?(a)
#     ^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6211
class Prism::DefinedNode < ::Prism::Node
  # Initialize a new DefinedNode node.
  #
  # @return [DefinedNode] a new instance of DefinedNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6213
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, lparen_loc, value, rparen_loc, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6343
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6225
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6230
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6240
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6235
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lparen_loc: Location?, ?value: Prism::node, ?rparen_loc: Location?, ?keyword_loc: Location) -> DefinedNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6245
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lparen_loc: T.nilable(Prism::Location),
      value: Prism::Node,
      rparen_loc: T.nilable(Prism::Location),
      keyword_loc: Prism::Location
    ).returns(Prism::DefinedNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6250
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lparen_loc: Location?, value: Prism::node, rparen_loc: Location?, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:6253
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6327
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6322
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6299
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6312
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6258
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6317
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6280
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6307
  def save_keyword_loc(repository); end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6272
  def save_lparen_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6294
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6332
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:6277
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6337
    def type; end
  end
end

# pkg:gem/prism#lib/prism/desugar_compiler.rb:5
class Prism::DesugarAndWriteNode
  include ::Prism::DSL

  # @return [DesugarAndWriteNode] a new instance of DesugarAndWriteNode
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:10
  def initialize(node, default_source, read_class, write_class, **arguments); end

  # Returns the value of attribute arguments.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:8
  def arguments; end

  # Desugar `x &&= y` to `x && x = y`
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:19
  def compile; end

  # Returns the value of attribute default_source.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:8
  def default_source; end

  # Returns the value of attribute node.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:8
  def node; end

  # Returns the value of attribute read_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:8
  def read_class; end

  # Returns the value of attribute write_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:8
  def write_class; end
end

# DesugarCompiler is a compiler that desugars Ruby code into a more primitive
# form. This is useful for consumers that want to deal with fewer node types.
#
# pkg:gem/prism#lib/prism/desugar_compiler.rb:256
class Prism::DesugarCompiler < ::Prism::MutationCompiler
  # @@foo &&= bar
  #
  # becomes
  #
  # @@foo && @@foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:262
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  #
  # becomes
  #
  # @@foo = @@foo + bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:280
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  #
  # becomes
  #
  # defined?(@@foo) ? @@foo : @@foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:271
  def visit_class_variable_or_write_node(node); end

  # Foo &&= bar
  #
  # becomes
  #
  # Foo && Foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:289
  def visit_constant_and_write_node(node); end

  # Foo += bar
  #
  # becomes
  #
  # Foo = Foo + bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:307
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  #
  # becomes
  #
  # defined?(Foo) ? Foo : Foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:298
  def visit_constant_or_write_node(node); end

  # $foo &&= bar
  #
  # becomes
  #
  # $foo && $foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:316
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  #
  # becomes
  #
  # $foo = $foo + bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:334
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  #
  # becomes
  #
  # defined?($foo) ? $foo : $foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:325
  def visit_global_variable_or_write_node(node); end

  # becomes
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:343
  def visit_instance_variable_and_write_node(node); end

  # becomes
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:361
  def visit_instance_variable_operator_write_node(node); end

  # becomes
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:352
  def visit_instance_variable_or_write_node(node); end

  # foo &&= bar
  #
  # becomes
  #
  # foo && foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:370
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  #
  # becomes
  #
  # foo = foo + bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:388
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  #
  # becomes
  #
  # foo || foo = bar
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:379
  def visit_local_variable_or_write_node(node); end
end

# pkg:gem/prism#lib/prism/desugar_compiler.rb:87
class Prism::DesugarOperatorWriteNode
  include ::Prism::DSL

  # @return [DesugarOperatorWriteNode] a new instance of DesugarOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:92
  def initialize(node, default_source, read_class, write_class, **arguments); end

  # Returns the value of attribute arguments.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:90
  def arguments; end

  # Desugar `x += y` to `x = x + y`
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:101
  def compile; end

  # Returns the value of attribute default_source.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:90
  def default_source; end

  # Returns the value of attribute node.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:90
  def node; end

  # Returns the value of attribute read_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:90
  def read_class; end

  # Returns the value of attribute write_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:90
  def write_class; end
end

# pkg:gem/prism#lib/prism/desugar_compiler.rb:36
class Prism::DesugarOrWriteDefinedNode
  include ::Prism::DSL

  # @return [DesugarOrWriteDefinedNode] a new instance of DesugarOrWriteDefinedNode
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:41
  def initialize(node, default_source, read_class, write_class, **arguments); end

  # Returns the value of attribute arguments.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:39
  def arguments; end

  # Desugar `x ||= y` to `defined?(x) ? x : x = y`
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:50
  def compile; end

  # Returns the value of attribute default_source.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:39
  def default_source; end

  # Returns the value of attribute node.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:39
  def node; end

  # Returns the value of attribute read_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:39
  def read_class; end

  # Returns the value of attribute write_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:39
  def write_class; end
end

# pkg:gem/prism#lib/prism/desugar_compiler.rb:131
class Prism::DesugarOrWriteNode
  include ::Prism::DSL

  # @return [DesugarOrWriteNode] a new instance of DesugarOrWriteNode
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:136
  def initialize(node, default_source, read_class, write_class, **arguments); end

  # Returns the value of attribute arguments.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:134
  def arguments; end

  # Desugar `x ||= y` to `x || x = y`
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:145
  def compile; end

  # Returns the value of attribute default_source.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:134
  def default_source; end

  # Returns the value of attribute node.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:134
  def node; end

  # Returns the value of attribute read_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:134
  def read_class; end

  # Returns the value of attribute write_class.
  #
  # pkg:gem/prism#lib/prism/desugar_compiler.rb:134
  def write_class; end
end

# The dispatcher class fires events for nodes that are found while walking an
# AST to all registered listeners. It's useful for performing different types
# of analysis on the AST while only having to walk the tree once.
#
# To use the dispatcher, you would first instantiate it and register listeners
# for the events you're interested in:
#
#     class OctalListener
#       def on_integer_node_enter(node)
#         if node.octal? && !node.slice.start_with?("0o")
#           warn("Octal integers should be written with the 0o prefix")
#         end
#       end
#     end
#
#     listener = OctalListener.new
#     dispatcher = Prism::Dispatcher.new
#     dispatcher.register(listener, :on_integer_node_enter)
#
# Then, you can walk any number of trees and dispatch events to the listeners:
#
#     result = Prism.parse("001 + 002 + 003")
#     dispatcher.dispatch(result.value)
#
# Optionally, you can also use `#dispatch_once` to dispatch enter and leave
# events for a single node without recursing further down the tree. This can
# be useful in circumstances where you want to reuse the listeners you already
# have registers but want to stop walking the tree at a certain point.
#
#     integer = result.value.statements.body.first.receiver.receiver
#     dispatcher.dispatch_once(integer)
#
# pkg:gem/prism#lib/prism/dispatcher.rb:45
class Prism::Dispatcher < ::Prism::Visitor
  # Initialize a new dispatcher.
  #
  # @return [Dispatcher] a new instance of Dispatcher
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:50
  def initialize; end

  # Walks `root` dispatching events to all registered listeners.
  #
  # def dispatch: (Node) -> void
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:77
  def dispatch(node); end

  # Dispatches a single event for `node` to all registered listeners.
  #
  # def dispatch_once: (Node) -> void
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:82
  def dispatch_once(node); end

  # attr_reader listeners: Hash[Symbol, Array[Listener]]
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:47
  def listeners; end

  # Register a listener for one or more events.
  #
  # def register: (Listener, *Symbol) -> void
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:57
  def register(listener, *events); end

  # Register all public methods of a listener that match the pattern
  # `on_<node_name>_(enter|leave)`.
  #
  # def register_public_methods: (Listener) -> void
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:65
  def register_public_methods(listener); end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:88
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:96
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:104
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:112
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:120
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:128
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:136
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:144
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:152
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:160
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:168
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:176
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:184
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:192
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:200
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:208
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:216
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:224
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:232
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:240
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:248
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:256
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:264
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:272
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:280
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:288
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:296
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:304
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:312
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:320
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:328
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:336
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:344
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:352
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:360
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:368
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:376
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:384
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:392
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:400
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:408
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:416
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:424
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:432
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:440
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:448
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:456
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:464
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:472
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:480
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:488
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:496
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:504
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:512
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:520
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:528
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:536
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:544
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:552
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:560
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:568
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:576
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:584
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:592
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:600
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:608
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:616
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:624
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:632
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:640
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:648
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:656
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:664
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:672
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:680
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:688
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:696
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:704
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:712
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:720
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:728
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:736
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:744
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:752
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:760
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:768
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:776
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for ItLocalVariableReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:784
  def visit_it_local_variable_read_node(node); end

  # Dispatch enter and leave events for ItParametersNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:792
  def visit_it_parameters_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:800
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:808
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:816
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:824
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:832
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:840
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:848
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:856
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:864
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:872
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:880
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:888
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:896
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:904
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:912
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:920
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:928
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:936
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:944
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:952
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:960
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:968
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:976
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:984
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:992
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1000
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1008
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1016
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1024
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1032
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1040
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1048
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1056
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1064
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1072
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1080
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1088
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1096
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1104
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1112
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1120
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1128
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1136
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1144
  def visit_self_node(node); end

  # Dispatch enter and leave events for ShareableConstantNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1152
  def visit_shareable_constant_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1160
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1168
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1176
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1184
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1192
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1200
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1208
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1216
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1224
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1232
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1240
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1248
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1256
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1264
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1272
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1280
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes and continue
  # walking the tree.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1288
  def visit_yield_node(node); end

  private

  # Register a listener for the given events.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:70
  def register_events(listener, events); end
end

# pkg:gem/prism#lib/prism/dispatcher.rb:1294
class Prism::Dispatcher::DispatchOnce < ::Prism::Visitor
  # @return [DispatchOnce] a new instance of DispatchOnce
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1297
  def initialize(listeners); end

  # Returns the value of attribute listeners.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1295
  def listeners; end

  # Dispatch enter and leave events for AliasGlobalVariableNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1302
  def visit_alias_global_variable_node(node); end

  # Dispatch enter and leave events for AliasMethodNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1308
  def visit_alias_method_node(node); end

  # Dispatch enter and leave events for AlternationPatternNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1314
  def visit_alternation_pattern_node(node); end

  # Dispatch enter and leave events for AndNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1320
  def visit_and_node(node); end

  # Dispatch enter and leave events for ArgumentsNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1326
  def visit_arguments_node(node); end

  # Dispatch enter and leave events for ArrayNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1332
  def visit_array_node(node); end

  # Dispatch enter and leave events for ArrayPatternNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1338
  def visit_array_pattern_node(node); end

  # Dispatch enter and leave events for AssocNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1344
  def visit_assoc_node(node); end

  # Dispatch enter and leave events for AssocSplatNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1350
  def visit_assoc_splat_node(node); end

  # Dispatch enter and leave events for BackReferenceReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1356
  def visit_back_reference_read_node(node); end

  # Dispatch enter and leave events for BeginNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1362
  def visit_begin_node(node); end

  # Dispatch enter and leave events for BlockArgumentNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1368
  def visit_block_argument_node(node); end

  # Dispatch enter and leave events for BlockLocalVariableNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1374
  def visit_block_local_variable_node(node); end

  # Dispatch enter and leave events for BlockNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1380
  def visit_block_node(node); end

  # Dispatch enter and leave events for BlockParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1386
  def visit_block_parameter_node(node); end

  # Dispatch enter and leave events for BlockParametersNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1392
  def visit_block_parameters_node(node); end

  # Dispatch enter and leave events for BreakNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1398
  def visit_break_node(node); end

  # Dispatch enter and leave events for CallAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1404
  def visit_call_and_write_node(node); end

  # Dispatch enter and leave events for CallNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1410
  def visit_call_node(node); end

  # Dispatch enter and leave events for CallOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1416
  def visit_call_operator_write_node(node); end

  # Dispatch enter and leave events for CallOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1422
  def visit_call_or_write_node(node); end

  # Dispatch enter and leave events for CallTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1428
  def visit_call_target_node(node); end

  # Dispatch enter and leave events for CapturePatternNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1434
  def visit_capture_pattern_node(node); end

  # Dispatch enter and leave events for CaseMatchNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1440
  def visit_case_match_node(node); end

  # Dispatch enter and leave events for CaseNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1446
  def visit_case_node(node); end

  # Dispatch enter and leave events for ClassNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1452
  def visit_class_node(node); end

  # Dispatch enter and leave events for ClassVariableAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1458
  def visit_class_variable_and_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1464
  def visit_class_variable_operator_write_node(node); end

  # Dispatch enter and leave events for ClassVariableOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1470
  def visit_class_variable_or_write_node(node); end

  # Dispatch enter and leave events for ClassVariableReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1476
  def visit_class_variable_read_node(node); end

  # Dispatch enter and leave events for ClassVariableTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1482
  def visit_class_variable_target_node(node); end

  # Dispatch enter and leave events for ClassVariableWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1488
  def visit_class_variable_write_node(node); end

  # Dispatch enter and leave events for ConstantAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1494
  def visit_constant_and_write_node(node); end

  # Dispatch enter and leave events for ConstantOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1500
  def visit_constant_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1506
  def visit_constant_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1512
  def visit_constant_path_and_write_node(node); end

  # Dispatch enter and leave events for ConstantPathNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1518
  def visit_constant_path_node(node); end

  # Dispatch enter and leave events for ConstantPathOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1524
  def visit_constant_path_operator_write_node(node); end

  # Dispatch enter and leave events for ConstantPathOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1530
  def visit_constant_path_or_write_node(node); end

  # Dispatch enter and leave events for ConstantPathTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1536
  def visit_constant_path_target_node(node); end

  # Dispatch enter and leave events for ConstantPathWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1542
  def visit_constant_path_write_node(node); end

  # Dispatch enter and leave events for ConstantReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1548
  def visit_constant_read_node(node); end

  # Dispatch enter and leave events for ConstantTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1554
  def visit_constant_target_node(node); end

  # Dispatch enter and leave events for ConstantWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1560
  def visit_constant_write_node(node); end

  # Dispatch enter and leave events for DefNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1566
  def visit_def_node(node); end

  # Dispatch enter and leave events for DefinedNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1572
  def visit_defined_node(node); end

  # Dispatch enter and leave events for ElseNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1578
  def visit_else_node(node); end

  # Dispatch enter and leave events for EmbeddedStatementsNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1584
  def visit_embedded_statements_node(node); end

  # Dispatch enter and leave events for EmbeddedVariableNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1590
  def visit_embedded_variable_node(node); end

  # Dispatch enter and leave events for EnsureNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1596
  def visit_ensure_node(node); end

  # Dispatch enter and leave events for FalseNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1602
  def visit_false_node(node); end

  # Dispatch enter and leave events for FindPatternNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1608
  def visit_find_pattern_node(node); end

  # Dispatch enter and leave events for FlipFlopNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1614
  def visit_flip_flop_node(node); end

  # Dispatch enter and leave events for FloatNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1620
  def visit_float_node(node); end

  # Dispatch enter and leave events for ForNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1626
  def visit_for_node(node); end

  # Dispatch enter and leave events for ForwardingArgumentsNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1632
  def visit_forwarding_arguments_node(node); end

  # Dispatch enter and leave events for ForwardingParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1638
  def visit_forwarding_parameter_node(node); end

  # Dispatch enter and leave events for ForwardingSuperNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1644
  def visit_forwarding_super_node(node); end

  # Dispatch enter and leave events for GlobalVariableAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1650
  def visit_global_variable_and_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1656
  def visit_global_variable_operator_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1662
  def visit_global_variable_or_write_node(node); end

  # Dispatch enter and leave events for GlobalVariableReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1668
  def visit_global_variable_read_node(node); end

  # Dispatch enter and leave events for GlobalVariableTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1674
  def visit_global_variable_target_node(node); end

  # Dispatch enter and leave events for GlobalVariableWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1680
  def visit_global_variable_write_node(node); end

  # Dispatch enter and leave events for HashNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1686
  def visit_hash_node(node); end

  # Dispatch enter and leave events for HashPatternNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1692
  def visit_hash_pattern_node(node); end

  # Dispatch enter and leave events for IfNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1698
  def visit_if_node(node); end

  # Dispatch enter and leave events for ImaginaryNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1704
  def visit_imaginary_node(node); end

  # Dispatch enter and leave events for ImplicitNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1710
  def visit_implicit_node(node); end

  # Dispatch enter and leave events for ImplicitRestNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1716
  def visit_implicit_rest_node(node); end

  # Dispatch enter and leave events for InNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1722
  def visit_in_node(node); end

  # Dispatch enter and leave events for IndexAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1728
  def visit_index_and_write_node(node); end

  # Dispatch enter and leave events for IndexOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1734
  def visit_index_operator_write_node(node); end

  # Dispatch enter and leave events for IndexOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1740
  def visit_index_or_write_node(node); end

  # Dispatch enter and leave events for IndexTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1746
  def visit_index_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1752
  def visit_instance_variable_and_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1758
  def visit_instance_variable_operator_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1764
  def visit_instance_variable_or_write_node(node); end

  # Dispatch enter and leave events for InstanceVariableReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1770
  def visit_instance_variable_read_node(node); end

  # Dispatch enter and leave events for InstanceVariableTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1776
  def visit_instance_variable_target_node(node); end

  # Dispatch enter and leave events for InstanceVariableWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1782
  def visit_instance_variable_write_node(node); end

  # Dispatch enter and leave events for IntegerNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1788
  def visit_integer_node(node); end

  # Dispatch enter and leave events for InterpolatedMatchLastLineNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1794
  def visit_interpolated_match_last_line_node(node); end

  # Dispatch enter and leave events for InterpolatedRegularExpressionNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1800
  def visit_interpolated_regular_expression_node(node); end

  # Dispatch enter and leave events for InterpolatedStringNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1806
  def visit_interpolated_string_node(node); end

  # Dispatch enter and leave events for InterpolatedSymbolNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1812
  def visit_interpolated_symbol_node(node); end

  # Dispatch enter and leave events for InterpolatedXStringNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1818
  def visit_interpolated_x_string_node(node); end

  # Dispatch enter and leave events for ItLocalVariableReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1824
  def visit_it_local_variable_read_node(node); end

  # Dispatch enter and leave events for ItParametersNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1830
  def visit_it_parameters_node(node); end

  # Dispatch enter and leave events for KeywordHashNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1836
  def visit_keyword_hash_node(node); end

  # Dispatch enter and leave events for KeywordRestParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1842
  def visit_keyword_rest_parameter_node(node); end

  # Dispatch enter and leave events for LambdaNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1848
  def visit_lambda_node(node); end

  # Dispatch enter and leave events for LocalVariableAndWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1854
  def visit_local_variable_and_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOperatorWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1860
  def visit_local_variable_operator_write_node(node); end

  # Dispatch enter and leave events for LocalVariableOrWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1866
  def visit_local_variable_or_write_node(node); end

  # Dispatch enter and leave events for LocalVariableReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1872
  def visit_local_variable_read_node(node); end

  # Dispatch enter and leave events for LocalVariableTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1878
  def visit_local_variable_target_node(node); end

  # Dispatch enter and leave events for LocalVariableWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1884
  def visit_local_variable_write_node(node); end

  # Dispatch enter and leave events for MatchLastLineNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1890
  def visit_match_last_line_node(node); end

  # Dispatch enter and leave events for MatchPredicateNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1896
  def visit_match_predicate_node(node); end

  # Dispatch enter and leave events for MatchRequiredNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1902
  def visit_match_required_node(node); end

  # Dispatch enter and leave events for MatchWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1908
  def visit_match_write_node(node); end

  # Dispatch enter and leave events for MissingNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1914
  def visit_missing_node(node); end

  # Dispatch enter and leave events for ModuleNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1920
  def visit_module_node(node); end

  # Dispatch enter and leave events for MultiTargetNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1926
  def visit_multi_target_node(node); end

  # Dispatch enter and leave events for MultiWriteNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1932
  def visit_multi_write_node(node); end

  # Dispatch enter and leave events for NextNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1938
  def visit_next_node(node); end

  # Dispatch enter and leave events for NilNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1944
  def visit_nil_node(node); end

  # Dispatch enter and leave events for NoKeywordsParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1950
  def visit_no_keywords_parameter_node(node); end

  # Dispatch enter and leave events for NumberedParametersNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1956
  def visit_numbered_parameters_node(node); end

  # Dispatch enter and leave events for NumberedReferenceReadNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1962
  def visit_numbered_reference_read_node(node); end

  # Dispatch enter and leave events for OptionalKeywordParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1968
  def visit_optional_keyword_parameter_node(node); end

  # Dispatch enter and leave events for OptionalParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1974
  def visit_optional_parameter_node(node); end

  # Dispatch enter and leave events for OrNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1980
  def visit_or_node(node); end

  # Dispatch enter and leave events for ParametersNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1986
  def visit_parameters_node(node); end

  # Dispatch enter and leave events for ParenthesesNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1992
  def visit_parentheses_node(node); end

  # Dispatch enter and leave events for PinnedExpressionNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:1998
  def visit_pinned_expression_node(node); end

  # Dispatch enter and leave events for PinnedVariableNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2004
  def visit_pinned_variable_node(node); end

  # Dispatch enter and leave events for PostExecutionNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2010
  def visit_post_execution_node(node); end

  # Dispatch enter and leave events for PreExecutionNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2016
  def visit_pre_execution_node(node); end

  # Dispatch enter and leave events for ProgramNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2022
  def visit_program_node(node); end

  # Dispatch enter and leave events for RangeNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2028
  def visit_range_node(node); end

  # Dispatch enter and leave events for RationalNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2034
  def visit_rational_node(node); end

  # Dispatch enter and leave events for RedoNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2040
  def visit_redo_node(node); end

  # Dispatch enter and leave events for RegularExpressionNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2046
  def visit_regular_expression_node(node); end

  # Dispatch enter and leave events for RequiredKeywordParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2052
  def visit_required_keyword_parameter_node(node); end

  # Dispatch enter and leave events for RequiredParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2058
  def visit_required_parameter_node(node); end

  # Dispatch enter and leave events for RescueModifierNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2064
  def visit_rescue_modifier_node(node); end

  # Dispatch enter and leave events for RescueNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2070
  def visit_rescue_node(node); end

  # Dispatch enter and leave events for RestParameterNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2076
  def visit_rest_parameter_node(node); end

  # Dispatch enter and leave events for RetryNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2082
  def visit_retry_node(node); end

  # Dispatch enter and leave events for ReturnNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2088
  def visit_return_node(node); end

  # Dispatch enter and leave events for SelfNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2094
  def visit_self_node(node); end

  # Dispatch enter and leave events for ShareableConstantNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2100
  def visit_shareable_constant_node(node); end

  # Dispatch enter and leave events for SingletonClassNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2106
  def visit_singleton_class_node(node); end

  # Dispatch enter and leave events for SourceEncodingNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2112
  def visit_source_encoding_node(node); end

  # Dispatch enter and leave events for SourceFileNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2118
  def visit_source_file_node(node); end

  # Dispatch enter and leave events for SourceLineNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2124
  def visit_source_line_node(node); end

  # Dispatch enter and leave events for SplatNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2130
  def visit_splat_node(node); end

  # Dispatch enter and leave events for StatementsNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2136
  def visit_statements_node(node); end

  # Dispatch enter and leave events for StringNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2142
  def visit_string_node(node); end

  # Dispatch enter and leave events for SuperNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2148
  def visit_super_node(node); end

  # Dispatch enter and leave events for SymbolNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2154
  def visit_symbol_node(node); end

  # Dispatch enter and leave events for TrueNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2160
  def visit_true_node(node); end

  # Dispatch enter and leave events for UndefNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2166
  def visit_undef_node(node); end

  # Dispatch enter and leave events for UnlessNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2172
  def visit_unless_node(node); end

  # Dispatch enter and leave events for UntilNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2178
  def visit_until_node(node); end

  # Dispatch enter and leave events for WhenNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2184
  def visit_when_node(node); end

  # Dispatch enter and leave events for WhileNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2190
  def visit_while_node(node); end

  # Dispatch enter and leave events for XStringNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2196
  def visit_x_string_node(node); end

  # Dispatch enter and leave events for YieldNode nodes.
  #
  # pkg:gem/prism#lib/prism/dispatcher.rb:2202
  def visit_yield_node(node); end
end

# This visitor provides the ability to call Node#to_dot, which converts a
# subtree into a graphviz dot graph.
#
# pkg:gem/prism#lib/prism/dot_visitor.rb:18
class Prism::DotVisitor < ::Prism::Visitor
  # Initialize a new dot visitor.
  #
  # @return [DotVisitor] a new instance of DotVisitor
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:110
  def initialize; end

  # The digraph that is being built.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:107
  def digraph; end

  # Convert this visitor into a graphviz dot graph string.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:115
  def to_dot; end

  # Visit a AliasGlobalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:120
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:145
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:170
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:195
  def visit_and_node(node); end

  # Visit a ArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:220
  def visit_arguments_node(node); end

  # Visit a ArrayNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:250
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:290
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:352
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:379
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:402
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:419
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:467
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:490
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:510
  def visit_block_node(node); end

  # Visit a BlockParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:545
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:573
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:616
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:639
  def visit_call_and_write_node(node); end

  # Visit a CallNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:685
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:748
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:797
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:843
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:873
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:898
  def visit_case_match_node(node); end

  # Visit a CaseNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:943
  def visit_case_node(node); end

  # Visit a ClassNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:988
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1035
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1062
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1092
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1119
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1136
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1153
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1180
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1207
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1237
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1264
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1289
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1318
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1346
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1371
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1400
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1425
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1442
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1459
  def visit_constant_write_node(node); end

  # Visit a DefNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1486
  def visit_def_node(node); end

  # Visit a DefinedNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1555
  def visit_defined_node(node); end

  # Visit a ElseNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1586
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1614
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1640
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1661
  def visit_ensure_node(node); end

  # Visit a FalseNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1687
  def visit_false_node(node); end

  # Visit a FindPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1701
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1752
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1784
  def visit_float_node(node); end

  # Visit a ForNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1801
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1843
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1857
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1871
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1891
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1918
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1948
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1975
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:1992
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2009
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2036
  def visit_hash_node(node); end

  # Visit a HashPatternNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2069
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2118
  def visit_if_node(node); end

  # Visit a ImaginaryNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2163
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2181
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2199
  def visit_implicit_rest_node(node); end

  # Visit a InNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2213
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2245
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2298
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2354
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2407
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2446
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2473
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2503
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2530
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2547
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2564
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2591
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2611
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2647
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2683
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2723
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2760
  def visit_interpolated_x_string_node(node); end

  # Visit a ItLocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2793
  def visit_it_local_variable_read_node(node); end

  # Visit a ItParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2807
  def visit_it_parameters_node(node); end

  # Visit a KeywordHashNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2821
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2851
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2879
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2917
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2947
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:2980
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3010
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3030
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3050
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3080
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3109
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3134
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3159
  def visit_match_write_node(node); end

  # Visit a MissingNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3190
  def visit_missing_node(node); end

  # Visit a ModuleNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3204
  def visit_module_node(node); end

  # Visit a MultiTargetNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3240
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3296
  def visit_multi_write_node(node); end

  # Visit a NextNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3359
  def visit_next_node(node); end

  # Visit a NilNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3382
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3396
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3416
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3433
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3450
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3477
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3507
  def visit_or_node(node); end

  # Visit a ParametersNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3532
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3616
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3645
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3672
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3693
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3722
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3751
  def visit_program_node(node); end

  # Visit a RangeNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3772
  def visit_range_node(node); end

  # Visit a RationalNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3804
  def visit_rational_node(node); end

  # Visit a RedoNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3827
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3841
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3870
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3893
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3913
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3938
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:3996
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4024
  def visit_retry_node(node); end

  # Visit a ReturnNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4038
  def visit_return_node(node); end

  # Visit a SelfNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4061
  def visit_self_node(node); end

  # Visit a ShareableConstantNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4075
  def visit_shareable_constant_node(node); end

  # Visit a SingletonClassNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4096
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4132
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4146
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4166
  def visit_source_line_node(node); end

  # Visit a SplatNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4180
  def visit_splat_node(node); end

  # Visit a StatementsNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4203
  def visit_statements_node(node); end

  # Visit a StringNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4230
  def visit_string_node(node); end

  # Visit a SuperNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4263
  def visit_super_node(node); end

  # Visit a SymbolNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4302
  def visit_symbol_node(node); end

  # Visit a TrueNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4337
  def visit_true_node(node); end

  # Visit a UndefNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4351
  def visit_undef_node(node); end

  # Visit a UnlessNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4381
  def visit_unless_node(node); end

  # Visit a UntilNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4424
  def visit_until_node(node); end

  # Visit a WhenNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4464
  def visit_when_node(node); end

  # Visit a WhileNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4505
  def visit_while_node(node); end

  # Visit a XStringNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4545
  def visit_x_string_node(node); end

  # Visit a YieldNode node.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4574
  def visit_yield_node(node); end

  private

  # Inspect a node that has arguments_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4620
  def arguments_node_flags_inspect(node); end

  # Inspect a node that has array_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4632
  def array_node_flags_inspect(node); end

  # Inspect a node that has call_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4640
  def call_node_flags_inspect(node); end

  # Inspect a node that has encoding_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4651
  def encoding_flags_inspect(node); end

  # Inspect a node that has integer_base_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4660
  def integer_base_flags_inspect(node); end

  # Inspect a node that has interpolated_string_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4671
  def interpolated_string_node_flags_inspect(node); end

  # Inspect a node that has keyword_hash_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4680
  def keyword_hash_node_flags_inspect(node); end

  # Inspect a location to display the start and end line and column numbers.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4614
  def location_inspect(location); end

  # Inspect a node that has loop_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4688
  def loop_flags_inspect(node); end

  # Generate a unique node ID for a node throughout the digraph.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4609
  def node_id(node); end

  # Inspect a node that has parameter_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4696
  def parameter_flags_inspect(node); end

  # Inspect a node that has parentheses_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4704
  def parentheses_node_flags_inspect(node); end

  # Inspect a node that has range_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4712
  def range_flags_inspect(node); end

  # Inspect a node that has regular_expression_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4720
  def regular_expression_flags_inspect(node); end

  # Inspect a node that has shareable_constant_node_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4738
  def shareable_constant_node_flags_inspect(node); end

  # Inspect a node that has string_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4748
  def string_flags_inspect(node); end

  # Inspect a node that has symbol_flags flags to display the flags as a
  # comma-separated list.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:4759
  def symbol_flags_inspect(node); end
end

# pkg:gem/prism#lib/prism/dot_visitor.rb:63
class Prism::DotVisitor::Digraph
  # @return [Digraph] a new instance of Digraph
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:66
  def initialize; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:80
  def edge(value); end

  # Returns the value of attribute edges.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:64
  def edges; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:72
  def node(value); end

  # Returns the value of attribute nodes.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:64
  def nodes; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:84
  def to_dot; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:76
  def waypoint(value); end

  # Returns the value of attribute waypoints.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:64
  def waypoints; end
end

# pkg:gem/prism#lib/prism/dot_visitor.rb:19
class Prism::DotVisitor::Field
  # @return [Field] a new instance of Field
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:22
  def initialize(name, value, port); end

  # Returns the value of attribute name.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:20
  def name; end

  # Returns the value of attribute port.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:20
  def port; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:28
  def to_dot; end

  # Returns the value of attribute value.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:20
  def value; end
end

# pkg:gem/prism#lib/prism/dot_visitor.rb:37
class Prism::DotVisitor::Table
  # @return [Table] a new instance of Table
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:40
  def initialize(name); end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:45
  def field(name, value = T.unsafe(nil), port: T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:38
  def fields; end

  # Returns the value of attribute name.
  #
  # pkg:gem/prism#lib/prism/dot_visitor.rb:38
  def name; end

  # pkg:gem/prism#lib/prism/dot_visitor.rb:49
  def to_dot; end
end

# Represents an `else` clause in a `case`, `if`, or `unless` statement.
#
#     if a then b else c end
#                 ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6356
class Prism::ElseNode < ::Prism::Node
  # Initialize a new ElseNode node.
  #
  # @return [ElseNode] a new instance of ElseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6358
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, else_keyword_loc, statements, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6465
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6369
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6374
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6386
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6379
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?else_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location?) -> ElseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6391
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      else_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::ElseNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6396
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:6399
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def else_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6439
  sig { returns(String) }
  def else_keyword; end

  # attr_reader else_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6404
  sig { returns(Prism::Location) }
  def else_keyword_loc; end

  # def end_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:6444
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:6420
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6449
  sig { override.returns(String) }
  def inspect; end

  # Save the else_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6412
  def save_else_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6434
  def save_end_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:6417
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6454
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6459
    def type; end
  end
end

# EmbDocComment objects correspond to comments that are surrounded by =begin
# and =end.
#
# pkg:gem/prism#lib/prism/parse_result.rb:549
class Prism::EmbDocComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:556
  sig { returns(String) }
  def inspect; end

  # This can only be true for inline comments.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:551
  sig { override.returns(T::Boolean) }
  def trailing?; end
end

# Represents an interpolated set of statements.
#
#     "foo #{bar}"
#          ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6477
class Prism::EmbeddedStatementsNode < ::Prism::Node
  # Initialize a new EmbeddedStatementsNode node.
  #
  # @return [EmbeddedStatementsNode] a new instance of EmbeddedStatementsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6479
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, statements, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6580
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6490
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6495
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6559
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6541
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6507
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6500
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?statements: StatementsNode?, ?closing_loc: Location) -> EmbeddedStatementsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6512
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      closing_loc: Prism::Location
    ).returns(Prism::EmbeddedStatementsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6517
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, statements: StatementsNode?, closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:6520
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6564
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6554
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6525
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6549
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6533
  def save_opening_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:6538
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6569
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6574
    def type; end
  end
end

# Represents an interpolated variable.
#
#     "foo #@bar"
#          ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6592
class Prism::EmbeddedVariableNode < ::Prism::Node
  # Initialize a new EmbeddedVariableNode node.
  #
  # @return [EmbeddedVariableNode] a new instance of EmbeddedVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6594
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, variable); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6674
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6604
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6609
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6619
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6614
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode) -> EmbeddedVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6624
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      variable: T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)
    ).returns(Prism::EmbeddedVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6629
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode }
  #
  # pkg:gem/prism#lib/prism/node.rb:6632
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6658
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6653
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6637
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6645
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6663
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6650
  sig do
    returns(T.any(Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode))
  end
  def variable; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6668
    def type; end
  end
end

# Flags for nodes that have unescaped content.
#
# pkg:gem/prism#lib/prism/node.rb:18708
module Prism::EncodingFlags; end

# internal bytes forced the encoding to binary
#
# pkg:gem/prism#lib/prism/node.rb:18713
Prism::EncodingFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# pkg:gem/prism#lib/prism/node.rb:18710
Prism::EncodingFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents an `ensure` clause in a `begin` statement.
#
#     begin
#       foo
#     ensure
#     ^^^^^^
#       bar
#     end
#
# pkg:gem/prism#lib/prism/node.rb:6689
class Prism::EnsureNode < ::Prism::Node
  # Initialize a new EnsureNode node.
  #
  # @return [EnsureNode] a new instance of EnsureNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6691
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, ensure_keyword_loc, statements, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6792
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6702
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6707
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6719
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6712
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?ensure_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location) -> EnsureNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6724
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      ensure_keyword_loc: Prism::Location,
      statements: T.nilable(Prism::StatementsNode),
      end_keyword_loc: Prism::Location
    ).returns(Prism::EnsureNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6729
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:6732
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6771
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6753
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # def ensure_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6766
  sig { returns(String) }
  def ensure_keyword; end

  # attr_reader ensure_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:6737
  sig { returns(Prism::Location) }
  def ensure_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6776
  sig { override.returns(String) }
  def inspect; end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6761
  def save_end_keyword_loc(repository); end

  # Save the ensure_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6745
  def save_ensure_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:6750
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6781
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6786
    def type; end
  end
end

# Represents the use of the literal `false` keyword.
#
#     false
#     ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6804
class Prism::FalseNode < ::Prism::Node
  # Initialize a new FalseNode node.
  #
  # @return [FalseNode] a new instance of FalseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6806
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:6863
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6814
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6819
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6829
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6824
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> FalseNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6834
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::FalseNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6839
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:6842
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:6847
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:6852
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:6857
    def type; end
  end
end

# Represents a find pattern in pattern matching.
#
#     foo in *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
#     foo in [*bar, baz, *qux]
#            ^^^^^^^^^^^^^^^^^
#
#     foo in Foo(*bar, baz, *qux)
#            ^^^^^^^^^^^^^^^^^^^^
#
#     foo => *bar, baz, *qux
#            ^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:6881
class Prism::FindPatternNode < ::Prism::Node
  # Initialize a new FindPatternNode node.
  #
  # @return [FindPatternNode] a new instance of FindPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6883
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, left, requireds, right, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7044
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:6897
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6902
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:7023
  sig { returns(T.nilable(String)) }
  def closing; end

  # The location of the closing brace.
  #
  #     foo in [*bar, baz, *qux]
  #                            ^
  #
  #     foo in Foo(*bar, baz, *qux)
  #                               ^
  #
  # pkg:gem/prism#lib/prism/node.rb:6999
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:6917
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:6907
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Represents the optional constant preceding the pattern
  #
  #     foo in Foo(*bar, baz, *qux)
  #            ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:6938
  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantPathNode | ConstantReadNode | nil, ?left: SplatNode, ?requireds: Array[Prism::node], ?right: SplatNode | MissingNode, ?opening_loc: Location?, ?closing_loc: Location?) -> FindPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:6922
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      left: Prism::SplatNode,
      requireds: T::Array[Prism::Node],
      right: T.any(Prism::SplatNode, Prism::MissingNode),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::FindPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:6927
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantPathNode | ConstantReadNode | nil, left: SplatNode, requireds: Array[Prism::node], right: SplatNode | MissingNode, opening_loc: Location?, closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:6930
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7028
  sig { override.returns(String) }
  def inspect; end

  # Represents the first wildcard node in the pattern.
  #
  #     foo in *bar, baz, *qux
  #            ^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #                ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:6947
  sig { returns(Prism::SplatNode) }
  def left; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:7018
  sig { returns(T.nilable(String)) }
  def opening; end

  # The location of the opening brace.
  #
  #     foo in [*bar, baz, *qux]
  #            ^
  #
  #     foo in Foo(*bar, baz, *qux)
  #               ^
  #
  # pkg:gem/prism#lib/prism/node.rb:6974
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Represents the nodes in between the wildcards.
  #
  #     foo in *bar, baz, *qux
  #                  ^^^
  #
  #     foo in Foo(*bar, baz, 1, *qux)
  #                      ^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:6956
  sig { returns(T::Array[Prism::Node]) }
  def requireds; end

  # Represents the second wildcard node in the pattern.
  #
  #     foo in *bar, baz, *qux
  #                       ^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #                           ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:6965
  sig { returns(T.any(Prism::SplatNode, Prism::MissingNode)) }
  def right; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7013
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:6988
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7033
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7038
    def type; end
  end
end

# Represents the use of the `..` or `...` operators to create flip flops.
#
#     baz if foo .. bar
#            ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7060
class Prism::FlipFlopNode < ::Prism::Node
  # Initialize a new FlipFlopNode node.
  #
  # @return [FlipFlopNode] a new instance of FlipFlopNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7062
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7154
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7073
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7078
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7091
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7083
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> FlipFlopNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7096
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::FlipFlopNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7101
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node?, right: Prism::node?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:7104
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:7109
  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7138
  sig { override.returns(String) }
  def inspect; end

  # attr_reader left: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:7114
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7133
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7120
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader right: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:7117
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7128
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7143
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7148
    def type; end
  end
end

# Represents a floating point number literal.
#
#     1.0
#     ^^^
#
# pkg:gem/prism#lib/prism/node.rb:7167
class Prism::FloatNode < ::Prism::Node
  # Initialize a new FloatNode node.
  #
  # @return [FloatNode] a new instance of FloatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7169
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, value: Float).void }
  def initialize(source, node_id, location, flags, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7230
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7178
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7183
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7193
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7188
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Float) -> FloatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7198
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer, value: Float).returns(Prism::FloatNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7203
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Float }
  #
  # pkg:gem/prism#lib/prism/node.rb:7206
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7214
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7219
  sig { override.returns(Symbol) }
  def type; end

  # The value of the floating point number as a Float.
  #
  # pkg:gem/prism#lib/prism/node.rb:7211
  sig { returns(Float) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7224
    def type; end
  end
end

# Represents the use of the `for` keyword.
#
#     for i in a end
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7240
class Prism::ForNode < ::Prism::Node
  # Initialize a new ForNode node.
  #
  # @return [ForNode] a new instance of ForNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7242
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7420
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7257
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7262
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # The collection to iterate over.
  #
  #     for i in a end
  #              ^
  #
  # pkg:gem/prism#lib/prism/node.rb:7303
  sig { returns(Prism::Node) }
  def collection; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7276
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7267
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode, ?collection: Prism::node, ?statements: StatementsNode?, ?for_keyword_loc: Location, ?in_keyword_loc: Location, ?do_keyword_loc: Location?, ?end_keyword_loc: Location) -> ForNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7281
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      index: T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode),
      collection: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      for_keyword_loc: Prism::Location,
      in_keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      end_keyword_loc: Prism::Location
    ).returns(Prism::ForNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7286
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode, collection: Prism::node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:7289
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:7394
  sig { returns(T.nilable(String)) }
  def do_keyword; end

  # The location of the `do` keyword, if present.
  #
  #     for i in a do end
  #                ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:7349
  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7399
  sig { returns(String) }
  def end_keyword; end

  # The location of the `end` keyword.
  #
  #     for i in a end
  #                ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:7371
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def for_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7384
  sig { returns(String) }
  def for_keyword; end

  # The location of the `for` keyword.
  #
  #     for i in a end
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:7317
  sig { returns(Prism::Location) }
  def for_keyword_loc; end

  # def in_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7389
  sig { returns(String) }
  def in_keyword; end

  # The location of the `in` keyword.
  #
  #     for i in a end
  #           ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:7333
  sig { returns(Prism::Location) }
  def in_keyword_loc; end

  # The index expression for `for` loops.
  #
  #     for i in a end
  #         ^
  #
  # pkg:gem/prism#lib/prism/node.rb:7297
  sig do
    returns(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode))
  end
  def index; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7404
  sig { override.returns(String) }
  def inspect; end

  # Save the do_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7363
  def save_do_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7379
  def save_end_keyword_loc(repository); end

  # Save the for_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7325
  def save_for_keyword_loc(repository); end

  # Save the in_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7341
  def save_in_keyword_loc(repository); end

  # Represents the body of statements to execute for each iteration of the loop.
  #
  #     for i in a
  #       foo(i)
  #       ^^^^^^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:7311
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7409
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7414
    def type; end
  end
end

# Represents forwarding all arguments to this method to another method.
#
#     def foo(...)
#       bar(...)
#           ^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:7438
class Prism::ForwardingArgumentsNode < ::Prism::Node
  # Initialize a new ForwardingArgumentsNode node.
  #
  # @return [ForwardingArgumentsNode] a new instance of ForwardingArgumentsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7440
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7497
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7448
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7453
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7463
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7458
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingArgumentsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7468
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ForwardingArgumentsNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7473
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:7476
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7481
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7486
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7491
    def type; end
  end
end

# Represents the use of the forwarding parameter in a method, block, or lambda declaration.
#
#     def foo(...)
#             ^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:7507
class Prism::ForwardingParameterNode < ::Prism::Node
  # Initialize a new ForwardingParameterNode node.
  #
  # @return [ForwardingParameterNode] a new instance of ForwardingParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7509
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7566
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7517
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7522
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7532
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7527
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7537
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ForwardingParameterNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7542
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:7545
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7550
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7555
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7560
    def type; end
  end
end

# Represents the use of the `super` keyword without parentheses or arguments, but which might have a block.
#
#     super
#     ^^^^^
#
#     super { 123 }
#     ^^^^^^^^^^^^^
#
# If it has any other arguments, it would be a `SuperNode` instead.
#
# pkg:gem/prism#lib/prism/node.rb:7580
class Prism::ForwardingSuperNode < ::Prism::Node
  # Initialize a new ForwardingSuperNode node.
  #
  # @return [ForwardingSuperNode] a new instance of ForwardingSuperNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7582
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).void
  end
  def initialize(source, node_id, location, flags, block); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7645
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7591
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # All other arguments are forwarded as normal, except the original block is replaced with the new block.
  #
  # pkg:gem/prism#lib/prism/node.rb:7626
  sig { returns(T.nilable(Prism::BlockNode)) }
  def block; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7596
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7608
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7601
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?block: BlockNode?) -> ForwardingSuperNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7613
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      block: T.nilable(Prism::BlockNode)
    ).returns(Prism::ForwardingSuperNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7618
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, block: BlockNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:7621
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7629
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7634
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7639
    def type; end
  end
end

# Represents the use of the `&&=` operator for assignment to a global variable.
#
#     $target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7655
class Prism::GlobalVariableAndWriteNode < ::Prism::Node
  # Initialize a new GlobalVariableAndWriteNode node.
  #
  # @return [GlobalVariableAndWriteNode] a new instance of GlobalVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7657
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7755
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7669
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7674
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7684
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7679
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7689
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7694
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:7697
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:201
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7739
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:7702
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7705
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7734
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7718
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7713
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7726
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7744
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:7731
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7749
    def type; end
  end
end

# Represents assigning to a global variable using an operator that isn't `=`.
#
#     $target += value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7768
class Prism::GlobalVariableOperatorWriteNode < ::Prism::Node
  # Initialize a new GlobalVariableOperatorWriteNode node.
  #
  # @return [GlobalVariableOperatorWriteNode] a new instance of GlobalVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7770
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7867
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7783
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:7848
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7832
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7788
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7798
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7793
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> GlobalVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7803
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::GlobalVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7808
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:7811
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:213
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7851
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:7816
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7819
  sig { returns(Prism::Location) }
  def name_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:406
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:413
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7840
  def save_binary_operator_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7827
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7856
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:7845
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7861
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a global variable.
#
#     $target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7881
class Prism::GlobalVariableOrWriteNode < ::Prism::Node
  # Initialize a new GlobalVariableOrWriteNode node.
  #
  # @return [GlobalVariableOrWriteNode] a new instance of GlobalVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7883
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:7981
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:7895
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7900
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:7910
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:7905
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7915
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::GlobalVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:7920
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:7923
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:207
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7965
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:7928
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7931
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:7960
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:7944
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7939
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:7952
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:7970
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:7957
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:7975
    def type; end
  end
end

# Represents referencing a global variable.
#
#     $foo
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:7994
class Prism::GlobalVariableReadNode < ::Prism::Node
  # Initialize a new GlobalVariableReadNode node.
  #
  # @return [GlobalVariableReadNode] a new instance of GlobalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:7996
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8061
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8005
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8010
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8020
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8015
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8025
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8030
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:8033
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8045
  sig { override.returns(String) }
  def inspect; end

  # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
  #
  #     $foo   # name `:$foo`
  #
  #     $_Test # name `:$_Test`
  #
  # pkg:gem/prism#lib/prism/node.rb:8042
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8050
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8055
    def type; end
  end
end

# Represents writing to a global variable in a context that doesn't have an explicit value.
#
#     $foo, $bar = baz
#     ^^^^  ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8071
class Prism::GlobalVariableTargetNode < ::Prism::Node
  # Initialize a new GlobalVariableTargetNode node.
  #
  # @return [GlobalVariableTargetNode] a new instance of GlobalVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8073
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8134
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8082
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8087
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8097
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8092
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8102
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::GlobalVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8107
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:8110
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8118
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:8115
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8123
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8128
    def type; end
  end
end

# Represents writing to a global variable.
#
#     $foo = 1
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8144
class Prism::GlobalVariableWriteNode < ::Prism::Node
  # Initialize a new GlobalVariableWriteNode node.
  #
  # @return [GlobalVariableWriteNode] a new instance of GlobalVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8146
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8260
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8158
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8163
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8173
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8168
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> GlobalVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8178
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::GlobalVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8183
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:8186
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8244
  sig { override.returns(String) }
  def inspect; end

  # The name of the global variable, which is a `$` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifier). Alternatively, it can be one of the special global variables designated by a symbol.
  #
  #     $foo = :bar  # name `:$foo`
  #
  #     $_Test = 123 # name `:$_Test`
  #
  # pkg:gem/prism#lib/prism/node.rb:8195
  sig { returns(Symbol) }
  def name; end

  # The location of the global variable's name.
  #
  #     $foo = :bar
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8201
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8239
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     $foo = :bar
  #          ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8226
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8209
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8234
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8249
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the global variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     $foo = :bar
  #            ^^^^
  #
  #     $-xyz = 123
  #             ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8220
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8254
    def type; end
  end
end

# Represents a hash literal.
#
#     { a => b }
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8273
class Prism::HashNode < ::Prism::Node
  # Initialize a new HashNode node.
  #
  # @return [HashNode] a new instance of HashNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8275
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, elements, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8386
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8286
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8291
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8365
  sig { returns(String) }
  def closing; end

  # The location of the closing brace.
  #
  #     { a => b }
  #              ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8347
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8301
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8296
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?elements: Array[AssocNode | AssocSplatNode], ?closing_loc: Location) -> HashNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8306
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)],
      closing_loc: Prism::Location
    ).returns(Prism::HashNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8311
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, elements: Array[AssocNode | AssocSplatNode], closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:8314
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The elements of the hash. These can be either `AssocNode`s or `AssocSplatNode`s.
  #
  #     { a: b }
  #       ^^^^
  #
  #     { **foo }
  #       ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8341
  sig { returns(T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8370
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8360
  sig { returns(String) }
  def opening; end

  # The location of the opening brace.
  #
  #     { a => b }
  #     ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8322
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8355
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8330
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8375
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8380
    def type; end
  end
end

# Represents a hash pattern in pattern matching.
#
#     foo => { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
#     foo => { a: 1, b: 2, **c }
#            ^^^^^^^^^^^^^^^^^^^
#
#     foo => Bar[a: 1, b: 2]
#            ^^^^^^^^^^^^^^^
#
#     foo in { a: 1, b: 2 }
#            ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8408
class Prism::HashPatternNode < ::Prism::Node
  # Initialize a new HashPatternNode node.
  #
  # @return [HashPatternNode] a new instance of HashPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8410
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, constant, elements, rest, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8563
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8423
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8428
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:8542
  sig { returns(T.nilable(String)) }
  def closing; end

  # The location of the closing brace.
  #
  #     foo => { a: 1 }
  #                   ^
  #
  #     foo => Bar[a: 1]
  #                    ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8518
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8442
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8433
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Represents the optional constant preceding the Hash.
  #
  #     foo => Bar[a: 1, b: 2]
  #          ^^^
  #
  #     foo => Bar::Baz[a: 1, b: 2]
  #          ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8466
  sig { returns(T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode))) }
  def constant; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantPathNode | ConstantReadNode | nil, ?elements: Array[AssocNode], ?rest: AssocSplatNode | NoKeywordsParameterNode | nil, ?opening_loc: Location?, ?closing_loc: Location?) -> HashPatternNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8447
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      constant: T.nilable(T.any(Prism::ConstantPathNode, Prism::ConstantReadNode)),
      elements: T::Array[Prism::AssocNode],
      rest: T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode)),
      opening_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::HashPatternNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8452
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantPathNode | ConstantReadNode | nil, elements: Array[AssocNode], rest: AssocSplatNode | NoKeywordsParameterNode | nil, opening_loc: Location?, closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:8455
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Represents the explicit named hash keys and values.
  #
  #     foo => { a: 1, b:, ** }
  #              ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8472
  sig { returns(T::Array[Prism::AssocNode]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8547
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:8537
  sig { returns(T.nilable(String)) }
  def opening; end

  # The location of the opening brace.
  #
  #     foo => { a: 1 }
  #            ^
  #
  #     foo => Bar[a: 1]
  #               ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8493
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Represents the rest of the Hash keys and values. This can be named, unnamed, or explicitly forbidden via `**nil`, this last one results in a `NoKeywordsParameterNode`.
  #
  #     foo => { a: 1, b:, **c }
  #                        ^^^
  #
  #     foo => { a: 1, b:, ** }
  #                        ^^
  #
  #     foo => { a: 1, b:, **nil }
  #                        ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8484
  sig { returns(T.nilable(T.any(Prism::AssocSplatNode, Prism::NoKeywordsParameterNode))) }
  def rest; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8532
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8507
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8552
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8557
    def type; end
  end
end

# pkg:gem/prism#lib/prism/node_ext.rb:55
module Prism::HeredocQuery
  # Returns true if this node was represented as a heredoc in the source code.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:57
  def heredoc?; end
end

# Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
#
#     bar if foo
#     ^^^^^^^^^^
#
#     if foo then bar end
#     ^^^^^^^^^^^^^^^^^^^
#
#     foo ? bar : baz
#     ^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8584
class Prism::IfNode < ::Prism::Node
  # Initialize a new IfNode node.
  #
  # @return [IfNode] a new instance of IfNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8586
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, if_keyword_loc, predicate, then_keyword_loc, statements, subsequent, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8780
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8600
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8605
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8619
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8610
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Returns the subsequent if/elsif/else clause of the if node. This method is
  # deprecated in favor of #subsequent.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:488
  def consequent; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?if_keyword_loc: Location?, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: ElseNode | IfNode | nil, ?end_keyword_loc: Location?) -> IfNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8624
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      if_keyword_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(T.any(Prism::ElseNode, Prism::IfNode)),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::IfNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8629
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, if_keyword_loc: Location?, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, subsequent: ElseNode | IfNode | nil, end_keyword_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:8632
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:8759
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # The location of the `end` keyword if present, `nil` otherwise.
  #
  #     if foo
  #       bar
  #     end
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8730
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def if_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:8749
  sig { returns(T.nilable(String)) }
  def if_keyword; end

  # The location of the `if` keyword if present.
  #
  #     bar if foo
  #         ^^
  #
  # The `if_keyword_loc` field will be `nil` when the `IfNode` represents a ternary expression.
  #
  # pkg:gem/prism#lib/prism/node.rb:8642
  sig { returns(T.nilable(Prism::Location)) }
  def if_keyword_loc; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8764
  sig { override.returns(String) }
  def inspect; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:92
  def newline_flag!(lines); end

  # The node for the condition the `IfNode` is testing.
  #
  #     if foo
  #        ^^^
  #       bar
  #     end
  #
  #     bar if foo
  #            ^^^
  #
  #     foo ? bar : baz
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8672
  sig { returns(Prism::Node) }
  def predicate; end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8744
  def save_end_keyword_loc(repository); end

  # Save the if_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8656
  def save_if_keyword_loc(repository); end

  # Save the then_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:8695
  def save_then_keyword_loc(repository); end

  # Represents the body of statements that will be executed when the predicate is evaluated as truthy. Will be `nil` when no body is provided.
  #
  #     if foo
  #       bar
  #       ^^^
  #       baz
  #       ^^^
  #     end
  #
  # pkg:gem/prism#lib/prism/node.rb:8707
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Represents an `ElseNode` or an `IfNode` when there is an `else` or an `elsif` in the `if` statement.
  #
  #     if foo
  #       bar
  #     elsif baz
  #     ^^^^^^^^^
  #       qux
  #       ^^^
  #     end
  #     ^^^
  #
  #     if foo then bar else baz end
  #                     ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:8722
  sig { returns(T.nilable(T.any(Prism::ElseNode, Prism::IfNode))) }
  def subsequent; end

  # def then_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:8754
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # The location of the `then` keyword (if present) or the `?` in a ternary expression, `nil` otherwise.
  #
  #     if foo then bar end
  #            ^^^^
  #
  #     a ? b : c
  #       ^
  #
  # pkg:gem/prism#lib/prism/node.rb:8681
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8769
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8774
    def type; end
  end
end

# Represents an imaginary number literal.
#
#     1.0i
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8795
class Prism::ImaginaryNode < ::Prism::Node
  # Initialize a new ImaginaryNode node.
  #
  # @return [ImaginaryNode] a new instance of ImaginaryNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8797
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).void
  end
  def initialize(source, node_id, location, flags, numeric); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8858
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8806
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8811
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8821
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8816
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numeric: FloatNode | IntegerNode | RationalNode) -> ImaginaryNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8826
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numeric: T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)
    ).returns(Prism::ImaginaryNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8831
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, numeric: FloatNode | IntegerNode | RationalNode }
  #
  # pkg:gem/prism#lib/prism/node.rb:8834
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8842
  sig { override.returns(String) }
  def inspect; end

  # attr_reader numeric: FloatNode | IntegerNode | RationalNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8839
  sig { returns(T.any(Prism::FloatNode, Prism::IntegerNode, Prism::RationalNode)) }
  def numeric; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8847
  sig { override.returns(Symbol) }
  def type; end

  # Returns the value of the node as a Ruby Complex.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:110
  sig { returns(Complex) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8852
    def type; end
  end
end

# Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
#
#     { foo: }
#       ^^^^
#
#     { Foo: }
#       ^^^^
#
#     foo in { bar: }
#              ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:8874
class Prism::ImplicitNode < ::Prism::Node
  # Initialize a new ImplicitNode node.
  #
  # @return [ImplicitNode] a new instance of ImplicitNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8876
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).void
  end
  def initialize(source, node_id, location, flags, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:8937
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8885
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8890
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8900
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8895
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode) -> ImplicitNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8905
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode)
    ).returns(Prism::ImplicitNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8910
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode }
  #
  # pkg:gem/prism#lib/prism/node.rb:8913
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8921
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:8926
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8918
  sig do
    returns(T.any(Prism::LocalVariableReadNode, Prism::CallNode, Prism::ConstantReadNode, Prism::LocalVariableTargetNode))
  end
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:8931
    def type; end
  end
end

# Represents using a trailing comma to indicate an implicit rest parameter.
#
#     foo { |bar,| }
#               ^
#
#     foo in [bar,]
#                ^
#
#     for foo, in bar do end
#            ^
#
#     foo, = bar
#        ^
#
# pkg:gem/prism#lib/prism/node.rb:8956
class Prism::ImplicitRestNode < ::Prism::Node
  # Initialize a new ImplicitRestNode node.
  #
  # @return [ImplicitRestNode] a new instance of ImplicitRestNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8958
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9015
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:8966
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8971
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:8981
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:8976
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ImplicitRestNode
  #
  # pkg:gem/prism#lib/prism/node.rb:8986
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ImplicitRestNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:8991
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:8994
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:8999
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9004
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9009
    def type; end
  end
end

# Represents the use of the `in` keyword in a case statement.
#
#     case a; in b then c end
#             ^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9024
class Prism::InNode < ::Prism::Node
  # Initialize a new InNode node.
  #
  # @return [InNode] a new instance of InNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9026
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, pattern, statements, in_loc, then_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9138
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9038
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9043
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9056
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9048
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?pattern: Prism::node, ?statements: StatementsNode?, ?in_loc: Location, ?then_loc: Location?) -> InNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9061
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      pattern: Prism::Node,
      statements: T.nilable(Prism::StatementsNode),
      in_loc: Prism::Location,
      then_loc: T.nilable(Prism::Location)
    ).returns(Prism::InNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9066
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, pattern: Prism::node, statements: StatementsNode?, in_loc: Location, then_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:9069
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def in: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9112
  sig { returns(String) }
  def in; end

  # attr_reader in_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9080
  sig { returns(Prism::Location) }
  def in_loc; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9122
  sig { override.returns(String) }
  def inspect; end

  # attr_reader pattern: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9074
  sig { returns(Prism::Node) }
  def pattern; end

  # Save the in_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9088
  def save_in_loc(repository); end

  # Save the then_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9107
  def save_then_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9077
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:9117
  sig { returns(T.nilable(String)) }
  def then; end

  # attr_reader then_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:9093
  sig { returns(T.nilable(Prism::Location)) }
  def then_loc; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9127
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9132
    def type; end
  end
end

# Represents the use of the `&&=` operator on a call to the `[]` method.
#
#     foo.bar[baz] &&= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9151
class Prism::IndexAndWriteNode < ::Prism::Node
  # Initialize a new IndexAndWriteNode node.
  #
  # @return [IndexAndWriteNode] a new instance of IndexAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9153
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9333
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9169
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9262
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9217
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: BlockArgumentNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9278
  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:9297
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:9230
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9174
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9307
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9265
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9189
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9179
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9194
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9199
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:9202
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9222
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9317
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9302
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9249
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9312
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9281
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:9227
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9207
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9244
  def save_call_operator_loc(repository); end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9273
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9257
  def save_opening_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9289
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9322
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9294
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9212
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9327
    def type; end
  end
end

# Represents the use of an assignment operator on a call to `[]`.
#
#     foo.bar[baz] += value
#     ^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9351
class Prism::IndexOperatorWriteNode < ::Prism::Node
  # Initialize a new IndexOperatorWriteNode node.
  #
  # @return [IndexOperatorWriteNode] a new instance of IndexOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9353
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, binary_operator, binary_operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9532
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9370
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9463
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9418
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:9482
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9485
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # attr_reader block: BlockArgumentNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9479
  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:9501
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:9431
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9375
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9511
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9466
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9390
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9380
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> IndexOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9395
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      binary_operator: Symbol,
      binary_operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9400
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, binary_operator: Symbol, binary_operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:9403
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9423
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9516
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9506
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9450
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:422
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:429
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:9428
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9408
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9493
  def save_binary_operator_loc(repository); end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9445
  def save_call_operator_loc(repository); end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9474
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9458
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9521
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9498
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9413
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9526
    def type; end
  end
end

# Represents the use of the `||=` operator on a call to `[]`.
#
#     foo.bar[baz] ||= value
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9551
class Prism::IndexOrWriteNode < ::Prism::Node
  # Initialize a new IndexOrWriteNode node.
  #
  # @return [IndexOrWriteNode] a new instance of IndexOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9553
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9733
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9569
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9662
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9617
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: BlockArgumentNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9678
  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  # def call_operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:9697
  sig { returns(T.nilable(String)) }
  def call_operator; end

  # attr_reader call_operator_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:9630
  sig { returns(T.nilable(Prism::Location)) }
  def call_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9574
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9707
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9665
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9589
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9579
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9594
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: T.nilable(Prism::Node),
      call_operator_loc: T.nilable(Prism::Location),
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::IndexOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9599
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:9602
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9622
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9717
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9702
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9649
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9712
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9681
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader receiver: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:9627
  sig { returns(T.nilable(Prism::Node)) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9607
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the call_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9644
  def save_call_operator_loc(repository); end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9673
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9657
  def save_opening_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9689
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9722
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9694
  sig { returns(Prism::Node) }
  def value; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9612
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9727
    def type; end
  end
end

# Represents assigning to an index.
#
#     foo[bar], = 1
#     ^^^^^^^^
#
#     begin
#     rescue => foo[bar]
#               ^^^^^^^^
#     end
#
#     for foo[bar] in baz do end
#         ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9759
class Prism::IndexTargetNode < ::Prism::Node
  # Initialize a new IndexTargetNode node.
  #
  # @return [IndexTargetNode] a new instance of IndexTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9761
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).void
  end
  def initialize(source, node_id, location, flags, receiver, opening_loc, arguments, closing_loc, block); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:9892
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9774
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9847
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def attribute_write?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9821
  sig { returns(T::Boolean) }
  def attribute_write?; end

  # attr_reader block: BlockArgumentNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:9863
  sig { returns(T.nilable(Prism::BlockArgumentNode)) }
  def block; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9779
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9871
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9850
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9793
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9784
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?) -> IndexTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9798
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      receiver: Prism::Node,
      opening_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode),
      closing_loc: Prism::Location,
      block: T.nilable(Prism::BlockArgumentNode)
    ).returns(Prism::IndexTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9803
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:9806
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def ignore_visibility?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9826
  sig { returns(T::Boolean) }
  def ignore_visibility?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9876
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9866
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9834
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader receiver: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9831
  sig { returns(Prism::Node) }
  def receiver; end

  # def safe_navigation?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9811
  sig { returns(T::Boolean) }
  def safe_navigation?; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9858
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9842
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9881
  sig { override.returns(Symbol) }
  def type; end

  # def variable_call?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:9816
  sig { returns(T::Boolean) }
  def variable_call?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:9886
    def type; end
  end
end

# InlineComment objects are the most common. They correspond to comments in
# the source file like this one that start with #.
#
# pkg:gem/prism#lib/prism/parse_result.rb:534
class Prism::InlineComment < ::Prism::Comment
  # Returns a string representation of this comment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:542
  sig { returns(String) }
  def inspect; end

  # Returns true if this comment happens on the same line as other code and
  # false if the comment is by itself.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:537
  sig { override.returns(T::Boolean) }
  def trailing?; end
end

# This visitor is responsible for composing the strings that get returned by
# the various #inspect methods defined on each of the nodes.
#
# pkg:gem/prism#lib/prism/inspect_visitor.rb:15
class Prism::InspectVisitor < ::Prism::Visitor
  # Initializes a new instance of the InspectVisitor.
  #
  # @return [InspectVisitor] a new instance of InspectVisitor
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:38
  sig { params(indent: String).void }
  def initialize(indent = T.unsafe(nil)); end

  # The list of commands that we need to execute in order to compose the
  # final string.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:35
  def commands; end

  # Compose the final string.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:51
  sig { returns(String) }
  def compose; end

  # The current prefix string.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:31
  def indent; end

  # Inspect a AliasGlobalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:80
  def visit_alias_global_variable_node(node); end

  # Inspect a AliasMethodNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:92
  def visit_alias_method_node(node); end

  # Inspect a AlternationPatternNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:104
  def visit_alternation_pattern_node(node); end

  # Inspect a AndNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:116
  def visit_and_node(node); end

  # Inspect a ArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:128
  def visit_arguments_node(node); end

  # Inspect a ArrayNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:144
  def visit_array_node(node); end

  # Inspect a ArrayPatternNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:162
  def visit_array_pattern_node(node); end

  # Inspect a AssocNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:201
  def visit_assoc_node(node); end

  # Inspect a AssocSplatNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:213
  def visit_assoc_splat_node(node); end

  # Inspect a BackReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:227
  def visit_back_reference_read_node(node); end

  # Inspect a BeginNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:235
  def visit_begin_node(node); end

  # Inspect a BlockArgumentNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:268
  def visit_block_argument_node(node); end

  # Inspect a BlockLocalVariableNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:282
  def visit_block_local_variable_node(node); end

  # Inspect a BlockNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:290
  def visit_block_node(node); end

  # Inspect a BlockParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:312
  def visit_block_parameter_node(node); end

  # Inspect a BlockParametersNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:326
  def visit_block_parameters_node(node); end

  # Inspect a BreakNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:350
  def visit_break_node(node); end

  # Inspect a CallAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:364
  def visit_call_and_write_node(node); end

  # Inspect a CallNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:384
  def visit_call_node(node); end

  # Inspect a CallOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:415
  def visit_call_operator_write_node(node); end

  # Inspect a CallOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:436
  def visit_call_or_write_node(node); end

  # Inspect a CallTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:456
  def visit_call_target_node(node); end

  # Inspect a CapturePatternNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:468
  def visit_capture_pattern_node(node); end

  # Inspect a CaseMatchNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:480
  def visit_case_match_node(node); end

  # Inspect a CaseNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:510
  def visit_case_node(node); end

  # Inspect a ClassNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:540
  def visit_class_node(node); end

  # Inspect a ClassVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:566
  def visit_class_variable_and_write_node(node); end

  # Inspect a ClassVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:578
  def visit_class_variable_operator_write_node(node); end

  # Inspect a ClassVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:591
  def visit_class_variable_or_write_node(node); end

  # Inspect a ClassVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:603
  def visit_class_variable_read_node(node); end

  # Inspect a ClassVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:611
  def visit_class_variable_target_node(node); end

  # Inspect a ClassVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:619
  def visit_class_variable_write_node(node); end

  # Inspect a ConstantAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:631
  def visit_constant_and_write_node(node); end

  # Inspect a ConstantOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:643
  def visit_constant_operator_write_node(node); end

  # Inspect a ConstantOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:656
  def visit_constant_or_write_node(node); end

  # Inspect a ConstantPathAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:668
  def visit_constant_path_and_write_node(node); end

  # Inspect a ConstantPathNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:680
  def visit_constant_path_node(node); end

  # Inspect a ConstantPathOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:700
  def visit_constant_path_operator_write_node(node); end

  # Inspect a ConstantPathOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:713
  def visit_constant_path_or_write_node(node); end

  # Inspect a ConstantPathTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:725
  def visit_constant_path_target_node(node); end

  # Inspect a ConstantPathWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:745
  def visit_constant_path_write_node(node); end

  # Inspect a ConstantReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:757
  def visit_constant_read_node(node); end

  # Inspect a ConstantTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:765
  def visit_constant_target_node(node); end

  # Inspect a ConstantWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:773
  def visit_constant_write_node(node); end

  # Inspect a DefNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:785
  def visit_def_node(node); end

  # Inspect a DefinedNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:819
  def visit_defined_node(node); end

  # Inspect a ElseNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:831
  def visit_else_node(node); end

  # Inspect a EmbeddedStatementsNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:846
  def visit_embedded_statements_node(node); end

  # Inspect a EmbeddedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:861
  def visit_embedded_variable_node(node); end

  # Inspect a EnsureNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:871
  def visit_ensure_node(node); end

  # Inspect a FalseNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:886
  def visit_false_node(node); end

  # Inspect a FindPatternNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:893
  def visit_find_pattern_node(node); end

  # Inspect a FlipFlopNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:921
  def visit_flip_flop_node(node); end

  # Inspect a FloatNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:941
  def visit_float_node(node); end

  # Inspect a ForNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:949
  def visit_for_node(node); end

  # Inspect a ForwardingArgumentsNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:970
  def visit_forwarding_arguments_node(node); end

  # Inspect a ForwardingParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:977
  def visit_forwarding_parameter_node(node); end

  # Inspect a ForwardingSuperNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:984
  def visit_forwarding_super_node(node); end

  # Inspect a GlobalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:997
  def visit_global_variable_and_write_node(node); end

  # Inspect a GlobalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1009
  def visit_global_variable_operator_write_node(node); end

  # Inspect a GlobalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1022
  def visit_global_variable_or_write_node(node); end

  # Inspect a GlobalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1034
  def visit_global_variable_read_node(node); end

  # Inspect a GlobalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1042
  def visit_global_variable_target_node(node); end

  # Inspect a GlobalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1050
  def visit_global_variable_write_node(node); end

  # Inspect a HashNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1062
  def visit_hash_node(node); end

  # Inspect a HashPatternNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1080
  def visit_hash_pattern_node(node); end

  # Inspect a IfNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1110
  def visit_if_node(node); end

  # Inspect a ImaginaryNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1134
  def visit_imaginary_node(node); end

  # Inspect a ImplicitNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1143
  def visit_implicit_node(node); end

  # Inspect a ImplicitRestNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1152
  def visit_implicit_rest_node(node); end

  # Inspect a InNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1159
  def visit_in_node(node); end

  # Inspect a IndexAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1176
  def visit_index_and_write_node(node); end

  # Inspect a IndexOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1207
  def visit_index_operator_write_node(node); end

  # Inspect a IndexOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1239
  def visit_index_or_write_node(node); end

  # Inspect a IndexTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1270
  def visit_index_target_node(node); end

  # Inspect a InstanceVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1293
  def visit_instance_variable_and_write_node(node); end

  # Inspect a InstanceVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1305
  def visit_instance_variable_operator_write_node(node); end

  # Inspect a InstanceVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1318
  def visit_instance_variable_or_write_node(node); end

  # Inspect a InstanceVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1330
  def visit_instance_variable_read_node(node); end

  # Inspect a InstanceVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1338
  def visit_instance_variable_target_node(node); end

  # Inspect a InstanceVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1346
  def visit_instance_variable_write_node(node); end

  # Inspect a IntegerNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1358
  def visit_integer_node(node); end

  # Inspect a InterpolatedMatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1366
  def visit_interpolated_match_last_line_node(node); end

  # Inspect a InterpolatedRegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1384
  def visit_interpolated_regular_expression_node(node); end

  # Inspect a InterpolatedStringNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1402
  def visit_interpolated_string_node(node); end

  # Inspect a InterpolatedSymbolNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1420
  def visit_interpolated_symbol_node(node); end

  # Inspect a InterpolatedXStringNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1438
  def visit_interpolated_x_string_node(node); end

  # Inspect a ItLocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1456
  def visit_it_local_variable_read_node(node); end

  # Inspect a ItParametersNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1463
  def visit_it_parameters_node(node); end

  # Inspect a KeywordHashNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1470
  def visit_keyword_hash_node(node); end

  # Inspect a KeywordRestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1486
  def visit_keyword_rest_parameter_node(node); end

  # Inspect a LambdaNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1500
  def visit_lambda_node(node); end

  # Inspect a LocalVariableAndWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1523
  def visit_local_variable_and_write_node(node); end

  # Inspect a LocalVariableOperatorWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1536
  def visit_local_variable_operator_write_node(node); end

  # Inspect a LocalVariableOrWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1550
  def visit_local_variable_or_write_node(node); end

  # Inspect a LocalVariableReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1563
  def visit_local_variable_read_node(node); end

  # Inspect a LocalVariableTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1572
  def visit_local_variable_target_node(node); end

  # Inspect a LocalVariableWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1581
  def visit_local_variable_write_node(node); end

  # Inspect a MatchLastLineNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1594
  def visit_match_last_line_node(node); end

  # Inspect a MatchPredicateNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1605
  def visit_match_predicate_node(node); end

  # Inspect a MatchRequiredNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1617
  def visit_match_required_node(node); end

  # Inspect a MatchWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1629
  def visit_match_write_node(node); end

  # Inspect a MissingNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1647
  def visit_missing_node(node); end

  # Inspect a ModuleNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1654
  def visit_module_node(node); end

  # Inspect a MultiTargetNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1673
  def visit_multi_target_node(node); end

  # Inspect a MultiWriteNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1706
  def visit_multi_write_node(node); end

  # Inspect a NextNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1742
  def visit_next_node(node); end

  # Inspect a NilNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1756
  def visit_nil_node(node); end

  # Inspect a NoKeywordsParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1763
  def visit_no_keywords_parameter_node(node); end

  # Inspect a NumberedParametersNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1772
  def visit_numbered_parameters_node(node); end

  # Inspect a NumberedReferenceReadNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1780
  def visit_numbered_reference_read_node(node); end

  # Inspect a OptionalKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1788
  def visit_optional_keyword_parameter_node(node); end

  # Inspect a OptionalParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1799
  def visit_optional_parameter_node(node); end

  # Inspect a OrNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1811
  def visit_or_node(node); end

  # Inspect a ParametersNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1823
  def visit_parameters_node(node); end

  # Inspect a ParenthesesNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1884
  def visit_parentheses_node(node); end

  # Inspect a PinnedExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1899
  def visit_pinned_expression_node(node); end

  # Inspect a PinnedVariableNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1911
  def visit_pinned_variable_node(node); end

  # Inspect a PostExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1921
  def visit_post_execution_node(node); end

  # Inspect a PreExecutionNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1937
  def visit_pre_execution_node(node); end

  # Inspect a ProgramNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1953
  def visit_program_node(node); end

  # Inspect a RangeNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1963
  def visit_range_node(node); end

  # Inspect a RationalNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1983
  def visit_rational_node(node); end

  # Inspect a RedoNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1992
  def visit_redo_node(node); end

  # Inspect a RegularExpressionNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:1999
  def visit_regular_expression_node(node); end

  # Inspect a RequiredKeywordParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2010
  def visit_required_keyword_parameter_node(node); end

  # Inspect a RequiredParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2019
  def visit_required_parameter_node(node); end

  # Inspect a RescueModifierNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2027
  def visit_rescue_modifier_node(node); end

  # Inspect a RescueNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2039
  def visit_rescue_node(node); end

  # Inspect a RestParameterNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2076
  def visit_rest_parameter_node(node); end

  # Inspect a RetryNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2090
  def visit_retry_node(node); end

  # Inspect a ReturnNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2097
  def visit_return_node(node); end

  # Inspect a SelfNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2111
  def visit_self_node(node); end

  # Inspect a ShareableConstantNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2118
  def visit_shareable_constant_node(node); end

  # Inspect a SingletonClassNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2127
  def visit_singleton_class_node(node); end

  # Inspect a SourceEncodingNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2146
  def visit_source_encoding_node(node); end

  # Inspect a SourceFileNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2153
  def visit_source_file_node(node); end

  # Inspect a SourceLineNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2161
  def visit_source_line_node(node); end

  # Inspect a SplatNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2168
  def visit_splat_node(node); end

  # Inspect a StatementsNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2182
  def visit_statements_node(node); end

  # Inspect a StringNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2198
  def visit_string_node(node); end

  # Inspect a SuperNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2209
  def visit_super_node(node); end

  # Inspect a SymbolNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2231
  def visit_symbol_node(node); end

  # Inspect a TrueNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2242
  def visit_true_node(node); end

  # Inspect a UndefNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2249
  def visit_undef_node(node); end

  # Inspect a UnlessNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2266
  def visit_unless_node(node); end

  # Inspect a UntilNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2290
  def visit_until_node(node); end

  # Inspect a WhenNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2308
  def visit_when_node(node); end

  # Inspect a WhileNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2332
  def visit_while_node(node); end

  # Inspect a XStringNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2350
  def visit_x_string_node(node); end

  # Inspect a YieldNode node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2361
  def visit_yield_node(node); end

  private

  # Compose a string representing the given inner location field.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2385
  def inspect_location(location); end

  # Compose a header for the given node.
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:2379
  def inspect_node(name, node); end

  class << self
    # Compose an inspect string for the given node.
    #
    # pkg:gem/prism#lib/prism/inspect_visitor.rb:44
    sig { params(node: Prism::Node).returns(String) }
    def compose(node); end
  end
end

# Most of the time, we can simply pass down the indent to the next node.
# However, when we are inside a list we want some extra special formatting
# when we hit an element in that list. In this case, we have a special
# command that replaces the subsequent indent with the given value.
#
# pkg:gem/prism#lib/prism/inspect_visitor.rb:20
class Prism::InspectVisitor::Replace
  # @return [Replace] a new instance of Replace
  #
  # pkg:gem/prism#lib/prism/inspect_visitor.rb:23
  def initialize(value); end

  # pkg:gem/prism#lib/prism/inspect_visitor.rb:21
  def value; end
end

# Represents the use of the `&&=` operator for assignment to an instance variable.
#
#     @target &&= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:9907
class Prism::InstanceVariableAndWriteNode < ::Prism::Node
  # Initialize a new InstanceVariableAndWriteNode node.
  #
  # @return [InstanceVariableAndWriteNode] a new instance of InstanceVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9909
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10007
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:9921
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9926
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:9936
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:9931
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:9941
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:9946
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:9949
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:219
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9991
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:9954
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9957
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:9986
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:9970
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9965
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:9978
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:9996
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:9983
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10001
    def type; end
  end
end

# Represents assigning to an instance variable using an operator that isn't `=`.
#
#     @target += value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10020
class Prism::InstanceVariableOperatorWriteNode < ::Prism::Node
  # Initialize a new InstanceVariableOperatorWriteNode node.
  #
  # @return [InstanceVariableOperatorWriteNode] a new instance of InstanceVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10022
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10119
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10035
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:10100
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10084
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10040
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10050
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10045
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> InstanceVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10055
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      binary_operator: Symbol
    ).returns(Prism::InstanceVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10060
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:10063
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:231
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10103
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:10068
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10071
  sig { returns(Prism::Location) }
  def name_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:438
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:445
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10092
  def save_binary_operator_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10079
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10108
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:10097
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10113
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to an instance variable.
#
#     @target ||= value
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10133
class Prism::InstanceVariableOrWriteNode < ::Prism::Node
  # Initialize a new InstanceVariableOrWriteNode node.
  #
  # @return [InstanceVariableOrWriteNode] a new instance of InstanceVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10135
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10233
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10147
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10152
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10162
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10157
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10167
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::InstanceVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10172
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:10175
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:225
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10217
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:10180
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10183
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10212
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10196
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10191
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10204
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10222
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:10209
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10227
    def type; end
  end
end

# Represents referencing an instance variable.
#
#     @foo
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10246
class Prism::InstanceVariableReadNode < ::Prism::Node
  # Initialize a new InstanceVariableReadNode node.
  #
  # @return [InstanceVariableReadNode] a new instance of InstanceVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10248
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10313
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10257
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10262
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10272
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10267
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10277
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10282
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:10285
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10297
  sig { override.returns(String) }
  def inspect; end

  # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @x     # name `:@x`
  #
  #     @_test # name `:@_test`
  #
  # pkg:gem/prism#lib/prism/node.rb:10294
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10302
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10307
    def type; end
  end
end

# Represents writing to an instance variable in a context that doesn't have an explicit value.
#
#     @foo, @bar = baz
#     ^^^^  ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10323
class Prism::InstanceVariableTargetNode < ::Prism::Node
  # Initialize a new InstanceVariableTargetNode node.
  #
  # @return [InstanceVariableTargetNode] a new instance of InstanceVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10325
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10386
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10334
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10339
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10349
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10344
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10354
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::InstanceVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10359
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:10362
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10370
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:10367
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10375
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10380
    def type; end
  end
end

# Represents writing to an instance variable.
#
#     @foo = 1
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10396
class Prism::InstanceVariableWriteNode < ::Prism::Node
  # Initialize a new InstanceVariableWriteNode node.
  #
  # @return [InstanceVariableWriteNode] a new instance of InstanceVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10398
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10512
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10410
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10415
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10425
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10420
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> InstanceVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10430
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::InstanceVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10435
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:10438
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10496
  sig { override.returns(String) }
  def inspect; end

  # The name of the instance variable, which is a `@` followed by an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     @x = :y       # name `:@x`
  #
  #     @_foo = "bar" # name `@_foo`
  #
  # pkg:gem/prism#lib/prism/node.rb:10447
  sig { returns(Symbol) }
  def name; end

  # The location of the variable name.
  #
  #     @_x = 1
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:10453
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10491
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     @x = y
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:10478
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10461
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10486
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10501
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the instance variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     @foo = :bar
  #            ^^^^
  #
  #     @_x = 1234
  #           ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:10472
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10506
    def type; end
  end
end

# Flags for integer nodes that correspond to the base of the integer.
#
# pkg:gem/prism#lib/prism/node.rb:18717
module Prism::IntegerBaseFlags; end

# 0b prefix
#
# pkg:gem/prism#lib/prism/node.rb:18719
Prism::IntegerBaseFlags::BINARY = T.let(T.unsafe(nil), Integer)

# 0d or no prefix
#
# pkg:gem/prism#lib/prism/node.rb:18722
Prism::IntegerBaseFlags::DECIMAL = T.let(T.unsafe(nil), Integer)

# 0x prefix
#
# pkg:gem/prism#lib/prism/node.rb:18728
Prism::IntegerBaseFlags::HEXADECIMAL = T.let(T.unsafe(nil), Integer)

# 0o or 0 prefix
#
# pkg:gem/prism#lib/prism/node.rb:18725
Prism::IntegerBaseFlags::OCTAL = T.let(T.unsafe(nil), Integer)

# Represents an integer number literal.
#
#     1
#     ^
#
# pkg:gem/prism#lib/prism/node.rb:10525
class Prism::IntegerNode < ::Prism::Node
  # Initialize a new IntegerNode node.
  #
  # @return [IntegerNode] a new instance of IntegerNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10527
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10608
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10536
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10569
  sig { returns(T::Boolean) }
  def binary?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10541
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10551
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10546
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Integer) -> IntegerNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10556
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Integer
    ).returns(Prism::IntegerNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10574
  sig { returns(T::Boolean) }
  def decimal?; end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10561
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:10564
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10584
  sig { returns(T::Boolean) }
  def hexadecimal?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10592
  sig { override.returns(String) }
  def inspect; end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10579
  sig { returns(T::Boolean) }
  def octal?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10597
  sig { override.returns(Symbol) }
  def type; end

  # The value of the integer literal as a number.
  #
  # pkg:gem/prism#lib/prism/node.rb:10589
  sig { returns(Integer) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10602
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo #{bar} baz/ then end
#        ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10619
class Prism::InterpolatedMatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # Initialize a new InterpolatedMatchLastLineNode node.
  #
  # @return [InterpolatedMatchLastLineNode] a new instance of InterpolatedMatchLastLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10621
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10775
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10632
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10690
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10637
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10754
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10736
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10647
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10642
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedMatchLastLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10652
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedMatchLastLineNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10657
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:10660
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10685
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10670
  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10710
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10715
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10705
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10665
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10759
  sig { override.returns(String) }
  def inspect; end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10675
  sig { returns(T::Boolean) }
  def multi_line?; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:122
  def newline_flag!(lines); end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10680
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10749
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10720
  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:10733
  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10744
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10728
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10764
  sig { override.returns(Symbol) }
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10700
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10695
  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10769
    def type; end
  end
end

# Represents a regular expression literal that contains interpolation.
#
#     /foo #{bar} baz/
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10789
class Prism::InterpolatedRegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # Initialize a new InterpolatedRegularExpressionNode node.
  #
  # @return [InterpolatedRegularExpressionNode] a new instance of InterpolatedRegularExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10791
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:10945
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10802
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10860
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10807
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10924
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10906
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10817
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10812
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedRegularExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10822
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedRegularExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10827
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:10830
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10855
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10840
  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10880
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10885
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10875
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10835
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10929
  sig { override.returns(String) }
  def inspect; end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10845
  sig { returns(T::Boolean) }
  def multi_line?; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:129
  def newline_flag!(lines); end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10850
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:10919
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:10890
  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:10903
  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10914
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:10898
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:10934
  sig { override.returns(Symbol) }
  def type; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10870
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:10865
  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:10939
    def type; end
  end
end

# Represents a string literal that contains interpolation.
#
#     "foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:10959
class Prism::InterpolatedStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # Initialize a new InterpolatedStringNode node.
  #
  # @return [InterpolatedStringNode] a new instance of InterpolatedStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10961
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode, Prism::InterpolatedXStringNode, Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11082
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:10972
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10977
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:11061
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:11037
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:10987
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:10982
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode], ?closing_loc: Location?) -> InterpolatedStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:10992
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode, Prism::InterpolatedXStringNode, Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:10997
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode], closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:11000
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:11005
  sig { returns(T::Boolean) }
  def frozen?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11066
  sig { override.returns(String) }
  def inspect; end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:11010
  sig { returns(T::Boolean) }
  def mutable?; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:136
  def newline_flag!(lines); end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:11056
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:11015
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode | InterpolatedXStringNode | SymbolNode | InterpolatedSymbolNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:11034
  sig do
    returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode, Prism::InterpolatedStringNode, Prism::XStringNode, Prism::InterpolatedXStringNode, Prism::SymbolNode, Prism::InterpolatedSymbolNode)])
  end
  def parts; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11051
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11029
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11071
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11076
    def type; end
  end
end

# Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
#
# pkg:gem/prism#lib/prism/node.rb:18732
module Prism::InterpolatedStringNodeFlags; end

# pkg:gem/prism#lib/prism/node.rb:18734
Prism::InterpolatedStringNodeFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# pkg:gem/prism#lib/prism/node.rb:18737
Prism::InterpolatedStringNodeFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

# Represents a symbol literal that contains interpolation.
#
#     :"foo #{bar} baz"
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11096
class Prism::InterpolatedSymbolNode < ::Prism::Node
  # Initialize a new InterpolatedSymbolNode node.
  #
  # @return [InterpolatedSymbolNode] a new instance of InterpolatedSymbolNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11098
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11209
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11109
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11114
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:11188
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:11164
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11124
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11119
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location?) -> InterpolatedSymbolNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11129
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: T.nilable(Prism::Location)
    ).returns(Prism::InterpolatedSymbolNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11134
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:11137
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11193
  sig { override.returns(String) }
  def inspect; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:143
  def newline_flag!(lines); end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:11183
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:11142
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:11161
  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11178
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11156
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11198
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11203
    def type; end
  end
end

# Represents an xstring literal that contains interpolation.
#
#     `foo #{bar} baz`
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11222
class Prism::InterpolatedXStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # Initialize a new InterpolatedXStringNode node.
  #
  # @return [InterpolatedXStringNode] a new instance of InterpolatedXStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11224
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11323
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11235
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11240
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11302
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11284
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11250
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11245
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedXStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11255
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      parts: T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)],
      closing_loc: Prism::Location
    ).returns(Prism::InterpolatedXStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11260
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:11263
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11307
  sig { override.returns(String) }
  def inspect; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:150
  def newline_flag!(lines); end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11297
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11268
  sig { returns(Prism::Location) }
  def opening_loc; end

  # attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:11281
  sig { returns(T::Array[T.any(Prism::StringNode, Prism::EmbeddedStatementsNode, Prism::EmbeddedVariableNode)]) }
  def parts; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11292
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11276
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11312
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11317
    def type; end
  end
end

# Represents reading from the implicit `it` local variable.
#
#     -> { it }
#          ^^
#
# pkg:gem/prism#lib/prism/node.rb:11336
class Prism::ItLocalVariableReadNode < ::Prism::Node
  # Initialize a new ItLocalVariableReadNode node.
  #
  # @return [ItLocalVariableReadNode] a new instance of ItLocalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11338
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11395
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11346
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11351
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11361
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11356
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItLocalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11366
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ItLocalVariableReadNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11371
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:11374
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11379
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11384
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11389
    def type; end
  end
end

# Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
#
#     -> { it + it }
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11404
class Prism::ItParametersNode < ::Prism::Node
  # Initialize a new ItParametersNode node.
  #
  # @return [ItParametersNode] a new instance of ItParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11406
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11463
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11414
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11419
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11429
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11424
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11434
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::ItParametersNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11439
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:11442
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11447
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11452
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11457
    def type; end
  end
end

# Represents a hash literal without opening and closing braces.
#
#     foo(a: b)
#         ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11472
class Prism::KeywordHashNode < ::Prism::Node
  # Initialize a new KeywordHashNode node.
  #
  # @return [KeywordHashNode] a new instance of KeywordHashNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11474
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).void
  end
  def initialize(source, node_id, location, flags, elements); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11540
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11483
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11488
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11498
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11493
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[AssocNode | AssocSplatNode]) -> KeywordHashNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11503
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      elements: T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]
    ).returns(Prism::KeywordHashNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11508
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, elements: Array[AssocNode | AssocSplatNode] }
  #
  # pkg:gem/prism#lib/prism/node.rb:11511
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader elements: Array[AssocNode | AssocSplatNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:11521
  sig { returns(T::Array[T.any(Prism::AssocNode, Prism::AssocSplatNode)]) }
  def elements; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11524
  sig { override.returns(String) }
  def inspect; end

  # def symbol_keys?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:11516
  sig { returns(T::Boolean) }
  def symbol_keys?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11529
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11534
    def type; end
  end
end

# Flags for keyword hash nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18741
module Prism::KeywordHashNodeFlags; end

# a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
#
# pkg:gem/prism#lib/prism/node.rb:18743
Prism::KeywordHashNodeFlags::SYMBOL_KEYS = T.let(T.unsafe(nil), Integer)

# Represents a keyword rest parameter to a method, block, or lambda definition.
#
#     def a(**b)
#           ^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:11553
class Prism::KeywordRestParameterNode < ::Prism::Node
  # Initialize a new KeywordRestParameterNode node.
  #
  # @return [KeywordRestParameterNode] a new instance of KeywordRestParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11555
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11660
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11566
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11571
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11581
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11576
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> KeywordRestParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11586
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::KeywordRestParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11591
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:11594
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11644
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol?
  #
  # pkg:gem/prism#lib/prism/node.rb:11604
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:11607
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11639
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11626
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:11599
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11621
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11634
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11649
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11654
    def type; end
  end
end

# Represents using a lambda literal (not the lambda method call).
#
#     ->(value) { value * 2 }
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11673
class Prism::LambdaNode < ::Prism::Node
  # Initialize a new LambdaNode node.
  #
  # @return [LambdaNode] a new instance of LambdaNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11675
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).void
  end
  def initialize(source, node_id, location, flags, locals, operator_loc, opening_loc, closing_loc, parameters, body); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11804
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11689
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: StatementsNode | BeginNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:11770
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11694
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11783
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11754
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11707
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11699
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?operator_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, ?body: StatementsNode | BeginNode | nil) -> LambdaNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11712
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      operator_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location,
      parameters: T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode)),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))
    ).returns(Prism::LambdaNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11717
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, body: StatementsNode | BeginNode | nil }
  #
  # pkg:gem/prism#lib/prism/node.rb:11720
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11788
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:11725
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11778
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11741
  sig { returns(Prism::Location) }
  def opening_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11773
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11728
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:11767
  sig { returns(T.nilable(T.any(Prism::BlockParametersNode, Prism::NumberedParametersNode, Prism::ItParametersNode))) }
  def parameters; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11762
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11749
  def save_opening_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11736
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11793
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11798
    def type; end
  end
end

# This class is responsible for lexing the source using prism and then
# converting those tokens to be compatible with Ripper. In the vast majority
# of cases, this is a one-to-one mapping of the token type. Everything else
# generally lines up. However, there are a few cases that require special
# handling.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:13
class Prism::LexCompat
  # @return [LexCompat] a new instance of LexCompat
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:620
  def initialize(source, **options); end

  # Returns the value of attribute options.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:618
  def options; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:625
  def result; end

  # Returns the value of attribute source.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:618
  def source; end
end

# Ripper doesn't include the rest of the token in the event, so we need to
# trim it down to just the content on the first line when comparing.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:231
class Prism::LexCompat::EndContentToken < ::Prism::LexCompat::Token
  # pkg:gem/prism#lib/prism/lex_compat.rb:232
  def ==(other); end
end

# A heredoc in this case is a list of tokens that belong to the body of the
# heredoc that should be appended onto the list of tokens when the heredoc
# closes.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:292
module Prism::LexCompat::Heredoc
  class << self
    # Here we will split between the two types of heredocs and return the
    # object that will store their tokens.
    #
    # pkg:gem/prism#lib/prism/lex_compat.rb:604
    def build(opening); end
  end
end

# Dash heredocs are a little more complicated. They are a list of tokens
# that need to be split on "\\\n" to mimic Ripper's behavior. We also need
# to keep track of the state that the heredoc was opened in.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:316
class Prism::LexCompat::Heredoc::DashHeredoc
  # @return [DashHeredoc] a new instance of DashHeredoc
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:319
  def initialize(split); end

  # pkg:gem/prism#lib/prism/lex_compat.rb:324
  def <<(token); end

  # pkg:gem/prism#lib/prism/lex_compat.rb:317
  def split; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:328
  def to_a; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:317
  def tokens; end
end

# Heredocs that are dedenting heredocs are a little more complicated.
# Ripper outputs on_ignored_sp tokens for the whitespace that is being
# removed from the output. prism only modifies the node itself and keeps
# the token the same. This simplifies prism, but makes comparing against
# Ripper much harder because there is a length mismatch.
#
# Fortunately, we already have to pull out the heredoc tokens in order to
# insert them into the stream in the correct order. As such, we can do
# some extra manipulation on the tokens to make them match Ripper's
# output by mirroring the dedent logic that Ripper uses.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:375
class Prism::LexCompat::Heredoc::DedentingHeredoc
  # @return [DedentingHeredoc] a new instance of DedentingHeredoc
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:380
  def initialize; end

  # As tokens are coming in, we track the minimum amount of common leading
  # whitespace on plain string content tokens. This allows us to later
  # remove that amount of whitespace from the beginning of each line.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:391
  def <<(token); end

  # Returns the value of attribute dedent.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:378
  def dedent; end

  # Returns the value of attribute dedent_next.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:378
  def dedent_next; end

  # Returns the value of attribute embexpr_balance.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:378
  def embexpr_balance; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:428
  def to_a; end

  # Returns the value of attribute tokens.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:378
  def tokens; end
end

# pkg:gem/prism#lib/prism/lex_compat.rb:376
Prism::LexCompat::Heredoc::DedentingHeredoc::TAB_WIDTH = T.let(T.unsafe(nil), Integer)

# Heredocs that are no dash or tilde heredocs are just a list of tokens.
# We need to keep them around so that we can insert them in the correct
# order back into the token stream and set the state of the last token to
# the state that the heredoc was opened in.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:297
class Prism::LexCompat::Heredoc::PlainHeredoc
  # @return [PlainHeredoc] a new instance of PlainHeredoc
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:300
  def initialize; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:304
  def <<(token); end

  # pkg:gem/prism#lib/prism/lex_compat.rb:308
  def to_a; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:298
  def tokens; end
end

# Ident tokens for the most part are exactly the same, except sometimes we
# know an ident is a local when ripper doesn't (when they are introduced
# through named captures in regular expressions). In that case we don't
# compare the state.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:249
class Prism::LexCompat::IdentToken < ::Prism::LexCompat::Token
  # pkg:gem/prism#lib/prism/lex_compat.rb:250
  def ==(other); end
end

# Tokens where state should be ignored
# used for :on_comment, :on_heredoc_end, :on_embexpr_end
#
# pkg:gem/prism#lib/prism/lex_compat.rb:239
class Prism::LexCompat::IgnoreStateToken < ::Prism::LexCompat::Token
  # pkg:gem/prism#lib/prism/lex_compat.rb:240
  def ==(other); end
end

# Ignored newlines can occasionally have a LABEL state attached to them, so
# we compare the state differently here.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:260
class Prism::LexCompat::IgnoredNewlineToken < ::Prism::LexCompat::Token
  # pkg:gem/prism#lib/prism/lex_compat.rb:261
  def ==(other); end
end

# If we have an identifier that follows a method name like:
#
#     def foo bar
#
# then Ripper will mark bar as END|LABEL if there is a local in a parent
# scope named bar because it hasn't pushed the local table yet. We do this
# more accurately, so we need to allow comparing against both END and
# END|LABEL.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:280
class Prism::LexCompat::ParamToken < ::Prism::LexCompat::Token
  # pkg:gem/prism#lib/prism/lex_compat.rb:281
  def ==(other); end
end

# This is a mapping of prism token types to Ripper token types. This is a
# many-to-one mapping because we split up our token types, whereas Ripper
# tends to group them.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:34
Prism::LexCompat::RIPPER = T.let(T.unsafe(nil), Hash)

# A result class specialized for holding tokens produced by the lexer.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:15
class Prism::LexCompat::Result < ::Prism::Result
  # Create a new lex compat result object with the given values.
  #
  # @return [Result] a new instance of Result
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:20
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Implement the hash pattern matching interface for Result.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:26
  def deconstruct_keys(keys); end

  # The list of tokens that were produced by the lexer.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:17
  def value; end
end

# When we produce tokens, we produce the same arrays that Ripper does.
# However, we add a couple of convenience methods onto them to make them a
# little easier to work with. We delegate all other methods to the array.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:205
class Prism::LexCompat::Token < ::SimpleDelegator
  # The type of the token.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:214
  def event; end

  # The location of the token in the source.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:209
  def location; end

  # The state of the lexer when this token was produced.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:224
  def state; end

  # The slice of the source that this token represents.
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:219
  def value; end
end

# This is a result specific to the `lex` and `lex_file` methods.
#
# pkg:gem/prism#lib/prism/parse_result.rb:769
class Prism::LexResult < ::Prism::Result
  # Create a new lex result object with the given values.
  #
  # @return [LexResult] a new instance of LexResult
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:774
  sig do
    params(
      value: T::Array[T.untyped],
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Implement the hash pattern matching interface for LexResult.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:780
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The list of tokens that were parsed from the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:771
  sig { returns(T::Array[T.untyped]) }
  def value; end
end

# This is a class that wraps the Ripper lexer to produce almost exactly the
# same tokens.
#
# pkg:gem/prism#lib/prism/lex_compat.rb:873
class Prism::LexRipper
  # @return [LexRipper] a new instance of LexRipper
  #
  # pkg:gem/prism#lib/prism/lex_compat.rb:876
  def initialize(source); end

  # pkg:gem/prism#lib/prism/lex_compat.rb:880
  def result; end

  # pkg:gem/prism#lib/prism/lex_compat.rb:874
  def source; end

  private

  # pkg:gem/prism#lib/prism/lex_compat.rb:914
  def lex(source); end
end

# Represents the use of the `&&=` operator for assignment to a local variable.
#
#     target &&= value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11820
class Prism::LocalVariableAndWriteNode < ::Prism::Node
  # Initialize a new LocalVariableAndWriteNode node.
  #
  # @return [LocalVariableAndWriteNode] a new instance of LocalVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11822
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:11924
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11835
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11840
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11850
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11845
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableAndWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11855
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableAndWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11860
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:11863
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # pkg:gem/prism#lib/prism/node.rb:11900
  sig { returns(Integer) }
  def depth; end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:237
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11908
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:11897
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11868
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:11903
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11881
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11876
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11889
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:11913
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:11894
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:11918
    def type; end
  end
end

# Represents assigning to a local variable using an operator that isn't `=`.
#
#     target += value
#     ^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:11938
class Prism::LocalVariableOperatorWriteNode < ::Prism::Node
  # Initialize a new LocalVariableOperatorWriteNode node.
  #
  # @return [LocalVariableOperatorWriteNode] a new instance of LocalVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11940
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, binary_operator_loc, value, name, binary_operator, depth); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12041
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:11954
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader binary_operator: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:12019
  sig { returns(Symbol) }
  def binary_operator; end

  # attr_reader binary_operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12000
  sig { returns(Prism::Location) }
  def binary_operator_loc; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11959
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:11969
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:11964
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?binary_operator: Symbol, ?depth: Integer) -> LocalVariableOperatorWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:11974
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      binary_operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      binary_operator: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOperatorWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:11979
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, binary_operator_loc: Location, value: Prism::node, name: Symbol, binary_operator: Symbol, depth: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:11982
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # pkg:gem/prism#lib/prism/node.rb:12022
  sig { returns(Integer) }
  def depth; end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:249
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12025
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:12016
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:11987
  sig { returns(Prism::Location) }
  def name_loc; end

  # Returns the binary operator used to modify the receiver. This method is
  # deprecated in favor of #binary_operator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:454
  def operator; end

  # Returns the location of the binary operator used to modify the receiver.
  # This method is deprecated in favor of #binary_operator_loc.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:461
  def operator_loc; end

  # Save the binary_operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12008
  def save_binary_operator_loc(repository); end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:11995
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12030
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:12013
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12035
    def type; end
  end
end

# Represents the use of the `||=` operator for assignment to a local variable.
#
#     target ||= value
#     ^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12056
class Prism::LocalVariableOrWriteNode < ::Prism::Node
  # Initialize a new LocalVariableOrWriteNode node.
  #
  # @return [LocalVariableOrWriteNode] a new instance of LocalVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12058
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12160
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12071
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12076
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12086
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12081
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableOrWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12091
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableOrWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12096
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:12099
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # pkg:gem/prism#lib/prism/node.rb:12136
  sig { returns(Integer) }
  def depth; end

  # pkg:gem/prism#lib/prism/desugar_compiler.rb:243
  def desugar; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12144
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:12133
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12104
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12139
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12117
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12112
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12125
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12149
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:12130
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12154
    def type; end
  end
end

# Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
#
#     foo
#     ^^^
#
# pkg:gem/prism#lib/prism/node.rb:12174
class Prism::LocalVariableReadNode < ::Prism::Node
  # Initialize a new LocalVariableReadNode node.
  #
  # @return [LocalVariableReadNode] a new instance of LocalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12176
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12255
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12186
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12191
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12201
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12196
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12206
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12211
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:12214
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The number of visible scopes that should be searched to find the origin of this local variable.
  #
  #     foo = 1; foo # depth 0
  #
  #     bar = 2; tap { bar } # depth 1
  #
  # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
  #
  # pkg:gem/prism#lib/prism/node.rb:12236
  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12239
  sig { override.returns(String) }
  def inspect; end

  # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     x      # name `:x`
  #
  #     _Test  # name `:_Test`
  #
  # Note that this can also be an underscore followed by a number for the default block parameters.
  #
  #     _1     # name `:_1`
  #
  # pkg:gem/prism#lib/prism/node.rb:12227
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12244
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12249
    def type; end
  end
end

# Represents writing to a local variable in a context that doesn't have an explicit value.
#
#     foo, bar = baz
#     ^^^  ^^^
#
#     foo => baz
#            ^^^
#
# pkg:gem/prism#lib/prism/node.rb:12269
class Prism::LocalVariableTargetNode < ::Prism::Node
  # Initialize a new LocalVariableTargetNode node.
  #
  # @return [LocalVariableTargetNode] a new instance of LocalVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12271
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12336
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12281
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12286
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12296
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12291
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12301
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer
    ).returns(Prism::LocalVariableTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12306
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:12309
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader depth: Integer
  #
  # pkg:gem/prism#lib/prism/node.rb:12317
  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12320
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:12314
  sig { returns(Symbol) }
  def name; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12325
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12330
    def type; end
  end
end

# Represents writing to a local variable.
#
#     foo = 1
#     ^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12347
class Prism::LocalVariableWriteNode < ::Prism::Node
  # Initialize a new LocalVariableWriteNode node.
  #
  # @return [LocalVariableWriteNode] a new instance of LocalVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12349
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, depth, name_loc, value, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12477
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12362
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12367
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12377
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12372
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> LocalVariableWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12382
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      depth: Integer,
      name_loc: Prism::Location,
      value: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::LocalVariableWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12387
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer, name_loc: Location, value: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:12390
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The number of semantic scopes we have to traverse to find the declaration of this variable.
  #
  #     foo = 1         # depth 0
  #
  #     tap { foo = 1 } # depth 1
  #
  # The specific rules for calculating the depth may differ from individual Ruby implementations, as they are not specified by the language. For more information, see [the Prism documentation](https://github.com/ruby/prism/blob/main/docs/local_variable_depth.md).
  #
  # pkg:gem/prism#lib/prism/node.rb:12408
  sig { returns(Integer) }
  def depth; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12461
  sig { override.returns(String) }
  def inspect; end

  # The name of the local variable, which is an [identifier](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#identifiers).
  #
  #     foo = :bar # name `:foo`
  #
  #     abc = 123  # name `:abc`
  #
  # pkg:gem/prism#lib/prism/node.rb:12399
  sig { returns(Symbol) }
  def name; end

  # The location of the variable name.
  #
  #     foo = :bar
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:12414
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12456
  sig { returns(String) }
  def operator; end

  # The location of the `=` operator.
  #
  #     x = :y
  #       ^
  #
  # pkg:gem/prism#lib/prism/node.rb:12443
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12422
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12451
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12466
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the local variable. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     foo = :bar
  #           ^^^^
  #
  #     abc = 1234
  #           ^^^^
  #
  # Note that since the name of a local variable is known before the value is parsed, it is valid for a local variable to appear within the value of its own write.
  #
  #     foo = foo
  #
  # pkg:gem/prism#lib/prism/node.rb:12437
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12471
    def type; end
  end
end

# This represents a location in the source.
#
# pkg:gem/prism#lib/prism/parse_result.rb:278
class Prism::Location
  # Create a new location object with the given source, start byte offset, and
  # byte length.
  #
  # @return [Location] a new instance of Location
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:293
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).void }
  def initialize(source, start_offset, length); end

  # Returns true if the given other location is equal to this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:481
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # Join this location with the first occurrence of the string in the source
  # that occurs after this location on the same line, and return the new
  # location. This will raise an error if the string does not exist.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:500
  sig { params(string: String).returns(Prism::Location) }
  def adjoin(string); end

  # The end column in code units using the given cache to fetch or calculate
  # the value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:466
  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_end_code_units_column(cache); end

  # The end offset from the start of the file in code units using the given
  # cache to fetch or calculate the value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:402
  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_end_code_units_offset(cache); end

  # The start column in code units using the given cache to fetch or calculate
  # the value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:442
  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_start_code_units_column(cache); end

  # The start offset from the start of the file in code units using the given
  # cache to fetch or calculate the value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:380
  sig do
    params(
      cache: T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer))
    ).returns(Integer)
  end
  def cached_start_code_units_offset(cache); end

  # Returns a new location that is the result of chopping off the last byte.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:339
  sig { returns(Prism::Location) }
  def chop; end

  # Returns all comments that are associated with this location (both leading
  # and trailing comments).
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:329
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # Create a new location object with the given options.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:334
  sig { params(source: Prism::Source, start_offset: Integer, length: Integer).returns(Prism::Location) }
  def copy(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  # Implement the hash pattern matching interface for Location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:471
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:454
  sig { returns(Integer) }
  def end_character_column; end

  # The character offset from the beginning of the source where this location
  # ends.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:391
  sig { returns(Integer) }
  def end_character_offset; end

  # The column number in code units of the given encoding where this location
  # ends from the start of the line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:460
  sig { params(encoding: Encoding).returns(Integer) }
  def end_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:396
  sig { params(encoding: Encoding).returns(Integer) }
  def end_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location ends from the start of the
  # line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:448
  sig { returns(Integer) }
  def end_column; end

  # The line number where this location ends.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:418
  sig { returns(Integer) }
  def end_line; end

  # The byte offset from the beginning of the source where this location ends.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:385
  sig { returns(Integer) }
  def end_offset; end

  # Returns a string representation of this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:344
  sig { returns(String) }
  def inspect; end

  # Returns a new location that stretches from this location to the given
  # other location. Raises an error if this location is not before the other
  # location or if they don't share the same source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:490
  sig { params(other: Prism::Location).returns(Prism::Location) }
  def join(other); end

  # Attach a comment to the leading comments of this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:312
  sig { params(comment: Prism::Comment).void }
  def leading_comment(comment); end

  # These are the comments that are associated with this location that exist
  # before the start of this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:307
  sig { returns(T::Array[Prism::Comment]) }
  def leading_comments; end

  # The length of this location in bytes.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:289
  sig { returns(Integer) }
  def length; end

  # Implement the pretty print interface for Location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:476
  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  # The source code that this location represents.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:354
  sig { returns(String) }
  def slice; end

  # The source code that this location represents starting from the beginning
  # of the line that this location starts on to the end of the line that this
  # location ends on.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:361
  def slice_lines; end

  # Returns all of the lines of the source code associated with this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:349
  sig { returns(T::Array[String]) }
  def source_lines; end

  # The column number in characters where this location ends from the start of
  # the line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:430
  sig { returns(Integer) }
  def start_character_column; end

  # The character offset from the beginning of the source where this location
  # starts.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:369
  sig { returns(Integer) }
  def start_character_offset; end

  # The column number in code units of the given encoding where this location
  # starts from the start of the line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:436
  sig { params(encoding: Encoding).returns(Integer) }
  def start_code_units_column(encoding = T.unsafe(nil)); end

  # The offset from the start of the file in code units of the given encoding.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:374
  sig { params(encoding: Encoding).returns(Integer) }
  def start_code_units_offset(encoding = T.unsafe(nil)); end

  # The column number in bytes where this location starts from the start of
  # the line.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:424
  sig { returns(Integer) }
  def start_column; end

  # The line number where this location starts.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:407
  sig { returns(Integer) }
  def start_line; end

  # The content of the line where this location starts before this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:412
  sig { returns(String) }
  def start_line_slice; end

  # The byte offset from the beginning of the source where this location
  # starts.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:286
  sig { returns(Integer) }
  def start_offset; end

  # Attach a comment to the trailing comments of this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:323
  sig { params(comment: Prism::Comment).void }
  def trailing_comment(comment); end

  # These are the comments that are associated with this location that exist
  # after the end of this location.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:318
  sig { returns(T::Array[Prism::Comment]) }
  def trailing_comments; end

  protected

  # A Source object that is used to determine more information from the given
  # offset and length.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:281
  sig { returns(Prism::Source) }
  def source; end
end

# Flags for while and until loop nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18747
module Prism::LoopFlags; end

# a loop after a begin statement, so the body is executed first before the condition
#
# pkg:gem/prism#lib/prism/node.rb:18749
Prism::LoopFlags::BEGIN_MODIFIER = T.let(T.unsafe(nil), Integer)

# This represents a magic comment that was encountered during parsing.
#
# pkg:gem/prism#lib/prism/parse_result.rb:562
class Prism::MagicComment
  # Create a new magic comment object with the given key and value locations.
  #
  # @return [MagicComment] a new instance of MagicComment
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:570
  sig { params(key_loc: Prism::Location, value_loc: Prism::Location).void }
  def initialize(key_loc, value_loc); end

  # Implement the hash pattern matching interface for MagicComment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:586
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Returns a string representation of this magic comment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:591
  sig { returns(String) }
  def inspect; end

  # Returns the key of the magic comment by slicing it from the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:576
  sig { returns(String) }
  def key; end

  # A Location object representing the location of the key in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:564
  sig { returns(Prism::Location) }
  def key_loc; end

  # Returns the value of the magic comment by slicing it from the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:581
  sig { returns(String) }
  def value; end

  # A Location object representing the location of the value in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:567
  sig { returns(Prism::Location) }
  def value_loc; end
end

# Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
#
#     if /foo/i then end
#        ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12491
class Prism::MatchLastLineNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # Initialize a new MatchLastLineNode node.
  #
  # @return [MatchLastLineNode] a new instance of MatchLastLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12493
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12666
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12505
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12563
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12510
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12645
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12619
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12520
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12515
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def content: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12640
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12606
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> MatchLastLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12525
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::MatchLastLineNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12530
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:12533
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12558
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12543
  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12583
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12588
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12578
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12538
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12650
  sig { override.returns(String) }
  def inspect; end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12548
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12553
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12635
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12593
  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12627
  def save_closing_loc(repository); end

  # Save the content_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12614
  def save_content_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12601
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12655
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader unescaped: String
  #
  # pkg:gem/prism#lib/prism/node.rb:12632
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12573
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:12568
  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12660
    def type; end
  end
end

# Represents the use of the modifier `in` operator.
#
#     foo in bar
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12680
class Prism::MatchPredicateNode < ::Prism::Node
  # Initialize a new MatchPredicateNode node.
  #
  # @return [MatchPredicateNode] a new instance of MatchPredicateNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12682
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12766
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12693
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12698
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12708
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12703
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchPredicateNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12713
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchPredicateNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12718
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, pattern: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:12721
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12750
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12745
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:12732
  sig { returns(Prism::Location) }
  def operator_loc; end

  # attr_reader pattern: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:12729
  sig { returns(Prism::Node) }
  def pattern; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12740
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12755
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:12726
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12760
    def type; end
  end
end

# Represents the use of the `=>` operator.
#
#     foo => bar
#     ^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12778
class Prism::MatchRequiredNode < ::Prism::Node
  # Initialize a new MatchRequiredNode node.
  #
  # @return [MatchRequiredNode] a new instance of MatchRequiredNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12780
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12912
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12791
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12796
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12806
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12801
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchRequiredNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12811
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      value: Prism::Node,
      pattern: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::MatchRequiredNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12816
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, pattern: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:12819
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12896
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12891
  sig { returns(String) }
  def operator; end

  # The location of the operator.
  #
  #     foo => bar
  #         ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:12878
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right-hand side of the operator. The type of the node depends on the expression.
  #
  # Anything that looks like a local variable name (including `_`) will result in a `LocalVariableTargetNode`.
  #
  #     foo => a # This is equivalent to writing `a = foo`
  #            ^
  #
  # Using an explicit `Array` or combining expressions with `,` will result in a `ArrayPatternNode`. This can be preceded by a constant.
  #
  #     foo => [a]
  #            ^^^
  #
  #     foo => a, b
  #            ^^^^
  #
  #     foo => Bar[a, b]
  #            ^^^^^^^^^
  #
  # If the array pattern contains at least two wildcard matches, a `FindPatternNode` is created instead.
  #
  #     foo => *, 1, *a
  #            ^^^^^
  #
  # Using an explicit `Hash` or a constant with square brackets and hash keys in the square brackets will result in a `HashPatternNode`.
  #
  #     foo => { a: 1, b: }
  #
  #     foo => Bar[a: 1, b:]
  #
  #     foo => Bar[**]
  #
  # To use any variable that needs run time evaluation, pinning is required. This results in a `PinnedVariableNode`
  #
  #     foo => ^a
  #            ^^
  #
  # Similar, any expression can be used with pinning. This results in a `PinnedExpressionNode`.
  #
  #     foo => ^(a + 1)
  #
  # Anything else will result in the regular node for that expression, for example a `ConstantReadNode`.
  #
  #     foo => CONST
  #
  # pkg:gem/prism#lib/prism/node.rb:12872
  sig { returns(Prism::Node) }
  def pattern; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:12886
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12901
  sig { override.returns(Symbol) }
  def type; end

  # Represents the left-hand side of the operator.
  #
  #     foo => bar
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:12827
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12906
    def type; end
  end
end

# Represents writing local variables using a regular expression match with named capture groups.
#
#     /(?<foo>bar)/ =~ baz
#     ^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:12924
class Prism::MatchWriteNode < ::Prism::Node
  # Initialize a new MatchWriteNode node.
  #
  # @return [MatchWriteNode] a new instance of MatchWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12926
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).void
  end
  def initialize(source, node_id, location, flags, call, targets); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:12991
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:12936
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader call: CallNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12969
  sig { returns(Prism::CallNode) }
  def call; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12941
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:12951
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:12946
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?call: CallNode, ?targets: Array[LocalVariableTargetNode]) -> MatchWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:12956
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      call: Prism::CallNode,
      targets: T::Array[Prism::LocalVariableTargetNode]
    ).returns(Prism::MatchWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:12961
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, call: CallNode, targets: Array[LocalVariableTargetNode] }
  #
  # pkg:gem/prism#lib/prism/node.rb:12964
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:12975
  sig { override.returns(String) }
  def inspect; end

  # attr_reader targets: Array[LocalVariableTargetNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:12972
  sig { returns(T::Array[Prism::LocalVariableTargetNode]) }
  def targets; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:12980
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:12985
    def type; end
  end
end

# Represents a node that is missing from the source and results in a syntax error.
#
# pkg:gem/prism#lib/prism/node.rb:13000
class Prism::MissingNode < ::Prism::Node
  # Initialize a new MissingNode node.
  #
  # @return [MissingNode] a new instance of MissingNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13002
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13059
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13010
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13015
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13025
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13020
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> MissingNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13030
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::MissingNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13035
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:13038
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13043
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13048
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13053
    def type; end
  end
end

# Represents a module declaration involving the `module` keyword.
#
#     module Foo end
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:13068
class Prism::ModuleNode < ::Prism::Node
  # Initialize a new ModuleNode node.
  #
  # @return [ModuleNode] a new instance of ModuleNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13070
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).void
  end
  def initialize(source, node_id, location, flags, locals, module_keyword_loc, constant_path, body, end_keyword_loc, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13184
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13084
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: StatementsNode | BeginNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:13139
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13089
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13102
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13094
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # attr_reader constant_path: ConstantReadNode | ConstantPathNode | MissingNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13136
  sig { returns(T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode)) }
  def constant_path; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?module_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | MissingNode, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location, ?name: Symbol) -> ModuleNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13107
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      module_keyword_loc: Prism::Location,
      constant_path: T.any(Prism::ConstantReadNode, Prism::ConstantPathNode, Prism::MissingNode),
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location,
      name: Symbol
    ).returns(Prism::ModuleNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13112
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], module_keyword_loc: Location, constant_path: ConstantReadNode | ConstantPathNode | MissingNode, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:13115
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13163
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:13142
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13168
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:13120
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def module_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13158
  sig { returns(String) }
  def module_keyword; end

  # attr_reader module_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:13123
  sig { returns(Prism::Location) }
  def module_keyword_loc; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:13155
  sig { returns(Symbol) }
  def name; end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13150
  def save_end_keyword_loc(repository); end

  # Save the module_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13131
  def save_module_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13173
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13178
    def type; end
  end
end

# Represents a multi-target expression.
#
#     a, (b, c) = 1, 2, 3
#        ^^^^^^
#
# This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
#
#     for a, b in [[1, 2], [3, 4]]
#         ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:13205
class Prism::MultiTargetNode < ::Prism::Node
  # Initialize a new MultiTargetNode node.
  #
  # @return [MultiTargetNode] a new instance of MultiTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13207
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13360
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13220
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13225
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13239
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13230
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: ImplicitRestNode | SplatNode | nil, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?) -> MultiTargetNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13244
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::MultiTargetNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13249
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], rest: ImplicitRestNode | SplatNode | nil, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], lparen_loc: Location?, rparen_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:13252
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13344
  sig { override.returns(String) }
  def inspect; end

  # Represents the targets expressions before a splat node.
  #
  #     a, (b, c, *) = 1, 2, 3, 4, 5
  #         ^^^^
  #
  # The splat node can be absent, in that case all target expressions are in the left field.
  #
  #     a, (b, c) = 1, 2, 3, 4, 5
  #         ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:13265
  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def lefts; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:13334
  sig { returns(T.nilable(String)) }
  def lparen; end

  # The location of the opening parenthesis.
  #
  #     a, (b, c) = 1, 2, 3
  #        ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13293
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # Represents a splat node in the target expression.
  #
  #     a, (b, *c) = 1, 2, 3, 4
  #            ^^
  #
  # The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
  #
  #     a, (b, *) = 1, 2, 3, 4
  #            ^
  #
  # If the `*` is omitted, this field will contain an `ImplicitRestNode`
  #
  #     a, (b,) = 1, 2, 3, 4
  #          ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13281
  sig { returns(T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode))) }
  def rest; end

  # Represents the targets expressions after a splat node.
  #
  #     a, (*, b, c) = 1, 2, 3, 4, 5
  #            ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:13287
  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::RequiredParameterNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def rights; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:13339
  sig { returns(T.nilable(String)) }
  def rparen; end

  # The location of the closing parenthesis.
  #
  #     a, (b, c) = 1, 2, 3
  #             ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13315
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13307
  def save_lparen_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13329
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13349
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13354
    def type; end
  end
end

# Represents a write to a multi-target expression.
#
#     a, b, c = 1, 2, 3
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:13376
class Prism::MultiWriteNode < ::Prism::Node
  # Initialize a new MultiWriteNode node.
  #
  # @return [MultiWriteNode] a new instance of MultiWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13378
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13561
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13393
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13398
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13413
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13403
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: ImplicitRestNode | SplatNode | nil, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?operator_loc: Location, ?value: Prism::node) -> MultiWriteNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13418
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      lefts: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      rest: T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode)),
      rights: T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)],
      lparen_loc: T.nilable(Prism::Location),
      rparen_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::MultiWriteNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13423
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], rest: ImplicitRestNode | SplatNode | nil, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:13426
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13545
  sig { override.returns(String) }
  def inspect; end

  # Represents the targets expressions before a splat node.
  #
  #     a, b, * = 1, 2, 3, 4, 5
  #     ^^^^
  #
  # The splat node can be absent, in that case all target expressions are in the left field.
  #
  #     a, b, c = 1, 2, 3, 4, 5
  #     ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:13439
  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def lefts; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:13530
  sig { returns(T.nilable(String)) }
  def lparen; end

  # The location of the opening parenthesis.
  #
  #     (a, b, c) = 1, 2, 3
  #     ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13467
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13540
  sig { returns(String) }
  def operator; end

  # The location of the operator.
  #
  #     a, b, c = 1, 2, 3
  #             ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13511
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents a splat node in the target expression.
  #
  #     a, b, *c = 1, 2, 3, 4
  #           ^^
  #
  # The variable can be empty, this results in a `SplatNode` with a `nil` expression field.
  #
  #     a, b, * = 1, 2, 3, 4
  #           ^
  #
  # If the `*` is omitted, this field will contain an `ImplicitRestNode`
  #
  #     a, b, = 1, 2, 3, 4
  #         ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13455
  sig { returns(T.nilable(T.any(Prism::ImplicitRestNode, Prism::SplatNode))) }
  def rest; end

  # Represents the targets expressions after a splat node.
  #
  #     a, *, b, c = 1, 2, 3, 4, 5
  #           ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:13461
  sig do
    returns(T::Array[T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::MultiTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode)])
  end
  def rights; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:13535
  sig { returns(T.nilable(String)) }
  def rparen; end

  # The location of the closing parenthesis.
  #
  #     (a, b, c) = 1, 2, 3
  #             ^
  #
  # pkg:gem/prism#lib/prism/node.rb:13489
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13481
  def save_lparen_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13519
  def save_operator_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13503
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13550
  sig { override.returns(Symbol) }
  def type; end

  # The value to write to the targets. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     a, b, c = 1, 2, 3
  #               ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:13527
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13555
    def type; end
  end
end

# This visitor walks through the tree and copies each node as it is being
# visited. This is useful for consumers that want to mutate the tree, as you
# can change subtrees in place without effecting the rest of the tree.
#
# pkg:gem/prism#lib/prism/mutation_compiler.rb:16
class Prism::MutationCompiler < ::Prism::Compiler
  # Copy a AliasGlobalVariableNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:18
  def visit_alias_global_variable_node(node); end

  # Copy a AliasMethodNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:23
  def visit_alias_method_node(node); end

  # Copy a AlternationPatternNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:28
  def visit_alternation_pattern_node(node); end

  # Copy a AndNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:33
  def visit_and_node(node); end

  # Copy a ArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:38
  def visit_arguments_node(node); end

  # Copy a ArrayNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:43
  def visit_array_node(node); end

  # Copy a ArrayPatternNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:48
  def visit_array_pattern_node(node); end

  # Copy a AssocNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:53
  def visit_assoc_node(node); end

  # Copy a AssocSplatNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:58
  def visit_assoc_splat_node(node); end

  # Copy a BackReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:63
  def visit_back_reference_read_node(node); end

  # Copy a BeginNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:68
  def visit_begin_node(node); end

  # Copy a BlockArgumentNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:73
  def visit_block_argument_node(node); end

  # Copy a BlockLocalVariableNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:78
  def visit_block_local_variable_node(node); end

  # Copy a BlockNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:83
  def visit_block_node(node); end

  # Copy a BlockParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:88
  def visit_block_parameter_node(node); end

  # Copy a BlockParametersNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:93
  def visit_block_parameters_node(node); end

  # Copy a BreakNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:98
  def visit_break_node(node); end

  # Copy a CallAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:103
  def visit_call_and_write_node(node); end

  # Copy a CallNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:108
  def visit_call_node(node); end

  # Copy a CallOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:113
  def visit_call_operator_write_node(node); end

  # Copy a CallOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:118
  def visit_call_or_write_node(node); end

  # Copy a CallTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:123
  def visit_call_target_node(node); end

  # Copy a CapturePatternNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:128
  def visit_capture_pattern_node(node); end

  # Copy a CaseMatchNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:133
  def visit_case_match_node(node); end

  # Copy a CaseNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:138
  def visit_case_node(node); end

  # Copy a ClassNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:143
  def visit_class_node(node); end

  # Copy a ClassVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:148
  def visit_class_variable_and_write_node(node); end

  # Copy a ClassVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:153
  def visit_class_variable_operator_write_node(node); end

  # Copy a ClassVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:158
  def visit_class_variable_or_write_node(node); end

  # Copy a ClassVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:163
  def visit_class_variable_read_node(node); end

  # Copy a ClassVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:168
  def visit_class_variable_target_node(node); end

  # Copy a ClassVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:173
  def visit_class_variable_write_node(node); end

  # Copy a ConstantAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:178
  def visit_constant_and_write_node(node); end

  # Copy a ConstantOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:183
  def visit_constant_operator_write_node(node); end

  # Copy a ConstantOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:188
  def visit_constant_or_write_node(node); end

  # Copy a ConstantPathAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:193
  def visit_constant_path_and_write_node(node); end

  # Copy a ConstantPathNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:198
  def visit_constant_path_node(node); end

  # Copy a ConstantPathOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:203
  def visit_constant_path_operator_write_node(node); end

  # Copy a ConstantPathOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:208
  def visit_constant_path_or_write_node(node); end

  # Copy a ConstantPathTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:213
  def visit_constant_path_target_node(node); end

  # Copy a ConstantPathWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:218
  def visit_constant_path_write_node(node); end

  # Copy a ConstantReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:223
  def visit_constant_read_node(node); end

  # Copy a ConstantTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:228
  def visit_constant_target_node(node); end

  # Copy a ConstantWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:233
  def visit_constant_write_node(node); end

  # Copy a DefNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:238
  def visit_def_node(node); end

  # Copy a DefinedNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:243
  def visit_defined_node(node); end

  # Copy a ElseNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:248
  def visit_else_node(node); end

  # Copy a EmbeddedStatementsNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:253
  def visit_embedded_statements_node(node); end

  # Copy a EmbeddedVariableNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:258
  def visit_embedded_variable_node(node); end

  # Copy a EnsureNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:263
  def visit_ensure_node(node); end

  # Copy a FalseNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:268
  def visit_false_node(node); end

  # Copy a FindPatternNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:273
  def visit_find_pattern_node(node); end

  # Copy a FlipFlopNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:278
  def visit_flip_flop_node(node); end

  # Copy a FloatNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:283
  def visit_float_node(node); end

  # Copy a ForNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:288
  def visit_for_node(node); end

  # Copy a ForwardingArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:293
  def visit_forwarding_arguments_node(node); end

  # Copy a ForwardingParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:298
  def visit_forwarding_parameter_node(node); end

  # Copy a ForwardingSuperNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:303
  def visit_forwarding_super_node(node); end

  # Copy a GlobalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:308
  def visit_global_variable_and_write_node(node); end

  # Copy a GlobalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:313
  def visit_global_variable_operator_write_node(node); end

  # Copy a GlobalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:318
  def visit_global_variable_or_write_node(node); end

  # Copy a GlobalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:323
  def visit_global_variable_read_node(node); end

  # Copy a GlobalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:328
  def visit_global_variable_target_node(node); end

  # Copy a GlobalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:333
  def visit_global_variable_write_node(node); end

  # Copy a HashNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:338
  def visit_hash_node(node); end

  # Copy a HashPatternNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:343
  def visit_hash_pattern_node(node); end

  # Copy a IfNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:348
  def visit_if_node(node); end

  # Copy a ImaginaryNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:353
  def visit_imaginary_node(node); end

  # Copy a ImplicitNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:358
  def visit_implicit_node(node); end

  # Copy a ImplicitRestNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:363
  def visit_implicit_rest_node(node); end

  # Copy a InNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:368
  def visit_in_node(node); end

  # Copy a IndexAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:373
  def visit_index_and_write_node(node); end

  # Copy a IndexOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:378
  def visit_index_operator_write_node(node); end

  # Copy a IndexOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:383
  def visit_index_or_write_node(node); end

  # Copy a IndexTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:388
  def visit_index_target_node(node); end

  # Copy a InstanceVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:393
  def visit_instance_variable_and_write_node(node); end

  # Copy a InstanceVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:398
  def visit_instance_variable_operator_write_node(node); end

  # Copy a InstanceVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:403
  def visit_instance_variable_or_write_node(node); end

  # Copy a InstanceVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:408
  def visit_instance_variable_read_node(node); end

  # Copy a InstanceVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:413
  def visit_instance_variable_target_node(node); end

  # Copy a InstanceVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:418
  def visit_instance_variable_write_node(node); end

  # Copy a IntegerNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:423
  def visit_integer_node(node); end

  # Copy a InterpolatedMatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:428
  def visit_interpolated_match_last_line_node(node); end

  # Copy a InterpolatedRegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:433
  def visit_interpolated_regular_expression_node(node); end

  # Copy a InterpolatedStringNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:438
  def visit_interpolated_string_node(node); end

  # Copy a InterpolatedSymbolNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:443
  def visit_interpolated_symbol_node(node); end

  # Copy a InterpolatedXStringNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:448
  def visit_interpolated_x_string_node(node); end

  # Copy a ItLocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:453
  def visit_it_local_variable_read_node(node); end

  # Copy a ItParametersNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:458
  def visit_it_parameters_node(node); end

  # Copy a KeywordHashNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:463
  def visit_keyword_hash_node(node); end

  # Copy a KeywordRestParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:468
  def visit_keyword_rest_parameter_node(node); end

  # Copy a LambdaNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:473
  def visit_lambda_node(node); end

  # Copy a LocalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:478
  def visit_local_variable_and_write_node(node); end

  # Copy a LocalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:483
  def visit_local_variable_operator_write_node(node); end

  # Copy a LocalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:488
  def visit_local_variable_or_write_node(node); end

  # Copy a LocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:493
  def visit_local_variable_read_node(node); end

  # Copy a LocalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:498
  def visit_local_variable_target_node(node); end

  # Copy a LocalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:503
  def visit_local_variable_write_node(node); end

  # Copy a MatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:508
  def visit_match_last_line_node(node); end

  # Copy a MatchPredicateNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:513
  def visit_match_predicate_node(node); end

  # Copy a MatchRequiredNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:518
  def visit_match_required_node(node); end

  # Copy a MatchWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:523
  def visit_match_write_node(node); end

  # Copy a MissingNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:528
  def visit_missing_node(node); end

  # Copy a ModuleNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:533
  def visit_module_node(node); end

  # Copy a MultiTargetNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:538
  def visit_multi_target_node(node); end

  # Copy a MultiWriteNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:543
  def visit_multi_write_node(node); end

  # Copy a NextNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:548
  def visit_next_node(node); end

  # Copy a NilNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:553
  def visit_nil_node(node); end

  # Copy a NoKeywordsParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:558
  def visit_no_keywords_parameter_node(node); end

  # Copy a NumberedParametersNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:563
  def visit_numbered_parameters_node(node); end

  # Copy a NumberedReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:568
  def visit_numbered_reference_read_node(node); end

  # Copy a OptionalKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:573
  def visit_optional_keyword_parameter_node(node); end

  # Copy a OptionalParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:578
  def visit_optional_parameter_node(node); end

  # Copy a OrNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:583
  def visit_or_node(node); end

  # Copy a ParametersNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:588
  def visit_parameters_node(node); end

  # Copy a ParenthesesNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:593
  def visit_parentheses_node(node); end

  # Copy a PinnedExpressionNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:598
  def visit_pinned_expression_node(node); end

  # Copy a PinnedVariableNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:603
  def visit_pinned_variable_node(node); end

  # Copy a PostExecutionNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:608
  def visit_post_execution_node(node); end

  # Copy a PreExecutionNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:613
  def visit_pre_execution_node(node); end

  # Copy a ProgramNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:618
  def visit_program_node(node); end

  # Copy a RangeNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:623
  def visit_range_node(node); end

  # Copy a RationalNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:628
  def visit_rational_node(node); end

  # Copy a RedoNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:633
  def visit_redo_node(node); end

  # Copy a RegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:638
  def visit_regular_expression_node(node); end

  # Copy a RequiredKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:643
  def visit_required_keyword_parameter_node(node); end

  # Copy a RequiredParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:648
  def visit_required_parameter_node(node); end

  # Copy a RescueModifierNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:653
  def visit_rescue_modifier_node(node); end

  # Copy a RescueNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:658
  def visit_rescue_node(node); end

  # Copy a RestParameterNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:663
  def visit_rest_parameter_node(node); end

  # Copy a RetryNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:668
  def visit_retry_node(node); end

  # Copy a ReturnNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:673
  def visit_return_node(node); end

  # Copy a SelfNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:678
  def visit_self_node(node); end

  # Copy a ShareableConstantNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:683
  def visit_shareable_constant_node(node); end

  # Copy a SingletonClassNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:688
  def visit_singleton_class_node(node); end

  # Copy a SourceEncodingNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:693
  def visit_source_encoding_node(node); end

  # Copy a SourceFileNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:698
  def visit_source_file_node(node); end

  # Copy a SourceLineNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:703
  def visit_source_line_node(node); end

  # Copy a SplatNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:708
  def visit_splat_node(node); end

  # Copy a StatementsNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:713
  def visit_statements_node(node); end

  # Copy a StringNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:718
  def visit_string_node(node); end

  # Copy a SuperNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:723
  def visit_super_node(node); end

  # Copy a SymbolNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:728
  def visit_symbol_node(node); end

  # Copy a TrueNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:733
  def visit_true_node(node); end

  # Copy a UndefNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:738
  def visit_undef_node(node); end

  # Copy a UnlessNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:743
  def visit_unless_node(node); end

  # Copy a UntilNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:748
  def visit_until_node(node); end

  # Copy a WhenNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:753
  def visit_when_node(node); end

  # Copy a WhileNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:758
  def visit_while_node(node); end

  # Copy a XStringNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:763
  def visit_x_string_node(node); end

  # Copy a YieldNode node
  #
  # pkg:gem/prism#lib/prism/mutation_compiler.rb:768
  def visit_yield_node(node); end
end

# Represents the use of the `next` keyword.
#
#     next 1
#     ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:13579
class Prism::NextNode < ::Prism::Node
  # Initialize a new NextNode node.
  #
  # @return [NextNode] a new instance of NextNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13581
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13663
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13591
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:13626
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13596
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13608
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13601
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> NextNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13613
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      arguments: T.nilable(Prism::ArgumentsNode),
      keyword_loc: Prism::Location
    ).returns(Prism::NextNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13618
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: ArgumentsNode?, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:13621
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13647
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13642
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:13629
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13637
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13652
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13657
    def type; end
  end
end

# Represents the use of the `nil` keyword.
#
#     nil
#     ^^^
#
# pkg:gem/prism#lib/prism/node.rb:13674
class Prism::NilNode < ::Prism::Node
  # Initialize a new NilNode node.
  #
  # @return [NilNode] a new instance of NilNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13676
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13733
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13684
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13689
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13699
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13694
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> NilNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13704
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::NilNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13709
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:13712
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13717
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13722
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13727
    def type; end
  end
end

# Represents the use of `**nil` inside method arguments.
#
#     def a(**nil)
#           ^^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:13743
class Prism::NoKeywordsParameterNode < ::Prism::Node
  # Initialize a new NoKeywordsParameterNode node.
  #
  # @return [NoKeywordsParameterNode] a new instance of NoKeywordsParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13745
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13840
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13755
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13760
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13770
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13765
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoKeywordsParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13775
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      keyword_loc: Prism::Location
    ).returns(Prism::NoKeywordsParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13780
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:13783
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13824
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13819
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:13801
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13814
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:13788
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13809
  def save_keyword_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:13796
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13829
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13834
    def type; end
  end
end

# This represents a node in the tree. It is the parent class of all of the
# various node types.
#
# pkg:gem/prism#lib/prism/node.rb:15
class Prism::Node
  abstract!

  # Accepts a visitor and calls back into the specialized visit function.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:261
  sig { abstract.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Returns the first node that matches the given block when visited in a
  # depth-first search. This is useful for finding a node that matches a
  # particular condition.
  #
  #     node.breadth_first_search { |node| node.node_id == node_id }
  #
  # pkg:gem/prism#lib/prism/node.rb:231
  sig { params(block: T.proc.params(node: Prism::Node).returns(T::Boolean)).returns(T.nilable(Prism::Node)) }
  def breadth_first_search(&block); end

  # Delegates to the cached_end_code_units_column of the associated location
  # object.
  #
  # pkg:gem/prism#lib/prism/node.rb:118
  def cached_end_code_units_column(cache); end

  # Delegates to the cached_end_code_units_offset of the associated location
  # object.
  #
  # pkg:gem/prism#lib/prism/node.rb:86
  def cached_end_code_units_offset(cache); end

  # Delegates to the cached_start_code_units_column of the associated location
  # object.
  #
  # pkg:gem/prism#lib/prism/node.rb:112
  def cached_start_code_units_column(cache); end

  # Delegates to the cached_start_code_units_offset of the associated location
  # object.
  #
  # pkg:gem/prism#lib/prism/node.rb:80
  def cached_start_code_units_offset(cache); end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:267
  sig { abstract.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # Returns an array of child nodes and locations that could potentially have
  # comments attached to them.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:281
  sig { abstract.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # Delegates to the comments of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:133
  def comments; end

  # Returns an array of child nodes, excluding any `nil`s in the place of
  # optional nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:275
  sig { abstract.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Returns an array of child nodes, including `nil`s in the place of optional
  # nodes that were not present.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:271
  sig { abstract.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # pkg:gem/prism#lib/prism/node_ext.rb:10
  def deprecated(*replacements); end

  # Delegates to the end_character_column of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:106
  def end_character_column; end

  # Delegates to the end_character_offset of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:74
  def end_character_offset; end

  # Delegates to the end_column of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:96
  def end_column; end

  # Delegates to the end_line of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:50
  def end_line; end

  # The end offset of the node in the source. This method is effectively a
  # delegate method to the location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:63
  sig { returns(Integer) }
  def end_offset; end

  sig { abstract.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Returns a string representation of the node.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:286
  sig { abstract.returns(String) }
  def inspect; end

  # Delegates to the leading_comments of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:123
  def leading_comments; end

  # A Location instance that represents the location of this node in the
  # source.
  #
  # pkg:gem/prism#lib/prism/node.rb:33
  sig { returns(Prism::Location) }
  def location; end

  # Returns true if the node has the newline flag set.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:164
  sig { returns(T::Boolean) }
  def newline?; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:70
  def newline_flag!(lines); end

  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:66
  def newline_flag?; end

  # A unique identifier for this node. This is used in a very specific
  # use case where you want to keep around a reference to a node without
  # having to keep around the syntax tree in memory. This unique identifier
  # will be consistent across multiple parses of the same source code.
  #
  # pkg:gem/prism#lib/prism/node.rb:24
  sig { returns(Integer) }
  def node_id; end

  # Similar to inspect, but respects the current level of indentation given by
  # the pretty print object.
  #
  # pkg:gem/prism#lib/prism/node.rb:175
  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  # Save this node using a saved source so that it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:27
  def save(repository); end

  # Save the location using a saved source so that it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:40
  def save_location(repository); end

  # Returns all of the lines of the source code associated with this node.
  # An alias for source_lines, used to mimic the API from
  # RubyVM::AbstractSyntaxTree to make it easier to migrate.
  #
  # pkg:gem/prism#lib/prism/node.rb:144
  sig { returns(T::Array[String]) }
  def script_lines; end

  # Slice the location of the node from the source.
  #
  # pkg:gem/prism#lib/prism/node.rb:147
  sig { returns(String) }
  def slice; end

  # Slice the location of the node from the source, starting at the beginning
  # of the line that the location starts on, ending at the end of the line
  # that the location ends on.
  #
  # pkg:gem/prism#lib/prism/node.rb:154
  sig { returns(String) }
  def slice_lines; end

  # Returns all of the lines of the source code associated with this node.
  #
  # pkg:gem/prism#lib/prism/node.rb:138
  sig { returns(T::Array[String]) }
  def source_lines; end

  # Delegates to the start_character_column of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:101
  def start_character_column; end

  # Delegates to the start_character_offset of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:69
  def start_character_offset; end

  # Delegates to the start_column of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:91
  def start_column; end

  # Delegates to the start_line of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:45
  def start_line; end

  # The start offset of the node in the source. This method is effectively a
  # delegate method to the location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:56
  sig { returns(Integer) }
  def start_offset; end

  # Returns true if the node has the static literal flag set.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:169
  sig { returns(T::Boolean) }
  def static_literal?; end

  # Convert this node into a graphviz dot graph string.
  #
  # pkg:gem/prism#lib/prism/node.rb:183
  sig { returns(String) }
  def to_dot; end

  # Delegates to the trailing_comments of the associated location object.
  #
  # pkg:gem/prism#lib/prism/node.rb:128
  def trailing_comments; end

  # Returns a list of nodes that are descendants of this node that contain the
  # given line and column. This is useful for locating a node that is selected
  # based on the line and column of the source code.
  #
  # Important to note is that the column given to this method should be in
  # bytes, as opposed to characters or code units.
  #
  # pkg:gem/prism#lib/prism/node.rb:194
  sig { params(line: Integer, column: Integer).returns(T::Array[Prism::Node]) }
  def tunnel(line, column); end

  # Sometimes you want to check an instance of a node against a list of
  # classes to see what kind of behavior to perform. Usually this is done by
  # calling `[cls1, cls2].include?(node.class)` or putting the node into a
  # case statement and doing `case node; when cls1; when cls2; end`. Both of
  # these approaches are relatively slow because of the constant lookups,
  # method calls, and/or array allocations.
  #
  # Instead, you can call #type, which will return to you a symbol that you
  # can use for comparison. This is faster than the other approaches because
  # it uses a single integer comparison, but also because if you're on CRuby
  # you can take advantage of the fact that case statements with all symbol
  # keys will use a jump table.
  #
  # @raise [NoMethodError]
  #
  # pkg:gem/prism#lib/prism/node.rb:302
  sig { abstract.returns(Symbol) }
  def type; end

  protected

  # An bitset of flags for this node. There are certain flags that are common
  # for all nodes, and then some nodes have specific flags.
  #
  # pkg:gem/prism#lib/prism/node.rb:160
  sig { returns(Integer) }
  def flags; end

  private

  # A pointer to the source that this node was created from.
  #
  # pkg:gem/prism#lib/prism/node.rb:17
  sig { returns(Prism::Source) }
  def source; end

  class << self
    # Returns a list of the fields that exist for this node class. Fields
    # describe the structure of the node. This kind of reflection is useful for
    # things like recursively visiting each node _and_ field in the tree.
    #
    # @raise [NoMethodError]
    #
    # pkg:gem/prism#lib/prism/node.rb:245
    def fields; end

    # Similar to #type, this method returns a symbol that you can use for
    # splitting on the type of the node without having to do a long === chain.
    # Note that like #type, it will still be slower than using == for a single
    # class, but should be faster in a case statement or an array comparison.
    #
    # @raise [NoMethodError]
    #
    # pkg:gem/prism#lib/prism/node.rb:310
    def type; end
  end
end

# The flags that are common to all nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18846
module Prism::NodeFlags; end

# A flag to indicate that the node is a candidate to emit a :line event
# through tracepoint when compiled.
#
# pkg:gem/prism#lib/prism/node.rb:18849
Prism::NodeFlags::NEWLINE = T.let(T.unsafe(nil), Integer)

# A flag to indicate that the value that the node represents is a value that
# can be determined at parse-time.
#
# pkg:gem/prism#lib/prism/node.rb:18853
Prism::NodeFlags::STATIC_LITERAL = T.let(T.unsafe(nil), Integer)

# Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
#
#     -> { _1 + _2 }
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:13851
class Prism::NumberedParametersNode < ::Prism::Node
  # Initialize a new NumberedParametersNode node.
  #
  # @return [NumberedParametersNode] a new instance of NumberedParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13853
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, maximum); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13914
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13862
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13867
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13877
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13872
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?maximum: Integer) -> NumberedParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13882
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      maximum: Integer
    ).returns(Prism::NumberedParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13887
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, maximum: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:13890
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13898
  sig { override.returns(String) }
  def inspect; end

  # attr_reader maximum: Integer
  #
  # pkg:gem/prism#lib/prism/node.rb:13895
  sig { returns(Integer) }
  def maximum; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13903
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13908
    def type; end
  end
end

# Represents reading a numbered reference to a capture in the previous match.
#
#     $1
#     ^^
#
# pkg:gem/prism#lib/prism/node.rb:13924
class Prism::NumberedReferenceReadNode < ::Prism::Node
  # Initialize a new NumberedReferenceReadNode node.
  #
  # @return [NumberedReferenceReadNode] a new instance of NumberedReferenceReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13926
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, number); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:13993
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:13935
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13940
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:13950
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:13945
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?number: Integer) -> NumberedReferenceReadNode
  #
  # pkg:gem/prism#lib/prism/node.rb:13955
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      number: Integer
    ).returns(Prism::NumberedReferenceReadNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:13960
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, number: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:13963
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:13977
  sig { override.returns(String) }
  def inspect; end

  # The (1-indexed, from the left) number of the capture group. Numbered references that are too large result in this value being `0`.
  #
  #     $1          # number `1`
  #
  #     $5432       # number `5432`
  #
  #     $4294967296 # number `0`
  #
  # pkg:gem/prism#lib/prism/node.rb:13974
  sig { returns(Integer) }
  def number; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:13982
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:13987
    def type; end
  end
end

# Represents an optional keyword parameter to a method, block, or lambda definition.
#
#     def a(b: 1)
#           ^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:14004
class Prism::OptionalKeywordParameterNode < ::Prism::Node
  # Initialize a new OptionalKeywordParameterNode node.
  #
  # @return [OptionalKeywordParameterNode] a new instance of OptionalKeywordParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14006
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14090
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14017
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14022
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14032
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14027
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node) -> OptionalKeywordParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14037
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalKeywordParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14042
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:14045
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14074
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:14055
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14058
  sig { returns(Prism::Location) }
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:14050
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14066
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14079
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:14071
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14084
    def type; end
  end
end

# Represents an optional parameter to a method, block, or lambda definition.
#
#     def a(b = 1)
#           ^^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:14104
class Prism::OptionalParameterNode < ::Prism::Node
  # Initialize a new OptionalParameterNode node.
  #
  # @return [OptionalParameterNode] a new instance of OptionalParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14106
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14209
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14118
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14123
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14133
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14128
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> OptionalParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14138
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location,
      operator_loc: Prism::Location,
      value: Prism::Node
    ).returns(Prism::OptionalParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14143
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:14146
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14193
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:14156
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14159
  sig { returns(Prism::Location) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14188
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14172
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:14151
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14167
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14180
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14198
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader value: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:14185
  sig { returns(Prism::Node) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14203
    def type; end
  end
end

# Represents the use of the `||` operator or the `or` keyword.
#
#     left or right
#     ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14223
class Prism::OrNode < ::Prism::Node
  # Initialize a new OrNode node.
  #
  # @return [OrNode] a new instance of OrNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14225
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14324
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14236
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14241
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14251
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14246
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> OrNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14256
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: Prism::Node,
      right: Prism::Node,
      operator_loc: Prism::Location
    ).returns(Prism::OrNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14261
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14264
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14308
  sig { override.returns(String) }
  def inspect; end

  # Represents the left side of the expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     left or right
  #     ^^^^
  #
  #     1 || 2
  #     ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14275
  sig { returns(Prism::Node) }
  def left; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14303
  sig { returns(String) }
  def operator; end

  # The location of the `or` keyword or the `||` operator.
  #
  #     left or right
  #          ^^
  #
  # pkg:gem/prism#lib/prism/node.rb:14290
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Represents the right side of the expression.
  #
  #     left || right
  #             ^^^^^
  #
  #     1 or 2
  #          ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14284
  sig { returns(Prism::Node) }
  def right; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14298
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14313
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14318
    def type; end
  end
end

# A parser for the pack template language.
#
# pkg:gem/prism#lib/prism/pack.rb:8
module Prism::Pack
  class << self
    # pkg:gem/prism#lib/prism.rb:105
    def parse(_arg0, _arg1, _arg2); end
  end
end

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::AGNOSTIC_ENDIAN = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::BACK = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::BER = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::BIG_ENDIAN = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::COMMENT = T.let(T.unsafe(nil), Symbol)

# A directive in the pack template language.
#
# pkg:gem/prism#lib/prism/pack.rb:62
class Prism::Pack::Directive
  # Initialize a new directive with the given values.
  #
  # @return [Directive] a new instance of Directive
  #
  # pkg:gem/prism#lib/prism/pack.rb:91
  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  # Provide a human-readable description of the directive.
  #
  # pkg:gem/prism#lib/prism/pack.rb:133
  def describe; end

  # The type of endianness of the directive.
  #
  # pkg:gem/prism#lib/prism/pack.rb:79
  def endian; end

  # The length of this directive (used for integers).
  #
  # pkg:gem/prism#lib/prism/pack.rb:88
  def length; end

  # The length type of this directive (used for integers).
  #
  # pkg:gem/prism#lib/prism/pack.rb:85
  def length_type; end

  # The type of signedness of the directive.
  #
  # pkg:gem/prism#lib/prism/pack.rb:76
  def signed; end

  # The size of the directive.
  #
  # pkg:gem/prism#lib/prism/pack.rb:82
  def size; end

  # A byteslice of the source string that this directive represents.
  #
  # pkg:gem/prism#lib/prism/pack.rb:70
  def source; end

  # The type of the directive.
  #
  # pkg:gem/prism#lib/prism/pack.rb:73
  def type; end

  # A symbol representing whether or not we are packing or unpacking.
  #
  # pkg:gem/prism#lib/prism/pack.rb:67
  def variant; end

  # A symbol representing the version of Ruby.
  #
  # pkg:gem/prism#lib/prism/pack.rb:64
  def version; end
end

# The descriptions of the various types of endianness.
#
# pkg:gem/prism#lib/prism/pack.rb:104
Prism::Pack::Directive::ENDIAN_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of signedness.
#
# pkg:gem/prism#lib/prism/pack.rb:113
Prism::Pack::Directive::SIGNED_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# The descriptions of the various types of sizes.
#
# pkg:gem/prism#lib/prism/pack.rb:120
Prism::Pack::Directive::SIZE_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::ENDIAN_NA = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::FLOAT = T.let(T.unsafe(nil), Symbol)

# The result of parsing a pack template.
#
# pkg:gem/prism#lib/prism/pack.rb:200
class Prism::Pack::Format
  # Create a new Format with the given directives and encoding.
  #
  # @return [Format] a new instance of Format
  #
  # pkg:gem/prism#lib/prism/pack.rb:208
  def initialize(directives, encoding); end

  # Provide a human-readable description of the format.
  #
  # pkg:gem/prism#lib/prism/pack.rb:214
  def describe; end

  # A list of the directives in the template.
  #
  # pkg:gem/prism#lib/prism/pack.rb:202
  def directives; end

  # The encoding of the template.
  #
  # pkg:gem/prism#lib/prism/pack.rb:205
  def encoding; end
end

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::INTEGER = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::LENGTH_FIXED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::LENGTH_MAX = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::LENGTH_NA = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::LENGTH_RELATIVE = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::LITTLE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::MOVE = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::NATIVE_ENDIAN = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::NULL = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIGNED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIGNED_NA = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_16 = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_32 = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_64 = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_8 = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_INT = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_LONG = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_LONG_LONG = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_NA = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_P = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SIZE_SHORT = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::SPACE = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_BASE64 = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_FIXED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_HEX_HIGH = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_HEX_LOW = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_LSB = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_MIME = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_MSB = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_NULL_PADDED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_NULL_TERMINATED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_POINTER = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_SPACE_PADDED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::STRING_UU = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::UNSIGNED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/prism#lib/prism/pack.rb:58
Prism::Pack::UTF8 = T.let(T.unsafe(nil), Symbol)

# Flags for parameter nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18753
module Prism::ParameterFlags; end

# a parameter name that has been repeated in the method signature
#
# pkg:gem/prism#lib/prism/node.rb:18755
Prism::ParameterFlags::REPEATED_PARAMETER = T.let(T.unsafe(nil), Integer)

# Represents the list of parameters on a method, block, or lambda definition.
#
#     def a(b, c, d)
#           ^^^^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:14337
class Prism::ParametersNode < ::Prism::Node
  # Initialize a new ParametersNode node.
  #
  # @return [ParametersNode] a new instance of ParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14339
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).void
  end
  def initialize(source, node_id, location, flags, requireds, optionals, rest, posts, keywords, keyword_rest, block); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14432
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14354
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader block: BlockParameterNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:14413
  sig { returns(T.nilable(Prism::BlockParameterNode)) }
  def block; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14359
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14377
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14364
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?requireds: Array[RequiredParameterNode | MultiTargetNode], ?optionals: Array[OptionalParameterNode], ?rest: RestParameterNode | ImplicitRestNode | nil, ?posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode], ?keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], ?keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, ?block: BlockParameterNode?) -> ParametersNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14382
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      requireds: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)],
      optionals: T::Array[Prism::OptionalParameterNode],
      rest: T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode)),
      posts: T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)],
      keywords: T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)],
      keyword_rest: T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)),
      block: T.nilable(Prism::BlockParameterNode)
    ).returns(Prism::ParametersNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14387
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, requireds: Array[RequiredParameterNode | MultiTargetNode], optionals: Array[OptionalParameterNode], rest: RestParameterNode | ImplicitRestNode | nil, posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode], keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, block: BlockParameterNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:14390
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14416
  sig { override.returns(String) }
  def inspect; end

  # attr_reader keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:14410
  sig do
    returns(T.nilable(T.any(Prism::KeywordRestParameterNode, Prism::ForwardingParameterNode, Prism::NoKeywordsParameterNode)))
  end
  def keyword_rest; end

  # attr_reader keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:14407
  sig { returns(T::Array[T.any(Prism::RequiredKeywordParameterNode, Prism::OptionalKeywordParameterNode)]) }
  def keywords; end

  # attr_reader optionals: Array[OptionalParameterNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:14398
  sig { returns(T::Array[Prism::OptionalParameterNode]) }
  def optionals; end

  # attr_reader posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:14404
  sig do
    returns(T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode, Prism::KeywordRestParameterNode, Prism::NoKeywordsParameterNode, Prism::ForwardingParameterNode)])
  end
  def posts; end

  # attr_reader requireds: Array[RequiredParameterNode | MultiTargetNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:14395
  sig { returns(T::Array[T.any(Prism::RequiredParameterNode, Prism::MultiTargetNode)]) }
  def requireds; end

  # attr_reader rest: RestParameterNode | ImplicitRestNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:14401
  sig { returns(T.nilable(T.any(Prism::RestParameterNode, Prism::ImplicitRestNode))) }
  def rest; end

  # Mirrors the Method#parameters method.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:272
  sig { returns(T::Array[T.any([Symbol, Symbol], [Symbol])]) }
  def signature; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14421
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14426
    def type; end
  end
end

# Represents a parenthesized expression
#
#     (10 + 34)
#     ^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14452
class Prism::ParenthesesNode < ::Prism::Node
  # Initialize a new ParenthesesNode node.
  #
  # @return [ParenthesesNode] a new instance of ParenthesesNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14454
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, body, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14560
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14465
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:14505
  sig { returns(T.nilable(Prism::Node)) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14470
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14539
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14521
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14482
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14475
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location) -> ParenthesesNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14487
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T.nilable(Prism::Node),
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::ParenthesesNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14492
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, body: Prism::node?, opening_loc: Location, closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14495
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14544
  sig { override.returns(String) }
  def inspect; end

  # def multiple_statements?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:14500
  sig { returns(T::Boolean) }
  def multiple_statements?; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:86
  def newline_flag!(lines); end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14534
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14508
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14529
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14516
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14549
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14554
    def type; end
  end
end

# Flags for parentheses nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18759
module Prism::ParenthesesNodeFlags; end

# parentheses that contain multiple potentially void statements
#
# pkg:gem/prism#lib/prism/node.rb:18761
Prism::ParenthesesNodeFlags::MULTIPLE_STATEMENTS = T.let(T.unsafe(nil), Integer)

# This represents an error that was encountered during parsing.
#
# pkg:gem/prism#lib/prism/parse_result.rb:597
class Prism::ParseError
  # Create a new error object with the given message and location.
  #
  # @return [ParseError] a new instance of ParseError
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:612
  sig { params(type: Symbol, message: String, location: Prism::Location, level: Symbol).void }
  def initialize(type, message, location, level); end

  # Implement the hash pattern matching interface for ParseError.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:620
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Returns a string representation of this error.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:625
  sig { returns(String) }
  def inspect; end

  # The level of this error.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:609
  sig { returns(Symbol) }
  def level; end

  # A Location object representing the location of this error in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:606
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this error.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:603
  sig { returns(String) }
  def message; end

  # The type of error. This is an _internal_ symbol that is used for
  # communicating with translation layers. It is not meant to be public API.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:600
  sig { returns(Symbol) }
  def type; end
end

# This is a result specific to the `parse_lex` and `parse_lex_file` methods.
#
# pkg:gem/prism#lib/prism/parse_result.rb:786
class Prism::ParseLexResult < ::Prism::Result
  # Create a new parse lex result object with the given values.
  #
  # @return [ParseLexResult] a new instance of ParseLexResult
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:792
  sig do
    params(
      value: [Prism::ProgramNode, T::Array[T.untyped]],
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Implement the hash pattern matching interface for ParseLexResult.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:798
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # A tuple of the syntax tree and the list of tokens that were parsed from
  # the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:789
  sig { returns([Prism::ProgramNode, T::Array[T.untyped]]) }
  def value; end
end

# This is a result specific to the `parse` and `parse_file` methods.
#
# pkg:gem/prism#lib/prism/parse_result.rb:727
class Prism::ParseResult < ::Prism::Result
  # Create a new parse result object with the given values.
  #
  # @return [ParseResult] a new instance of ParseResult
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:740
  sig do
    params(
      value: Prism::ProgramNode,
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  # Attach the list of comments to their respective locations in the tree.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:751
  def attach_comments!; end

  # Implement the hash pattern matching interface for ParseResult.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:746
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Returns a string representation of the syntax tree with the errors
  # displayed inline.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:763
  def errors_format; end

  # Walk the tree and mark nodes that are on a new line, loosely emulating
  # the behavior of CRuby's `:line` tracepoint event.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:757
  def mark_newlines!; end

  # The syntax tree that was parsed from the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:737
  sig { returns(Prism::ProgramNode) }
  def value; end
end

# When we've parsed the source, we have both the syntax tree and the list of
# comments that we found in the source. This class is responsible for
# walking the tree and finding the nearest location to attach each comment.
#
# It does this by first finding the nearest locations to each comment.
# Locations can either come from nodes directly or from location fields on
# nodes. For example, a `ClassNode` has an overall location encompassing the
# entire class, but it also has a location for the `class` keyword.
#
# Once the nearest locations are found, it determines which one to attach
# to. If it's a trailing comment (a comment on the same line as other source
# code), it will favor attaching to the nearest location that occurs before
# the comment. Otherwise it will favor attaching to the nearest location
# that is after the comment.
#
# pkg:gem/prism#lib/prism/parse_result/comments.rb:20
class Prism::ParseResult::Comments
  # Create a new Comments object that will attach comments to the given
  # parse result.
  #
  # @return [Comments] a new instance of Comments
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:87
  def initialize(parse_result); end

  # Attach the comments to their respective locations in the tree by
  # mutating the parse result.
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:93
  def attach!; end

  # The parse result that we are attaching comments to.
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:83
  def parse_result; end

  private

  # Responsible for finding the nearest targets to the given comment within
  # the context of the given encapsulating node.
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:120
  def nearest_targets(node, comment); end
end

# A target for attaching comments that is based on a location field on a
# node. For example, the `end` token of a ClassNode.
#
# pkg:gem/prism#lib/prism/parse_result/comments.rb:54
class Prism::ParseResult::Comments::LocationTarget
  # @return [LocationTarget] a new instance of LocationTarget
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:57
  def initialize(location); end

  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:69
  def encloses?(comment); end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:65
  def end_offset; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:73
  def leading_comment(comment); end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:55
  def location; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:61
  def start_offset; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:77
  def trailing_comment(comment); end
end

# A target for attaching comments that is based on a specific node's
# location.
#
# pkg:gem/prism#lib/prism/parse_result/comments.rb:23
class Prism::ParseResult::Comments::NodeTarget
  # @return [NodeTarget] a new instance of NodeTarget
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:26
  def initialize(node); end

  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result/comments.rb:38
  def encloses?(comment); end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:34
  def end_offset; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:43
  def leading_comment(comment); end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:24
  def node; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:30
  def start_offset; end

  # pkg:gem/prism#lib/prism/parse_result/comments.rb:47
  def trailing_comment(comment); end
end

# An object to represent the set of errors on a parse result. This object
# can be used to format the errors in a human-readable way.
#
# pkg:gem/prism#lib/prism/parse_result/errors.rb:10
class Prism::ParseResult::Errors
  # Initialize a new set of errors from the given parse result.
  #
  # @return [Errors] a new instance of Errors
  #
  # pkg:gem/prism#lib/prism/parse_result/errors.rb:15
  def initialize(parse_result); end

  # Formats the errors in a human-readable way and return them as a string.
  #
  # pkg:gem/prism#lib/prism/parse_result/errors.rb:20
  def format; end

  # The parse result that contains the errors.
  #
  # pkg:gem/prism#lib/prism/parse_result/errors.rb:12
  def parse_result; end
end

# The :line tracepoint event gets fired whenever the Ruby VM encounters an
# expression on a new line. The types of expressions that can trigger this
# event are:
#
# * if statements
# * unless statements
# * nodes that are children of statements lists
#
# In order to keep track of the newlines, we have a list of offsets that
# come back from the parser. We assign these offsets to the first nodes that
# we find in the tree that are on those lines.
#
# Note that the logic in this file should be kept in sync with the Java
# MarkNewlinesVisitor, since that visitor is responsible for marking the
# newlines for JRuby/TruffleRuby.
#
# This file is autoloaded only when `mark_newlines!` is called, so the
# re-opening of the various nodes in this file will only be performed in
# that case. We do that to avoid storing the extra `@newline` instance
# variable on every node if we don't need it.
#
# pkg:gem/prism#lib/prism/parse_result/newlines.rb:26
class Prism::ParseResult::Newlines < ::Prism::Visitor
  # Create a new Newlines visitor with the given newline offsets.
  #
  # @return [Newlines] a new instance of Newlines
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:28
  def initialize(lines); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:34
  def visit_block_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:48
  def visit_if_node(node); end

  # Permit block/lambda nodes to mark newlines within themselves.
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:45
  def visit_lambda_node(node); end

  # Permit statements lists to mark newlines within themselves.
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:56
  def visit_statements_node(node); end

  # Mark if/unless nodes as newlines.
  #
  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:53
  def visit_unless_node(node); end
end

# This represents a warning that was encountered during parsing.
#
# pkg:gem/prism#lib/prism/parse_result.rb:631
class Prism::ParseWarning
  # Create a new warning object with the given message and location.
  #
  # @return [ParseWarning] a new instance of ParseWarning
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:646
  sig { params(type: Symbol, message: String, location: Prism::Location, level: Symbol).void }
  def initialize(type, message, location, level); end

  # Implement the hash pattern matching interface for ParseWarning.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:654
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Returns a string representation of this warning.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:659
  sig { returns(String) }
  def inspect; end

  # The level of this warning.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:643
  sig { returns(Symbol) }
  def level; end

  # A Location object representing the location of this warning in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:640
  sig { returns(Prism::Location) }
  def location; end

  # The message associated with this warning.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:637
  sig { returns(String) }
  def message; end

  # The type of warning. This is an _internal_ symbol that is used for
  # communicating with translation layers. It is not meant to be public API.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:634
  sig { returns(Symbol) }
  def type; end
end

# A pattern is an object that wraps a Ruby pattern matching expression. The
# expression would normally be passed to an `in` clause within a `case`
# expression or a rightward assignment expression. For example, in the
# following snippet:
#
#     case node
#     in ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]
#     end
#
# the pattern is the <tt>ConstantPathNode[...]</tt> expression.
#
# The pattern gets compiled into an object that responds to #call by running
# the #compile method. This method itself will run back through Prism to
# parse the expression into a tree, then walk the tree to generate the
# necessary callable objects. For example, if you wanted to compile the
# expression above into a callable, you would:
#
#     callable = Prism::Pattern.new("ConstantPathNode[ConstantReadNode[name: :Prism], ConstantReadNode[name: :Pattern]]").compile
#     callable.call(node)
#
# The callable object returned by #compile is guaranteed to respond to #call
# with a single argument, which is the node to match against. It also is
# guaranteed to respond to #===, which means it itself can be used in a `case`
# expression, as in:
#
#     case node
#     when callable
#     end
#
# If the query given to the initializer cannot be compiled into a valid
# matcher (either because of a syntax error or because it is using syntax we
# do not yet support) then a Prism::Pattern::CompilationError will be
# raised.
#
# pkg:gem/prism#lib/prism/pattern.rb:38
class Prism::Pattern
  # Create a new pattern with the given query. The query should be a string
  # containing a Ruby pattern matching expression.
  #
  # @return [Pattern] a new instance of Pattern
  #
  # pkg:gem/prism#lib/prism/pattern.rb:64
  def initialize(query); end

  # Compile the query into a callable object that can be used to match against
  # nodes.
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/pattern.rb:71
  def compile; end

  # The query that this pattern was initialized with.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:60
  def query; end

  # Scan the given node and all of its children for nodes that match the
  # pattern. If a block is given, it will be called with each node that
  # matches the pattern. If no block is given, an enumerator will be returned
  # that will yield each node that matches the pattern.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:87
  def scan(root); end

  private

  # Shortcut for combining two procs into one that returns true if both return
  # true.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:103
  def combine_and(left, right); end

  # Shortcut for combining two procs into one that returns true if either
  # returns true.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:109
  def combine_or(left, right); end

  # in foo | bar
  #
  # pkg:gem/prism#lib/prism/pattern.rb:144
  def compile_alternation_pattern_node(node); end

  # in [foo, bar, baz]
  #
  # pkg:gem/prism#lib/prism/pattern.rb:119
  def compile_array_pattern_node(node); end

  # Compile a name associated with a constant.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:169
  def compile_constant_name(node, name); end

  # in Prism::ConstantReadNode
  #
  # pkg:gem/prism#lib/prism/pattern.rb:149
  def compile_constant_path_node(node); end

  # in ConstantReadNode
  # in String
  #
  # pkg:gem/prism#lib/prism/pattern.rb:164
  def compile_constant_read_node(node); end

  # Raise an error because the given node is not supported.
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/pattern.rb:114
  def compile_error(node); end

  # in InstanceVariableReadNode[name: Symbol]
  # in { name: Symbol }
  #
  # pkg:gem/prism#lib/prism/pattern.rb:185
  def compile_hash_pattern_node(node); end

  # in nil
  #
  # pkg:gem/prism#lib/prism/pattern.rb:215
  def compile_nil_node(node); end

  # Compile any kind of node. Dispatch out to the individual compilation
  # methods based on the type of node.
  #
  # pkg:gem/prism#lib/prism/pattern.rb:244
  def compile_node(node); end

  # in /foo/
  #
  # pkg:gem/prism#lib/prism/pattern.rb:220
  def compile_regular_expression_node(node); end

  # in ""
  # in "foo"
  #
  # pkg:gem/prism#lib/prism/pattern.rb:228
  def compile_string_node(node); end

  # in :+
  # in :foo
  #
  # pkg:gem/prism#lib/prism/pattern.rb:236
  def compile_symbol_node(node); end
end

# Raised when the query given to a pattern is either invalid Ruby syntax or
# is using syntax that we don't yet support.
#
# pkg:gem/prism#lib/prism/pattern.rb:41
class Prism::Pattern::CompilationError < ::StandardError
  # Create a new CompilationError with the given representation of the node
  # that caused the error.
  #
  # @return [CompilationError] a new instance of CompilationError
  #
  # pkg:gem/prism#lib/prism/pattern.rb:44
  def initialize(repr); end
end

# Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
#
#     foo in ^(bar)
#            ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14573
class Prism::PinnedExpressionNode < ::Prism::Node
  # Initialize a new PinnedExpressionNode node.
  #
  # @return [PinnedExpressionNode] a new instance of PinnedExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14575
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, expression, operator_loc, lparen_loc, rparen_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14705
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14587
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14592
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14602
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14597
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?operator_loc: Location, ?lparen_loc: Location, ?rparen_loc: Location) -> PinnedExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14607
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      operator_loc: Prism::Location,
      lparen_loc: Prism::Location,
      rparen_loc: Prism::Location
    ).returns(Prism::PinnedExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14612
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14615
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The expression used in the pinned expression
  #
  #     foo in ^(bar)
  #              ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:14623
  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14689
  sig { override.returns(String) }
  def inspect; end

  # def lparen: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14679
  sig { returns(String) }
  def lparen; end

  # The location of the opening parenthesis.
  #
  #     foo in ^(bar)
  #             ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14645
  sig { returns(Prism::Location) }
  def lparen_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14674
  sig { returns(String) }
  def operator; end

  # The location of the `^` operator
  #
  #     foo in ^(bar)
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14629
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def rparen: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14684
  sig { returns(String) }
  def rparen; end

  # The location of the closing parenthesis.
  #
  #     foo in ^(bar)
  #                 ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14661
  sig { returns(Prism::Location) }
  def rparen_loc; end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14653
  def save_lparen_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14637
  def save_operator_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14669
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14694
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14699
    def type; end
  end
end

# Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
#
#     foo in ^bar
#            ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14718
class Prism::PinnedVariableNode < ::Prism::Node
  # Initialize a new PinnedVariableNode node.
  #
  # @return [PinnedVariableNode] a new instance of PinnedVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14720
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, variable, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14806
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14730
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14735
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14745
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14740
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode, ?operator_loc: Location) -> PinnedVariableNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14750
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      variable: T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode),
      operator_loc: Prism::Location
    ).returns(Prism::PinnedVariableNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14755
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14758
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14790
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14785
  sig { returns(String) }
  def operator; end

  # The location of the `^` operator
  #
  #     foo in ^bar
  #            ^
  #
  # pkg:gem/prism#lib/prism/node.rb:14772
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14780
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14795
  sig { override.returns(Symbol) }
  def type; end

  # The variable used in the pinned expression
  #
  #     foo in ^bar
  #             ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:14766
  sig do
    returns(T.any(Prism::LocalVariableReadNode, Prism::InstanceVariableReadNode, Prism::ClassVariableReadNode, Prism::GlobalVariableReadNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::ItLocalVariableReadNode, Prism::MissingNode))
  end
  def variable; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14800
    def type; end
  end
end

# Represents the use of the `END` keyword.
#
#     END { foo }
#     ^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14817
class Prism::PostExecutionNode < ::Prism::Node
  # Initialize a new PostExecutionNode node.
  #
  # @return [PostExecutionNode] a new instance of PostExecutionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14819
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:14939
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14831
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14836
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14918
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14895
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14848
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14841
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PostExecutionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14853
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PostExecutionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14858
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14861
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14923
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14908
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14869
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:14913
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:14882
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14903
  def save_closing_loc(repository); end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14877
  def save_keyword_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:14890
  def save_opening_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:14866
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:14928
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:14933
    def type; end
  end
end

# Represents the use of the `BEGIN` keyword.
#
#     BEGIN { foo }
#     ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:14952
class Prism::PreExecutionNode < ::Prism::Node
  # Initialize a new PreExecutionNode node.
  #
  # @return [PreExecutionNode] a new instance of PreExecutionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14954
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15074
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:14966
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14971
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15053
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15030
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:14983
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:14976
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PreExecutionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:14988
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      statements: T.nilable(Prism::StatementsNode),
      keyword_loc: Prism::Location,
      opening_loc: Prism::Location,
      closing_loc: Prism::Location
    ).returns(Prism::PreExecutionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:14993
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:14996
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15058
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15043
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15004
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15048
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15017
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15038
  def save_closing_loc(repository); end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15012
  def save_keyword_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15025
  def save_opening_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:15001
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15063
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15068
    def type; end
  end
end

# The top level node of any parse tree.
#
# pkg:gem/prism#lib/prism/node.rb:15084
class Prism::ProgramNode < ::Prism::Node
  # Initialize a new ProgramNode node.
  #
  # @return [ProgramNode] a new instance of ProgramNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15086
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).void
  end
  def initialize(source, node_id, location, flags, locals, statements); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15151
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15096
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15101
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15111
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15106
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?statements: StatementsNode) -> ProgramNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15116
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      statements: Prism::StatementsNode
    ).returns(Prism::ProgramNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15121
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], statements: StatementsNode }
  #
  # pkg:gem/prism#lib/prism/node.rb:15124
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15135
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:15129
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # attr_reader statements: StatementsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15132
  sig { returns(Prism::StatementsNode) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15140
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15145
    def type; end
  end
end

# Flags for range and flip-flop nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18765
module Prism::RangeFlags; end

# ... operator
#
# pkg:gem/prism#lib/prism/node.rb:18767
Prism::RangeFlags::EXCLUDE_END = T.let(T.unsafe(nil), Integer)

# Represents the use of the `..` or `...` operators.
#
#     1..2
#     ^^^^
#
#     c if a =~ /left/ ... b =~ /right/
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:15166
class Prism::RangeNode < ::Prism::Node
  # Initialize a new RangeNode node.
  #
  # @return [RangeNode] a new instance of RangeNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15168
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15273
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15179
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15184
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15197
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15189
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> RangeNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15202
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      left: T.nilable(Prism::Node),
      right: T.nilable(Prism::Node),
      operator_loc: Prism::Location
    ).returns(Prism::RangeNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15207
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node?, right: Prism::node?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:15210
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def exclude_end?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15215
  sig { returns(T::Boolean) }
  def exclude_end?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15257
  sig { override.returns(String) }
  def inspect; end

  # The left-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     1...
  #     ^
  #
  #     hello...goodbye
  #     ^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:15226
  sig { returns(T.nilable(Prism::Node)) }
  def left; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15252
  sig { returns(String) }
  def operator; end

  # The location of the `..` or `...` operator.
  #
  # pkg:gem/prism#lib/prism/node.rb:15239
  sig { returns(Prism::Location) }
  def operator_loc; end

  # The right-hand side of the range, if present. It can be either `nil` or any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     ..5
  #       ^
  #
  #     1...foo
  #         ^^^
  # If neither right-hand or left-hand side was included, this will be a MissingNode.
  #
  # pkg:gem/prism#lib/prism/node.rb:15236
  sig { returns(T.nilable(Prism::Node)) }
  def right; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15247
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15262
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15267
    def type; end
  end
end

# Represents a rational number literal.
#
#     1.0r
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:15286
class Prism::RationalNode < ::Prism::Node
  # Initialize a new RationalNode node.
  #
  # @return [RationalNode] a new instance of RationalNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15288
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).void
  end
  def initialize(source, node_id, location, flags, numerator, denominator); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15377
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15298
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def binary?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15331
  sig { returns(T::Boolean) }
  def binary?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15303
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15313
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15308
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numerator: Integer, ?denominator: Integer) -> RationalNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15318
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      numerator: Integer,
      denominator: Integer
    ).returns(Prism::RationalNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  # def decimal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15336
  sig { returns(T::Boolean) }
  def decimal?; end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15323
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, numerator: Integer, denominator: Integer }
  #
  # pkg:gem/prism#lib/prism/node.rb:15326
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The denominator of the rational number.
  #
  #     1.5r # denominator 2
  #
  # pkg:gem/prism#lib/prism/node.rb:15358
  sig { returns(Integer) }
  def denominator; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def hexadecimal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15346
  sig { returns(T::Boolean) }
  def hexadecimal?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15361
  sig { override.returns(String) }
  def inspect; end

  # The numerator of the rational number.
  #
  #     1.5r # numerator 3
  #
  # pkg:gem/prism#lib/prism/node.rb:15353
  sig { returns(Integer) }
  def numerator; end

  # Returns the value of the node as an IntegerNode or a FloatNode. This
  # method is deprecated in favor of #value or #numerator/#denominator.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:123
  def numeric; end

  # def octal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15341
  sig { returns(T::Boolean) }
  def octal?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15366
  sig { override.returns(Symbol) }
  def type; end

  # Returns the value of the node as a Ruby Rational.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:117
  sig { returns(Rational) }
  def value; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15371
    def type; end
  end
end

# Represents the use of the `redo` keyword.
#
#     redo
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:15389
class Prism::RedoNode < ::Prism::Node
  # Initialize a new RedoNode node.
  #
  # @return [RedoNode] a new instance of RedoNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15391
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15448
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15399
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15404
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15414
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15409
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RedoNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15419
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::RedoNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15424
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:15427
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15432
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15437
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15442
    def type; end
  end
end

# The Reflection module provides the ability to reflect on the structure of
# the syntax tree itself, as opposed to looking at a single syntax tree. This
# is useful in metaprogramming contexts.
#
# pkg:gem/prism#lib/prism/reflection.rb:16
module Prism::Reflection
  class << self
    # Returns the fields for the given node.
    #
    # pkg:gem/prism#lib/prism/reflection.rb:107
    sig { params(node: T.class_of(Prism::Node)).returns(T::Array[Prism::Reflection::Field]) }
    def fields_for(node); end
  end
end

# A constant field represents a constant value on a node. Effectively, it
# represents an identifier found within the source. It resolves to a symbol
# in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:48
class Prism::Reflection::ConstantField < ::Prism::Reflection::Field; end

# A constant list field represents a list of constant values on a node. It
# resolves to an array of symbols in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:58
class Prism::Reflection::ConstantListField < ::Prism::Reflection::Field; end

# A field represents a single piece of data on a node. It is the base class
# for all other field types.
#
# pkg:gem/prism#lib/prism/reflection.rb:19
class Prism::Reflection::Field
  # Initializes the field with the given name.
  #
  # @return [Field] a new instance of Field
  #
  # pkg:gem/prism#lib/prism/reflection.rb:24
  sig { params(name: Symbol).void }
  def initialize(name); end

  # The name of the field.
  #
  # pkg:gem/prism#lib/prism/reflection.rb:21
  sig { returns(Symbol) }
  def name; end
end

# A flags field represents a bitset of flags on a node. It resolves to an
# integer in Ruby. Note that the flags cannot be accessed directly on the
# node because the integer is kept private. Instead, the various flags in
# the bitset should be accessed through their query methods.
#
# pkg:gem/prism#lib/prism/reflection.rb:95
class Prism::Reflection::FlagsField < ::Prism::Reflection::Field
  # Initializes the flags field with the given name and flags.
  #
  # @return [FlagsField] a new instance of FlagsField
  #
  # pkg:gem/prism#lib/prism/reflection.rb:100
  sig { params(name: Symbol, flags: T::Array[Symbol]).void }
  def initialize(name, flags); end

  # The names of the flags in the bitset.
  #
  # pkg:gem/prism#lib/prism/reflection.rb:97
  sig { returns(T::Array[Symbol]) }
  def flags; end
end

# A float field represents a double-precision floating point value. It is
# used exclusively to represent the value of a floating point literal. It
# resolves to a Float in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:88
class Prism::Reflection::FloatField < ::Prism::Reflection::Field; end

# An integer field represents an integer value. It is used to represent the
# value of an integer literal, the depth of local variables, and the number
# of a numbered reference. It resolves to an Integer in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:82
class Prism::Reflection::IntegerField < ::Prism::Reflection::Field; end

# A location field represents the location of some part of the node in the
# source code. For example, the location of a keyword or an operator. It
# resolves to a Prism::Location in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:70
class Prism::Reflection::LocationField < ::Prism::Reflection::Field; end

# A node field represents a single child node in the syntax tree. It
# resolves to a Prism::Node in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:31
class Prism::Reflection::NodeField < ::Prism::Reflection::Field; end

# A node list field represents a list of child nodes in the syntax tree. It
# resolves to an array of Prism::Node instances in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:42
class Prism::Reflection::NodeListField < ::Prism::Reflection::Field; end

# An optional constant field represents a constant value on a node that may
# or may not be present. It resolves to either a symbol or nil in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:53
class Prism::Reflection::OptionalConstantField < ::Prism::Reflection::Field; end

# An optional location field represents the location of some part of the
# node in the source code that may or may not be present. It resolves to
# either a Prism::Location or nil in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:76
class Prism::Reflection::OptionalLocationField < ::Prism::Reflection::Field; end

# An optional node field represents a single child node in the syntax tree
# that may or may not be present. It resolves to either a Prism::Node or nil
# in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:37
class Prism::Reflection::OptionalNodeField < ::Prism::Reflection::Field; end

# A string field represents a string value on a node. It almost always
# represents the unescaped value of a string-like literal. It resolves to a
# string in Ruby.
#
# pkg:gem/prism#lib/prism/reflection.rb:64
class Prism::Reflection::StringField < ::Prism::Reflection::Field; end

# Flags for regular expression and match last line nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18771
module Prism::RegularExpressionFlags; end

# n - forces the ASCII-8BIT encoding
#
# pkg:gem/prism#lib/prism/node.rb:18788
Prism::RegularExpressionFlags::ASCII_8BIT = T.let(T.unsafe(nil), Integer)

# e - forces the EUC-JP encoding
#
# pkg:gem/prism#lib/prism/node.rb:18785
Prism::RegularExpressionFlags::EUC_JP = T.let(T.unsafe(nil), Integer)

# x - ignores whitespace and allows comments in regular expressions
#
# pkg:gem/prism#lib/prism/node.rb:18776
Prism::RegularExpressionFlags::EXTENDED = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to binary
#
# pkg:gem/prism#lib/prism/node.rb:18800
Prism::RegularExpressionFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# pkg:gem/prism#lib/prism/node.rb:18803
Prism::RegularExpressionFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# pkg:gem/prism#lib/prism/node.rb:18797
Prism::RegularExpressionFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# i - ignores the case of characters when matching
#
# pkg:gem/prism#lib/prism/node.rb:18773
Prism::RegularExpressionFlags::IGNORE_CASE = T.let(T.unsafe(nil), Integer)

# m - allows $ to match the end of lines within strings
#
# pkg:gem/prism#lib/prism/node.rb:18779
Prism::RegularExpressionFlags::MULTI_LINE = T.let(T.unsafe(nil), Integer)

# o - only interpolates values into the regular expression once
#
# pkg:gem/prism#lib/prism/node.rb:18782
Prism::RegularExpressionFlags::ONCE = T.let(T.unsafe(nil), Integer)

# u - forces the UTF-8 encoding
#
# pkg:gem/prism#lib/prism/node.rb:18794
Prism::RegularExpressionFlags::UTF_8 = T.let(T.unsafe(nil), Integer)

# s - forces the Windows-31J encoding
#
# pkg:gem/prism#lib/prism/node.rb:18791
Prism::RegularExpressionFlags::WINDOWS_31J = T.let(T.unsafe(nil), Integer)

# Represents a regular expression literal with no interpolation.
#
#     /foo/i
#     ^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:15457
class Prism::RegularExpressionNode < ::Prism::Node
  include ::Prism::RegularExpressionOptions

  # Initialize a new RegularExpressionNode node.
  #
  # @return [RegularExpressionNode] a new instance of RegularExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15459
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15632
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15471
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def ascii_8bit?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15529
  sig { returns(T::Boolean) }
  def ascii_8bit?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15476
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15611
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15585
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15486
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15481
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def content: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15606
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15572
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> RegularExpressionNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15491
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::RegularExpressionNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15496
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:15499
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def euc_jp?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15524
  sig { returns(T::Boolean) }
  def euc_jp?; end

  # def extended?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15509
  sig { returns(T::Boolean) }
  def extended?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15549
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15554
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15544
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def ignore_case?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15504
  sig { returns(T::Boolean) }
  def ignore_case?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15616
  sig { override.returns(String) }
  def inspect; end

  # def multi_line?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15514
  sig { returns(T::Boolean) }
  def multi_line?; end

  # def once?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15519
  sig { returns(T::Boolean) }
  def once?; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15601
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15559
  sig { returns(Prism::Location) }
  def opening_loc; end

  sig { returns(Integer) }
  def options; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15593
  def save_closing_loc(repository); end

  # Save the content_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15580
  def save_content_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15567
  def save_opening_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15621
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader unescaped: String
  #
  # pkg:gem/prism#lib/prism/node.rb:15598
  sig { returns(String) }
  def unescaped; end

  # def utf_8?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15539
  sig { returns(T::Boolean) }
  def utf_8?; end

  # def windows_31j?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15534
  sig { returns(T::Boolean) }
  def windows_31j?; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15626
    def type; end
  end
end

# pkg:gem/prism#lib/prism/node_ext.rb:23
module Prism::RegularExpressionOptions
  # Returns a numeric value that represents the flags that were used to create
  # the regular expression.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:26
  def options; end
end

# Prism parses deterministically for the same input. This provides a nice
# property that is exposed through the #node_id API on nodes. Effectively this
# means that for the same input, these values will remain consistent every
# time the source is parsed. This means we can reparse the source same with a
# #node_id value and find the exact same node again.
#
# The Relocation module provides an API around this property. It allows you to
# "save" nodes and locations using a minimal amount of memory (just the
# node_id and a field identifier) and then reify them later.
#
# pkg:gem/prism#lib/prism/relocation.rb:14
module Prism::Relocation
  class << self
    # Create a new repository for the given filepath.
    #
    # pkg:gem/prism#lib/prism/relocation.rb:496
    def filepath(value); end

    # Create a new repository for the given string.
    #
    # pkg:gem/prism#lib/prism/relocation.rb:501
    def string(value); end
  end
end

# A field representing the start and end character columns.
#
# pkg:gem/prism#lib/prism/relocation.rb:270
class Prism::Relocation::CharacterColumnsField
  # Fetches the start and end character column of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:272
  def fields(value); end
end

# A field representing the start and end character offsets.
#
# pkg:gem/prism#lib/prism/relocation.rb:218
class Prism::Relocation::CharacterOffsetsField
  # Fetches the start and end character offset of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:220
  def fields(value); end
end

# A field representing the start and end code unit columns for a specific
# encoding.
#
# pkg:gem/prism#lib/prism/relocation.rb:282
class Prism::Relocation::CodeUnitColumnsField
  # Initialize a new field with the associated repository and encoding.
  #
  # @return [CodeUnitColumnsField] a new instance of CodeUnitColumnsField
  #
  # pkg:gem/prism#lib/prism/relocation.rb:291
  def initialize(repository, encoding); end

  # The associated encoding for the code units.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:288
  def encoding; end

  # Fetches the start and end code units column of a value for a particular
  # encoding.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:299
  def fields(value); end

  # The repository object that is used for lazily creating a code units
  # cache.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:285
  def repository; end

  private

  # Lazily create a code units cache for the associated encoding.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:309
  def cache; end
end

# A field representing the start and end code unit offsets.
#
# pkg:gem/prism#lib/prism/relocation.rb:229
class Prism::Relocation::CodeUnitOffsetsField
  # Initialize a new field with the associated repository and encoding.
  #
  # @return [CodeUnitOffsetsField] a new instance of CodeUnitOffsetsField
  #
  # pkg:gem/prism#lib/prism/relocation.rb:238
  def initialize(repository, encoding); end

  # The associated encoding for the code units.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:235
  def encoding; end

  # Fetches the start and end code units offset of a value for a particular
  # encoding.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:246
  def fields(value); end

  # A pointer to the repository object that is used for lazily creating a
  # code units cache.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:232
  def repository; end

  private

  # Lazily create a code units cache for the associated encoding.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:256
  def cache; end
end

# A field representing the start and end byte columns.
#
# pkg:gem/prism#lib/prism/relocation.rb:262
class Prism::Relocation::ColumnsField
  # Fetches the start and end byte column of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:264
  def fields(value); end
end

# An abstract field used as the parent class of the two comments fields.
#
# pkg:gem/prism#lib/prism/relocation.rb:315
class Prism::Relocation::CommentsField
  private

  # Create comment objects from the given values.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:330
  def comments(values); end
end

# An object that represents a slice of a comment.
#
# pkg:gem/prism#lib/prism/relocation.rb:317
class Prism::Relocation::CommentsField::Comment
  # Initialize a new comment with the given slice.
  #
  # @return [Comment] a new instance of Comment
  #
  # pkg:gem/prism#lib/prism/relocation.rb:322
  def initialize(slice); end

  # The slice of the comment.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:319
  def slice; end
end

# An entry in a repository that will lazily reify its values when they are
# first accessed.
#
# pkg:gem/prism#lib/prism/relocation.rb:17
class Prism::Relocation::Entry
  # Initialize a new entry with the given repository.
  #
  # @return [Entry] a new instance of Entry
  #
  # pkg:gem/prism#lib/prism/relocation.rb:25
  def initialize(repository); end

  # Fetch the leading and trailing comments of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:120
  def comments; end

  # Fetch the end character column of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:93
  def end_character_column; end

  # Fetch the end character offset of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:61
  def end_character_offset; end

  # Fetch the end code units column of the value, for the encoding that was
  # configured on the repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:105
  def end_code_units_column; end

  # Fetch the end code units offset of the value, for the encoding that was
  # configured on the repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:73
  def end_code_units_offset; end

  # Fetch the end byte column of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:83
  def end_column; end

  # Fetch the end line of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:41
  def end_line; end

  # Fetch the end byte offset of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:51
  def end_offset; end

  # Fetch the filepath of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:31
  def filepath; end

  # Fetch the leading comments of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:110
  def leading_comments; end

  # Reify the values on this entry with the given values. This is an
  # internal-only API that is called from the repository when it is time to
  # reify the values.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:127
  def reify!(values); end

  # Fetch the start character column of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:88
  def start_character_column; end

  # Fetch the start character offset of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:56
  def start_character_offset; end

  # Fetch the start code units column of the value, for the encoding that
  # was configured on the repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:99
  def start_code_units_column; end

  # Fetch the start code units offset of the value, for the encoding that
  # was configured on the repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:67
  def start_code_units_offset; end

  # Fetch the start byte column of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:78
  def start_column; end

  # Fetch the start line of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:36
  def start_line; end

  # Fetch the start byte offset of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:46
  def start_offset; end

  # Fetch the trailing comments of the value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:115
  def trailing_comments; end

  private

  # Fetch a value from the entry, raising an error if it is missing.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:135
  def fetch_value(name); end

  # Return the values from the repository, reifying them if necessary.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:143
  def values; end
end

# Raised if a value that could potentially be on an entry is missing
# because it was either not configured on the repository or it has not yet
# been fetched.
#
# pkg:gem/prism#lib/prism/relocation.rb:21
class Prism::Relocation::Entry::MissingValueError < ::StandardError; end

# A field that represents the file path.
#
# pkg:gem/prism#lib/prism/relocation.rb:186
class Prism::Relocation::FilepathField
  # Initialize a new field with the given file path.
  #
  # @return [FilepathField] a new instance of FilepathField
  #
  # pkg:gem/prism#lib/prism/relocation.rb:191
  def initialize(value); end

  # Fetch the file path.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:196
  def fields(_value); end

  # The file path that this field represents.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:188
  def value; end
end

# A field representing the leading comments.
#
# pkg:gem/prism#lib/prism/relocation.rb:336
class Prism::Relocation::LeadingCommentsField < ::Prism::Relocation::CommentsField
  # Fetches the leading comments of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:338
  def fields(value); end
end

# A field representing the start and end lines.
#
# pkg:gem/prism#lib/prism/relocation.rb:202
class Prism::Relocation::LinesField
  # Fetches the start and end line of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:204
  def fields(value); end
end

# A field representing the start and end byte offsets.
#
# pkg:gem/prism#lib/prism/relocation.rb:210
class Prism::Relocation::OffsetsField
  # Fetches the start and end byte offset of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:212
  def fields(value); end
end

# A repository is a configured collection of fields and a set of entries
# that knows how to reparse a source and reify the values.
#
# pkg:gem/prism#lib/prism/relocation.rb:353
class Prism::Relocation::Repository
  # Initialize a new repository with the given source.
  #
  # @return [Repository] a new instance of Repository
  #
  # pkg:gem/prism#lib/prism/relocation.rb:370
  def initialize(source); end

  # Configure the character columns field for this repository and return
  # self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:416
  def character_columns; end

  # Configure the character offsets field for this repository and return
  # self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:399
  def character_offsets; end

  # Configure the code unit columns field for this repository for a specific
  # encoding and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:422
  def code_unit_columns(encoding); end

  # Configure the code unit offsets field for this repository for a specific
  # encoding and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:405
  def code_unit_offsets(encoding); end

  # Create a code units cache for the given encoding from the source.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:377
  def code_units_cache(encoding); end

  # Configure the columns field for this repository and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:410
  def columns; end

  # Configure both the leading and trailing comment fields for this
  # repository and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:440
  def comments; end

  # This method is called from nodes and locations when they want to enter
  # themselves into the repository. It it internal-only and meant to be
  # called from the #save* APIs.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:447
  def enter(node_id, field_name); end

  # The entries that have been saved on this repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:367
  def entries; end

  # The fields that have been configured on this repository.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:364
  def fields; end

  # Configure the filepath field for this repository and return self.
  #
  # @raise [ConfigurationError]
  #
  # pkg:gem/prism#lib/prism/relocation.rb:382
  def filepath; end

  # Configure the leading comments field for this repository and return
  # self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:428
  def leading_comments; end

  # Configure the lines field for this repository and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:388
  def lines; end

  # Configure the offsets field for this repository and return self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:393
  def offsets; end

  # This method is called from the entries in the repository when they need
  # to reify their values. It is internal-only and meant to be called from
  # the various value APIs.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:456
  def reify!; end

  # The source associated with this repository. This will be either a
  # SourceFilepath (the most common use case) or a SourceString.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:361
  def source; end

  # Configure the trailing comments field for this repository and return
  # self.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:434
  def trailing_comments; end

  private

  # Append the given field to the repository and return the repository so
  # that these calls can be chained.
  #
  # @raise [ConfigurationError]
  #
  # pkg:gem/prism#lib/prism/relocation.rb:488
  def field(name, value); end
end

# Raised when multiple fields of the same type are configured on the same
# repository.
#
# pkg:gem/prism#lib/prism/relocation.rb:356
class Prism::Relocation::Repository::ConfigurationError < ::StandardError; end

# Represents the source of a repository that will be reparsed.
#
# pkg:gem/prism#lib/prism/relocation.rb:149
class Prism::Relocation::Source
  # Initialize the source with the given value.
  #
  # @return [Source] a new instance of Source
  #
  # pkg:gem/prism#lib/prism/relocation.rb:154
  def initialize(value); end

  # Create a code units cache for the given encoding.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:164
  def code_units_cache(encoding); end

  # Reparse the value and return the parse result.
  #
  # @raise [NotImplementedError]
  #
  # pkg:gem/prism#lib/prism/relocation.rb:159
  def result; end

  # The value that will need to be reparsed.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:151
  def value; end
end

# A source that is represented by a file path.
#
# pkg:gem/prism#lib/prism/relocation.rb:170
class Prism::Relocation::SourceFilepath < ::Prism::Relocation::Source
  # Reparse the file and return the parse result.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:172
  def result; end
end

# A source that is represented by a string.
#
# pkg:gem/prism#lib/prism/relocation.rb:178
class Prism::Relocation::SourceString < ::Prism::Relocation::Source
  # Reparse the string and return the parse result.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:180
  def result; end
end

# A field representing the trailing comments.
#
# pkg:gem/prism#lib/prism/relocation.rb:344
class Prism::Relocation::TrailingCommentsField < ::Prism::Relocation::CommentsField
  # Fetches the trailing comments of a value.
  #
  # pkg:gem/prism#lib/prism/relocation.rb:346
  def fields(value); end
end

# Represents a required keyword parameter to a method, block, or lambda definition.
#
#     def a(b: )
#           ^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:15647
class Prism::RequiredKeywordParameterNode < ::Prism::Node
  # Initialize a new RequiredKeywordParameterNode node.
  #
  # @return [RequiredKeywordParameterNode] a new instance of RequiredKeywordParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15649
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15729
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15659
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15664
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15674
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15669
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location) -> RequiredKeywordParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15679
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol,
      name_loc: Prism::Location
    ).returns(Prism::RequiredKeywordParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15684
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:15687
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15713
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:15697
  sig { returns(Symbol) }
  def name; end

  # attr_reader name_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15700
  sig { returns(Prism::Location) }
  def name_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15692
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15708
  def save_name_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15718
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15723
    def type; end
  end
end

# Represents a required parameter to a method, block, or lambda definition.
#
#     def a(b)
#           ^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:15742
class Prism::RequiredParameterNode < ::Prism::Node
  # Initialize a new RequiredParameterNode node.
  #
  # @return [RequiredParameterNode] a new instance of RequiredParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15744
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer, name: Symbol).void }
  def initialize(source, node_id, location, flags, name); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15810
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15753
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15758
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15768
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15763
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> RequiredParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15773
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: Symbol
    ).returns(Prism::RequiredParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15778
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
  #
  # pkg:gem/prism#lib/prism/node.rb:15781
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15794
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol
  #
  # pkg:gem/prism#lib/prism/node.rb:15791
  sig { returns(Symbol) }
  def name; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:15786
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15799
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15804
    def type; end
  end
end

# Represents an expression modified with a rescue.
#
#     foo rescue nil
#     ^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:15821
class Prism::RescueModifierNode < ::Prism::Node
  # Initialize a new RescueModifierNode node.
  #
  # @return [RescueModifierNode] a new instance of RescueModifierNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15823
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).void
  end
  def initialize(source, node_id, location, flags, expression, keyword_loc, rescue_expression); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:15907
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15834
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15839
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15849
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15844
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?keyword_loc: Location, ?rescue_expression: Prism::node) -> RescueModifierNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15854
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      expression: Prism::Node,
      keyword_loc: Prism::Location,
      rescue_expression: Prism::Node
    ).returns(Prism::RescueModifierNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15859
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node, keyword_loc: Location, rescue_expression: Prism::node }
  #
  # pkg:gem/prism#lib/prism/node.rb:15862
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:15867
  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15891
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:15886
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15870
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:116
  def newline_flag!(lines); end

  # attr_reader rescue_expression: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:15883
  sig { returns(Prism::Node) }
  def rescue_expression; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15878
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:15896
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:15901
    def type; end
  end
end

# Represents a rescue statement.
#
#     begin
#     rescue Foo, *splat, Bar => ex
#       foo
#     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#     end
#
# `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.
#
# pkg:gem/prism#lib/prism/node.rb:15924
class Prism::RescueNode < ::Prism::Node
  # Initialize a new RescueNode node.
  #
  # @return [RescueNode] a new instance of RescueNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15926
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, exceptions, operator_loc, reference, then_keyword_loc, statements, subsequent); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16073
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:15941
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15946
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:15961
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15951
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Returns the subsequent rescue clause of the rescue node. This method is
  # deprecated in favor of #subsequent.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:497
  def consequent; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?exceptions: Array[Prism::node], ?operator_loc: Location?, ?reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: RescueNode?) -> RescueNode
  #
  # pkg:gem/prism#lib/prism/node.rb:15966
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      exceptions: T::Array[Prism::Node],
      operator_loc: T.nilable(Prism::Location),
      reference: T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)),
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      subsequent: T.nilable(Prism::RescueNode)
    ).returns(Prism::RescueNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:15971
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, exceptions: Array[Prism::node], operator_loc: Location?, reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil, then_keyword_loc: Location?, statements: StatementsNode?, subsequent: RescueNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:15974
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader exceptions: Array[Prism::node]
  #
  # pkg:gem/prism#lib/prism/node.rb:15992
  sig { returns(T::Array[Prism::Node]) }
  def exceptions; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16057
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16042
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:15979
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def operator: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:16047
  sig { returns(T.nilable(String)) }
  def operator; end

  # attr_reader operator_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:15995
  sig { returns(T.nilable(Prism::Location)) }
  def operator_loc; end

  # attr_reader reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:16014
  sig do
    returns(T.nilable(T.any(Prism::LocalVariableTargetNode, Prism::InstanceVariableTargetNode, Prism::ClassVariableTargetNode, Prism::GlobalVariableTargetNode, Prism::ConstantTargetNode, Prism::ConstantPathTargetNode, Prism::CallTargetNode, Prism::IndexTargetNode, Prism::BackReferenceReadNode, Prism::NumberedReferenceReadNode, Prism::MissingNode)))
  end
  def reference; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:15987
  def save_keyword_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16009
  def save_operator_loc(repository); end

  # Save the then_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16031
  def save_then_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:16036
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # attr_reader subsequent: RescueNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:16039
  sig { returns(T.nilable(Prism::RescueNode)) }
  def subsequent; end

  # def then_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:16052
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:16017
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16062
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16067
    def type; end
  end
end

# Represents a rest parameter to a method, block, or lambda definition.
#
#     def a(*b)
#           ^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:16091
class Prism::RestParameterNode < ::Prism::Node
  # Initialize a new RestParameterNode node.
  #
  # @return [RestParameterNode] a new instance of RestParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16093
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16198
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16104
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16109
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16119
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16114
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> RestParameterNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16124
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      name: T.nilable(Symbol),
      name_loc: T.nilable(Prism::Location),
      operator_loc: Prism::Location
    ).returns(Prism::RestParameterNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16129
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16132
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16182
  sig { override.returns(String) }
  def inspect; end

  # attr_reader name: Symbol?
  #
  # pkg:gem/prism#lib/prism/node.rb:16142
  sig { returns(T.nilable(Symbol)) }
  def name; end

  # attr_reader name_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:16145
  sig { returns(T.nilable(Prism::Location)) }
  def name_loc; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16177
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16164
  sig { returns(Prism::Location) }
  def operator_loc; end

  # def repeated_parameter?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16137
  sig { returns(T::Boolean) }
  def repeated_parameter?; end

  # Save the name_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16159
  def save_name_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16172
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16187
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16192
    def type; end
  end
end

# This represents the result of a call to ::parse or ::parse_file. It contains
# the requested structure, any comments that were encounters, and any errors
# that were encountered.
#
# pkg:gem/prism#lib/prism/parse_result.rb:667
class Prism::Result
  # Create a new result object with the given values.
  #
  # @return [Result] a new instance of Result
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:689
  sig do
    params(
      comments: T::Array[Prism::Comment],
      magic_comments: T::Array[Prism::MagicComment],
      data_loc: T.nilable(Prism::Location),
      errors: T::Array[Prism::ParseError],
      warnings: T::Array[Prism::ParseWarning],
      source: Prism::Source
    ).void
  end
  def initialize(comments, magic_comments, data_loc, errors, warnings, source); end

  # Create a code units cache for the given encoding.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:721
  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  # The list of comments that were encountered during parsing.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:669
  sig { returns(T::Array[Prism::Comment]) }
  def comments; end

  # An optional location that represents the location of the __END__ marker
  # and the rest of the content of the file. This content is loaded into the
  # DATA constant when the file being parsed is the main file being executed.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:677
  sig { returns(T.nilable(Prism::Location)) }
  def data_loc; end

  # Implement the hash pattern matching interface for Result.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:699
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Returns the encoding of the source code that was parsed.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:704
  sig { returns(Encoding) }
  def encoding; end

  # The list of errors that were generated during parsing.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:680
  sig { returns(T::Array[Prism::ParseError]) }
  def errors; end

  # Returns true if there were errors during parsing and false if there were
  # not.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:716
  sig { returns(T::Boolean) }
  def failure?; end

  # The list of magic comments that were encountered during parsing.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:672
  sig { returns(T::Array[Prism::MagicComment]) }
  def magic_comments; end

  # A Source instance that represents the source code that was parsed.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:686
  sig { returns(Prism::Source) }
  def source; end

  # Returns true if there were no errors during parsing and false if there
  # were.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:710
  sig { returns(T::Boolean) }
  def success?; end

  # The list of warnings that were generated during parsing.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:683
  sig { returns(T::Array[Prism::ParseWarning]) }
  def warnings; end
end

# Represents the use of the `retry` keyword.
#
#     retry
#     ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16211
class Prism::RetryNode < ::Prism::Node
  # Initialize a new RetryNode node.
  #
  # @return [RetryNode] a new instance of RetryNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16213
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16270
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16221
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16226
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16236
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16231
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RetryNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16241
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::RetryNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16246
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16249
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16254
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16259
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16264
    def type; end
  end
end

# Represents the use of the `return` keyword.
#
#     return 1
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16279
class Prism::ReturnNode < ::Prism::Node
  # Initialize a new ReturnNode node.
  #
  # @return [ReturnNode] a new instance of ReturnNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16281
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, arguments); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16363
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16291
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:16339
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16296
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16308
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16301
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?arguments: ArgumentsNode?) -> ReturnNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16313
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      arguments: T.nilable(Prism::ArgumentsNode)
    ).returns(Prism::ReturnNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16318
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, arguments: ArgumentsNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:16321
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16347
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16342
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16326
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16334
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16352
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16357
    def type; end
  end
end

# This object is passed to the various Prism.* methods that accept the
# `scopes` option as an element of the list. It defines both the local
# variables visible at that scope as well as the forwarding parameters
# available at that scope.
#
# pkg:gem/prism#lib/prism/parse_result.rb:875
class Prism::Scope
  # Create a new scope object with the given locals and forwarding.
  #
  # @return [Scope] a new instance of Scope
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:886
  sig { params(locals: T::Array[Symbol], forwarding: T::Array[Symbol]).void }
  def initialize(locals, forwarding); end

  # The list of local variables that are forwarded to the next scope. This
  # should by defined as an array of symbols containing the specific values of
  # :*, :**, :&, or :"...".
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:883
  sig { returns(T::Array[Symbol]) }
  def forwarding; end

  # The list of local variables that are defined in this scope. This should be
  # defined as an array of symbols.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:878
  sig { returns(T::Array[Symbol]) }
  def locals; end
end

# Represents the `self` keyword.
#
#     self
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16374
class Prism::SelfNode < ::Prism::Node
  # Initialize a new SelfNode node.
  #
  # @return [SelfNode] a new instance of SelfNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16376
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16433
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16384
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16389
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16399
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16394
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SelfNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16404
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SelfNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16409
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16412
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16417
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16422
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16427
    def type; end
  end
end

# A module responsible for deserializing parse results.
#
# pkg:gem/prism#lib/prism/serialize.rb:17
module Prism::Serialize
  class << self
    # Deserialize the dumped output from a request to lex or lex_file.
    #
    # The formatting of the source of this method is purposeful to illustrate
    # the structure of the serialized data.
    #
    # pkg:gem/prism#lib/prism/serialize.rb:87
    def load_lex(input, serialized, freeze); end

    # Deserialize the dumped output from a request to parse or parse_file.
    #
    # The formatting of the source of this method is purposeful to illustrate
    # the structure of the serialized data.
    #
    # pkg:gem/prism#lib/prism/serialize.rb:34
    def load_parse(input, serialized, freeze); end

    # Deserialize the dumped output from a request to parse_comments or
    # parse_file_comments.
    #
    # The formatting of the source of this method is purposeful to illustrate
    # the structure of the serialized data.
    #
    # pkg:gem/prism#lib/prism/serialize.rb:131
    def load_parse_comments(input, serialized, freeze); end

    # Deserialize the dumped output from a request to parse_lex or
    # parse_lex_file.
    #
    # The formatting of the source of this method is purposeful to illustrate
    # the structure of the serialized data.
    #
    # pkg:gem/prism#lib/prism/serialize.rb:153
    def load_parse_lex(input, serialized, freeze); end
  end
end

# pkg:gem/prism#lib/prism/serialize.rb:202
class Prism::Serialize::ConstantPool
  # @return [ConstantPool] a new instance of ConstantPool
  #
  # pkg:gem/prism#lib/prism/serialize.rb:205
  def initialize(input, serialized, base, size); end

  # pkg:gem/prism#lib/prism/serialize.rb:213
  def get(index, encoding); end

  # Returns the value of attribute size.
  #
  # pkg:gem/prism#lib/prism/serialize.rb:203
  def size; end
end

# StringIO is synchronized and that adds a high overhead on TruffleRuby.
#
# pkg:gem/prism#lib/prism/serialize.rb:256
Prism::Serialize::FastStringIO = StringIO

# pkg:gem/prism#lib/prism/serialize.rb:259
class Prism::Serialize::Loader
  # @return [Loader] a new instance of Loader
  #
  # pkg:gem/prism#lib/prism/serialize.rb:262
  def initialize(source, serialized); end

  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/serialize.rb:270
  def eof?; end

  # Returns the value of attribute input.
  #
  # pkg:gem/prism#lib/prism/serialize.rb:260
  def input; end

  # Returns the value of attribute io.
  #
  # pkg:gem/prism#lib/prism/serialize.rb:260
  def io; end

  # pkg:gem/prism#lib/prism/serialize.rb:304
  def load_comments(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:831
  def load_constant(constant_pool, encoding); end

  # pkg:gem/prism#lib/prism/serialize.rb:275
  def load_constant_pool(constant_pool); end

  # pkg:gem/prism#lib/prism/serialize.rb:782
  def load_double; end

  # pkg:gem/prism#lib/prism/serialize.rb:797
  def load_embedded_string(encoding); end

  # pkg:gem/prism#lib/prism/serialize.rb:292
  def load_encoding; end

  # pkg:gem/prism#lib/prism/serialize.rb:667
  def load_error_level; end

  # pkg:gem/prism#lib/prism/serialize.rb:682
  def load_errors(encoding, freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:286
  def load_header; end

  # pkg:gem/prism#lib/prism/serialize.rb:771
  def load_integer; end

  # pkg:gem/prism#lib/prism/serialize.rb:298
  def load_line_offsets(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:818
  def load_location(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:812
  def load_location_object(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:321
  def load_magic_comments(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:842
  def load_node(constant_pool, encoding, freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:836
  def load_optional_constant(constant_pool, encoding); end

  # pkg:gem/prism#lib/prism/serialize.rb:823
  def load_optional_location(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:827
  def load_optional_location_object(freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:790
  def load_optional_node(constant_pool, encoding, freeze); end

  # pkg:gem/prism#lib/prism/serialize.rb:801
  def load_string(encoding); end

  # pkg:gem/prism#lib/prism/serialize.rb:733
  def load_tokens; end

  # pkg:gem/prism#lib/prism/serialize.rb:786
  def load_uint32; end

  # pkg:gem/prism#lib/prism/serialize.rb:766
  def load_varsint; end

  # variable-length integer using https://en.wikipedia.org/wiki/LEB128
  # This is also what protobuf uses: https://protobuf.dev/programming-guides/encoding/#varints
  #
  # pkg:gem/prism#lib/prism/serialize.rb:752
  def load_varuint; end

  # pkg:gem/prism#lib/prism/serialize.rb:701
  def load_warning_level; end

  # pkg:gem/prism#lib/prism/serialize.rb:714
  def load_warnings(encoding, freeze); end

  # Returns the value of attribute source.
  #
  # pkg:gem/prism#lib/prism/serialize.rb:260
  def source; end
end

# pkg:gem/prism#lib/prism/serialize.rb:338
Prism::Serialize::Loader::DIAGNOSTIC_TYPES = T.let(T.unsafe(nil), Array)

# The major version of prism that we are expecting to find in the serialized
# strings.
#
# pkg:gem/prism#lib/prism/serialize.rb:20
Prism::Serialize::MAJOR_VERSION = T.let(T.unsafe(nil), Integer)

# The minor version of prism that we are expecting to find in the serialized
# strings.
#
# pkg:gem/prism#lib/prism/serialize.rb:24
Prism::Serialize::MINOR_VERSION = T.let(T.unsafe(nil), Integer)

# The patch version of prism that we are expecting to find in the serialized
# strings.
#
# pkg:gem/prism#lib/prism/serialize.rb:28
Prism::Serialize::PATCH_VERSION = T.let(T.unsafe(nil), Integer)

# The token types that can be indexed by their enum values.
#
# pkg:gem/prism#lib/prism/serialize.rb:2227
Prism::Serialize::TOKEN_TYPES = T.let(T.unsafe(nil), Array)

# This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
#
#     C = { a: 1 }
#     ^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16443
class Prism::ShareableConstantNode < ::Prism::Node
  # Initialize a new ShareableConstantNode node.
  #
  # @return [ShareableConstantNode] a new instance of ShareableConstantNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16445
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).void
  end
  def initialize(source, node_id, location, flags, write); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16521
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16454
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16459
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16469
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16464
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode) -> ShareableConstantNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16474
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      write: T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode)
    ).returns(Prism::ShareableConstantNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16479
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode }
  #
  # pkg:gem/prism#lib/prism/node.rb:16482
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def experimental_copy?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16497
  sig { returns(T::Boolean) }
  def experimental_copy?; end

  # def experimental_everything?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16492
  sig { returns(T::Boolean) }
  def experimental_everything?; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16505
  sig { override.returns(String) }
  def inspect; end

  # def literal?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16487
  sig { returns(T::Boolean) }
  def literal?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16510
  sig { override.returns(Symbol) }
  def type; end

  # The constant write that should be modified with the shareability state.
  #
  # pkg:gem/prism#lib/prism/node.rb:16502
  sig do
    returns(T.any(Prism::ConstantWriteNode, Prism::ConstantAndWriteNode, Prism::ConstantOrWriteNode, Prism::ConstantOperatorWriteNode, Prism::ConstantPathWriteNode, Prism::ConstantPathAndWriteNode, Prism::ConstantPathOrWriteNode, Prism::ConstantPathOperatorWriteNode))
  end
  def write; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16515
    def type; end
  end
end

# Flags for shareable constant nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18807
module Prism::ShareableConstantNodeFlags; end

# constant writes that should be modified with shareable constant value experimental copy
#
# pkg:gem/prism#lib/prism/node.rb:18815
Prism::ShareableConstantNodeFlags::EXPERIMENTAL_COPY = T.let(T.unsafe(nil), Integer)

# constant writes that should be modified with shareable constant value experimental everything
#
# pkg:gem/prism#lib/prism/node.rb:18812
Prism::ShareableConstantNodeFlags::EXPERIMENTAL_EVERYTHING = T.let(T.unsafe(nil), Integer)

# constant writes that should be modified with shareable constant value literal
#
# pkg:gem/prism#lib/prism/node.rb:18809
Prism::ShareableConstantNodeFlags::LITERAL = T.let(T.unsafe(nil), Integer)

# Represents a singleton class declaration involving the `class` keyword.
#
#     class << self end
#     ^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16532
class Prism::SingletonClassNode < ::Prism::Node
  # Initialize a new SingletonClassNode node.
  #
  # @return [SingletonClassNode] a new instance of SingletonClassNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16534
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16663
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16548
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: StatementsNode | BeginNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:16616
  sig { returns(T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode))) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16553
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def class_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16632
  sig { returns(String) }
  def class_keyword; end

  # attr_reader class_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16587
  sig { returns(Prism::Location) }
  def class_keyword_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16566
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16558
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?operator_loc: Location, ?expression: Prism::node, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location) -> SingletonClassNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16571
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      locals: T::Array[Symbol],
      class_keyword_loc: Prism::Location,
      operator_loc: Prism::Location,
      expression: Prism::Node,
      body: T.nilable(T.any(Prism::StatementsNode, Prism::BeginNode)),
      end_keyword_loc: Prism::Location
    ).returns(Prism::SingletonClassNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16576
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Prism::node, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16579
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def end_keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16642
  sig { returns(String) }
  def end_keyword; end

  # attr_reader end_keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16619
  sig { returns(Prism::Location) }
  def end_keyword_loc; end

  # attr_reader expression: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:16613
  sig { returns(Prism::Node) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16647
  sig { override.returns(String) }
  def inspect; end

  # attr_reader locals: Array[Symbol]
  #
  # pkg:gem/prism#lib/prism/node.rb:16584
  sig { returns(T::Array[Symbol]) }
  def locals; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16637
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16600
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the class_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16595
  def save_class_keyword_loc(repository); end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16627
  def save_end_keyword_loc(repository); end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16608
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16652
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16657
    def type; end
  end
end

# This represents a source of Ruby code that has been parsed. It is used in
# conjunction with locations to allow them to resolve line numbers and source
# ranges.
#
# pkg:gem/prism#lib/prism/parse_result.rb:8
class Prism::Source
  # Create a new source object with the given source code.
  #
  # @return [Source] a new instance of Source
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:46
  sig { params(source: String, start_line: Integer, offsets: T::Array[Integer]).void }
  def initialize(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end

  # Return the column number in characters for the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:108
  sig { params(byte_offset: Integer).returns(Integer) }
  def character_column(byte_offset); end

  # Return the character offset for the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:103
  sig { params(byte_offset: Integer).returns(Integer) }
  def character_offset(byte_offset); end

  # Generate a cache that targets a specific encoding for calculating code
  # unit offsets.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:136
  sig do
    params(
      encoding: Encoding
    ).returns(T.any(Prism::CodeUnitsCache, T.proc.params(byte_offset: Integer).returns(Integer)))
  end
  def code_units_cache(encoding); end

  # Returns the column number in code units for the given encoding for the
  # given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:142
  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_column(byte_offset, encoding); end

  # Returns the offset from the start of the file for the given byte offset
  # counting in code units for the given encoding.
  #
  # This method is tested with UTF-8, UTF-16, and UTF-32. If there is the
  # concept of code units that differs from the number of characters in other
  # encodings, it is not captured here.
  #
  # We purposefully replace invalid and undefined characters with replacement
  # characters in this conversion. This happens for two reasons. First, it's
  # possible that the given byte offset will not occur on a character
  # boundary. Second, it's possible that the source code will contain a
  # character that has no equivalent in the given encoding.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:124
  sig { params(byte_offset: Integer, encoding: Encoding).returns(Integer) }
  def code_units_offset(byte_offset, encoding); end

  # Return the column number for the given byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:98
  sig { params(byte_offset: Integer).returns(Integer) }
  def column(byte_offset); end

  # Freeze this object and the objects it contains.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:147
  def deep_freeze; end

  # Returns the encoding of the source code, which is set by parameters to the
  # parser or by the encoding magic comment.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:64
  sig { returns(Encoding) }
  def encoding; end

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:81
  sig { params(byte_offset: Integer).returns(Integer) }
  def line(byte_offset); end

  # Returns the byte offset of the end of the line corresponding to the given
  # byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:93
  def line_end(byte_offset); end

  # Return the byte offset of the start of the line corresponding to the given
  # byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:87
  sig { params(byte_offset: Integer).returns(Integer) }
  def line_start(byte_offset); end

  # Returns the lines of the source code as an array of strings.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:69
  sig { returns(T::Array[String]) }
  def lines; end

  # The list of newline byte offsets in the source code.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:43
  sig { returns(T::Array[Integer]) }
  def offsets; end

  # Replace the value of offsets with the given value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:58
  sig { params(offsets: T::Array[Integer]).void }
  def replace_offsets(offsets); end

  # Replace the value of start_line with the given value.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:53
  sig { params(start_line: Integer).void }
  def replace_start_line(start_line); end

  # Perform a byteslice on the source code using the given byte offset and
  # byte length.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:75
  sig { params(byte_offset: Integer, length: Integer).returns(String) }
  def slice(byte_offset, length); end

  # The source code that this source object represents.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:37
  sig { returns(String) }
  def source; end

  # The line number where this source starts.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:40
  sig { returns(Integer) }
  def start_line; end

  private

  # Binary search through the offsets to find the line number for the given
  # byte offset.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:157
  def find_line(byte_offset); end

  class << self
    # Create a new source object with the given source code. This method should
    # be used instead of `new` and it will return either a `Source` or a
    # specialized and more performant `ASCIISource` if no multibyte characters
    # are present in the source code.
    #
    # pkg:gem/prism#lib/prism/parse_result.rb:13
    def for(source, start_line = T.unsafe(nil), offsets = T.unsafe(nil)); end
  end
end

# Represents the use of the `__ENCODING__` keyword.
#
#     __ENCODING__
#     ^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16679
class Prism::SourceEncodingNode < ::Prism::Node
  # Initialize a new SourceEncodingNode node.
  #
  # @return [SourceEncodingNode] a new instance of SourceEncodingNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16681
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16738
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16689
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16694
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16704
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16699
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceEncodingNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16709
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SourceEncodingNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16714
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16717
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16722
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16727
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16732
    def type; end
  end
end

# Represents the use of the `__FILE__` keyword.
#
#     __FILE__
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16747
class Prism::SourceFileNode < ::Prism::Node
  # Initialize a new SourceFileNode node.
  #
  # @return [SourceFileNode] a new instance of SourceFileNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16749
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).void
  end
  def initialize(source, node_id, location, flags, filepath); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16830
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16758
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16763
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16773
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16768
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?filepath: String) -> SourceFileNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16778
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      filepath: String
    ).returns(Prism::SourceFileNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16783
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, filepath: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:16786
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # Represents the file path being parsed. This corresponds directly to the `filepath` option given to the various `Prism::parse*` APIs.
  #
  # pkg:gem/prism#lib/prism/node.rb:16811
  sig { returns(String) }
  def filepath; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16796
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16791
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16801
  sig { returns(T::Boolean) }
  def frozen?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16814
  sig { override.returns(String) }
  def inspect; end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:16806
  sig { returns(T::Boolean) }
  def mutable?; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16819
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16824
    def type; end
  end
end

# Represents the use of the `__LINE__` keyword.
#
#     __LINE__
#     ^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:16841
class Prism::SourceLineNode < ::Prism::Node
  # Initialize a new SourceLineNode node.
  #
  # @return [SourceLineNode] a new instance of SourceLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16843
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16900
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16851
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16856
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16866
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16861
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceLineNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16871
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::SourceLineNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16876
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:16879
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16884
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16889
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16894
    def type; end
  end
end

# Represents the use of the splat operator.
#
#     [*a]
#      ^^
#
# pkg:gem/prism#lib/prism/node.rb:16909
class Prism::SplatNode < ::Prism::Node
  # Initialize a new SplatNode node.
  #
  # @return [SplatNode] a new instance of SplatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16911
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).void
  end
  def initialize(source, node_id, location, flags, operator_loc, expression); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:16993
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:16921
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16926
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:16938
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:16931
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?expression: Prism::node?) -> SplatNode
  #
  # pkg:gem/prism#lib/prism/node.rb:16943
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      operator_loc: Prism::Location,
      expression: T.nilable(Prism::Node)
    ).returns(Prism::SplatNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:16948
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, expression: Prism::node? }
  #
  # pkg:gem/prism#lib/prism/node.rb:16951
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # attr_reader expression: Prism::node?
  #
  # pkg:gem/prism#lib/prism/node.rb:16969
  sig { returns(T.nilable(Prism::Node)) }
  def expression; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16977
  sig { override.returns(String) }
  def inspect; end

  # def operator: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:16972
  sig { returns(String) }
  def operator; end

  # attr_reader operator_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:16956
  sig { returns(Prism::Location) }
  def operator_loc; end

  # Save the operator_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:16964
  def save_operator_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:16982
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:16987
    def type; end
  end
end

# Represents a set of statements contained within some scope.
#
#     foo; bar; baz
#     ^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17004
class Prism::StatementsNode < ::Prism::Node
  # Initialize a new StatementsNode node.
  #
  # @return [StatementsNode] a new instance of StatementsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17006
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).void
  end
  def initialize(source, node_id, location, flags, body); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17067
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17015
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader body: Array[Prism::node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17048
  sig { returns(T::Array[Prism::Node]) }
  def body; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17020
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17030
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17025
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Array[Prism::node]) -> StatementsNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17035
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      body: T::Array[Prism::Node]
    ).returns(Prism::StatementsNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17040
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, body: Array[Prism::node] }
  #
  # pkg:gem/prism#lib/prism/node.rb:17043
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17051
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17056
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17061
    def type; end
  end
end

# Flags for string nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18819
module Prism::StringFlags; end

# internal bytes forced the encoding to binary
#
# pkg:gem/prism#lib/prism/node.rb:18824
Prism::StringFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# pkg:gem/prism#lib/prism/node.rb:18821
Prism::StringFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# pkg:gem/prism#lib/prism/node.rb:18827
Prism::StringFlags::FROZEN = T.let(T.unsafe(nil), Integer)

# pkg:gem/prism#lib/prism/node.rb:18830
Prism::StringFlags::MUTABLE = T.let(T.unsafe(nil), Integer)

# Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
#
#     "foo"
#     ^^^^^
#
#     %w[foo]
#        ^^^
#
#     "foo #{bar} baz"
#      ^^^^      ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17084
class Prism::StringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # Initialize a new StringNode node.
  #
  # @return [StringNode] a new instance of StringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17086
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17236
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17098
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17103
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17215
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17183
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17113
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17108
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def content: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17210
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:17170
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?content_loc: Location, ?closing_loc: Location?, ?unescaped: String) -> StringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17118
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      content_loc: Prism::Location,
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::StringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17123
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:17126
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17136
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17131
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def frozen?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17141
  sig { returns(T::Boolean) }
  def frozen?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17220
  sig { override.returns(String) }
  def inspect; end

  # def mutable?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17146
  sig { returns(T::Boolean) }
  def mutable?; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17205
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17151
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17197
  def save_closing_loc(repository); end

  # Save the content_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17178
  def save_content_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17165
  def save_opening_loc(repository); end

  # Occasionally it's helpful to treat a string as if it were interpolated so
  # that there's a consistent interface for working with strings.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:75
  sig { returns(Prism::InterpolatedStringNode) }
  def to_interpolated; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17225
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader unescaped: String
  #
  # pkg:gem/prism#lib/prism/node.rb:17202
  sig { returns(String) }
  def unescaped; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17230
    def type; end
  end
end

# Query methods that allow categorizing strings based on their context for
# where they could be valid in a Ruby syntax tree.
#
# pkg:gem/prism#lib/prism/string_query.rb:7
class Prism::StringQuery
  # Initialize a new query with the given string.
  #
  # @return [StringQuery] a new instance of StringQuery
  #
  # pkg:gem/prism#lib/prism/string_query.rb:12
  def initialize(string); end

  # Whether or not this string is a valid constant name.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/string_query.rb:22
  def constant?; end

  # Whether or not this string is a valid local variable name.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/string_query.rb:17
  def local?; end

  # Whether or not this string is a valid method name.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/string_query.rb:27
  def method_name?; end

  # The string that this query is wrapping.
  #
  # pkg:gem/prism#lib/prism/string_query.rb:9
  def string; end

  class << self
    # Mirrors the C extension's StringQuery::constant? method.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def constant?(_arg0); end

    # Mirrors the C extension's StringQuery::local? method.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def local?(_arg0); end

    # Mirrors the C extension's StringQuery::method_name? method.
    #
    # @return [Boolean]
    #
    # pkg:gem/prism#lib/prism.rb:105
    def method_name?(_arg0); end
  end
end

# Represents the use of the `super` keyword with parentheses or arguments.
#
#     super()
#     ^^^^^^^
#
#     super foo, bar
#     ^^^^^^^^^^^^^^
#
# If no arguments are provided (except for a block), it would be a `ForwardingSuperNode` instead.
#
# pkg:gem/prism#lib/prism/node.rb:17255
class Prism::SuperNode < ::Prism::Node
  # Initialize a new SuperNode node.
  #
  # @return [SuperNode] a new instance of SuperNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17257
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc, block); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17394
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17270
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # Can be only `nil` when there are empty parentheses, like `super()`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17338
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # attr_reader block: BlockNode | BlockArgumentNode | nil
  #
  # pkg:gem/prism#lib/prism/node.rb:17360
  sig { returns(T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))) }
  def block; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17275
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17288
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17280
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?block: BlockNode | BlockArgumentNode | nil) -> SuperNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17293
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location),
      block: T.nilable(T.any(Prism::BlockNode, Prism::BlockArgumentNode))
    ).returns(Prism::SuperNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17298
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: BlockNode | BlockArgumentNode | nil }
  #
  # pkg:gem/prism#lib/prism/node.rb:17301
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17378
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17363
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:17306
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17368
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17319
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17373
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17341
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17314
  def save_keyword_loc(repository); end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17333
  def save_lparen_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17355
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17383
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17388
    def type; end
  end
end

# Flags for symbol nodes.
#
# pkg:gem/prism#lib/prism/node.rb:18834
module Prism::SymbolFlags; end

# internal bytes forced the encoding to binary
#
# pkg:gem/prism#lib/prism/node.rb:18839
Prism::SymbolFlags::FORCED_BINARY_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to US-ASCII
#
# pkg:gem/prism#lib/prism/node.rb:18842
Prism::SymbolFlags::FORCED_US_ASCII_ENCODING = T.let(T.unsafe(nil), Integer)

# internal bytes forced the encoding to UTF-8
#
# pkg:gem/prism#lib/prism/node.rb:18836
Prism::SymbolFlags::FORCED_UTF8_ENCODING = T.let(T.unsafe(nil), Integer)

# Represents a symbol literal or a symbol contained within a `%i` list.
#
#     :foo
#     ^^^^
#
#     %i[foo]
#        ^^^
#
# pkg:gem/prism#lib/prism/node.rb:17411
class Prism::SymbolNode < ::Prism::Node
  # Initialize a new SymbolNode node.
  #
  # @return [SymbolNode] a new instance of SymbolNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17413
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, value_loc, closing_loc, unescaped); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17564
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17425
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17430
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17543
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17511
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17440
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17435
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?value_loc: Location?, ?closing_loc: Location?, ?unescaped: String) -> SymbolNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17445
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: T.nilable(Prism::Location),
      value_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      unescaped: String
    ).returns(Prism::SymbolNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17450
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:17453
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17463
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_us_ascii_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17468
  sig { returns(T::Boolean) }
  def forced_us_ascii_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17458
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17548
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17533
  sig { returns(T.nilable(String)) }
  def opening; end

  # attr_reader opening_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17473
  sig { returns(T.nilable(Prism::Location)) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17525
  def save_closing_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17487
  def save_opening_loc(repository); end

  # Save the value_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17506
  def save_value_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17553
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader unescaped: String
  #
  # pkg:gem/prism#lib/prism/node.rb:17530
  sig { returns(String) }
  def unescaped; end

  # def value: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17538
  sig { returns(T.nilable(String)) }
  def value; end

  # attr_reader value_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17492
  sig { returns(T.nilable(Prism::Location)) }
  def value_loc; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17558
    def type; end
  end
end

# This represents a token from the Ruby source.
#
# pkg:gem/prism#lib/prism/parse_result.rb:804
class Prism::Token
  # Create a new token object with the given type, value, and location.
  #
  # @return [Token] a new instance of Token
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:816
  sig { params(source: Prism::Source, type: Symbol, value: String, location: T.any(Integer, Prism::Location)).void }
  def initialize(source, type, value, location); end

  # Returns true if the given other token is equal to this token.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:851
  sig { params(other: T.untyped).returns(T::Boolean) }
  def ==(other); end

  # Implement the hash pattern matching interface for Token.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:824
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # Freeze this object and the objects it contains.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:864
  def deep_freeze; end

  # Returns a string representation of this token.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:858
  def inspect; end

  # A Location object representing the location of this token in the source.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:829
  sig { returns(Prism::Location) }
  def location; end

  # Implement the pretty print interface for Token.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:836
  sig { params(q: T.untyped).void }
  def pretty_print(q); end

  # The type of token that this token is.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:810
  sig { returns(Symbol) }
  def type; end

  # A byteslice of the source that this token represents.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:813
  sig { returns(String) }
  def value; end

  private

  # The Source object that represents the source this token came from.
  #
  # pkg:gem/prism#lib/prism/parse_result.rb:806
  sig { returns(Prism::Source) }
  def source; end
end

# This module is responsible for converting the prism syntax tree into other
# syntax trees.
#
# pkg:gem/prism#lib/prism/translation.rb:7
module Prism::Translation; end

# This class is the entry-point for converting a prism syntax tree into the
# whitequark/parser gem's syntax tree. It inherits from the base parser for
# the parser gem, and overrides the parse* methods to parse with prism and
# then translate.
#
# Note that this version of the parser always parses using the latest
# version of Ruby syntax supported by Prism. If you want specific version
# support, use one of the version-specific subclasses, such as
# `Prism::Translation::Parser34`. If you want to parse using the same
# version of Ruby syntax as the currently running version of Ruby, use
# `Prism::Translation::ParserCurrent`.
#
# pkg:gem/prism#lib/prism/translation/parser.rb:29
class Prism::Translation::Parser < ::Parser::Base
  # The `builder` argument is used to create the parser using our custom builder class by default.
  #
  # By using the `:parser` keyword argument, you can translate in a way that is compatible with
  # the Parser gem using any parser.
  #
  # For example, in RuboCop for Ruby LSP, the following approach can be used to improve performance
  # by reusing a pre-parsed `Prism::ParseLexResult`:
  #
  #   class PrismPreparsed
  #     def initialize(prism_result)
  #       @prism_result = prism_result
  #     end
  #
  #     def parse_lex(source, **options)
  #       @prism_result
  #     end
  #   end
  #
  #   prism_preparsed = PrismPreparsed.new(prism_result)
  #
  #   Prism::Translation::Ruby34.new(builder, parser: prism_preparsed)
  #
  # In an object passed to the `:parser` keyword argument, the `parse` and `parse_lex` methods
  # should be implemented as needed.
  #
  # @return [Parser] a new instance of Parser
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:74
  def initialize(builder = T.unsafe(nil), parser: T.unsafe(nil)); end

  # The default encoding for Ruby files is UTF-8.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:91
  def default_encoding; end

  # Parses a source buffer and returns the AST.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:99
  def parse(source_buffer); end

  # Parses a source buffer and returns the AST and the source code comments.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:112
  def parse_with_comments(source_buffer); end

  # Parses a source buffer and returns the AST, the source code comments,
  # and the tokens emitted by the lexer.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:129
  def tokenize(source_buffer, recover = T.unsafe(nil)); end

  # Since prism resolves num params for us, we don't need to support this
  # kind of logic here.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:155
  def try_declare_numparam(node); end

  # pkg:gem/prism#lib/prism/translation/parser.rb:86
  sig { overridable.returns(Integer) }
  def version; end

  # pkg:gem/prism#lib/prism/translation/parser.rb:95
  def yyerror; end

  private

  # Build the parser gem AST from the prism AST.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:313
  def build_ast(program, offset_cache); end

  # Build the parser gem comments from the prism comments.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:318
  def build_comments(comments, offset_cache); end

  # Prism deals with offsets in bytes, while the parser gem deals with
  # offsets in characters. We need to handle this conversion in order to
  # build the parser gem AST.
  #
  # If the bytesize of the source is the same as the length, then we can
  # just use the offset directly. Otherwise, we build an array where the
  # index is the byte offset and the value is the character offset.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:296
  def build_offset_cache(source); end

  # Build a range from a prism location.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:330
  def build_range(location, offset_cache); end

  # Build the parser gem tokens from the prism tokens.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:325
  def build_tokens(tokens, offset_cache); end

  # Converts the version format handled by Parser to the format handled by Prism.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:353
  def convert_for_prism(version); end

  # Build a diagnostic from the given prism parse error.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:174
  def error_diagnostic(error, offset_cache); end

  # Options for how prism should parse/lex the source.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:339
  def prism_options; end

  # If there was a error generated during the parse, then raise an
  # appropriate syntax error. Otherwise return the result.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:274
  def unwrap(result, offset_cache); end

  # This is a hook to allow consumers to disable some errors if they don't
  # want them to block creating the syntax tree.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:163
  def valid_error?(error); end

  # This is a hook to allow consumers to disable some warnings if they don't
  # want them to block creating the syntax tree.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:169
  def valid_warning?(warning); end

  # Build a diagnostic from the given prism parse warning.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:247
  def warning_diagnostic(warning, offset_cache); end
end

# This class is the entry-point for Ruby 3.3 of `Prism::Translation::Parser`.
#
# pkg:gem/prism#lib/prism/translation/parser33.rb:7
class Prism::Translation::Parser33 < ::Prism::Translation::Parser
  # pkg:gem/prism#lib/prism/translation/parser33.rb:8
  sig { override.returns(Integer) }
  def version; end
end

# This class is the entry-point for Ruby 3.4 of `Prism::Translation::Parser`.
#
# pkg:gem/prism#lib/prism/translation/parser34.rb:7
class Prism::Translation::Parser34 < ::Prism::Translation::Parser
  # pkg:gem/prism#lib/prism/translation/parser34.rb:8
  sig { override.returns(Integer) }
  def version; end
end

# pkg:gem/prism#lib/prism/translation/parser35.rb:6
Prism::Translation::Parser35 = Prism::Translation::Parser40

# This class is the entry-point for Ruby 4.0 of `Prism::Translation::Parser`.
#
# pkg:gem/prism#lib/prism/translation/parser40.rb:7
class Prism::Translation::Parser40 < ::Prism::Translation::Parser
  # pkg:gem/prism#lib/prism/translation/parser40.rb:8
  sig { override.returns(Integer) }
  def version; end
end

# This class is the entry-point for Ruby 4.1 of `Prism::Translation::Parser`.
#
# pkg:gem/prism#lib/prism/translation/parser41.rb:7
class Prism::Translation::Parser41 < ::Prism::Translation::Parser
  # pkg:gem/prism#lib/prism/translation/parser41.rb:8
  def version; end
end

# A builder that knows how to convert more modern Ruby syntax
# into whitequark/parser gem's syntax tree.
#
# pkg:gem/prism#lib/prism/translation/parser/builder.rb:9
class Prism::Translation::Parser::Builder < ::Parser::Builders::Default
  # The following three lines have been added to support the `it` block parameter syntax in the source code below.
  #
  #   if args.type == :itarg
  #     block_type = :itblock
  #     args = :it
  #
  # https://github.com/whitequark/parser/blob/v3.3.7.1/lib/parser/builders/default.rb#L1122-L1155
  #
  # pkg:gem/prism#lib/prism/translation/parser/builder.rb:22
  def block(method_call, begin_t, args, body, end_t); end

  # It represents the `it` block argument, which is not yet implemented in the Parser gem.
  #
  # pkg:gem/prism#lib/prism/translation/parser/builder.rb:11
  def itarg; end
end

# A visitor that knows how to convert a prism syntax tree into the
# whitequark/parser gem's syntax tree.
#
# pkg:gem/prism#lib/prism/translation/parser/compiler.rb:9
class Prism::Translation::Parser::Compiler < ::Prism::Compiler
  # Initialize a new compiler with the given parser, offset cache, and
  # options.
  #
  # @return [Compiler] a new instance of Compiler
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:40
  def initialize(parser, offset_cache, forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # The Parser::Builders::Default instance that is being used to build the
  # AST.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:19
  def builder; end

  # The types of values that can be forwarded in the current scope.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:30
  def forwarding; end

  # Whether or not the current node is in a destructure.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:33
  def in_destructure; end

  # Whether or not the current node is in a pattern.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:36
  def in_pattern; end

  # The offset cache that is used to map between byte and character
  # offsets in the file.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:27
  def offset_cache; end

  # The Parser::Base instance that is being used to build the AST.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:15
  def parser; end

  # The Parser::Source::Buffer instance that is holding a reference to the
  # source code.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:23
  def source_buffer; end

  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:59
  def visit_alias_global_variable_node(node); end

  # alias foo bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:53
  def visit_alias_method_node(node); end

  # foo => bar | baz
  #        ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:65
  def visit_alternation_pattern_node(node); end

  # a and b
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:71
  def visit_and_node(node); end

  # foo(bar)
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:128
  def visit_arguments_node(node); end

  # []
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:77
  def visit_array_node(node); end

  # foo => [bar]
  #        ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:105
  def visit_array_pattern_node(node); end

  # { a: 1 }
  #   ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:134
  def visit_assoc_node(node); end

  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:182
  def visit_assoc_splat_node(node); end

  # $+
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:194
  def visit_back_reference_read_node(node); end

  # begin end
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:200
  def visit_begin_node(node); end

  # foo(&bar)
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:245
  def visit_block_argument_node(node); end

  # foo { |; bar| }
  #          ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:251
  def visit_block_local_variable_node(node); end

  # A block on a keyword or method call.
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:256
  def visit_block_node(node); end

  # def foo(&bar); end
  #         ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:262
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:267
  def visit_block_parameters_node(node); end

  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:276
  def visit_break_node(node); end

  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:381
  def visit_call_and_write_node(node); end

  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:288
  def visit_call_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:362
  def visit_call_operator_write_node(node); end

  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:400
  def visit_call_or_write_node(node); end

  # foo.bar, = 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:419
  def visit_call_target_node(node); end

  # foo => bar => baz
  #        ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:431
  def visit_capture_pattern_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:450
  def visit_case_match_node(node); end

  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:437
  def visit_case_node(node); end

  # class Foo; end
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:463
  def visit_class_node(node); end

  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:502
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:492
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:512
  def visit_class_variable_or_write_node(node); end

  # @@foo
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:476
  def visit_class_variable_read_node(node); end

  # @@foo, = bar
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:522
  def visit_class_variable_target_node(node); end

  # @@foo = 1
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:482
  def visit_class_variable_write_node(node); end

  # Foo &&= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:553
  def visit_constant_and_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:543
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:563
  def visit_constant_or_write_node(node); end

  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:619
  def visit_constant_path_and_write_node(node); end

  # Foo::Bar
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:579
  def visit_constant_path_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:609
  def visit_constant_path_operator_write_node(node); end

  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:629
  def visit_constant_path_or_write_node(node); end

  # Foo::Bar, = baz
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:639
  def visit_constant_path_target_node(node); end

  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:599
  def visit_constant_path_write_node(node); end

  # Foo
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:528
  def visit_constant_read_node(node); end

  # Foo, = bar
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:573
  def visit_constant_target_node(node); end

  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:537
  def visit_constant_write_node(node); end

  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:648
  def visit_def_node(node); end

  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:695
  def visit_defined_node(node); end

  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:731
  def visit_else_node(node); end

  # "foo #{bar}"
  #      ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:737
  def visit_embedded_statements_node(node); end

  # "foo #@bar"
  #      ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:747
  def visit_embedded_variable_node(node); end

  # begin; foo; ensure; bar; end
  #             ^^^^^^^^^^^^
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:753
  def visit_ensure_node(node); end

  # false
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:759
  def visit_false_node(node); end

  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:765
  def visit_find_pattern_node(node); end

  # 0..5
  # ^^^^
  # if foo .. bar; end
  #    ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1541
  def visit_flip_flop_node(node); end

  # 1.0
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:777
  def visit_float_node(node); end

  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:783
  def visit_for_node(node); end

  # def foo(...); bar(...); end
  #                   ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:801
  def visit_forwarding_arguments_node(node); end

  # def foo(...); end
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:807
  def visit_forwarding_parameter_node(node); end

  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:816
  def visit_forwarding_super_node(node); end

  # $foo &&= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:854
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:844
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:864
  def visit_global_variable_or_write_node(node); end

  # $foo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:828
  def visit_global_variable_read_node(node); end

  # $foo, = bar
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:874
  def visit_global_variable_target_node(node); end

  # $foo = 1
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:834
  def visit_global_variable_write_node(node); end

  # {}
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:880
  def visit_hash_node(node); end

  # foo => {}
  #        ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:890
  def visit_hash_pattern_node(node); end

  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:908
  def visit_if_node(node); end

  # 1i
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:950
  def visit_imaginary_node(node); end

  # { foo: }
  #   ^^^^
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:956
  def visit_implicit_node(node); end

  # foo { |bar,| }
  #           ^
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:962
  def visit_implicit_rest_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:968
  def visit_in_node(node); end

  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1016
  def visit_index_and_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:998
  def visit_index_operator_write_node(node); end

  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1034
  def visit_index_or_write_node(node); end

  # foo[bar], = 1
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1052
  def visit_index_target_node(node); end

  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1089
  def visit_instance_variable_and_write_node(node); end

  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1079
  def visit_instance_variable_operator_write_node(node); end

  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1099
  def visit_instance_variable_or_write_node(node); end

  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1063
  def visit_instance_variable_read_node(node); end

  # @foo, = bar
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1109
  def visit_instance_variable_target_node(node); end

  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1069
  def visit_instance_variable_write_node(node); end

  # 1
  # ^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1115
  def visit_integer_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1132
  def visit_interpolated_match_last_line_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1121
  def visit_interpolated_regular_expression_node(node); end

  # "foo #{bar}"
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1136
  def visit_interpolated_string_node(node); end

  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1150
  def visit_interpolated_symbol_node(node); end

  # `foo #{bar}`
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1160
  def visit_interpolated_x_string_node(node); end

  # -> { it }
  #      ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1174
  def visit_it_local_variable_read_node(node); end

  # -> { it }
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1180
  def visit_it_parameters_node(node); end

  # foo(bar: baz)
  #     ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1196
  def visit_keyword_hash_node(node); end

  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1205
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1214
  def visit_lambda_node(node); end

  # foo &&= bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1266
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1256
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1276
  def visit_local_variable_or_write_node(node); end

  # foo
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1240
  def visit_local_variable_read_node(node); end

  # foo, = bar
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1286
  def visit_local_variable_target_node(node); end

  # foo = 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1246
  def visit_local_variable_write_node(node); end

  # /foo/
  # ^^^^^
  # if /foo/ then end
  #    ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1577
  def visit_match_last_line_node(node); end

  # foo in bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1296
  def visit_match_predicate_node(node); end

  # foo => bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1306
  def visit_match_required_node(node); end

  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1316
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error. The parser gem doesn't have such a concept, so
  # we invent our own here.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1327
  def visit_missing_node(node); end

  # module Foo; end
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1333
  def visit_module_node(node); end

  # foo, bar = baz
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1344
  def visit_multi_target_node(node); end

  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1354
  def visit_multi_write_node(node); end

  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1377
  def visit_next_node(node); end

  # nil
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1389
  def visit_nil_node(node); end

  # def foo(**nil); end
  #         ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1395
  def visit_no_keywords_parameter_node(node); end

  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1405
  def visit_numbered_parameters_node(node); end

  # $1
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1411
  def visit_numbered_reference_read_node(node); end

  # def foo(bar: baz); end
  #         ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1417
  def visit_optional_keyword_parameter_node(node); end

  # def foo(bar = 1); end
  #         ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1423
  def visit_optional_parameter_node(node); end

  # a or b
  # ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1429
  def visit_or_node(node); end

  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1435
  def visit_parameters_node(node); end

  # ()
  # ^^
  #
  # (1)
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1474
  def visit_parentheses_node(node); end

  # foo => ^(bar)
  #        ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1484
  def visit_pinned_expression_node(node); end

  # foo = 1 and bar => ^foo
  #                    ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1492
  def visit_pinned_variable_node(node); end

  # END {}
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1497
  def visit_post_execution_node(node); end

  # BEGIN {}
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1507
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1517
  def visit_program_node(node); end

  # 0..5
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1523
  def visit_range_node(node); end

  # 1r
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1545
  def visit_rational_node(node); end

  # redo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1551
  def visit_redo_node(node); end

  # /foo/
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1557
  def visit_regular_expression_node(node); end

  # def foo(bar:); end
  #         ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1581
  def visit_required_keyword_parameter_node(node); end

  # def foo(bar); end
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1587
  def visit_required_parameter_node(node); end

  # foo rescue bar
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1593
  def visit_rescue_modifier_node(node); end

  # begin; rescue; end
  #        ^^^^^^^
  #
  # @raise [CompilationError]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1611
  def visit_rescue_node(node); end

  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1620
  def visit_rest_parameter_node(node); end

  # retry
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1626
  def visit_retry_node(node); end

  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1635
  def visit_return_node(node); end

  # self
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1647
  def visit_self_node(node); end

  # A shareable constant.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1652
  def visit_shareable_constant_node(node); end

  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1658
  def visit_singleton_class_node(node); end

  # __ENCODING__
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1670
  def visit_source_encoding_node(node); end

  # __FILE__
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1676
  def visit_source_file_node(node); end

  # __LINE__
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1682
  def visit_source_line_node(node); end

  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1694
  def visit_splat_node(node); end

  # A list of statements.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1707
  def visit_statements_node(node); end

  # "foo"
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1713
  def visit_string_node(node); end

  # super(foo)
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1738
  def visit_super_node(node); end

  # :foo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1761
  def visit_symbol_node(node); end

  # true
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1788
  def visit_true_node(node); end

  # undef foo
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1794
  def visit_undef_node(node); end

  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1803
  def visit_unless_node(node); end

  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1833
  def visit_until_node(node); end

  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1859
  def visit_when_node(node); end

  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1877
  def visit_while_node(node); end

  # `foo`
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1903
  def visit_x_string_node(node); end

  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1929
  def visit_yield_node(node); end

  private

  # Initialize a new compiler with the given option overrides, used to
  # visit a subtree with the given options.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1943
  def copy_compiler(forwarding: T.unsafe(nil), in_destructure: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # When *, **, &, or ... are used as an argument in a method call, we
  # check if they were allowed by the current context. To determine that
  # we build this lookup table.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1950
  def find_forwarding(node); end

  # Returns the set of targets for a MultiTargetNode or a MultiWriteNode.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1963
  def multi_target_elements(node); end

  # Negate the value of a numeric node. This is a special case where you
  # have a negative sign on one line and then a number on the next line.
  # In normal Ruby, this will always be a method call. The parser gem,
  # however, marks this as a numeric literal. We have to massage the tree
  # here to get it into the correct form.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1975
  def numeric_negate(message_loc, receiver); end

  # Blocks can have a special set of parameters that automatically expand
  # when given arrays if they have a single required parameter and no
  # other parameters.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:1989
  def procarg0?(parameters); end

  # Constructs a new source range from the given start and end offsets.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2006
  def srange(location); end

  # Constructs a new source range from the given start and end offsets.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2011
  def srange_offsets(start_offset, end_offset); end

  # Constructs a new source range by finding a semicolon between the given
  # start offset and end offset. If the semicolon is not found, it returns
  # nil. Importantly it does not search past newlines or comments.
  #
  # Note that end_offset is allowed to be nil, in which case this will
  # search until the end of the string.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2021
  def srange_semicolon(start_offset, end_offset); end

  # When the content of a string node is split across multiple lines, the
  # parser gem creates individual string nodes for each line the content is part of.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2138
  def string_nodes_from_interpolation(node, opening); end

  # Create parser string nodes from a single prism node. The parser gem
  # "glues" strings together when a line continuation is encountered.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2150
  def string_nodes_from_line_continuations(unescaped, escaped, start_offset, opening); end

  # Transform a location into a token that the parser gem expects.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2029
  def token(location); end

  # Visit a block node on a call.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2034
  def visit_block(call, block); end

  # Visit a heredoc that can be either a string or an xstring.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2069
  def visit_heredoc(node); end

  # Visit a numeric node and account for the optional sign.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2115
  def visit_numeric(node, value); end

  # Within the given block, track that we're within a pattern.
  #
  # pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2127
  def within_pattern; end
end

# Raised when the tree is malformed or there is a bug in the compiler.
#
# pkg:gem/prism#lib/prism/translation/parser/compiler.rb:11
class Prism::Translation::Parser::Compiler::CompilationError < ::StandardError; end

# Locations in the parser gem AST are generated using this class. We
# store a reference to its constant to make it slightly faster to look
# up.
#
# pkg:gem/prism#lib/prism/translation/parser/compiler.rb:2003
Prism::Translation::Parser::Compiler::Range = Parser::Source::Range

# pkg:gem/prism#lib/prism/translation/parser.rb:30
Prism::Translation::Parser::Diagnostic = Parser::Diagnostic

# Accepts a list of prism tokens and converts them into the expected
# format for the parser gem.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:13
class Prism::Translation::Parser::Lexer
  # Initialize the lexer with the given source buffer, prism tokens, and
  # offset cache.
  #
  # @return [Lexer] a new instance of Lexer
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:231
  def initialize(source_buffer, lexed, offset_cache); end

  # An array of tuples that contain prism tokens and their associated lex
  # state when they were lexed.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:224
  def lexed; end

  # A hash that maps offsets in bytes to offsets in characters.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:227
  def offset_cache; end

  # The Parser::Source::Buffer that the tokens were lexed from.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:220
  def source_buffer; end

  # Convert the prism tokens into the expected format for the parser gem.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:241
  def to_a; end

  private

  # Wonky heredoc tab/spaces rules.
  # https://github.com/ruby/prism/blob/v1.3.0/src/prism.c#L10548-L10558
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:593
  def calculate_heredoc_whitespace(heredoc_token_index); end

  # Escape a byte value, given the control and meta flags.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:735
  def escape_build(value, control, meta); end

  # Read an escape out of the string scanner, given the control and meta
  # flags, and push the unescaped value into the result.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:743
  def escape_read(result, scanner, control, meta); end

  # Determine if characters preceeded by a backslash should be escaped or not
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:804
  def interpolation?(quote); end

  # Parse a complex from the string representation.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:564
  def parse_complex(value); end

  # Parse a float from the string representation.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:557
  def parse_float(value); end

  # Parse an integer from the string representation.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:550
  def parse_integer(value); end

  # Parse a rational from the string representation.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:579
  def parse_rational(value); end

  # Determine if the string is part of a %-style array.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:814
  def percent_array?(quote); end

  # For %-arrays whitespace, the parser gem only considers whitespace before the newline.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:792
  def percent_array_leading_whitespace(string); end

  # In a percent array, certain whitespace can be preceeded with a backslash,
  # causing the following characters to be part of the previous element.
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:784
  def percent_array_unescape(string); end

  # Creates a new parser range, taking prisms byte offsets into account
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:545
  def range(start_offset, end_offset); end

  # Regexp allow interpolation but are handled differently during unescaping
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:809
  def regexp?(quote); end

  # Certain strings are merged into a single string token.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:718
  def simplify_string?(value, quote); end

  # Wonky heredoc tab/spaces rules.
  # https://github.com/ruby/prism/blob/v1.3.0/src/prism.c#L16528-L16545
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:640
  def trim_heredoc_whitespace(string, heredoc); end

  # Apply Ruby string escaping rules
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:675
  def unescape_string(string, quote); end
end

# Types of tokens that are allowed to continue a method call with comments in-between.
# For these, the parser gem doesn't emit a newline token after the last comment.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:211
Prism::Translation::Parser::Lexer::COMMENT_CONTINUATION_TYPES = T.let(T.unsafe(nil), Set)

# When one of these delimiters is encountered, then the other
# one is allowed to be escaped as well.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:666
Prism::Translation::Parser::Lexer::DELIMITER_SYMETRY = T.let(T.unsafe(nil), Hash)

# Escape sequences that have special and should appear unescaped in the resulting string.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:657
Prism::Translation::Parser::Lexer::ESCAPES = T.let(T.unsafe(nil), Hash)

# These constants represent flags in our lex state. We really, really
# don't want to be using them and we really, really don't want to be
# exposing them as part of our public API. Unfortunately, we don't have
# another way of matching the exact tokens that the parser gem expects
# without them. We should find another way to do this, but in the
# meantime we'll hide them from the documentation and mark them as
# private constants.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:193
Prism::Translation::Parser::Lexer::EXPR_BEG = T.let(T.unsafe(nil), Integer)

# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:194
Prism::Translation::Parser::Lexer::EXPR_LABEL = T.let(T.unsafe(nil), Integer)

# Heredocs are complex and require us to keep track of a bit of info to refer to later
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
class Prism::Translation::Parser::Lexer::HeredocData < ::Struct
  # Returns the value of attribute common_whitespace
  #
  # @return [Object] the current value of common_whitespace
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
  def common_whitespace; end

  # Sets the attribute common_whitespace
  #
  # @param value [Object] the value to set the attribute common_whitespace to.
  # @return [Object] the newly set value
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
  def common_whitespace=(_); end

  # Returns the value of attribute identifier
  #
  # @return [Object] the current value of identifier
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
  def identifier; end

  # Sets the attribute identifier
  #
  # @param value [Object] the value to set the attribute identifier to.
  # @return [Object] the newly set value
  #
  # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
  def identifier=(_); end

  class << self
    # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
    def [](*_arg0); end

    # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
    def inspect; end

    # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
    def keyword_init?; end

    # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
    def members; end

    # pkg:gem/prism#lib/prism/translation/parser/lexer.rb:215
    def new(*_arg0); end
  end
end

# It is used to determine whether `do` is of the token type `kDO` or `kDO_LAMBDA`.
#
# NOTE: In edge cases like `-> (foo = -> (bar) {}) do end`, please note that `kDO` is still returned
# instead of `kDO_LAMBDA`, which is expected: https://github.com/ruby/prism/pull/3046
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:200
Prism::Translation::Parser::Lexer::LAMBDA_TOKEN_TYPES = T.let(T.unsafe(nil), Set)

# The `PARENTHESIS_LEFT` token in Prism is classified as either `tLPAREN` or `tLPAREN2` in the Parser gem.
# The following token types are listed as those classified as `tLPAREN`.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:204
Prism::Translation::Parser::Lexer::LPAREN_CONVERSION_TOKEN_TYPES = T.let(T.unsafe(nil), Set)

# https://github.com/whitequark/parser/blob/v3.3.6.0/lib/parser/lexer-strings.rl#L14
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:671
Prism::Translation::Parser::Lexer::REGEXP_META_CHARACTERS = T.let(T.unsafe(nil), Array)

# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:237
Prism::Translation::Parser::Lexer::Range = Parser::Source::Range

# The direct translating of types between the two lexers.
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:19
Prism::Translation::Parser::Lexer::TYPES = T.let(T.unsafe(nil), Hash)

# These tokens are always skipped
#
# pkg:gem/prism#lib/prism/translation/parser/lexer.rb:15
Prism::Translation::Parser::Lexer::TYPES_ALWAYS_SKIP = T.let(T.unsafe(nil), Set)

# The parser gem has a list of diagnostics with a hard-coded set of error
# messages. We create our own diagnostic class in order to set our own
# error messages.
#
# pkg:gem/prism#lib/prism/translation/parser.rb:36
class Prism::Translation::Parser::PrismDiagnostic < ::Parser::Diagnostic
  # Initialize a new diagnostic with the given message and location.
  #
  # @return [PrismDiagnostic] a new instance of PrismDiagnostic
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:41
  def initialize(message, level, reason, location); end

  # This is the cached message coming from prism.
  #
  # pkg:gem/prism#lib/prism/translation/parser.rb:38
  def message; end
end

# pkg:gem/prism#lib/prism/translation/parser.rb:47
Prism::Translation::Parser::Racc_debug_parser = T.let(T.unsafe(nil), FalseClass)

# pkg:gem/prism#lib/prism/translation/parser_current.rb:14
Prism::Translation::ParserCurrent = Prism::Translation::Parser40

# This class provides a compatibility layer between prism and Ripper. It
# functions by parsing the entire tree first and then walking it and
# executing each of the Ripper callbacks as it goes. To use this class, you
# treat `Prism::Translation::Ripper` effectively as you would treat the
# `Ripper` class.
#
# Note that this class will serve the most common use cases, but Ripper's
# API is extensive and undocumented. It relies on reporting the state of the
# parser at any given time. We do our best to replicate that here, but
# because it is a different architecture it is not possible to perfectly
# replicate the behavior of Ripper.
#
# The main known difference is that we may omit dispatching some events in
# some cases. This impacts the following events:
#
# - on_assign_error
# - on_comma
# - on_ignored_nl
# - on_ignored_sp
# - on_kw
# - on_label_end
# - on_lbrace
# - on_lbracket
# - on_lparen
# - on_nl
# - on_op
# - on_operator_ambiguous
# - on_rbrace
# - on_rbracket
# - on_rparen
# - on_semicolon
# - on_sp
# - on_symbeg
# - on_tstring_beg
# - on_tstring_end
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:44
class Prism::Translation::Ripper < ::Prism::Compiler
  # Create a new Translation::Ripper object with the given source.
  #
  # @return [Ripper] a new instance of Ripper
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:445
  def initialize(source, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

  # The current column number of the parser.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:442
  def column; end

  # True if the parser encountered an error during parsing.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:458
  sig { returns(T::Boolean) }
  def error?; end

  # The filename of the source being parsed.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:436
  def filename; end

  # The current line number of the parser.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:439
  def lineno; end

  # Parse the source and return the result.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:463
  sig { returns(T.untyped) }
  def parse; end

  # The source that is being parsed.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:433
  def source; end

  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:562
  def visit_alias_global_variable_node(node); end

  # alias foo bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:552
  def visit_alias_method_node(node); end

  # foo => bar | baz
  #        ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:586
  def visit_alternation_pattern_node(node); end

  # a and b
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:606
  def visit_and_node(node); end

  # foo(bar)
  #     ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:797
  def visit_arguments_node(node); end

  # []
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:616
  def visit_array_node(node); end

  # foo => [bar]
  #        ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:776
  def visit_array_pattern_node(node); end

  # { a: 1 }
  #   ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:804
  def visit_assoc_node(node); end

  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:817
  def visit_assoc_splat_node(node); end

  # $+
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:826
  def visit_back_reference_read_node(node); end

  # begin end
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:833
  def visit_begin_node(node); end

  # foo(&bar)
  #     ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:897
  def visit_block_argument_node(node); end

  # foo { |; bar| }
  #          ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:903
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:909
  def visit_block_node(node); end

  # def foo(&bar); end
  #         ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:945
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:959
  def visit_block_parameters_node(node); end

  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:983
  def visit_break_node(node); end

  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1205
  def visit_call_and_write_node(node); end

  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1003
  def visit_call_node(node); end

  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1183
  def visit_call_operator_write_node(node); end

  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1227
  def visit_call_or_write_node(node); end

  # foo.bar, = 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1249
  def visit_call_target_node(node); end

  # foo => bar => baz
  #        ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1274
  def visit_capture_pattern_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1297
  def visit_case_match_node(node); end

  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1284
  def visit_case_node(node); end

  # class Foo; end
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1310
  def visit_class_node(node); end

  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1363
  def visit_class_variable_and_write_node(node); end

  # @@foo += bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1349
  def visit_class_variable_operator_write_node(node); end

  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1377
  def visit_class_variable_or_write_node(node); end

  # @@foo
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1328
  def visit_class_variable_read_node(node); end

  # @@foo, = bar
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1391
  def visit_class_variable_target_node(node); end

  # @@foo = 1
  # ^^^^^^^^^
  #
  # @@foo, @@bar = 1
  # ^^^^^  ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1338
  def visit_class_variable_write_node(node); end

  # Foo &&= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1433
  def visit_constant_and_write_node(node); end

  # Foo += bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1419
  def visit_constant_operator_write_node(node); end

  # Foo ||= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1447
  def visit_constant_or_write_node(node); end

  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1534
  def visit_constant_path_and_write_node(node); end

  # Foo::Bar
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1468
  def visit_constant_path_node(node); end

  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1520
  def visit_constant_path_operator_write_node(node); end

  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1548
  def visit_constant_path_or_write_node(node); end

  # Foo::Bar, = baz
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1562
  def visit_constant_path_target_node(node); end

  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1491
  def visit_constant_path_write_node(node); end

  # Foo
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1398
  def visit_constant_read_node(node); end

  # Foo, = bar
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1461
  def visit_constant_target_node(node); end

  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1408
  def visit_constant_write_node(node); end

  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1571
  def visit_def_node(node); end

  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1618
  def visit_defined_node(node); end

  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1640
  def visit_else_node(node); end

  # "foo #{bar}"
  #      ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1656
  def visit_embedded_statements_node(node); end

  # "foo #@bar"
  #      ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1677
  def visit_embedded_variable_node(node); end

  # Visit an EnsureNode node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1688
  def visit_ensure_node(node); end

  # false
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1706
  def visit_false_node(node); end

  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1713
  def visit_find_pattern_node(node); end

  # if foo .. bar; end
  #    ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1738
  def visit_flip_flop_node(node); end

  # 1.0
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1752
  def visit_float_node(node); end

  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1758
  def visit_for_node(node); end

  # def foo(...); bar(...); end
  #                   ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1775
  def visit_forwarding_arguments_node(node); end

  # def foo(...); end
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1782
  def visit_forwarding_parameter_node(node); end

  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1792
  def visit_forwarding_super_node(node); end

  # $foo &&= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1841
  def visit_global_variable_and_write_node(node); end

  # $foo += bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1827
  def visit_global_variable_operator_write_node(node); end

  # $foo ||= bar
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1855
  def visit_global_variable_or_write_node(node); end

  # $foo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1806
  def visit_global_variable_read_node(node); end

  # $foo, = bar
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1869
  def visit_global_variable_target_node(node); end

  # $foo = 1
  # ^^^^^^^^
  #
  # $foo, $bar = 1
  # ^^^^  ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1816
  def visit_global_variable_write_node(node); end

  # {}
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1876
  def visit_hash_node(node); end

  # foo => {}
  #        ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1891
  def visit_hash_pattern_node(node); end

  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1933
  def visit_if_node(node); end

  # 1i
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1969
  def visit_imaginary_node(node); end

  # { foo: }
  #   ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1975
  def visit_implicit_node(node); end

  # foo { |bar,| }
  #           ^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1980
  def visit_implicit_rest_node(node); end

  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1987
  def visit_in_node(node); end

  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2022
  def visit_index_and_write_node(node); end

  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2005
  def visit_index_operator_write_node(node); end

  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2039
  def visit_index_or_write_node(node); end

  # foo[bar], = 1
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2056
  def visit_index_target_node(node); end

  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2098
  def visit_instance_variable_and_write_node(node); end

  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2084
  def visit_instance_variable_operator_write_node(node); end

  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2112
  def visit_instance_variable_or_write_node(node); end

  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2066
  def visit_instance_variable_read_node(node); end

  # @foo, = bar
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2126
  def visit_instance_variable_target_node(node); end

  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2073
  def visit_instance_variable_write_node(node); end

  # 1
  # ^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2133
  def visit_integer_node(node); end

  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2139
  def visit_interpolated_match_last_line_node(node); end

  # /foo #{bar}/
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2158
  def visit_interpolated_regular_expression_node(node); end

  # "foo #{bar}"
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2177
  def visit_interpolated_string_node(node); end

  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2205
  def visit_interpolated_symbol_node(node); end

  # `foo #{bar}`
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2218
  def visit_interpolated_x_string_node(node); end

  # -> { it }
  #      ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2248
  def visit_it_local_variable_read_node(node); end

  # -> { it }
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2255
  def visit_it_parameters_node(node); end

  # foo(bar: baz)
  #     ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2260
  def visit_keyword_hash_node(node); end

  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2272
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2286
  def visit_lambda_node(node); end

  # foo &&= bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2378
  def visit_local_variable_and_write_node(node); end

  # foo += bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2364
  def visit_local_variable_operator_write_node(node); end

  # foo ||= bar
  # ^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2392
  def visit_local_variable_or_write_node(node); end

  # foo
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2346
  def visit_local_variable_read_node(node); end

  # foo, = bar
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2406
  def visit_local_variable_target_node(node); end

  # foo = 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2353
  def visit_local_variable_write_node(node); end

  # if /foo/ then end
  #    ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2413
  def visit_match_last_line_node(node); end

  # foo in bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2428
  def visit_match_predicate_node(node); end

  # foo => bar
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2437
  def visit_match_required_node(node); end

  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2446
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2452
  def visit_missing_node(node); end

  # module Foo; end
  # ^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2458
  def visit_module_node(node); end

  # (foo, bar), bar = qux
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2475
  def visit_multi_target_node(node); end

  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2529
  def visit_multi_write_node(node); end

  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2549
  def visit_next_node(node); end

  # nil
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2563
  def visit_nil_node(node); end

  # def foo(**nil); end
  #         ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2570
  def visit_no_keywords_parameter_node(node); end

  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2579
  def visit_numbered_parameters_node(node); end

  # $1
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2584
  def visit_numbered_reference_read_node(node); end

  # def foo(bar: baz); end
  #         ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2591
  def visit_optional_keyword_parameter_node(node); end

  # def foo(bar = 1); end
  #         ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2601
  def visit_optional_parameter_node(node); end

  # a or b
  # ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2611
  def visit_or_node(node); end

  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2621
  def visit_parameters_node(node); end

  # ()
  # ^^
  #
  # (1)
  # ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2648
  def visit_parentheses_node(node); end

  # foo => ^(bar)
  #        ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2662
  def visit_pinned_expression_node(node); end

  # foo = 1 and bar => ^foo
  #                    ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2671
  def visit_pinned_variable_node(node); end

  # END {}
  # ^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2677
  def visit_post_execution_node(node); end

  # BEGIN {}
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2692
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2706
  def visit_program_node(node); end

  # 0..5
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2717
  def visit_range_node(node); end

  # 1r
  # ^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2731
  def visit_rational_node(node); end

  # redo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2737
  def visit_redo_node(node); end

  # /foo/
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2744
  def visit_regular_expression_node(node); end

  # def foo(bar:); end
  #         ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2766
  def visit_required_keyword_parameter_node(node); end

  # def foo(bar); end
  #         ^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2773
  def visit_required_parameter_node(node); end

  # foo rescue bar
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2780
  def visit_rescue_modifier_node(node); end

  # begin; rescue; end
  #        ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2790
  def visit_rescue_node(node); end

  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2848
  def visit_rest_parameter_node(node); end

  # retry
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2860
  def visit_retry_node(node); end

  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2870
  def visit_return_node(node); end

  # self
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2884
  def visit_self_node(node); end

  # A shareable constant.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2890
  def visit_shareable_constant_node(node); end

  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2896
  def visit_singleton_class_node(node); end

  # __ENCODING__
  # ^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2906
  def visit_source_encoding_node(node); end

  # __FILE__
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2913
  def visit_source_file_node(node); end

  # __LINE__
  # ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2920
  def visit_source_line_node(node); end

  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2933
  def visit_splat_node(node); end

  # A list of statements.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2938
  def visit_statements_node(node); end

  # "foo"
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2955
  def visit_string_node(node); end

  # super(foo)
  # ^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3087
  def visit_super_node(node); end

  # :foo
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3108
  def visit_symbol_node(node); end

  # true
  # ^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3132
  def visit_true_node(node); end

  # undef foo
  # ^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3139
  def visit_undef_node(node); end

  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3151
  def visit_unless_node(node); end

  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3179
  def visit_until_node(node); end

  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3203
  def visit_when_node(node); end

  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3224
  def visit_while_node(node); end

  # `foo`
  # ^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3248
  def visit_x_string_node(node); end

  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3271
  def visit_yield_node(node); end

  private

  # :stopdoc:
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3411
  def _dispatch_0; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3412
  def _dispatch_1(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3413
  def _dispatch_2(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3414
  def _dispatch_3(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3415
  def _dispatch_4(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3416
  def _dispatch_5(_, _, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3417
  def _dispatch_7(_, _, _, _, _, _, _); end

  # This method is responsible for updating lineno and column information
  # to reflect the current node.
  #
  # This method could be drastically improved with some caching on the start
  # of every line, but for now it's good enough.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3401
  def bounds(location); end

  # Returns true if the given node is a command node.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1174
  def command?(node); end

  # This method is called when the parser found syntax error.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3439
  def compile_error(msg); end

  # This method is provided by the Ripper C extension. It is called when a
  # string needs to be dedented because of a tilde heredoc. It is expected
  # that it will modify the string in place and return the number of bytes
  # that were removed.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3454
  def dedent_string(string, width); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_BEGIN(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_CHAR(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_END(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on___end__(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_alias(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_alias_error(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_aref(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_aref_field(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_arg_ambiguous(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_arg_paren(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_args_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_args_add_block(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_args_add_star(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_args_forward; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_args_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_array(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_aryptn(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_assign(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_assign_error(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_assoc_new(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_assoc_splat(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_assoclist_from_args(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_backref(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_backtick(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_bare_assoc_hash(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_begin(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_binary(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_block_var(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_blockarg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_bodystmt(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_brace_block(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_break(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_call(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_case(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_class(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_class_name_error(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_comma(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_command(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_command_call(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_comment(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_const(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_const_path_field(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_const_path_ref(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_const_ref(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_cvar(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_def(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_defined(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_defs(_, _, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_do_block(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_dot2(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_dot3(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_dyna_symbol(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_else(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_elsif(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embdoc(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embdoc_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embdoc_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embexpr_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embexpr_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_embvar(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_ensure(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_excessed_comma; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_fcall(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_field(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_float(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_fndptn(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_for(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_gvar(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_hash(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_heredoc_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_heredoc_dedent(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_heredoc_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_hshptn(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_ident(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_if(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_if_mod(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_ifop(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_ignored_nl(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_ignored_sp(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_imaginary(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_in(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_int(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_ivar(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_kw(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_kwrest_param(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_label(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_label_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_lambda(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_lbrace(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_lbracket(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_lparen(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_magic_comment(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_massign(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_method_add_arg(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_method_add_block(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mlhs_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mlhs_add_post(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mlhs_add_star(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mlhs_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mlhs_paren(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_module(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mrhs_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mrhs_add_star(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mrhs_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_mrhs_new_from_args(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_next(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_nl(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_nokw_param(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_op(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_opassign(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_operator_ambiguous(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_param_error(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_params(_, _, _, _, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_paren(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_parse_error(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_period(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_program(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_qsymbols_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_qsymbols_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_qsymbols_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_qwords_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_qwords_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_qwords_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_rational(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_rbrace(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_rbracket(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_redo; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_regexp_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_regexp_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_regexp_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_regexp_literal(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_regexp_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_rescue(_, _, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_rescue_mod(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_rest_param(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_retry; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_return(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_return0; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_rparen(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_sclass(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_semicolon(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_sp(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_stmts_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_stmts_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_concat(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_content; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_dvar(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_embexpr(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_string_literal(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_super(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_symbeg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_symbol(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_symbol_literal(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_symbols_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_symbols_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_symbols_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_tlambda(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_tlambeg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_top_const_field(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_top_const_ref(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_tstring_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_tstring_content(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_tstring_end(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_unary(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_undef(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_unless(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_unless_mod(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_until(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_until_mod(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_var_alias(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_var_field(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_var_ref(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_vcall(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_void_stmt; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_when(_, _, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_while(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_while_mod(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_word_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_word_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_words_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_words_beg(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_words_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3447
  def on_words_sep(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_xstring_add(_, _); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_xstring_literal(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_xstring_new; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_yield(_); end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_yield0; end

  # pkg:gem/prism#lib/prism/translation/ripper.rb:3425
  def on_zsuper; end

  # Lazily initialize the parse result.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3297
  def result; end

  # Returns true if there is a comma between the two locations.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3306
  def trailing_comma?(left, right); end

  # Visit one side of an alias global variable node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:571
  def visit_alias_global_variable_node_value(node); end

  # Visit a list of elements, like the elements of an array or arguments.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:757
  def visit_arguments(elements); end

  # Visit the clauses of a begin node to form an on_bodystmt call.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:841
  def visit_begin_node_clauses(location, node, allow_newline); end

  # Visit the body of a structure that can have either a set of statements
  # or statements wrapped in rescue/else/ensure.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:876
  def visit_body_node(location, node, allow_newline = T.unsafe(nil)); end

  # Visit the arguments and block of a call node and return the arguments
  # and block as they should be used.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1147
  def visit_call_node_arguments(arguments_node, block_node, trailing_comma); end

  # Visit a constant path that is part of a write node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:1500
  def visit_constant_path_write_node_target(node); end

  # Visit a destructured positional parameter node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2635
  def visit_destructured_parameter_node(node); end

  # Visit a string that is expressed using a <<~ heredoc.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3006
  def visit_heredoc_node(parts, base); end

  # Ripper gives back the escaped string content but strips out the common
  # leading whitespace. Prism gives back the unescaped string content and
  # a location for the escaped string content. Unfortunately these don't
  # work well together, so here we need to re-derive the common leading
  # whitespace.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2981
  def visit_heredoc_node_whitespace(parts); end

  # Visit a heredoc node that is representing a string.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3052
  def visit_heredoc_string_node(node); end

  # Visit a heredoc node that is representing an xstring.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3069
  def visit_heredoc_x_string_node(node); end

  # Visit the targets of a multi-target node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2488
  def visit_multi_target_node_targets(lefts, rest, rights, skippable); end

  # Visit a node that represents a number. We need to explicitly handle the
  # unary - operator.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3345
  def visit_number_node(node); end

  # Visit a pattern within a pattern match. This is used to bypass the
  # parenthesis node that can be used to wrap patterns.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:596
  def visit_pattern_node(node); end

  # Visit the list of statements of a statements node. We support nil
  # statements in the list. This would normally not be allowed by the
  # structure of the prism parse tree, but we manually add them here so that
  # we can mirror Ripper's void stmt.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2947
  def visit_statements_node_body(body); end

  # Visit an individual part of a string-like node.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:2237
  def visit_string_content(part); end

  # Visit the string content of a particular node. This method is used to
  # split into the various token types.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3318
  def visit_token(token, allow_keywords = T.unsafe(nil)); end

  # Dispatch a words_sep event that contains the space between the elements
  # of list literals.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:746
  def visit_words_sep(opening_loc, previous, current); end

  # Visit a node that represents a write value. This is used to handle the
  # special case of an implicit array that is generated without brackets.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3363
  def visit_write_value(node); end

  # Returns true if there is a semicolon between the two locations.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3311
  def void_stmt?(left, right, allow_newline); end

  # This method is called when weak warning is produced by the parser.
  # +fmt+ and +args+ is printf style.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3430
  def warn(fmt, *args); end

  # This method is called when strong warning is produced by the parser.
  # +fmt+ and +args+ is printf style.
  #
  # pkg:gem/prism#lib/prism/translation/ripper.rb:3435
  def warning(fmt, *args); end

  class << self
    # Tokenizes the Ruby program and returns an array of an array,
    # which is formatted like
    # <code>[[lineno, column], type, token, state]</code>.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # use the +raise_errors+ keyword to raise a SyntaxError for an error in +src+.
    #
    #     require "ripper"
    #     require "pp"
    #
    #     pp Ripper.lex("def m(a) nil end")
    #     #=> [[[1,  0], :on_kw,     "def", FNAME    ],
    #          [[1,  3], :on_sp,     " ",   FNAME    ],
    #          [[1,  4], :on_ident,  "m",   ENDFN    ],
    #          [[1,  5], :on_lparen, "(",   BEG|LABEL],
    #          [[1,  6], :on_ident,  "a",   ARG      ],
    #          [[1,  7], :on_rparen, ")",   ENDFN    ],
    #          [[1,  8], :on_sp,     " ",   BEG      ],
    #          [[1,  9], :on_kw,     "nil", END      ],
    #          [[1, 12], :on_sp,     " ",   END      ],
    #          [[1, 13], :on_kw,     "end", END      ]]
    #
    # pkg:gem/prism#lib/prism/translation/ripper.rb:73
    def lex(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end

    # Parses the given Ruby program read from +src+.
    # +src+ must be a String or an IO or a object with a #gets method.
    #
    # pkg:gem/prism#lib/prism/translation/ripper.rb:47
    def parse(src, filename = T.unsafe(nil), lineno = T.unsafe(nil)); end

    # Parses +src+ and create S-exp tree.
    # Returns more readable tree rather than Ripper.sexp_raw.
    # This method is mainly for developer use.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # returning +nil+ in such cases. Use the +raise_errors+ keyword
    # to raise a SyntaxError for an error in +src+.
    #
    #     require "ripper"
    #     require "pp"
    #
    #     pp Ripper.sexp("def m(a) nil end")
    #       #=> [:program,
    #            [[:def,
    #             [:@ident, "m", [1, 4]],
    #             [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil, nil, nil, nil]],
    #             [:bodystmt, [[:var_ref, [:@kw, "nil", [1, 9]]]], nil, nil, nil]]]]
    #
    # pkg:gem/prism#lib/prism/translation/ripper.rb:382
    def sexp(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end

    # Parses +src+ and create S-exp tree.
    # This method is mainly for developer use.
    # The +filename+ argument is mostly ignored.
    # By default, this method does not handle syntax errors in +src+,
    # returning +nil+ in such cases. Use the +raise_errors+ keyword
    # to raise a SyntaxError for an error in +src+.
    #
    #     require "ripper"
    #     require "pp"
    #
    #     pp Ripper.sexp_raw("def m(a) nil end")
    #       #=> [:program,
    #            [:stmts_add,
    #             [:stmts_new],
    #             [:def,
    #              [:@ident, "m", [1, 4]],
    #              [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil]],
    #              [:bodystmt,
    #               [:stmts_add, [:stmts_new], [:var_ref, [:@kw, "nil", [1, 9]]]],
    #               nil,
    #               nil,
    #               nil]]]]
    #
    # pkg:gem/prism#lib/prism/translation/ripper.rb:417
    def sexp_raw(src, filename = T.unsafe(nil), lineno = T.unsafe(nil), raise_errors: T.unsafe(nil)); end
  end
end

# A list of all of the Ruby binary operators.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:338
Prism::Translation::Ripper::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)

# This array contains name of all ripper events.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:290
Prism::Translation::Ripper::EVENTS = T.let(T.unsafe(nil), Array)

# A list of all of the Ruby keywords.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:293
Prism::Translation::Ripper::KEYWORDS = T.let(T.unsafe(nil), Array)

# This array contains name of parser events.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:284
Prism::Translation::Ripper::PARSER_EVENTS = T.let(T.unsafe(nil), Array)

# This contains a table of all of the parser events and their
# corresponding arity.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:85
Prism::Translation::Ripper::PARSER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

# This array contains name of scanner events.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:287
Prism::Translation::Ripper::SCANNER_EVENTS = T.let(T.unsafe(nil), Array)

# This contains a table of all of the scanner events and their
# corresponding arity.
#
# pkg:gem/prism#lib/prism/translation/ripper.rb:228
Prism::Translation::Ripper::SCANNER_EVENT_TABLE = T.let(T.unsafe(nil), Hash)

# This class mirrors the ::Ripper::SexpBuilder subclass of ::Ripper that
# returns the arrays of [type, *children].
#
# pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:11
class Prism::Translation::Ripper::SexpBuilder < ::Prism::Translation::Ripper
  # :stopdoc:
  #
  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:14
  def error; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_BEGIN(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_CHAR(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_END(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on___end__(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_alias(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_alias_error(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_aref(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_aref_field(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_arg_ambiguous(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_arg_paren(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_args_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_args_add_block(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_args_add_star(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_args_forward(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_args_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_array(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_aryptn(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_assign(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_assign_error(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_assoc_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_assoc_splat(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_assoclist_from_args(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_backref(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_backtick(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_bare_assoc_hash(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_begin(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_binary(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_block_var(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_blockarg(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_bodystmt(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_brace_block(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_break(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_call(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_case(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_class(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_class_name_error(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_comma(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_command(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_command_call(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_comment(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_const(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_const_path_field(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_const_path_ref(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_const_ref(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_cvar(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_def(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_defined(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_defs(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_do_block(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_dot2(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_dot3(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_dyna_symbol(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_else(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_elsif(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embdoc(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embdoc_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embdoc_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embexpr_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embexpr_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_embvar(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_ensure(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_excessed_comma(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_fcall(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_field(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_float(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_fndptn(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_for(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_gvar(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_hash(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_heredoc_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_heredoc_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_hshptn(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_ident(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_if(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_if_mod(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_ifop(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_ignored_nl(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_ignored_sp(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_imaginary(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_in(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_int(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_ivar(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_kw(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_kwrest_param(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_label(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_label_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_lambda(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_lbrace(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_lbracket(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_lparen(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_magic_comment(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_massign(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_method_add_arg(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_method_add_block(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mlhs_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mlhs_add_post(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mlhs_add_star(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mlhs_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mlhs_paren(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_module(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mrhs_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mrhs_add_star(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mrhs_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_mrhs_new_from_args(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_next(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_nl(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_nokw_param(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_op(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_opassign(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_operator_ambiguous(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_param_error(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_params(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_paren(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_period(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_program(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_qsymbols_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_qsymbols_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_qsymbols_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_qwords_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_qwords_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_qwords_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_rational(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_rbrace(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_rbracket(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_redo(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_regexp_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_regexp_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_regexp_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_regexp_literal(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_regexp_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_rescue(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_rescue_mod(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_rest_param(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_retry(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_return(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_return0(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_rparen(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_sclass(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_semicolon(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_sp(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_stmts_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_stmts_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_concat(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_content(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_dvar(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_embexpr(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_string_literal(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_super(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_symbeg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_symbol(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_symbol_literal(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_symbols_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_symbols_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_symbols_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_tlambda(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_tlambeg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_top_const_field(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_top_const_ref(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_tstring_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_tstring_content(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_tstring_end(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_unary(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_undef(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_unless(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_unless_mod(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_until(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_until_mod(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_var_alias(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_var_field(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_var_ref(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_vcall(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_void_stmt(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_when(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_while(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_while_mod(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_word_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_word_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_words_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_words_beg(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_words_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:55
  def on_words_sep(tok); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_xstring_add(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_xstring_literal(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_xstring_new(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_yield(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_yield0(*args); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_zsuper(*args); end

  private

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:67
  def compile_error(mesg); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:18
  def dedent_element(e, width); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:62
  def on_error(mesg); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:25
  def on_heredoc_dedent(val, width); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:47
  def on_parse_error(mesg); end
end

# This class mirrors the ::Ripper::SexpBuilderPP subclass of ::Ripper that
# returns the same values as ::Ripper::SexpBuilder except with a couple of
# niceties that flatten linked lists into arrays.
#
# pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:75
class Prism::Translation::Ripper::SexpBuilderPP < ::Prism::Translation::Ripper::SexpBuilder
  private

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:93
  def _dispatch_event_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:97
  def _dispatch_event_push(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_args_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_args_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:80
  def on_heredoc_dedent(val, width); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_mlhs_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:110
  def on_mlhs_add_post(list, post); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:106
  def on_mlhs_add_star(list, star); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_mlhs_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:102
  def on_mlhs_paren(list); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_mrhs_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_mrhs_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_qsymbols_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_qsymbols_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_qwords_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_qwords_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_regexp_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_regexp_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_stmts_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_stmts_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_string_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_symbols_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_symbols_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_word_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_word_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_words_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_words_new; end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:118
  def on_xstring_add(list, item); end

  # pkg:gem/prism#lib/prism/translation/ripper/sexp.rb:116
  def on_xstring_new; end
end

# This module is the entry-point for converting a prism syntax tree into the
# seattlerb/ruby_parser gem's syntax tree.
#
# pkg:gem/prism#lib/prism/translation/ruby_parser.rb:20
class Prism::Translation::RubyParser
  # Parse the given source and translate it into the seattlerb/ruby_parser
  # gem's Sexp format.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1917
  def parse(source, filepath = T.unsafe(nil)); end

  # Parse the given file and translate it into the seattlerb/ruby_parser
  # gem's Sexp format.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1923
  def parse_file(filepath); end

  # Parse the give file and translate it into the
  # seattlerb/ruby_parser gem's Sexp format. This method is
  # provided for API compatibility to RubyParser and takes an
  # optional +timeout+ argument.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1931
  def process(ruby, file = T.unsafe(nil), timeout = T.unsafe(nil)); end

  private

  # Translate the given parse result and filepath into the
  # seattlerb/ruby_parser gem's Sexp format.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1953
  def translate(result, filepath); end

  class << self
    # Parse the given source and translate it into the seattlerb/ruby_parser
    # gem's Sexp format.
    #
    # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1938
    def parse(source, filepath = T.unsafe(nil)); end

    # Parse the given file and translate it into the seattlerb/ruby_parser
    # gem's Sexp format.
    #
    # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1944
    def parse_file(filepath); end
  end
end

# A prism visitor that builds Sexp objects.
#
# pkg:gem/prism#lib/prism/translation/ruby_parser.rb:22
class Prism::Translation::RubyParser::Compiler < ::Prism::Compiler
  # Initialize a new compiler with the given file name.
  #
  # @return [Compiler] a new instance of Compiler
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:37
  def initialize(file, in_def: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # This is the name of the file that we are compiling. We set it on every
  # Sexp object that is generated, and also use it to compile `__FILE__`
  # nodes.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:26
  def file; end

  # Class variables will change their type based on if they are inside of
  # a method definition or not, so we need to track that state.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:30
  def in_def; end

  # Some nodes will change their representation if they are inside of a
  # pattern, so we need to track that state.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:34
  def in_pattern; end

  # ```
  # alias $foo $bar
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:55
  def visit_alias_global_variable_node(node); end

  # ```
  # alias foo bar
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:47
  def visit_alias_method_node(node); end

  # ```
  # foo => bar | baz
  #        ^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:63
  def visit_alternation_pattern_node(node); end

  # ```
  # a and b
  # ^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:71
  def visit_and_node(node); end

  # ```
  # foo(bar)
  #     ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:128
  def visit_arguments_node(node); end

  # ```
  # []
  # ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:91
  def visit_array_node(node); end

  # ```
  # foo => [bar]
  #        ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:103
  def visit_array_pattern_node(node); end

  # ```
  # { a: 1 }
  #   ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:136
  def visit_assoc_node(node); end

  # ```
  # def foo(**); bar(**); end
  #                  ^^
  #
  # { **foo }
  #   ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:147
  def visit_assoc_splat_node(node); end

  # ```
  # $+
  # ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:159
  def visit_back_reference_read_node(node); end

  # ```
  # begin end
  # ^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:167
  def visit_begin_node(node); end

  # ```
  # foo(&bar)
  #     ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:202
  def visit_block_argument_node(node); end

  # ```
  # foo { |; bar| }
  #          ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:212
  def visit_block_local_variable_node(node); end

  # A block on a keyword or method call.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:217
  def visit_block_node(node); end

  # ```
  # def foo(&bar); end
  #         ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:225
  def visit_block_parameter_node(node); end

  # A block's parameters.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:230
  def visit_block_parameters_node(node); end

  # ```
  # break
  # ^^^^^
  #
  # break foo
  # ^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:272
  def visit_break_node(node); end

  # ```
  # foo.bar &&= baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:346
  def visit_call_and_write_node(node); end

  # ```
  # foo
  # ^^^
  #
  # foo.bar
  # ^^^^^^^
  #
  # foo.bar() {}
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:292
  def visit_call_node(node); end

  # ```
  # foo.bar += baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:334
  def visit_call_operator_write_node(node); end

  # ```
  # foo.bar ||= baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:358
  def visit_call_or_write_node(node); end

  # ```
  # foo.bar, = 1
  # ^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:383
  def visit_call_target_node(node); end

  # ```
  # foo => bar => baz
  #        ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:391
  def visit_capture_pattern_node(node); end

  # ```
  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:407
  def visit_case_match_node(node); end

  # ```
  # case foo; when bar; end
  # ^^^^^^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:399
  def visit_case_node(node); end

  # ```
  # class Foo; end
  # ^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:415
  def visit_class_node(node); end

  # ```
  # @@foo &&= bar
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:468
  def visit_class_variable_and_write_node(node); end

  # ```
  # @@foo += bar
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:460
  def visit_class_variable_operator_write_node(node); end

  # ```
  # @@foo ||= bar
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:476
  def visit_class_variable_or_write_node(node); end

  # ```
  # @@foo
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:441
  def visit_class_variable_read_node(node); end

  # ```
  # @@foo, = bar
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:484
  def visit_class_variable_target_node(node); end

  # ```
  # @@foo = 1
  # ^^^^^^^^^
  #
  # @@foo, @@bar = 1
  # ^^^^^  ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:452
  def visit_class_variable_write_node(node); end

  # ```
  # Foo &&= bar
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:525
  def visit_constant_and_write_node(node); end

  # ```
  # Foo += bar
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:517
  def visit_constant_operator_write_node(node); end

  # ```
  # Foo ||= bar
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:533
  def visit_constant_or_write_node(node); end

  # ```
  # Foo::Bar &&= baz
  # ^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:580
  def visit_constant_path_and_write_node(node); end

  # ```
  # Foo::Bar
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:549
  def visit_constant_path_node(node); end

  # ```
  # Foo::Bar += baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:572
  def visit_constant_path_operator_write_node(node); end

  # ```
  # Foo::Bar ||= baz
  # ^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:588
  def visit_constant_path_or_write_node(node); end

  # ```
  # Foo::Bar, = baz
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:596
  def visit_constant_path_target_node(node); end

  # ```
  # Foo::Bar = 1
  # ^^^^^^^^^^^^
  #
  # Foo::Foo, Bar::Bar = 1
  # ^^^^^^^^  ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:564
  def visit_constant_path_write_node(node); end

  # ```
  # Foo
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:498
  def visit_constant_read_node(node); end

  # ```
  # Foo, = bar
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:541
  def visit_constant_target_node(node); end

  # ```
  # Foo = 1
  # ^^^^^^^
  #
  # Foo, Bar = 1
  # ^^^  ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:509
  def visit_constant_write_node(node); end

  # ```
  # def foo; end
  # ^^^^^^^^^^^^
  #
  # def self.foo; end
  # ^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:614
  def visit_def_node(node); end

  # ```
  # defined? a
  # ^^^^^^^^^^
  #
  # defined?(a)
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:649
  def visit_defined_node(node); end

  # ```
  # if foo then bar else baz end
  #                 ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:657
  def visit_else_node(node); end

  # ```
  # "foo #{bar}"
  #      ^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:665
  def visit_embedded_statements_node(node); end

  # ```
  # "foo #@bar"
  #      ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:675
  def visit_embedded_variable_node(node); end

  # ```
  # begin; foo; ensure; bar; end
  #             ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:683
  def visit_ensure_node(node); end

  # ```
  # false
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:691
  def visit_false_node(node); end

  # ```
  # foo => [*, bar, *]
  #        ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:699
  def visit_find_pattern_node(node); end

  # ```
  # if foo .. bar; end
  #    ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:707
  def visit_flip_flop_node(node); end

  # ```
  # 1.0
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:719
  def visit_float_node(node); end

  # ```
  # for foo in bar do end
  # ^^^^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:727
  def visit_for_node(node); end

  # ```
  # def foo(...); bar(...); end
  #                   ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:735
  def visit_forwarding_arguments_node(node); end

  # ```
  # def foo(...); end
  #         ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:743
  def visit_forwarding_parameter_node(node); end

  # ```
  # super
  # ^^^^^
  #
  # super {}
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:754
  def visit_forwarding_super_node(node); end

  # ```
  # $foo &&= bar
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:789
  def visit_global_variable_and_write_node(node); end

  # ```
  # $foo += bar
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:781
  def visit_global_variable_operator_write_node(node); end

  # ```
  # $foo ||= bar
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:797
  def visit_global_variable_or_write_node(node); end

  # ```
  # $foo
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:762
  def visit_global_variable_read_node(node); end

  # ```
  # $foo, = bar
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:805
  def visit_global_variable_target_node(node); end

  # ```
  # $foo = 1
  # ^^^^^^^^
  #
  # $foo, $bar = 1
  # ^^^^  ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:773
  def visit_global_variable_write_node(node); end

  # ```
  # {}
  # ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:813
  def visit_hash_node(node); end

  # ```
  # foo => {}
  #        ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:821
  def visit_hash_pattern_node(node); end

  # ```
  # if foo then bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar if foo
  # ^^^^^^^^^^
  #
  # foo ? bar : baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:844
  def visit_if_node(node); end

  # 1i
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:849
  def visit_imaginary_node(node); end

  # ```
  # { foo: }
  #   ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:857
  def visit_implicit_node(node); end

  # ```
  # foo { |bar,| }
  #           ^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:864
  def visit_implicit_rest_node(node); end

  # ```
  # case foo; in bar; end
  # ^^^^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:871
  def visit_in_node(node); end

  # ```
  # foo[bar] &&= baz
  # ^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:901
  def visit_index_and_write_node(node); end

  # ```
  # foo[bar] += baz
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:886
  def visit_index_operator_write_node(node); end

  # ```
  # foo[bar] ||= baz
  # ^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:916
  def visit_index_or_write_node(node); end

  # ```
  # foo[bar], = 1
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:931
  def visit_index_target_node(node); end

  # ```
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:969
  def visit_instance_variable_and_write_node(node); end

  # ```
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:961
  def visit_instance_variable_operator_write_node(node); end

  # ```
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:977
  def visit_instance_variable_or_write_node(node); end

  # ```
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:942
  def visit_instance_variable_read_node(node); end

  # ```
  # @foo, = bar
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:985
  def visit_instance_variable_target_node(node); end

  # ```
  # ^^^^^^^^
  #
  # @foo, @bar = 1
  # ^^^^  ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:953
  def visit_instance_variable_write_node(node); end

  # ```
  # 1
  # ^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:993
  def visit_integer_node(node); end

  # ```
  # if /foo #{bar}/ then end
  #    ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1001
  def visit_interpolated_match_last_line_node(node); end

  # ```
  # /foo #{bar}/
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1020
  def visit_interpolated_regular_expression_node(node); end

  # ```
  # "foo #{bar}"
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1037
  def visit_interpolated_string_node(node); end

  # ```
  # :"foo #{bar}"
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1046
  def visit_interpolated_symbol_node(node); end

  # ```
  # `foo #{bar}`
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1055
  def visit_interpolated_x_string_node(node); end

  # ```
  # -> { it }
  #      ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1138
  def visit_it_local_variable_read_node(node); end

  # ```
  # foo(bar: baz)
  #     ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1146
  def visit_keyword_hash_node(node); end

  # ```
  # def foo(**bar); end
  #         ^^^^^
  #
  # def foo(**); end
  #         ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1157
  def visit_keyword_rest_parameter_node(node); end

  # -> {}
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1162
  def visit_lambda_node(node); end

  # ```
  # foo &&= bar
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1213
  def visit_local_variable_and_write_node(node); end

  # ```
  # foo += bar
  # ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1205
  def visit_local_variable_operator_write_node(node); end

  # ```
  # foo ||= bar
  # ^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1221
  def visit_local_variable_or_write_node(node); end

  # ```
  # foo
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1182
  def visit_local_variable_read_node(node); end

  # ```
  # foo, = bar
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1229
  def visit_local_variable_target_node(node); end

  # ```
  # foo = 1
  # ^^^^^^^
  #
  # foo, bar = 1
  # ^^^  ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1197
  def visit_local_variable_write_node(node); end

  # ```
  # if /foo/ then end
  #    ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1237
  def visit_match_last_line_node(node); end

  # ```
  # foo in bar
  # ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1245
  def visit_match_predicate_node(node); end

  # ```
  # foo => bar
  # ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1253
  def visit_match_required_node(node); end

  # ```
  # /(?<foo>foo)/ =~ bar
  # ^^^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1261
  def visit_match_write_node(node); end

  # A node that is missing from the syntax tree. This is only used in the
  # case of a syntax error. The parser gem doesn't have such a concept, so
  # we invent our own here.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1268
  def visit_missing_node(node); end

  # ```
  # module Foo; end
  # ^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1276
  def visit_module_node(node); end

  # ```
  # foo, bar = baz
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1302
  def visit_multi_target_node(node); end

  # ```
  # foo, bar = baz
  # ^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1314
  def visit_multi_write_node(node); end

  # ```
  # next
  # ^^^^
  #
  # next foo
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1340
  def visit_next_node(node); end

  # ```
  # nil
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1355
  def visit_nil_node(node); end

  # ```
  # def foo(**nil); end
  #         ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1363
  def visit_no_keywords_parameter_node(node); end

  # ```
  # -> { _1 + _2 }
  # ^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1371
  def visit_numbered_parameters_node(node); end

  # ```
  # $1
  # ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1379
  def visit_numbered_reference_read_node(node); end

  # ```
  # def foo(bar: baz); end
  #         ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1387
  def visit_optional_keyword_parameter_node(node); end

  # ```
  # def foo(bar = 1); end
  #         ^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1395
  def visit_optional_parameter_node(node); end

  # ```
  # a or b
  # ^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1403
  def visit_or_node(node); end

  # ```
  # def foo(bar, *baz); end
  #         ^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1423
  def visit_parameters_node(node); end

  # ```
  # ()
  # ^^
  #
  # (1)
  # ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1465
  def visit_parentheses_node(node); end

  # ```
  # foo => ^(bar)
  #        ^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1477
  def visit_pinned_expression_node(node); end

  # ```
  # foo = 1 and bar => ^foo
  #                    ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1485
  def visit_pinned_variable_node(node); end

  # END {}
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1494
  def visit_post_execution_node(node); end

  # BEGIN {}
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1499
  def visit_pre_execution_node(node); end

  # The top-level program node.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1504
  def visit_program_node(node); end

  # ```
  # 0..5
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1512
  def visit_range_node(node); end

  # ```
  # 1r
  # ^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1536
  def visit_rational_node(node); end

  # ```
  # redo
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1544
  def visit_redo_node(node); end

  # ```
  # /foo/
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1552
  def visit_regular_expression_node(node); end

  # ```
  # def foo(bar:); end
  #         ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1560
  def visit_required_keyword_parameter_node(node); end

  # ```
  # def foo(bar); end
  #         ^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1568
  def visit_required_parameter_node(node); end

  # ```
  # foo rescue bar
  # ^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1576
  def visit_rescue_modifier_node(node); end

  # ```
  # begin; rescue; end
  #        ^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1584
  def visit_rescue_node(node); end

  # ```
  # def foo(*bar); end
  #         ^^^^
  #
  # def foo(*); end
  #         ^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1606
  def visit_rest_parameter_node(node); end

  # ```
  # retry
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1614
  def visit_retry_node(node); end

  # ```
  # return
  # ^^^^^^
  #
  # return 1
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1625
  def visit_return_node(node); end

  # ```
  # self
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1640
  def visit_self_node(node); end

  # A shareable constant.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1645
  def visit_shareable_constant_node(node); end

  # ```
  # class << self; end
  # ^^^^^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1653
  def visit_singleton_class_node(node); end

  # ```
  # __ENCODING__
  # ^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1663
  def visit_source_encoding_node(node); end

  # ```
  # __FILE__
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1672
  def visit_source_file_node(node); end

  # ```
  # __LINE__
  # ^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1680
  def visit_source_line_node(node); end

  # ```
  # foo(*bar)
  #     ^^^^
  #
  # def foo((bar, *baz)); end
  #               ^^^^
  #
  # def foo(*); bar(*); end
  #                 ^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1694
  def visit_splat_node(node); end

  # A list of statements.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1703
  def visit_statements_node(node); end

  # ```
  # "foo"
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1717
  def visit_string_node(node); end

  # ```
  # super(foo)
  # ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1732
  def visit_super_node(node); end

  # ```
  # :foo
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1748
  def visit_symbol_node(node); end

  # ```
  # true
  # ^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1756
  def visit_true_node(node); end

  # ```
  # undef foo
  # ^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1764
  def visit_undef_node(node); end

  # ```
  # unless foo; bar end
  # ^^^^^^^^^^^^^^^^^^^
  #
  # bar unless foo
  # ^^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1776
  def visit_unless_node(node); end

  # ```
  # until foo; bar end
  # ^^^^^^^^^^^^^^^^^
  #
  # bar until foo
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1787
  def visit_until_node(node); end

  # ```
  # case foo; when bar; end
  #           ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1795
  def visit_when_node(node); end

  # ```
  # while foo; bar end
  # ^^^^^^^^^^^^^^^^^^
  #
  # bar while foo
  # ^^^^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1806
  def visit_while_node(node); end

  # ```
  # `foo`
  # ^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1814
  def visit_x_string_node(node); end

  # ```
  # yield
  # ^^^^^
  #
  # yield 1
  # ^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1832
  def visit_yield_node(node); end

  private

  # Attach prism comments to the given sexp.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1839
  def attach_comments(sexp, node); end

  # If a class variable is written within a method definition, it has a
  # different type than everywhere else.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:490
  def class_variable_write_type; end

  # Create a new compiler with the given options.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1850
  def copy_compiler(in_def: T.unsafe(nil), in_pattern: T.unsafe(nil)); end

  # Call nodes with operators following them will either be op_asgn or
  # op_asgn2 nodes. That is determined by their call operator and their
  # right-hand side.
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:369
  def op_asgn?(node); end

  # Call nodes with operators following them can use &. as an operator,
  # which changes their type by prefixing "safe_".
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:375
  def op_asgn_type(node, type); end

  # Create a new Sexp object from the given prism node and arguments.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1855
  def s(node, *arguments); end

  # Visit a block node, which will modify the AST by wrapping the given
  # visited node in an iter node.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1865
  def visit_block(node, sexp, block); end

  # ```
  # def foo((bar, baz)); end
  #         ^^^^^^^^^^
  # ```
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1440
  def visit_destructured_parameter(node); end

  # Visit the interpolated content of the string-like node.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1062
  def visit_interpolated_parts(parts); end

  # Pattern constants get wrapped in another layer of :const.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1886
  def visit_pattern_constant(node); end

  # If the bounds of a range node are empty parentheses, then they do not
  # get replaced by their usual s(:nil), but instead are s(:begin).
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1524
  def visit_range_bounds_node(node); end

  # Visit the value of a write, which will be on the right-hand side of
  # a write operator. Because implicit arrays can have splats, those could
  # potentially be wrapped in an svalue node.
  #
  # pkg:gem/prism#lib/prism/translation/ruby_parser.rb:1900
  def visit_write_value(node); end
end

# Represents the use of the literal `true` keyword.
#
#     true
#     ^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17578
class Prism::TrueNode < ::Prism::Node
  # Initialize a new TrueNode node.
  #
  # @return [TrueNode] a new instance of TrueNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17580
  sig { params(source: Prism::Source, node_id: Integer, location: Prism::Location, flags: Integer).void }
  def initialize(source, node_id, location, flags); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17637
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17588
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17593
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17603
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17598
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> TrueNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17608
  sig { params(node_id: Integer, location: Prism::Location, flags: Integer).returns(Prism::TrueNode) }
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17613
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:17616
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17621
  sig { override.returns(String) }
  def inspect; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17626
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17631
    def type; end
  end
end

# Represents the use of the `undef` keyword.
#
#     undef :foo, :bar, :baz
#     ^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17646
class Prism::UndefNode < ::Prism::Node
  # Initialize a new UndefNode node.
  #
  # @return [UndefNode] a new instance of UndefNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17648
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).void
  end
  def initialize(source, node_id, location, flags, names, keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17728
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17658
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17663
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17673
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17668
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?names: Array[SymbolNode | InterpolatedSymbolNode], ?keyword_loc: Location) -> UndefNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17678
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      names: T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)],
      keyword_loc: Prism::Location
    ).returns(Prism::UndefNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17683
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, names: Array[SymbolNode | InterpolatedSymbolNode], keyword_loc: Location }
  #
  # pkg:gem/prism#lib/prism/node.rb:17686
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17712
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17707
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:17694
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # attr_reader names: Array[SymbolNode | InterpolatedSymbolNode]
  #
  # pkg:gem/prism#lib/prism/node.rb:17691
  sig { returns(T::Array[T.any(Prism::SymbolNode, Prism::InterpolatedSymbolNode)]) }
  def names; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17702
  def save_keyword_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17717
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17722
    def type; end
  end
end

# Represents the use of the `unless` keyword, either in the block form or the modifier form.
#
#     bar unless foo
#     ^^^^^^^^^^^^^^
#
#     unless foo then bar end
#     ^^^^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17743
class Prism::UnlessNode < ::Prism::Node
  # Initialize a new UnlessNode node.
  #
  # @return [UnlessNode] a new instance of UnlessNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17745
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, predicate, then_keyword_loc, statements, else_clause, end_keyword_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:17912
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17759
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17764
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17778
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17769
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # Returns the else clause of the unless node. This method is deprecated in
  # favor of #else_clause.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:506
  def consequent; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?else_clause: ElseNode?, ?end_keyword_loc: Location?) -> UnlessNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17783
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      predicate: Prism::Node,
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode),
      else_clause: T.nilable(Prism::ElseNode),
      end_keyword_loc: T.nilable(Prism::Location)
    ).returns(Prism::UnlessNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17788
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, else_clause: ElseNode?, end_keyword_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:17791
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # The else clause of the unless expression, if present.
  #
  #     unless cond then bar else baz end
  #                          ^^^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17856
  sig { returns(T.nilable(Prism::ElseNode)) }
  def else_clause; end

  # def end_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17891
  sig { returns(T.nilable(String)) }
  def end_keyword; end

  # The location of the `end` keyword, if present.
  #
  #     unless cond then bar end
  #                          ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17862
  sig { returns(T.nilable(Prism::Location)) }
  def end_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17896
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:17881
  sig { returns(String) }
  def keyword; end

  # The location of the `unless` keyword.
  #
  #     unless cond then bar end
  #     ^^^^^^
  #
  #     bar unless cond
  #         ^^^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17802
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:98
  def newline_flag!(lines); end

  # The condition to be evaluated for the unless expression. It can be any [non-void expression](https://github.com/ruby/prism/blob/main/docs/parsing_rules.md#non-void-expression).
  #
  #     unless cond then bar end
  #            ^^^^
  #
  #     bar unless cond
  #                ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17821
  sig { returns(Prism::Node) }
  def predicate; end

  # Save the end_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17876
  def save_end_keyword_loc(repository); end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17810
  def save_keyword_loc(repository); end

  # Save the then_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17841
  def save_then_keyword_loc(repository); end

  # The body of statements that will executed if the unless condition is
  # falsey. Will be `nil` if no body is provided.
  #
  #     unless cond then bar end
  #                      ^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17850
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:17886
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # The location of the `then` keyword, if present.
  #
  #     unless cond then bar end
  #                 ^^^^
  #
  # pkg:gem/prism#lib/prism/node.rb:17827
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:17901
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:17906
    def type; end
  end
end

# Represents the use of the `until` keyword, either in the block form or the modifier form.
#
#     bar until foo
#     ^^^^^^^^^^^^^
#
#     until foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:17930
class Prism::UntilNode < ::Prism::Node
  # Initialize a new UntilNode node.
  #
  # @return [UntilNode] a new instance of UntilNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17932
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:18074
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:17945
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:17981
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17950
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18053
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18018
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:17963
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:17955
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> UntilNode
  #
  # pkg:gem/prism#lib/prism/node.rb:17968
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::UntilNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:17973
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, do_keyword_loc: Location?, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:17976
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18048
  sig { returns(T.nilable(String)) }
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:17999
  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18058
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18043
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:17986
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:104
  def newline_flag!(lines); end

  # attr_reader predicate: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:18037
  sig { returns(Prism::Node) }
  def predicate; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18032
  def save_closing_loc(repository); end

  # Save the do_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18013
  def save_do_keyword_loc(repository); end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:17994
  def save_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:18040
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:18063
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:18068
    def type; end
  end
end

# The version constant is set by reading the result of calling pm_version.
Prism::VERSION = T.let(T.unsafe(nil), String)

# A visitor is a class that provides a default implementation for every accept
# method defined on the nodes. This means it can walk a tree without the
# caller needing to define any special handling. This allows you to handle a
# subset of the tree, while still walking the whole tree.
#
# For example, to find all of the method calls that call the `foo` method, you
# could write:
#
#     class FooCalls < Prism::Visitor
#       def visit_call_node(node)
#         if node.name == :foo
#           # Do something with the node
#         end
#
#         # Call super so that the visitor continues walking the tree
#         super
#       end
#     end
#
# pkg:gem/prism#lib/prism/visitor.rb:57
class Prism::Visitor < ::Prism::BasicVisitor
  # Visit a AliasGlobalVariableNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:59
  sig { params(node: Prism::AliasGlobalVariableNode).void }
  def visit_alias_global_variable_node(node); end

  # Visit a AliasMethodNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:64
  sig { params(node: Prism::AliasMethodNode).void }
  def visit_alias_method_node(node); end

  # Visit a AlternationPatternNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:69
  sig { params(node: Prism::AlternationPatternNode).void }
  def visit_alternation_pattern_node(node); end

  # Visit a AndNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:74
  sig { params(node: Prism::AndNode).void }
  def visit_and_node(node); end

  # Visit a ArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:79
  sig { params(node: Prism::ArgumentsNode).void }
  def visit_arguments_node(node); end

  # Visit a ArrayNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:84
  sig { params(node: Prism::ArrayNode).void }
  def visit_array_node(node); end

  # Visit a ArrayPatternNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:89
  sig { params(node: Prism::ArrayPatternNode).void }
  def visit_array_pattern_node(node); end

  # Visit a AssocNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:94
  sig { params(node: Prism::AssocNode).void }
  def visit_assoc_node(node); end

  # Visit a AssocSplatNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:99
  sig { params(node: Prism::AssocSplatNode).void }
  def visit_assoc_splat_node(node); end

  # Visit a BackReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:104
  sig { params(node: Prism::BackReferenceReadNode).void }
  def visit_back_reference_read_node(node); end

  # Visit a BeginNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:109
  sig { params(node: Prism::BeginNode).void }
  def visit_begin_node(node); end

  # Visit a BlockArgumentNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:114
  sig { params(node: Prism::BlockArgumentNode).void }
  def visit_block_argument_node(node); end

  # Visit a BlockLocalVariableNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:119
  sig { params(node: Prism::BlockLocalVariableNode).void }
  def visit_block_local_variable_node(node); end

  # Visit a BlockNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:124
  sig { params(node: Prism::BlockNode).void }
  def visit_block_node(node); end

  # Visit a BlockParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:129
  sig { params(node: Prism::BlockParameterNode).void }
  def visit_block_parameter_node(node); end

  # Visit a BlockParametersNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:134
  sig { params(node: Prism::BlockParametersNode).void }
  def visit_block_parameters_node(node); end

  # Visit a BreakNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:139
  sig { params(node: Prism::BreakNode).void }
  def visit_break_node(node); end

  # Visit a CallAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:144
  sig { params(node: Prism::CallAndWriteNode).void }
  def visit_call_and_write_node(node); end

  # Visit a CallNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:149
  sig { params(node: Prism::CallNode).void }
  def visit_call_node(node); end

  # Visit a CallOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:154
  sig { params(node: Prism::CallOperatorWriteNode).void }
  def visit_call_operator_write_node(node); end

  # Visit a CallOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:159
  sig { params(node: Prism::CallOrWriteNode).void }
  def visit_call_or_write_node(node); end

  # Visit a CallTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:164
  sig { params(node: Prism::CallTargetNode).void }
  def visit_call_target_node(node); end

  # Visit a CapturePatternNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:169
  sig { params(node: Prism::CapturePatternNode).void }
  def visit_capture_pattern_node(node); end

  # Visit a CaseMatchNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:174
  sig { params(node: Prism::CaseMatchNode).void }
  def visit_case_match_node(node); end

  # Visit a CaseNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:179
  sig { params(node: Prism::CaseNode).void }
  def visit_case_node(node); end

  # Visit a ClassNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:184
  sig { params(node: Prism::ClassNode).void }
  def visit_class_node(node); end

  # Visit a ClassVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:189
  sig { params(node: Prism::ClassVariableAndWriteNode).void }
  def visit_class_variable_and_write_node(node); end

  # Visit a ClassVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:194
  sig { params(node: Prism::ClassVariableOperatorWriteNode).void }
  def visit_class_variable_operator_write_node(node); end

  # Visit a ClassVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:199
  sig { params(node: Prism::ClassVariableOrWriteNode).void }
  def visit_class_variable_or_write_node(node); end

  # Visit a ClassVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:204
  sig { params(node: Prism::ClassVariableReadNode).void }
  def visit_class_variable_read_node(node); end

  # Visit a ClassVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:209
  sig { params(node: Prism::ClassVariableTargetNode).void }
  def visit_class_variable_target_node(node); end

  # Visit a ClassVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:214
  sig { params(node: Prism::ClassVariableWriteNode).void }
  def visit_class_variable_write_node(node); end

  # Visit a ConstantAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:219
  sig { params(node: Prism::ConstantAndWriteNode).void }
  def visit_constant_and_write_node(node); end

  # Visit a ConstantOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:224
  sig { params(node: Prism::ConstantOperatorWriteNode).void }
  def visit_constant_operator_write_node(node); end

  # Visit a ConstantOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:229
  sig { params(node: Prism::ConstantOrWriteNode).void }
  def visit_constant_or_write_node(node); end

  # Visit a ConstantPathAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:234
  sig { params(node: Prism::ConstantPathAndWriteNode).void }
  def visit_constant_path_and_write_node(node); end

  # Visit a ConstantPathNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:239
  sig { params(node: Prism::ConstantPathNode).void }
  def visit_constant_path_node(node); end

  # Visit a ConstantPathOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:244
  sig { params(node: Prism::ConstantPathOperatorWriteNode).void }
  def visit_constant_path_operator_write_node(node); end

  # Visit a ConstantPathOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:249
  sig { params(node: Prism::ConstantPathOrWriteNode).void }
  def visit_constant_path_or_write_node(node); end

  # Visit a ConstantPathTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:254
  sig { params(node: Prism::ConstantPathTargetNode).void }
  def visit_constant_path_target_node(node); end

  # Visit a ConstantPathWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:259
  sig { params(node: Prism::ConstantPathWriteNode).void }
  def visit_constant_path_write_node(node); end

  # Visit a ConstantReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:264
  sig { params(node: Prism::ConstantReadNode).void }
  def visit_constant_read_node(node); end

  # Visit a ConstantTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:269
  sig { params(node: Prism::ConstantTargetNode).void }
  def visit_constant_target_node(node); end

  # Visit a ConstantWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:274
  sig { params(node: Prism::ConstantWriteNode).void }
  def visit_constant_write_node(node); end

  # Visit a DefNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:279
  sig { params(node: Prism::DefNode).void }
  def visit_def_node(node); end

  # Visit a DefinedNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:284
  sig { params(node: Prism::DefinedNode).void }
  def visit_defined_node(node); end

  # Visit a ElseNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:289
  sig { params(node: Prism::ElseNode).void }
  def visit_else_node(node); end

  # Visit a EmbeddedStatementsNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:294
  sig { params(node: Prism::EmbeddedStatementsNode).void }
  def visit_embedded_statements_node(node); end

  # Visit a EmbeddedVariableNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:299
  sig { params(node: Prism::EmbeddedVariableNode).void }
  def visit_embedded_variable_node(node); end

  # Visit a EnsureNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:304
  sig { params(node: Prism::EnsureNode).void }
  def visit_ensure_node(node); end

  # Visit a FalseNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:309
  sig { params(node: Prism::FalseNode).void }
  def visit_false_node(node); end

  # Visit a FindPatternNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:314
  sig { params(node: Prism::FindPatternNode).void }
  def visit_find_pattern_node(node); end

  # Visit a FlipFlopNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:319
  sig { params(node: Prism::FlipFlopNode).void }
  def visit_flip_flop_node(node); end

  # Visit a FloatNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:324
  sig { params(node: Prism::FloatNode).void }
  def visit_float_node(node); end

  # Visit a ForNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:329
  sig { params(node: Prism::ForNode).void }
  def visit_for_node(node); end

  # Visit a ForwardingArgumentsNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:334
  sig { params(node: Prism::ForwardingArgumentsNode).void }
  def visit_forwarding_arguments_node(node); end

  # Visit a ForwardingParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:339
  sig { params(node: Prism::ForwardingParameterNode).void }
  def visit_forwarding_parameter_node(node); end

  # Visit a ForwardingSuperNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:344
  sig { params(node: Prism::ForwardingSuperNode).void }
  def visit_forwarding_super_node(node); end

  # Visit a GlobalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:349
  sig { params(node: Prism::GlobalVariableAndWriteNode).void }
  def visit_global_variable_and_write_node(node); end

  # Visit a GlobalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:354
  sig { params(node: Prism::GlobalVariableOperatorWriteNode).void }
  def visit_global_variable_operator_write_node(node); end

  # Visit a GlobalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:359
  sig { params(node: Prism::GlobalVariableOrWriteNode).void }
  def visit_global_variable_or_write_node(node); end

  # Visit a GlobalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:364
  sig { params(node: Prism::GlobalVariableReadNode).void }
  def visit_global_variable_read_node(node); end

  # Visit a GlobalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:369
  sig { params(node: Prism::GlobalVariableTargetNode).void }
  def visit_global_variable_target_node(node); end

  # Visit a GlobalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:374
  sig { params(node: Prism::GlobalVariableWriteNode).void }
  def visit_global_variable_write_node(node); end

  # Visit a HashNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:379
  sig { params(node: Prism::HashNode).void }
  def visit_hash_node(node); end

  # Visit a HashPatternNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:384
  sig { params(node: Prism::HashPatternNode).void }
  def visit_hash_pattern_node(node); end

  # Visit a IfNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:389
  sig { params(node: Prism::IfNode).void }
  def visit_if_node(node); end

  # Visit a ImaginaryNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:394
  sig { params(node: Prism::ImaginaryNode).void }
  def visit_imaginary_node(node); end

  # Visit a ImplicitNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:399
  sig { params(node: Prism::ImplicitNode).void }
  def visit_implicit_node(node); end

  # Visit a ImplicitRestNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:404
  sig { params(node: Prism::ImplicitRestNode).void }
  def visit_implicit_rest_node(node); end

  # Visit a InNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:409
  sig { params(node: Prism::InNode).void }
  def visit_in_node(node); end

  # Visit a IndexAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:414
  sig { params(node: Prism::IndexAndWriteNode).void }
  def visit_index_and_write_node(node); end

  # Visit a IndexOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:419
  sig { params(node: Prism::IndexOperatorWriteNode).void }
  def visit_index_operator_write_node(node); end

  # Visit a IndexOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:424
  sig { params(node: Prism::IndexOrWriteNode).void }
  def visit_index_or_write_node(node); end

  # Visit a IndexTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:429
  sig { params(node: Prism::IndexTargetNode).void }
  def visit_index_target_node(node); end

  # Visit a InstanceVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:434
  sig { params(node: Prism::InstanceVariableAndWriteNode).void }
  def visit_instance_variable_and_write_node(node); end

  # Visit a InstanceVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:439
  sig { params(node: Prism::InstanceVariableOperatorWriteNode).void }
  def visit_instance_variable_operator_write_node(node); end

  # Visit a InstanceVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:444
  sig { params(node: Prism::InstanceVariableOrWriteNode).void }
  def visit_instance_variable_or_write_node(node); end

  # Visit a InstanceVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:449
  sig { params(node: Prism::InstanceVariableReadNode).void }
  def visit_instance_variable_read_node(node); end

  # Visit a InstanceVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:454
  sig { params(node: Prism::InstanceVariableTargetNode).void }
  def visit_instance_variable_target_node(node); end

  # Visit a InstanceVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:459
  sig { params(node: Prism::InstanceVariableWriteNode).void }
  def visit_instance_variable_write_node(node); end

  # Visit a IntegerNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:464
  sig { params(node: Prism::IntegerNode).void }
  def visit_integer_node(node); end

  # Visit a InterpolatedMatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:469
  sig { params(node: Prism::InterpolatedMatchLastLineNode).void }
  def visit_interpolated_match_last_line_node(node); end

  # Visit a InterpolatedRegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:474
  sig { params(node: Prism::InterpolatedRegularExpressionNode).void }
  def visit_interpolated_regular_expression_node(node); end

  # Visit a InterpolatedStringNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:479
  sig { params(node: Prism::InterpolatedStringNode).void }
  def visit_interpolated_string_node(node); end

  # Visit a InterpolatedSymbolNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:484
  sig { params(node: Prism::InterpolatedSymbolNode).void }
  def visit_interpolated_symbol_node(node); end

  # Visit a InterpolatedXStringNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:489
  sig { params(node: Prism::InterpolatedXStringNode).void }
  def visit_interpolated_x_string_node(node); end

  # Visit a ItLocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:494
  sig { params(node: Prism::ItLocalVariableReadNode).void }
  def visit_it_local_variable_read_node(node); end

  # Visit a ItParametersNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:499
  sig { params(node: Prism::ItParametersNode).void }
  def visit_it_parameters_node(node); end

  # Visit a KeywordHashNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:504
  sig { params(node: Prism::KeywordHashNode).void }
  def visit_keyword_hash_node(node); end

  # Visit a KeywordRestParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:509
  sig { params(node: Prism::KeywordRestParameterNode).void }
  def visit_keyword_rest_parameter_node(node); end

  # Visit a LambdaNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:514
  sig { params(node: Prism::LambdaNode).void }
  def visit_lambda_node(node); end

  # Visit a LocalVariableAndWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:519
  sig { params(node: Prism::LocalVariableAndWriteNode).void }
  def visit_local_variable_and_write_node(node); end

  # Visit a LocalVariableOperatorWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:524
  sig { params(node: Prism::LocalVariableOperatorWriteNode).void }
  def visit_local_variable_operator_write_node(node); end

  # Visit a LocalVariableOrWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:529
  sig { params(node: Prism::LocalVariableOrWriteNode).void }
  def visit_local_variable_or_write_node(node); end

  # Visit a LocalVariableReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:534
  sig { params(node: Prism::LocalVariableReadNode).void }
  def visit_local_variable_read_node(node); end

  # Visit a LocalVariableTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:539
  sig { params(node: Prism::LocalVariableTargetNode).void }
  def visit_local_variable_target_node(node); end

  # Visit a LocalVariableWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:544
  sig { params(node: Prism::LocalVariableWriteNode).void }
  def visit_local_variable_write_node(node); end

  # Visit a MatchLastLineNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:549
  sig { params(node: Prism::MatchLastLineNode).void }
  def visit_match_last_line_node(node); end

  # Visit a MatchPredicateNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:554
  sig { params(node: Prism::MatchPredicateNode).void }
  def visit_match_predicate_node(node); end

  # Visit a MatchRequiredNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:559
  sig { params(node: Prism::MatchRequiredNode).void }
  def visit_match_required_node(node); end

  # Visit a MatchWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:564
  sig { params(node: Prism::MatchWriteNode).void }
  def visit_match_write_node(node); end

  # Visit a MissingNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:569
  sig { params(node: Prism::MissingNode).void }
  def visit_missing_node(node); end

  # Visit a ModuleNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:574
  sig { params(node: Prism::ModuleNode).void }
  def visit_module_node(node); end

  # Visit a MultiTargetNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:579
  sig { params(node: Prism::MultiTargetNode).void }
  def visit_multi_target_node(node); end

  # Visit a MultiWriteNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:584
  sig { params(node: Prism::MultiWriteNode).void }
  def visit_multi_write_node(node); end

  # Visit a NextNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:589
  sig { params(node: Prism::NextNode).void }
  def visit_next_node(node); end

  # Visit a NilNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:594
  sig { params(node: Prism::NilNode).void }
  def visit_nil_node(node); end

  # Visit a NoKeywordsParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:599
  sig { params(node: Prism::NoKeywordsParameterNode).void }
  def visit_no_keywords_parameter_node(node); end

  # Visit a NumberedParametersNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:604
  sig { params(node: Prism::NumberedParametersNode).void }
  def visit_numbered_parameters_node(node); end

  # Visit a NumberedReferenceReadNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:609
  sig { params(node: Prism::NumberedReferenceReadNode).void }
  def visit_numbered_reference_read_node(node); end

  # Visit a OptionalKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:614
  sig { params(node: Prism::OptionalKeywordParameterNode).void }
  def visit_optional_keyword_parameter_node(node); end

  # Visit a OptionalParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:619
  sig { params(node: Prism::OptionalParameterNode).void }
  def visit_optional_parameter_node(node); end

  # Visit a OrNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:624
  sig { params(node: Prism::OrNode).void }
  def visit_or_node(node); end

  # Visit a ParametersNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:629
  sig { params(node: Prism::ParametersNode).void }
  def visit_parameters_node(node); end

  # Visit a ParenthesesNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:634
  sig { params(node: Prism::ParenthesesNode).void }
  def visit_parentheses_node(node); end

  # Visit a PinnedExpressionNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:639
  sig { params(node: Prism::PinnedExpressionNode).void }
  def visit_pinned_expression_node(node); end

  # Visit a PinnedVariableNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:644
  sig { params(node: Prism::PinnedVariableNode).void }
  def visit_pinned_variable_node(node); end

  # Visit a PostExecutionNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:649
  sig { params(node: Prism::PostExecutionNode).void }
  def visit_post_execution_node(node); end

  # Visit a PreExecutionNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:654
  sig { params(node: Prism::PreExecutionNode).void }
  def visit_pre_execution_node(node); end

  # Visit a ProgramNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:659
  sig { params(node: Prism::ProgramNode).void }
  def visit_program_node(node); end

  # Visit a RangeNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:664
  sig { params(node: Prism::RangeNode).void }
  def visit_range_node(node); end

  # Visit a RationalNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:669
  sig { params(node: Prism::RationalNode).void }
  def visit_rational_node(node); end

  # Visit a RedoNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:674
  sig { params(node: Prism::RedoNode).void }
  def visit_redo_node(node); end

  # Visit a RegularExpressionNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:679
  sig { params(node: Prism::RegularExpressionNode).void }
  def visit_regular_expression_node(node); end

  # Visit a RequiredKeywordParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:684
  sig { params(node: Prism::RequiredKeywordParameterNode).void }
  def visit_required_keyword_parameter_node(node); end

  # Visit a RequiredParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:689
  sig { params(node: Prism::RequiredParameterNode).void }
  def visit_required_parameter_node(node); end

  # Visit a RescueModifierNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:694
  sig { params(node: Prism::RescueModifierNode).void }
  def visit_rescue_modifier_node(node); end

  # Visit a RescueNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:699
  sig { params(node: Prism::RescueNode).void }
  def visit_rescue_node(node); end

  # Visit a RestParameterNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:704
  sig { params(node: Prism::RestParameterNode).void }
  def visit_rest_parameter_node(node); end

  # Visit a RetryNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:709
  sig { params(node: Prism::RetryNode).void }
  def visit_retry_node(node); end

  # Visit a ReturnNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:714
  sig { params(node: Prism::ReturnNode).void }
  def visit_return_node(node); end

  # Visit a SelfNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:719
  sig { params(node: Prism::SelfNode).void }
  def visit_self_node(node); end

  # Visit a ShareableConstantNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:724
  sig { params(node: Prism::ShareableConstantNode).void }
  def visit_shareable_constant_node(node); end

  # Visit a SingletonClassNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:729
  sig { params(node: Prism::SingletonClassNode).void }
  def visit_singleton_class_node(node); end

  # Visit a SourceEncodingNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:734
  sig { params(node: Prism::SourceEncodingNode).void }
  def visit_source_encoding_node(node); end

  # Visit a SourceFileNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:739
  sig { params(node: Prism::SourceFileNode).void }
  def visit_source_file_node(node); end

  # Visit a SourceLineNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:744
  sig { params(node: Prism::SourceLineNode).void }
  def visit_source_line_node(node); end

  # Visit a SplatNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:749
  sig { params(node: Prism::SplatNode).void }
  def visit_splat_node(node); end

  # Visit a StatementsNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:754
  sig { params(node: Prism::StatementsNode).void }
  def visit_statements_node(node); end

  # Visit a StringNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:759
  sig { params(node: Prism::StringNode).void }
  def visit_string_node(node); end

  # Visit a SuperNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:764
  sig { params(node: Prism::SuperNode).void }
  def visit_super_node(node); end

  # Visit a SymbolNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:769
  sig { params(node: Prism::SymbolNode).void }
  def visit_symbol_node(node); end

  # Visit a TrueNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:774
  sig { params(node: Prism::TrueNode).void }
  def visit_true_node(node); end

  # Visit a UndefNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:779
  sig { params(node: Prism::UndefNode).void }
  def visit_undef_node(node); end

  # Visit a UnlessNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:784
  sig { params(node: Prism::UnlessNode).void }
  def visit_unless_node(node); end

  # Visit a UntilNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:789
  sig { params(node: Prism::UntilNode).void }
  def visit_until_node(node); end

  # Visit a WhenNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:794
  sig { params(node: Prism::WhenNode).void }
  def visit_when_node(node); end

  # Visit a WhileNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:799
  sig { params(node: Prism::WhileNode).void }
  def visit_while_node(node); end

  # Visit a XStringNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:804
  sig { params(node: Prism::XStringNode).void }
  def visit_x_string_node(node); end

  # Visit a YieldNode node
  #
  # pkg:gem/prism#lib/prism/visitor.rb:809
  sig { params(node: Prism::YieldNode).void }
  def visit_yield_node(node); end
end

# Represents the use of the `when` keyword within a case statement.
#
#     case true
#     when true
#     ^^^^^^^^^
#     end
#
# pkg:gem/prism#lib/prism/node.rb:18091
class Prism::WhenNode < ::Prism::Node
  # Initialize a new WhenNode node.
  #
  # @return [WhenNode] a new instance of WhenNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18093
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, conditions, then_keyword_loc, statements); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:18205
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:18105
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18110
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:18123
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:18115
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # attr_reader conditions: Array[Prism::node]
  #
  # pkg:gem/prism#lib/prism/node.rb:18154
  sig { returns(T::Array[Prism::Node]) }
  def conditions; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?conditions: Array[Prism::node], ?then_keyword_loc: Location?, ?statements: StatementsNode?) -> WhenNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18128
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      conditions: T::Array[Prism::Node],
      then_keyword_loc: T.nilable(Prism::Location),
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhenNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18133
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, conditions: Array[Prism::node], then_keyword_loc: Location?, statements: StatementsNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:18136
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18189
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18179
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18141
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18149
  def save_keyword_loc(repository); end

  # Save the then_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18171
  def save_then_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:18176
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # def then_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18184
  sig { returns(T.nilable(String)) }
  def then_keyword; end

  # attr_reader then_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18157
  sig { returns(T.nilable(Prism::Location)) }
  def then_keyword_loc; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:18194
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:18199
    def type; end
  end
end

# Represents the use of the `while` keyword, either in the block form or the modifier form.
#
#     bar while foo
#     ^^^^^^^^^^^^^
#
#     while foo do bar end
#     ^^^^^^^^^^^^^^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:18222
class Prism::WhileNode < ::Prism::Node
  # Initialize a new WhileNode node.
  #
  # @return [WhileNode] a new instance of WhileNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18224
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:18366
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:18237
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def begin_modifier?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:18273
  sig { returns(T::Boolean) }
  def begin_modifier?; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18242
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18345
  sig { returns(T.nilable(String)) }
  def closing; end

  # attr_reader closing_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18310
  sig { returns(T.nilable(Prism::Location)) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:18255
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:18247
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> WhileNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18260
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      do_keyword_loc: T.nilable(Prism::Location),
      closing_loc: T.nilable(Prism::Location),
      predicate: Prism::Node,
      statements: T.nilable(Prism::StatementsNode)
    ).returns(Prism::WhileNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18265
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, do_keyword_loc: Location?, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode? }
  #
  # pkg:gem/prism#lib/prism/node.rb:18268
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  # def do_keyword: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18340
  sig { returns(T.nilable(String)) }
  def do_keyword; end

  # attr_reader do_keyword_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18291
  sig { returns(T.nilable(Prism::Location)) }
  def do_keyword_loc; end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18350
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18335
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18278
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # pkg:gem/prism#lib/prism/parse_result/newlines.rb:110
  def newline_flag!(lines); end

  # attr_reader predicate: Prism::node
  #
  # pkg:gem/prism#lib/prism/node.rb:18329
  sig { returns(Prism::Node) }
  def predicate; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18324
  def save_closing_loc(repository); end

  # Save the do_keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18305
  def save_do_keyword_loc(repository); end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18286
  def save_keyword_loc(repository); end

  # attr_reader statements: StatementsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:18332
  sig { returns(T.nilable(Prism::StatementsNode)) }
  def statements; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:18355
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:18360
    def type; end
  end
end

# Represents an xstring literal with no interpolation.
#
#     `foo`
#     ^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:18381
class Prism::XStringNode < ::Prism::Node
  include ::Prism::HeredocQuery

  # Initialize a new XStringNode node.
  #
  # @return [XStringNode] a new instance of XStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18383
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).void
  end
  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:18511
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:18395
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18400
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def closing: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18490
  sig { returns(String) }
  def closing; end

  # attr_reader closing_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18464
  sig { returns(Prism::Location) }
  def closing_loc; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:18410
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:18405
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def content: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18485
  sig { returns(String) }
  def content; end

  # attr_reader content_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18451
  sig { returns(Prism::Location) }
  def content_loc; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> XStringNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18415
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      opening_loc: Prism::Location,
      content_loc: Prism::Location,
      closing_loc: Prism::Location,
      unescaped: String
    ).returns(Prism::XStringNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18420
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
  #
  # pkg:gem/prism#lib/prism/node.rb:18423
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def forced_binary_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:18433
  sig { returns(T::Boolean) }
  def forced_binary_encoding?; end

  # def forced_utf8_encoding?: () -> bool
  #
  # @return [Boolean]
  #
  # pkg:gem/prism#lib/prism/node.rb:18428
  sig { returns(T::Boolean) }
  def forced_utf8_encoding?; end

  sig { returns(T::Boolean) }
  def heredoc?; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18495
  sig { override.returns(String) }
  def inspect; end

  # def opening: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18480
  sig { returns(String) }
  def opening; end

  # attr_reader opening_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18438
  sig { returns(Prism::Location) }
  def opening_loc; end

  # Save the closing_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18472
  def save_closing_loc(repository); end

  # Save the content_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18459
  def save_content_loc(repository); end

  # Save the opening_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18446
  def save_opening_loc(repository); end

  # Occasionally it's helpful to treat a string as if it were interpolated so
  # that there's a consistent interface for working with strings.
  #
  # pkg:gem/prism#lib/prism/node_ext.rb:93
  sig { returns(Prism::InterpolatedXStringNode) }
  def to_interpolated; end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:18500
  sig { override.returns(Symbol) }
  def type; end

  # attr_reader unescaped: String
  #
  # pkg:gem/prism#lib/prism/node.rb:18477
  sig { returns(String) }
  def unescaped; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:18505
    def type; end
  end
end

# Represents the use of the `yield` keyword.
#
#     yield 1
#     ^^^^^^^
#
# pkg:gem/prism#lib/prism/node.rb:18525
class Prism::YieldNode < ::Prism::Node
  # Initialize a new YieldNode node.
  #
  # @return [YieldNode] a new instance of YieldNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18527
  sig do
    params(
      source: Prism::Source,
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).void
  end
  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc); end

  # Implements case-equality for the node. This is effectively == but without
  # comparing the value of locations. Locations are checked only for presence.
  #
  # pkg:gem/prism#lib/prism/node.rb:18659
  def ===(other); end

  # def accept: (Visitor visitor) -> void
  #
  # pkg:gem/prism#lib/prism/node.rb:18539
  sig { override.params(visitor: Prism::Visitor).returns(T.untyped) }
  def accept(visitor); end

  # attr_reader arguments: ArgumentsNode?
  #
  # pkg:gem/prism#lib/prism/node.rb:18606
  sig { returns(T.nilable(Prism::ArgumentsNode)) }
  def arguments; end

  # def child_nodes: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18544
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def child_nodes; end

  # def comment_targets: () -> Array[Node | Location]
  #
  # pkg:gem/prism#lib/prism/node.rb:18556
  sig { override.returns(T::Array[T.any(Prism::Node, Prism::Location)]) }
  def comment_targets; end

  # def compact_child_nodes: () -> Array[Node]
  #
  # pkg:gem/prism#lib/prism/node.rb:18549
  sig { override.returns(T::Array[Prism::Node]) }
  def compact_child_nodes; end

  # def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?) -> YieldNode
  #
  # pkg:gem/prism#lib/prism/node.rb:18561
  sig do
    params(
      node_id: Integer,
      location: Prism::Location,
      flags: Integer,
      keyword_loc: Prism::Location,
      lparen_loc: T.nilable(Prism::Location),
      arguments: T.nilable(Prism::ArgumentsNode),
      rparen_loc: T.nilable(Prism::Location)
    ).returns(Prism::YieldNode)
  end
  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  # def child_nodes: () -> Array[Node?]
  # def deconstruct: () -> Array[Node?]
  #
  # pkg:gem/prism#lib/prism/node.rb:18566
  sig { override.returns(T::Array[T.nilable(Prism::Node)]) }
  def deconstruct; end

  # def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location? }
  #
  # pkg:gem/prism#lib/prism/node.rb:18569
  sig { params(keys: T.nilable(T::Array[Symbol])).returns(T::Hash[Symbol, T.untyped]) }
  def deconstruct_keys(keys); end

  sig { override.returns(T::Array[Prism::Reflection::Field]) }
  def fields; end

  # def inspect -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18643
  sig { override.returns(String) }
  def inspect; end

  # def keyword: () -> String
  #
  # pkg:gem/prism#lib/prism/node.rb:18628
  sig { returns(String) }
  def keyword; end

  # attr_reader keyword_loc: Location
  #
  # pkg:gem/prism#lib/prism/node.rb:18574
  sig { returns(Prism::Location) }
  def keyword_loc; end

  # def lparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18633
  sig { returns(T.nilable(String)) }
  def lparen; end

  # attr_reader lparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18587
  sig { returns(T.nilable(Prism::Location)) }
  def lparen_loc; end

  # def rparen: () -> String?
  #
  # pkg:gem/prism#lib/prism/node.rb:18638
  sig { returns(T.nilable(String)) }
  def rparen; end

  # attr_reader rparen_loc: Location?
  #
  # pkg:gem/prism#lib/prism/node.rb:18609
  sig { returns(T.nilable(Prism::Location)) }
  def rparen_loc; end

  # Save the keyword_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18582
  def save_keyword_loc(repository); end

  # Save the lparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18601
  def save_lparen_loc(repository); end

  # Save the rparen_loc location using the given saved source so that
  # it can be retrieved later.
  #
  # pkg:gem/prism#lib/prism/node.rb:18623
  def save_rparen_loc(repository); end

  # Return a symbol representation of this node type. See `Node#type`.
  #
  # pkg:gem/prism#lib/prism/node.rb:18648
  sig { override.returns(Symbol) }
  def type; end

  class << self
    # Return a symbol representation of this node type. See `Node::type`.
    #
    # pkg:gem/prism#lib/prism/node.rb:18653
    def type; end
  end
end

# pkg:gem/prism#lib/prism/translation/ruby_parser.rb:11
class RubyParser; end

# pkg:gem/prism#lib/prism/translation/ruby_parser.rb:12
class RubyParser::SyntaxError < ::RuntimeError; end
