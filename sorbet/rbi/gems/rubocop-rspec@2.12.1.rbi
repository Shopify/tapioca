# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-rspec` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-rspec`.

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/version.rb:3
module RuboCop; end

class RuboCop::AST::Node < ::Parser::AST::Node
  include ::RuboCop::RSpec::Node
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:4
module RuboCop::Cop; end

# source://rubocop-1.31.2/lib/rubocop/cop/mixin/allowed_pattern.rb:38
RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:5
module RuboCop::Cop::RSpec; end

# Checks that left braces for adjacent single line lets are aligned.
#
# @example
#
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz) { bar }
#   let(:a) { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_left_let_brace.rb:20
class RuboCop::Cop::RSpec::AlignLeftLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_left_let_brace.rb:29
  def on_new_investigation; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_left_let_brace.rb:44
  def token_aligner; end

  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_left_let_brace.rb:25
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_left_let_brace.rb:23
RuboCop::Cop::RSpec::AlignLeftLetBrace::MSG = T.let(T.unsafe(nil), String)

# Checks that right braces for adjacent single line lets are aligned.
#
# @example
#
#   # bad
#   let(:foobar) { blahblah }
#   let(:baz)    { bar }
#   let(:a)      { b }
#
#   # good
#   let(:foobar) { blahblah }
#   let(:baz)    { bar      }
#   let(:a)      { b        }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_right_let_brace.rb:20
class RuboCop::Cop::RSpec::AlignRightLetBrace < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_right_let_brace.rb:29
  def on_new_investigation; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_right_let_brace.rb:44
  def token_aligner; end

  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_right_let_brace.rb:25
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/align_right_let_brace.rb:23
RuboCop::Cop::RSpec::AlignRightLetBrace::MSG = T.let(T.unsafe(nil), String)

# Check that instances are not being stubbed globally.
#
# Prefer instance doubles over stubbing any instance of a class
#
# @example
#   # bad
#   describe MyClass do
#   before { allow_any_instance_of(MyClass).to receive(:foo) }
#   end
#
#   # good
#   describe MyClass do
#   let(:my_instance) { instance_double(MyClass) }
#
#   before do
#   allow(MyClass).to receive(:new).and_return(my_instance)
#   allow(my_instance).to receive(:foo)
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/any_instance.rb:25
class RuboCop::Cop::RSpec::AnyInstance < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/any_instance.rb:33
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/any_instance.rb:26
RuboCop::Cop::RSpec::AnyInstance::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/any_instance.rb:27
RuboCop::Cop::RSpec::AnyInstance::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that around blocks actually run the test.
#
# @example
#   # bad
#   around do
#   some_method
#   end
#
#   around do |test|
#   some_method
#   end
#
#   # good
#   around do |test|
#   some_method
#   test.call
#   end
#
#   around do |test|
#   some_method
#   test.run
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:28
class RuboCop::Cop::RSpec::AroundBlock < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:39
  def find_arg_usage(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:34
  def hook(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:43
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:55
  def add_no_arg_offense(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:59
  def check_for_unused_proxy(block, proxy); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:29
RuboCop::Cop::RSpec::AroundBlock::MSG_NO_ARG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/around_block.rb:30
RuboCop::Cop::RSpec::AroundBlock::MSG_UNUSED_ARG = T.let(T.unsafe(nil), String)

# @abstract parent class to RSpec cops
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/base.rb:7
class RuboCop::Cop::RSpec::Base < ::RuboCop::Cop::Base
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::RSpec::Language::NodePattern

  # Set the config for dynamic DSL configuration-aware helpers
  # that have no other means of accessing the configuration.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/base.rb:20
  def on_new_investigation; end

  class << self
    # Invoke the original inherited hook so our cops are recognized
    #
    # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/base.rb:14
    def inherited(subclass); end
  end
end

# Check for expectations where `be` is used without argument.
#
# The `be` matcher is too generic, as it pass on everything that is not
# nil or false. If that is the exact intend, use `be_truthy`. In all other
# cases it's better to specify what exactly is the expected value.
#
# @example
#
#   # bad
#   expect(foo).to be
#
#   # good
#   expect(foo).to be_truthy
#   expect(foo).to be 1.0
#   expect(foo).to be(true)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be.rb:22
class RuboCop::Cop::RSpec::Be < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be.rb:26
  def be_without_args(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be.rb:30
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be.rb:23
RuboCop::Cop::RSpec::Be::MSG = T.let(T.unsafe(nil), String)

# Check for expectations where `be(...)` can replace `eq(...)`.
#
# The `be` matcher compares by identity while the `eq` matcher compares
# using `==`. Booleans and nil can be compared by identity and therefore
# the `be` matcher is preferable as it is a more strict test.
#
# @example
#
#   # bad
#   expect(foo).to eq(true)
#   expect(foo).to eq(false)
#   expect(foo).to eq(nil)
#
#   # good
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(nil)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eq.rb:24
class RuboCop::Cop::RSpec::BeEq < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eq.rb:31
  def eq_type_with_identity?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eq.rb:35
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eq.rb:27
RuboCop::Cop::RSpec::BeEq::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eq.rb:28
RuboCop::Cop::RSpec::BeEq::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for expectations where `be(...)` can replace `eql(...)`.
#
# The `be` matcher compares by identity while the `eql` matcher
# compares using `eql?`. Integers, floats, booleans, symbols, and nil
# can be compared by identity and therefore the `be` matcher is
# preferable as it is a more strict test.
#
# This cop only looks for instances of `expect(...).to eql(...)`. We
# do not check `to_not` or `not_to` since `!eql?` is more strict
# than `!equal?`. We also do not try to flag `eq` because if
# `a == b`, and `b` is comparable by identity, `a` is still not
# necessarily the same type as `b` since the `#==` operator can
# coerce objects for comparison.
#
# @example
#
#   # bad
#   expect(foo).to eql(1)
#   expect(foo).to eql(1.0)
#   expect(foo).to eql(true)
#   expect(foo).to eql(false)
#   expect(foo).to eql(:bar)
#   expect(foo).to eql(nil)
#
#   # good
#   expect(foo).to be(1)
#   expect(foo).to be(1.0)
#   expect(foo).to be(true)
#   expect(foo).to be(false)
#   expect(foo).to be(:bar)
#   expect(foo).to be(nil)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eql.rb:38
class RuboCop::Cop::RSpec::BeEql < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eql.rb:45
  def eql_type_with_identity(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eql.rb:49
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eql.rb:41
RuboCop::Cop::RSpec::BeEql::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_eql.rb:42
RuboCop::Cop::RSpec::BeEql::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Ensures a consistent style is used when matching `nil`.
#
# You can either use the more specific `be_nil` matcher, or the more
# generic `be` matcher with a `nil` argument.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: be_nil` (default)
#   # bad
#   expect(foo).to be(nil)
#
#   # good
#   expect(foo).to be_nil
# @example `EnforcedStyle: be`
#   # bad
#   expect(foo).to be_nil
#
#   # good
#   expect(foo).to be(nil)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:27
class RuboCop::Cop::RSpec::BeNil < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:36
  def be_nil_matcher?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:41
  def nil_value_expectation?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:45
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:64
  def check_be_nil_style(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:56
  def check_be_style(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:31
RuboCop::Cop::RSpec::BeNil::BE_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:32
RuboCop::Cop::RSpec::BeNil::BE_NIL_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/be_nil.rb:33
RuboCop::Cop::RSpec::BeNil::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that before/after(:all) isn't being used.
#
# @example
#   # bad
#   #
#   # Faster but risk of state leaking between examples
#   #
#   describe MyClass do
#   before(:all) { Widget.create }
#   after(:all) { Widget.delete_all }
#   end
#
#   # good
#   #
#   # Slower but examples are properly isolated
#   #
#   describe MyClass do
#   before(:each) { Widget.create }
#   after(:each) { Widget.delete_all }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/before_after_all.rb:26
class RuboCop::Cop::RSpec::BeforeAfterAll < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/before_after_all.rb:35
  def before_or_after_all(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/before_after_all.rb:39
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/before_after_all.rb:27
RuboCop::Cop::RSpec::BeforeAfterAll::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/before_after_all.rb:32
RuboCop::Cop::RSpec::BeforeAfterAll::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:6
module RuboCop::Cop::RSpec::Capybara; end

# Checks that no expectations are set on Capybara's `current_path`.
#
# The
# https://www.rubydoc.info/github/teamcapybara/capybara/master/Capybara/RSpecMatchers#have_current_path-instance_method[`have_current_path` matcher]
# should be used on `page` to set expectations on Capybara's
# current path, since it uses
# https://github.com/teamcapybara/capybara/blob/master/README.md#asynchronous-javascript-ajax-and-friends[Capybara's waiting functionality]
# which ensures that preceding actions (like `click_link`) have
# completed.
#
# @example
#   # bad
#   expect(current_path).to eq('/callback')
#   expect(page.current_path).to match(/widgets/)
#
#   # good
#   expect(page).to have_current_path("/callback")
#   expect(page).to have_current_path(/widgets/)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:26
class RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # Supported matchers: eq(...) / match(/regexp/) / match('regexp')
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:42
  def as_is_matcher(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:36
  def expectation_set_on_current_path(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:59
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:49
  def regexp_str_matcher(param0 = T.unsafe(nil)); end

  private

  # `have_current_path` with no options will include the querystring
  # while `page.current_path` does not.
  # This ensures the option `ignore_query: true` is added
  # except when the expectation is a regexp or string
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:105
  def add_ignore_query_options(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:71
  def autocorrect(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:95
  def convert_regexp_str_to_literal(corrector, matcher_node, regexp_str); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:82
  def rewrite_expectation(corrector, node, to_symbol, matcher_node); end

  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:55
    def autocorrect_incompatible_with; end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:29
RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/current_path_expectation.rb:33
RuboCop::Cop::RSpec::Capybara::CurrentPathExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for consistent method usage in feature specs.
#
# By default, the cop disables all Capybara-specific methods that have
# the same native RSpec method (e.g. are just aliases). Some teams
# however may prefer using some of the Capybara methods (like `feature`)
# to make it obvious that the test uses Capybara, while still disable
# the rest of the methods, like `given` (alias for `let`), `background`
# (alias for `before`), etc. You can configure which of the methods to
# be enabled by using the EnabledMethods configuration option.
#
# @example
#   # bad
#   feature 'User logs in' do
#   given(:user) { User.new }
#
#   background do
#   visit new_session_path
#   end
#
#   scenario 'with OAuth' do
#   # ...
#   end
#   end
#
#   # good
#   describe 'User logs in' do
#   let(:user) { User.new }
#
#   before do
#   visit new_session_path
#   end
#
#   it 'with OAuth' do
#   # ...
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:43
class RuboCop::Cop::RSpec::Capybara::FeatureMethods < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:60
  def capybara_speak(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:65
  def feature_method(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:83
  def message(range); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:71
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:90
  def enabled?(method_name); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:94
  def enabled_methods; end
end

# https://github.com/teamcapybara/capybara/blob/e283c1aeaa72441f5403963577e16333bf111a81/lib/capybara/rspec/features.rb#L31-L36
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:50
RuboCop::Cop::RSpec::Capybara::FeatureMethods::MAP = T.let(T.unsafe(nil), Hash)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/feature_methods.rb:47
RuboCop::Cop::RSpec::Capybara::FeatureMethods::MSG = T.let(T.unsafe(nil), String)

# Checks for there is a more specific matcher offered by Capybara.
#
# @example
#
#   # bad
#   expect(page).to have_selector('button')
#   expect(page).to have_no_selector('button.cls')
#   expect(page).to have_css('button')
#   expect(page).to have_no_css('a.cls', exact_text: 'foo')
#   expect(page).to have_css('table.cls')
#   expect(page).to have_css('select')
#
#   # good
#   expect(page).to have_button
#   expect(page).to have_no_button(class: 'cls')
#   expect(page).to have_button
#   expect(page).to have_no_link('foo', class: 'cls')
#   expect(page).to have_table(class: 'cls')
#   expect(page).to have_select
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:27
class RuboCop::Cop::RSpec::Capybara::SpecificMatcher < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:39
  def first_argument(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:43
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:58
  def acceptable_pattern?(arg); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:68
  def good_matcher(node, matcher); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:62
  def message(node, matcher); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:53
  def specific_matcher(arg); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:28
RuboCop::Cop::RSpec::Capybara::SpecificMatcher::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:29
RuboCop::Cop::RSpec::Capybara::SpecificMatcher::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/specific_matcher.rb:31
RuboCop::Cop::RSpec::Capybara::SpecificMatcher::SPECIFIC_MATCHER = T.let(T.unsafe(nil), Hash)

# Checks for boolean visibility in Capybara finders.
#
# Capybara lets you find elements that match a certain visibility using
# the `:visible` option. `:visible` accepts both boolean and symbols as
# values, however using booleans can have unwanted effects. `visible:
# false` does not find just invisible elements, but both visible and
# invisible elements. For expressiveness and clarity, use one of the
# symbol values, `:all`, `:hidden` or `:visible`.
# Read more in
# https://www.rubydoc.info/gems/capybara/Capybara%2FNode%2FFinders:all[the documentation].
#
# @example
#
#   # bad
#   expect(page).to have_selector('.foo', visible: false)
#   expect(page).to have_css('.foo', visible: true)
#   expect(page).to have_link('my link', visible: false)
#
#   # good
#   expect(page).to have_selector('.foo', visible: :visible)
#   expect(page).to have_css('.foo', visible: :all)
#   expect(page).to have_link('my link', visible: :hidden)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:30
class RuboCop::Cop::RSpec::Capybara::VisibilityMatcher < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:60
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:56
  def visible_false?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:51
  def visible_true?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:67
  def capybara_matcher?(method_name); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:33
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::CAPYBARA_MATCHER_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:31
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::MSG_FALSE = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:32
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::MSG_TRUE = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/capybara/visibility_matcher.rb:48
RuboCop::Cop::RSpec::Capybara::VisibilityMatcher::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer negated matchers over `to change.by(0)`.
#
# @example
#   # bad
#   expect { run }.to change(Foo, :bar).by(0)
#   expect { run }.to change { Foo.bar }.by(0)
#
#   # bad - compound expectations
#   expect { run }
#   .to change(Foo, :bar).by(0)
#   .and change(Foo, :baz).by(0)
#   expect { run }
#   .to change { Foo.bar }.by(0)
#   .and change { Foo.baz }.by(0)
#
#   # good
#   expect { run }.not_to change(Foo, :bar)
#   expect { run }.not_to change { Foo.bar }
#
#   # good - compound expectations
#   define_negated_matcher :not_change, :change
#   expect { run }
#   .to not_change(Foo, :bar)
#   .and not_change(Foo, :baz)
#   expect { run }
#   .to not_change { Foo.bar }
#   .and not_change { Foo.baz }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:34
class RuboCop::Cop::RSpec::ChangeByZero < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:42
  def expect_change_with_arguments(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:49
  def expect_change_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:58
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:85
  def autocorrect(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:70
  def check_offense(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:81
  def compound_expectations?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:36
RuboCop::Cop::RSpec::ChangeByZero::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:37
RuboCop::Cop::RSpec::ChangeByZero::MSG_COMPOUND = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/change_by_zero.rb:39
RuboCop::Cop::RSpec::ChangeByZero::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Help methods for working with nodes containing comments.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:7
module RuboCop::Cop::RSpec::CommentsHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:17
  def begin_pos_with_comment(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:32
  def buffer; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:27
  def end_line_position(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:10
  def source_range_with_comment(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/comments_help.rb:23
  def start_line_position(node); end
end

# `context` should not be used for specifying methods.
#
# @example
#   # bad
#   context '#foo_bar' do
#   # ...
#   end
#
#   context '.foo_bar' do
#   # ...
#   end
#
#   # good
#   describe '#foo_bar' do
#   # ...
#   end
#
#   describe '.foo_bar' do
#   # ...
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_method.rb:26
class RuboCop::Cop::RSpec::ContextMethod < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_method.rb:32
  def context_method(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_method.rb:36
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_method.rb:46
  def method_name?(description); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_method.rb:29
RuboCop::Cop::RSpec::ContextMethod::MSG = T.let(T.unsafe(nil), String)

# Checks that `context` docstring starts with an allowed prefix.
#
# The default list of prefixes is minimal. Users are encouraged to tailor
# the configuration to meet project needs. Other acceptable prefixes may
# include `if`, `unless`, `for`, `before`, `after`, or `during`.
# They may consist of multiple words if desired.
#
# @example `Prefixes` configuration
#
#   # .rubocop.yml
#   # RSpec/ContextWording:
#   #   Prefixes:
#   #     - when
#   #     - with
#   #     - without
#   #     - if
#   #     - unless
#   #     - for
# @example
#   # bad
#   context 'the display name not present' do
#   # ...
#   end
#
#   # good
#   context 'when the display name is not present' do
#   # ...
#   end
# @see https://rspec.rubystyle.guide/#context-descriptions
# @see http://www.betterspecs.org/#contexts
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:38
class RuboCop::Cop::RSpec::ContextWording < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:42
  def context_wording(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:46
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:55
  def bad_prefix?(description); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:59
  def joined_prefixes; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:71
  def prefix_regex; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:67
  def prefixes; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/context_wording.rb:39
RuboCop::Cop::RSpec::ContextWording::MSG = T.let(T.unsafe(nil), String)

# Check that the first argument to the top-level describe is a constant.
#
# It can be configured to ignore strings when certain metadata is passed.
#
# Ignores Rails and Aruba `type` metadata by default.
#
# @example `IgnoredMetadata` configuration
#
#   # .rubocop.yml
#   # RSpec/DescribeClass:
#   #   IgnoredMetadata:
#   #     type:
#   #       - request
#   #       - controller
# @example
#   # bad
#   describe 'Do something' do
#   end
#
#   # good
#   describe TestedClass do
#   subject { described_class }
#   end
#
#   describe 'TestedClass::VERSION' do
#   subject { Object.const_get(self.class.description) }
#   end
#
#   describe "A feature example", type: :feature do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:37
class RuboCop::Cop::RSpec::DescribeClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:44
  def example_group_with_ignored_metadata?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:49
  def not_a_const_described(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:58
  def on_top_level_group(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:54
  def sym_pair(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:79
  def ignored_metadata; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:68
  def ignored_metadata?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:74
  def string_constant?(described); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_class.rb:40
RuboCop::Cop::RSpec::DescribeClass::MSG = T.let(T.unsafe(nil), String)

# Checks that the second argument to `describe` specifies a method.
#
# @example
#   # bad
#   describe MyClass, 'do something' do
#   end
#
#   # good
#   describe MyClass, '#my_instance_method' do
#   end
#
#   describe MyClass, '.my_class_method' do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_method.rb:19
class RuboCop::Cop::RSpec::DescribeMethod < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_method.rb:32
  def on_top_level_group(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_method.rb:26
  def second_argument(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_method.rb:22
RuboCop::Cop::RSpec::DescribeMethod::MSG = T.let(T.unsafe(nil), String)

# Avoid describing symbols.
#
# @example
#   # bad
#   describe :my_method do
#   # ...
#   end
#
#   # good
#   describe '#my_method' do
#   # ...
#   end
# @see https://github.com/rspec/rspec-core/issues/1610
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_symbol.rb:20
class RuboCop::Cop::RSpec::DescribeSymbol < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_symbol.rb:25
  def describe_symbol?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_symbol.rb:29
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_symbol.rb:21
RuboCop::Cop::RSpec::DescribeSymbol::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/describe_symbol.rb:22
RuboCop::Cop::RSpec::DescribeSymbol::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that tests use `described_class`.
#
# If the first argument of describe is a class, the class is exposed to
# each example via described_class.
#
# This cop can be configured using the `EnforcedStyle` and `SkipBlocks`
# options.
#
# There's a known caveat with rspec-rails's `controller` helper that
# runs its block in a different context, and `described_class` is not
# available to it. `SkipBlocks` option excludes detection in all
# non-RSpec related blocks.
#
# To narrow down this setting to only a specific directory, it is
# possible to use an overriding configuration file local to that
# directory.
#
# @example `EnforcedStyle: described_class` (default)
#   # bad
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { described_class.do_something }
#   end
# @example `EnforcedStyle: explicit`
#   # bad
#   describe MyClass do
#   subject { described_class.do_something }
#   end
#
#   # good
#   describe MyClass do
#   subject { MyClass.do_something }
#   end
# @example `SkipBlocks: true`
#   # spec/controllers/.rubocop.yml
#   # RSpec/DescribedClass:
#   #   SkipBlocks: true
#
#   # acceptable
#   describe MyConcern do
#   controller(ApplicationController) do
#   include MyConcern
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:57
class RuboCop::Cop::RSpec::DescribedClass < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:65
  def common_instance_exec_closure?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:81
  def contains_described_class?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:76
  def described_constant(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:84
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:70
  def rspec_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:73
  def scope_changing_syntax?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:101
  def autocorrect(corrector, match); end

  # @example
  #   # nil represents base constant
  #   collapse_namespace([], [:C])                # => [:C]
  #   collapse_namespace([:A, :B], [:C])          # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [:B, :C])      # => [:A, :B, :C]
  #   collapse_namespace([:A, :B], [nil, :C])     # => [nil, :C]
  #   collapse_namespace([:A, :B], [nil, :B, :C]) # => [nil, :B, :C]
  # @param namespace [Array<Symbol>]
  # @param const [Array<Symbol>]
  # @return [Array<Symbol>]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:176
  def collapse_namespace(namespace, const); end

  # @example
  #   const_name(s(:const, nil, :C))                # => [:C]
  #   const_name(s(:const, s(:const, nil, :M), :C)) # => [:M, :C]
  #   const_name(s(:const, s(:cbase), :C))          # => [nil, :C]
  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:193
  def const_name(node); end

  # @yield [node]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:111
  def find_usage(node, &block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:162
  def full_const_name(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:121
  def message(offense); end

  # @example
  #   namespace(node) # => [:A, :B, :C]
  # @param node [RuboCop::AST::Node]
  # @return [Array<Symbol>]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:208
  def namespace(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:140
  def offensive?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:148
  def offensive_described_class?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:130
  def scope_change?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:136
  def skippable_block?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:61
RuboCop::Cop::RSpec::DescribedClass::DESCRIBED_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class.rb:62
RuboCop::Cop::RSpec::DescribedClass::MSG = T.let(T.unsafe(nil), String)

# Avoid opening modules and defining specs within them.
#
# @example
#   # bad
#   module MyModule
#   RSpec.describe MyClass do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe MyModule::MyClass do
#   # ...
#   end
# @see https://github.com/rubocop/rubocop-rspec/issues/735
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class_module_wrapping.rb:22
class RuboCop::Cop::RSpec::DescribedClassModuleWrapping < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class_module_wrapping.rb:26
  def find_rspec_blocks(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class_module_wrapping.rb:28
  def on_module(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/described_class_module_wrapping.rb:23
RuboCop::Cop::RSpec::DescribedClassModuleWrapping::MSG = T.let(T.unsafe(nil), String)

# Enforces custom RSpec dialects.
#
# A dialect can be based on the following RSpec methods:
#
# - describe, context, feature, example_group
# - xdescribe, xcontext, xfeature
# - fdescribe, fcontext, ffeature
# - shared_examples, shared_examples_for, shared_context
# - it, specify, example, scenario, its
# - fit, fspecify, fexample, fscenario, focus
# - xit, xspecify, xexample, xscenario, skip
# - pending
# - prepend_before, before, append_before,
# - around
# - prepend_after, after, append_after
# - let, let!
# - subject, subject!
# - expect, is_expected, expect_any_instance_of
#
# By default all of the RSpec methods and aliases are allowed. By setting
# a config like:
#
#   RSpec/Dialect:
#     PreferredMethods:
#       context: describe
#
# You can expect the following behavior:
#
# @example
#   # bad
#   context 'display name presence' do
#   # ...
#   end
#
#   # good
#   describe 'display name presence' do
#   # ...
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/dialect.rb:44
class RuboCop::Cop::RSpec::Dialect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/dialect.rb:53
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/dialect.rb:51
  def rspec_method?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/dialect.rb:48
RuboCop::Cop::RSpec::Dialect::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group does not include any tests.
#
# @example usage
#
#   # bad
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   context 'extra chunky' do   # flagged by rubocop
#   let(:chunkiness) { true }
#   end
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   let(:bacon)      { Bacon.new(chunkiness) }
#   let(:chunkiness) { false                 }
#
#   it 'is chunky' do
#   expect(bacon.chunky?).to be_truthy
#   end
#   end
#
#   # good
#   describe Bacon do
#   pending 'will add tests later'
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:38
class RuboCop::Cop::RSpec::EmptyExampleGroup < ::RuboCop::Cop::RSpec::Base
  # Match example group blocks and yield their body
  #
  # @example source that matches
  #   describe 'example group' do
  #   it { is_expected.to be }
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] example group body
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:51
  def example_group_body(param0 = T.unsafe(nil)); end

  # Match examples, example groups and includes
  #
  # @example source that matches
  #   it { is_expected.to fly }
  #   describe('non-empty example groups too') { }
  #   it_behaves_like 'an animal'
  #   it_behaves_like('a cat') { let(:food) { 'milk' } }
  #   it_has_root_access
  #   skip
  #   it 'will be implemented later'
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:69
  def example_or_group_or_include?(param0 = T.unsafe(nil)); end

  # Matches examples defined in scopes where they could run
  #
  # @example source that matches
  #   it { expect(myself).to be_run }
  #   describe { it { i_run_as_well } }
  # @example source that does not match
  #   before { it { whatever here wont run anyway } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:126
  def examples?(param0 = T.unsafe(nil)); end

  # Match examples or examples inside blocks
  #
  # @example source that matches
  #   it { expect(drink).to be_cold }
  #   context('when winter') { it { expect(drink).to be_hot } }
  #   (1..5).each { |divisor| it { is_expected.to divide_by(divisor) } }
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:107
  def examples_directly_or_in_block?(param0 = T.unsafe(nil)); end

  # Match examples defined inside a block which is not a hook
  #
  # @example source that matches
  #   %w(r g b).each do |color|
  #   it { is_expected.to have_color(color) }
  #   end
  # @example source that does not match
  #   before do
  #   it { is_expected.to fall_into_oblivion }
  #   end
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:93
  def examples_inside_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:133
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:155
  def conditionals_with_examples?(body); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:163
  def examples_in_branches?(condition_node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:144
  def offensive?(body); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_example_group.rb:39
RuboCop::Cop::RSpec::EmptyExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks for empty before and after hooks.
#
# @example
#   # bad
#   before {}
#   after do; end
#   before(:all) do
#   end
#   after(:all) { }
#
#   # good
#   before { create_users }
#   after do
#   cleanup_users
#   end
#   before(:all) do
#   create_feed
#   end
#   after(:all) { cleanup_feed }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_hook.rb:25
class RuboCop::Cop::RSpec::EmptyHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_hook.rb:32
  def empty_hook?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_hook.rb:36
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_hook.rb:29
RuboCop::Cop::RSpec::EmptyHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#   it 'does that' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   it 'does this' do
#   end
#
#   it 'does that' do
#   end
#   end
#
#   # fair - it's ok to have non-separated one-liners
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
# @example with AllowConsecutiveOneLiners configuration
#
#   # rubocop.yml
#   # RSpec/EmptyLineAfterExample:
#   #   AllowConsecutiveOneLiners: false
#
#   # bad
#   RSpec.describe Foo do
#   it { one }
#   it { two }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:44
class RuboCop::Cop::RSpec::EmptyLineAfterExample < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:63
  def allow_consecutive_one_liners?; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:59
  def allowed_one_liner?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:67
  def consecutive_one_liner?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:71
  def next_one_line_example?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:79
  def next_sibling(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:50
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example.rb:48
RuboCop::Cop::RSpec::EmptyLineAfterExample::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after example group blocks.
#
# @example
#   # bad
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#   describe '#baz' do
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   describe '#bar' do
#   end
#
#   describe '#baz' do
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example_group.rb:26
class RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example_group.rb:32
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_example_group.rb:30
RuboCop::Cop::RSpec::EmptyLineAfterExampleGroup::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after the last let block.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:something) { other }
#   it { does_something }
#
#   # good
#   let(:foo) { bar }
#   let(:something) { other }
#
#   it { does_something }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_final_let.rb:19
class RuboCop::Cop::RSpec::EmptyLineAfterFinalLet < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_final_let.rb:25
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_final_let.rb:23
RuboCop::Cop::RSpec::EmptyLineAfterFinalLet::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after hook blocks.
#
# @example
#   # bad
#   before { do_something }
#   it { does_something }
#
#   # bad
#   after { do_something }
#   it { does_something }
#
#   # bad
#   around { |test| test.run }
#   it { does_something }
#
#   # good
#   before { do_something }
#
#   it { does_something }
#
#   # good
#   after { do_something }
#
#   it { does_something }
#
#   # good
#   around { |test| test.run }
#
#   it { does_something }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_hook.rb:36
class RuboCop::Cop::RSpec::EmptyLineAfterHook < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_hook.rb:42
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_hook.rb:40
RuboCop::Cop::RSpec::EmptyLineAfterHook::MSG = T.let(T.unsafe(nil), String)

# Checks if there is an empty line after subject block.
#
# @example
#   # bad
#   subject(:obj) { described_class }
#   let(:foo) { bar }
#
#   # good
#   subject(:obj) { described_class }
#
#   let(:foo) { bar }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_subject.rb:17
class RuboCop::Cop::RSpec::EmptyLineAfterSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_subject.rb:24
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/empty_line_after_subject.rb:22
RuboCop::Cop::RSpec::EmptyLineAfterSubject::MSG = T.let(T.unsafe(nil), String)

# Helps determine the offending location if there is not an empty line
# following the node. Allows comments to follow directly after
# in the following cases.
# - followed by empty line(s)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/empty_line_separation.rb:11
module RuboCop::Cop::RSpec::EmptyLineSeparation
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RangeHelp

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/empty_line_separation.rb:52
  def last_child?(node); end

  # @yield [offending_loc(enable_directive_line || final_end_line)]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/empty_line_separation.rb:26
  def missing_separating_line(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/empty_line_separation.rb:15
  def missing_separating_line_offense(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/empty_line_separation.rb:42
  def offending_loc(last_line); end
end

# Checks for long examples.
#
# A long example is usually more difficult to understand. Consider
# extracting out some behavior, e.g. with a `let` block, or a helper
# method.
#
# You can set literals you want to fold with `CountAsOne`.
# Available are: 'array', 'hash', and 'heredoc'. Each literal
# will be counted as one line regardless of its actual size.
#
# @example
#   # bad
#   it do
#   service = described_class.new
#   more_setup
#   more_setup
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it do
#   service = described_class.new
#   result = service.call
#   expect(result).to be(true)
#   end
# @example CountAsOne: ['array', 'heredoc']
#
#   it do
#   array = [         # +1
#   1,
#   2
#   ]
#
#   hash = {          # +3
#   key: 'value'
#   }
#
#   msg = <<~HEREDOC  # +1
#   Heredoc
#   content.
#   HEREDOC
#   end                 # 5 points
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_length.rb:50
class RuboCop::Cop::RSpec::ExampleLength < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::CodeLength

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_length.rb:55
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_length.rb:63
  def cop_label; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_length.rb:53
RuboCop::Cop::RSpec::ExampleLength::LABEL = T.let(T.unsafe(nil), String)

# Checks for examples without a description.
#
# RSpec allows for auto-generated example descriptions when there is no
# description provided or the description is an empty one.
#
# This cop removes empty descriptions.
# It also defines whether auto-generated description is allowed, based
# on the configured style.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: always_allow` (default)
#   # bad
#   it('') { is_expected.to be_good }
#   it '' do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
# @example `EnforcedStyle: single_line_only`
#   # bad
#   it('') { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
#
#   # good
#   it { is_expected.to be_good }
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_good }
#   it do
#   result = service.call
#   expect(result).to be(true)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:50
class RuboCop::Cop::RSpec::ExampleWithoutDescription < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:58
  def example_description(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:60
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:74
  def check_example_without_description(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:81
  def disallow_empty_description?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:55
RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_ADD_DESCRIPTION = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_without_description.rb:53
RuboCop::Cop::RSpec::ExampleWithoutDescription::MSG_DEFAULT_ARGUMENT = T.let(T.unsafe(nil), String)

# Checks for common mistakes in example descriptions.
#
# This cop will correct docstrings that begin with 'should' and 'it'.
#
# The autocorrect is experimental - use with care! It can be configured
# with CustomTransform (e.g. have => has) and IgnoredWords (e.g. only).
#
# @example
#   # bad
#   it 'should find nothing' do
#   end
#
#   # good
#   it 'finds nothing' do
#   end
# @example
#   # bad
#   it 'it does things' do
#   end
#
#   # good
#   it 'does things' do
#   end
# @see http://betterspecs.org/#should
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:32
class RuboCop::Cop::RSpec::ExampleWording < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:42
  def it_description(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:49
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:61
  def add_wording_offense(node, message); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:108
  def custom_transform; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:71
  def docstring(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:112
  def ignored_words; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:81
  def replacement_text(node); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:97
  def text(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:39
RuboCop::Cop::RSpec::ExampleWording::IT_PREFIX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:36
RuboCop::Cop::RSpec::ExampleWording::MSG_IT = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:35
RuboCop::Cop::RSpec::ExampleWording::MSG_SHOULD = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/example_wording.rb:38
RuboCop::Cop::RSpec::ExampleWording::SHOULD_PREFIX = T.let(T.unsafe(nil), Regexp)

# Checks for excessive whitespace in example descriptions.
#
# @example
#   # bad
#   it '  has  excessive   spacing  ' do
#   end
#
#   # good
#   it 'has excessive spacing' do
#   end
# @example
#   # bad
#   context '  when a condition   is met  ' do
#   end
#
#   # good
#   context 'when a condition is met' do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:25
class RuboCop::Cop::RSpec::ExcessiveDocstringSpacing < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:31
  def example_description(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:38
  def on_send(node); end

  private

  # @param node [RuboCop::AST::Node]
  # @param text [String]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:66
  def add_whitespace_offense(node, text); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:75
  def docstring(node); end

  # @param text [String]
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:53
  def excessive_whitespace?(text); end

  # @param text [String]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:60
  def strip_excessive_whitespace(text); end

  # Recursive processing is required to process nested dstr nodes
  # that is the case for \-separated multiline strings with interpolation.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:87
  def text(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/excessive_docstring_spacing.rb:28
RuboCop::Cop::RSpec::ExcessiveDocstringSpacing::MSG = T.let(T.unsafe(nil), String)

# Checks for `expect(...)` calls containing literal values.
#
# Autocorrection is performed when the expected is not a literal.
#
# @example
#   # bad
#   expect(5).to eq(price)
#   expect(/foo/).to eq(pattern)
#   expect("John").to eq(name)
#
#   # good
#   expect(price).to eq(5)
#   expect(pattern).to eq(/foo/)
#   expect(name).to eq("John")
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:21
class RuboCop::Cop::RSpec::ExpectActual < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:51
  def expect_literal(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:62
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:85
  def complex_literal?(node); end

  # This is not implement using a NodePattern because it seems
  # to not be able to match against an explicit (nil) sexp
  #
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:77
  def literal?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:81
  def simple_literal?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:90
  def swap(corrector, actual, expected); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:39
RuboCop::Cop::RSpec::ExpectActual::COMPLEX_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:24
RuboCop::Cop::RSpec::ExpectActual::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:26
RuboCop::Cop::RSpec::ExpectActual::SIMPLE_LITERALS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_actual.rb:48
RuboCop::Cop::RSpec::ExpectActual::SUPPORTED_MATCHERS = T.let(T.unsafe(nil), Array)

# Checks for consistent style of change matcher.
#
# Enforces either passing object and attribute as arguments to the matcher
# or passing a block that reads the attribute value.
#
# This cop can be configured using the `EnforcedStyle` option.
#
# @example `EnforcedStyle: method_call` (default)
#   # bad
#   expect { run }.to change { Foo.bar }
#   expect { run }.to change { foo.baz }
#
#   # good
#   expect { run }.to change(Foo, :bar)
#   expect { run }.to change(foo, :baz)
#   # also good when there are arguments or chained method calls
#   expect { run }.to change { Foo.bar(:count) }
#   expect { run }.to change { user.reload.name }
# @example `EnforcedStyle: block`
#   # bad
#   expect { run }.to change(Foo, :bar)
#
#   # good
#   expect { run }.to change { Foo.bar }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:32
class RuboCop::Cop::RSpec::ExpectChange < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:41
  def expect_change_with_arguments(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:46
  def expect_change_with_block(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:72
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:60
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:36
RuboCop::Cop::RSpec::ExpectChange::MSG_BLOCK = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:37
RuboCop::Cop::RSpec::ExpectChange::MSG_CALL = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_change.rb:38
RuboCop::Cop::RSpec::ExpectChange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Do not use `expect` in hooks such as `before`.
#
# @example
#   # bad
#   before do
#   expect(something).to eq 'foo'
#   end
#
#   # bad
#   after do
#   expect_any_instance_of(Something).to receive(:foo)
#   end
#
#   # good
#   it do
#   expect(something).to eq 'foo'
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_in_hook.rb:23
class RuboCop::Cop::RSpec::ExpectInHook < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_in_hook.rb:27
  def expectation(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_in_hook.rb:29
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_in_hook.rb:41
  def message(expect, hook); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_in_hook.rb:24
RuboCop::Cop::RSpec::ExpectInHook::MSG = T.let(T.unsafe(nil), String)

# Checks for opportunities to use `expect { ... }.to output`.
#
# @example
#   # bad
#   $stdout = StringIO.new
#   my_app.print_report
#   $stdout = STDOUT
#   expect($stdout.string).to eq('Hello World')
#
#   # good
#   expect { my_app.print_report }.to output('Hello World').to_stdout
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_output.rb:17
class RuboCop::Cop::RSpec::ExpectOutput < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_output.rb:21
  def on_gvasgn(node); end

  private

  # Detect if we are inside the scope of a single example
  #
  # We want to encourage using `expect { ... }.to output` so
  # we only care about situations where you would replace with
  # an expectation. Therefore, assignments to stderr or stdout
  # within a `before(:all)` or otherwise outside of an example
  # don't matter.
  #
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_output.rb:42
  def inside_example_scope?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/expect_output.rb:18
RuboCop::Cop::RSpec::ExpectOutput::MSG = T.let(T.unsafe(nil), String)

# A helper for `explicit` style
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:121
module RuboCop::Cop::RSpec::ExplicitHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:159
  def predicate_matcher?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:168
  def predicate_matcher_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:135
  def allowed_explicit_matchers; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:139
  def check_explicit(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:191
  def corrector_explicit(corrector, to_node, actual, matcher, block_child); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:185
  def message_explicit(matcher); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:198
  def move_predicate(corrector, actual, matcher, block_child); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:177
  def predicate_matcher_name?(name); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:228
  def replacement_matcher(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:210
  def to_predicate_method(matcher); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:127
RuboCop::Cop::RSpec::ExplicitHelper::BUILT_IN_MATCHERS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:125
RuboCop::Cop::RSpec::ExplicitHelper::MSG_EXPLICIT = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:6
module RuboCop::Cop::RSpec::FactoryBot; end

# Always declare attribute values as blocks.
#
# @example
#   # bad
#   kind [:active, :rejected].sample
#
#   # good
#   kind { [:active, :rejected].sample }
#
#   # bad
#   closed_at 1.day.from_now
#
#   # good
#   closed_at { 1.day.from_now }
#
#   # bad
#   count 1
#
#   # good
#   count { 1 }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:27
class RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:85
  def association?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:38
  def factory_attributes(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:42
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:33
  def value_matcher(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:119
  def attribute_defining_method?(method_name); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:58
  def autocorrect(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:87
  def autocorrect_replacing_parens(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:94
  def autocorrect_without_parens(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:103
  def braces(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:66
  def offensive_receiver?(receiver, node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:80
  def proc?(attribute); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:72
  def receiver_matches_first_block_argument?(receiver, node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:115
  def reserved_method?(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:111
  def value_hash_without_braces?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/attribute_defined_statically.rb:30
RuboCop::Cop::RSpec::FactoryBot::AttributeDefinedStatically::MSG = T.let(T.unsafe(nil), String)

# Checks for create_list usage.
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: create_list` (default)
#   # bad
#   3.times { create :user }
#
#   # good
#   create_list :user, 3
#
#   # bad
#   3.times { create :user, age: 18 }
#
#   # good - index is used to alter the created models attributes
#   3.times { |n| create :user, age: n }
#
#   # good - contains a method call, may return different values
#   3.times { create :user, age: rand }
# @example `EnforcedStyle: n_times`
#   # bad
#   create_list :user, 3
#
#   # good
#   3.times { create :user }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:33
class RuboCop::Cop::RSpec::FactoryBot::CreateList < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:60
  def arguments_include_method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:65
  def factory_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:70
  def factory_list_call(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:43
  def n_times_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:51
  def n_times_block_with_arg_and_used?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:74
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:88
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:101
  def contains_only_factory?(node); end
end

# :nodoc
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:110
module RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector
  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:113
  def build_options_string(options); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:117
  def format_method_call(node, method, arguments); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:125
  def format_receiver(receiver); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:163
class RuboCop::Cop::RSpec::FactoryBot::CreateList::CreateListCorrector
  include ::RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector

  # @return [CreateListCorrector] a new instance of CreateListCorrector
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:166
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:170
  def call(corrector); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:193
  def build_arguments(node, count); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:202
  def call_replacement(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:184
  def call_with_block_replacement(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:215
  def format_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:223
  def format_multiline_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:231
  def format_singleline_block(node); end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:182
  def node; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:38
RuboCop::Cop::RSpec::FactoryBot::CreateList::MSG_CREATE_LIST = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:39
RuboCop::Cop::RSpec::FactoryBot::CreateList::MSG_N_TIMES = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:40
RuboCop::Cop::RSpec::FactoryBot::CreateList::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:133
class RuboCop::Cop::RSpec::FactoryBot::CreateList::TimesCorrector
  include ::RuboCop::Cop::RSpec::FactoryBot::CreateList::Corrector

  # @return [TimesCorrector] a new instance of TimesCorrector
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:136
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:140
  def call(corrector); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:149
  def generate_n_times_block(node); end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/create_list.rb:147
  def node; end
end

# Use string value when setting the class attribute explicitly.
#
# This cop would promote faster tests by lazy-loading of
# application files. Also, this could help you suppress potential bugs
# in combination with external libraries by avoiding a preload of
# application files from the factory files.
#
# @example
#   # bad
#   factory :foo, class: Foo do
#   end
#
#   # good
#   factory :foo, class: 'Foo' do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:22
class RuboCop::Cop::RSpec::FactoryBot::FactoryClassName < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:31
  def class_name(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:35
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:48
  def allowed?(const_name); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:27
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::ALLOWED_CONSTANTS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:25
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/factory_class_name.rb:28
RuboCop::Cop::RSpec::FactoryBot::FactoryClassName::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Use shorthands from `FactoryBot::Syntax::Methods` in your specs.
#
# @example
#   # bad
#   FactoryBot.create(:bar)
#   FactoryBot.build(:bar)
#   FactoryBot.attributes_for(:bar)
#
#   # good
#   create(:bar)
#   build(:bar)
#   attributes_for(:bar)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:49
class RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:77
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:90
  def crime_scene(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:97
  def offense(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:55
RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/factory_bot/syntax_methods.rb:57
RuboCop::Cop::RSpec::FactoryBot::SyntaxMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Checks that spec file paths are consistent and well-formed.
#
# By default, this checks that spec file paths are consistent with the
# test subject and and enforces that it reflects the described
# class/module and its optionally called out method.
#
# With the configuration option `IgnoreMethods` the called out method will
# be ignored when determining the enforced path.
#
# With the configuration option `CustomTransform` modules or classes can
# be specified that should not as usual be transformed from CamelCase to
# snake_case (e.g. 'RuboCop' => 'rubocop' ).
#
# With the configuration option `SpecSuffixOnly` test files will only
# be checked to ensure they end in '_spec.rb'. This option disables
# checking for consistency in the test subject or test methods.
#
# @example
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # bad
#   my_class_spec.rb         # describe MyClass, '#method'
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_method_spec.rb  # describe MyClass, '#method'
#
#   # good
#   my_class/method_spec.rb  # describe MyClass, '#method'
# @example when configuration is `IgnoreMethods: true`
#   # bad
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
# @example when configuration is `SpecSuffixOnly: true`
#   # good
#   whatever_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass
#
#   # good
#   my_class_spec.rb         # describe MyClass, '#method'
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:59
class RuboCop::Cop::RSpec::FilePath < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:65
  def example_group(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:74
  def on_top_level_example_group(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:72
  def routing_metadata?(param0); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:133
  def camel_to_snake_case(string); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:140
  def custom_transform; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:86
  def ensure_correct_file_path(send_node, example_group, arguments); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:125
  def expected_path(constant); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:148
  def filename_ends_with?(pattern); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:144
  def ignore_methods?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:118
  def name_pattern(method_name); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:102
  def pattern_for(example_group, method_name); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:114
  def pattern_for_spec_suffix_only?; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:153
  def relevant_rubocop_rspec_file?(_file); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:98
  def routing_spec?(args); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:157
  def spec_suffix_only?; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/file_path.rb:62
RuboCop::Cop::RSpec::FilePath::MSG = T.let(T.unsafe(nil), String)

# Helps find the true end location of nodes which might contain heredocs.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/final_end_location.rb:7
module RuboCop::Cop::RSpec::FinalEndLocation
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/final_end_location.rb:8
  def final_end_location(start_node); end
end

# Checks if examples are focused.
#
# @example
#   # bad
#   describe MyClass, focus: true do
#   end
#
#   describe MyClass, :focus do
#   end
#
#   fdescribe MyClass do
#   end
#
#   # good
#   describe MyClass do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:22
class RuboCop::Cop::RSpec::Focus < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:29
  def focusable_selector?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:46
  def focused_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:40
  def metadata(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:51
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:78
  def correct_send(corrector, focus); end

  # @yield [node]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:65
  def focus_metadata(node, &block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:71
  def with_surrounding(focus); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/focus.rb:26
RuboCop::Cop::RSpec::Focus::MSG = T.let(T.unsafe(nil), String)

# Checks the arguments passed to `before`, `around`, and `after`.
#
# This cop checks for consistent style when specifying RSpec
# hooks which run for each example. There are three supported
# styles: "implicit", "each", and "example." All styles have
# the same behavior.
#
# @example `EnforcedStyle: implicit` (default)
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # good
#   before do
#   # ...
#   end
# @example `EnforcedStyle: each`
#   # bad
#   before(:example) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:each) do
#   # ...
#   end
# @example `EnforcedStyle: example`
#   # bad
#   before(:each) do
#   # ...
#   end
#
#   # bad
#   before do
#   # ...
#   end
#
#   # good
#   before(:example) do
#   # ...
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:60
class RuboCop::Cop::RSpec::HookArgument < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:75
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:68
  def scoped_hook(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:73
  def unscoped_hook(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:118
  def argument_range(send_node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:91
  def check_implicit(method_send); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:102
  def explicit_message(scope); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:114
  def hook(node, &block); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:110
  def implicit_style?; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:65
RuboCop::Cop::RSpec::HookArgument::EXPLICIT_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hook_argument.rb:64
RuboCop::Cop::RSpec::HookArgument::IMPLICIT_MSG = T.let(T.unsafe(nil), String)

# Checks for before/around/after hooks that come after an example.
#
# @example
#   # Bad
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   before { prepare }
#   after { clean_up }
#
#   # Good
#   before { prepare }
#   after { clean_up }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:26
class RuboCop::Cop::RSpec::HooksBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:32
  def example_or_group?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:39
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:70
  def autocorrect(corrector, node, first_example); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:51
  def check_hooks(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:66
  def find_first_example(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:47
  def multiline_block?(block); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/hooks_before_examples.rb:29
RuboCop::Cop::RSpec::HooksBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks for equality assertions with identical expressions on both sides.
#
# @example
#
#   # bad
#   expect(foo.bar).to eq(foo.bar)
#   expect(foo.bar).to eql(foo.bar)
#
#   # good
#   expect(foo.bar).to eq(2)
#   expect(foo.bar).to eql(2)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/identical_equality_assertion.rb:18
class RuboCop::Cop::RSpec::IdenticalEqualityAssertion < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/identical_equality_assertion.rb:24
  def equality_check?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/identical_equality_assertion.rb:30
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/identical_equality_assertion.rb:19
RuboCop::Cop::RSpec::IdenticalEqualityAssertion::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/identical_equality_assertion.rb:21
RuboCop::Cop::RSpec::IdenticalEqualityAssertion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that implicit block expectation syntax is not used.
#
# Prefer using explicit block expectations.
#
# @example
#   # bad
#   subject { -> { do_something } }
#   it { is_expected.to change(something).to(new_value) }
#
#   # good
#   it 'changes something to a new value' do
#   expect { do_something }.to change(something).to(new_value)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:19
class RuboCop::Cop::RSpec::ImplicitBlockExpectation < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:35
  def implicit_expect(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:24
  def lambda?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:32
  def lambda_subject?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:39
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:61
  def find_subject(block_node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:57
  def multi_statement_example_group?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:48
  def nearest_subject(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:20
RuboCop::Cop::RSpec::ImplicitBlockExpectation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_block_expectation.rb:21
RuboCop::Cop::RSpec::ImplicitBlockExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that a consistent implicit expectation style is used.
#
# This cop can be configured using the `EnforcedStyle` option
# and supports the `--auto-gen-config` flag.
#
# @example `EnforcedStyle: is_expected` (default)
#
#   # bad
#   it { should be_truthy }
#
#   # good
#   it { is_expected.to be_truthy }
# @example `EnforcedStyle: should`
#
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { should be_truthy }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:27
class RuboCop::Cop::RSpec::ImplicitExpect < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:34
  def implicit_expect(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:49
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:78
  def is_expected_range(source_map); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:69
  def offending_expect(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:86
  def offense_message(offending_source); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:94
  def replacement_source(offending_source); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:47
RuboCop::Cop::RSpec::ImplicitExpect::ENFORCED_REPLACEMENTS = T.let(T.unsafe(nil), Hash)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_expect.rb:31
RuboCop::Cop::RSpec::ImplicitExpect::MSG = T.let(T.unsafe(nil), String)

# Checks for usage of implicit subject (`is_expected` / `should`).
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: single_line_only` (default)
#   # bad
#   it do
#   is_expected.to be_truthy
#   end
#
#   # good
#   it { is_expected.to be_truthy }
#   it do
#   expect(subject).to be_truthy
#   end
# @example `EnforcedStyle: single_statement_only`
#   # bad
#   it do
#   foo = 1
#   is_expected.to be_truthy
#   end
#
#   # good
#   it do
#   foo = 1
#   expect(subject).to be_truthy
#   end
#   it do
#   is_expected.to be_truthy
#   end
# @example `EnforcedStyle: disallow`
#   # bad
#   it { is_expected.to be_truthy }
#
#   # good
#   it { expect(subject).to be_truthy }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:45
class RuboCop::Cop::RSpec::ImplicitSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:53
  def implicit_subject?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:57
  def on_send(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:87
  def allowed_by_style?(example); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:68
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:80
  def valid_usage?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:49
RuboCop::Cop::RSpec::ImplicitSubject::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/implicit_subject.rb:50
RuboCop::Cop::RSpec::ImplicitSubject::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# A helper for `inflected` style
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:7
module RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:39
  def be_bool?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:44
  def be_boolthy?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:29
  def predicate_in_actual?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:48
  def boolean_matcher?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:16
  def check_inflected(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:60
  def message_inflected(predicate); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:56
  def predicate?(sym); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:85
  def remove_predicate(corrector, predicate); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:96
  def rewrite_matcher(corrector, predicate, matcher); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:67
  def to_predicate_matcher(name); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:107
  def true?(to_symbol, matcher); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:11
RuboCop::Cop::RSpec::InflectedHelper::MSG_INFLECTED = T.let(T.unsafe(nil), String)

# Helps you identify whether a given node
# is within an example group or not.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/inside_example_group.rb:8
module RuboCop::Cop::RSpec::InsideExampleGroup
  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/inside_example_group.rb:19
  def example_group_root?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/inside_example_group.rb:23
  def example_group_root_with_siblings?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/inside_example_group.rb:11
  def inside_example_group?(node); end
end

# Checks for `instance_double` used with `have_received`.
#
# @example
#   # bad
#   it do
#   foo = instance_double(Foo).as_null_object
#   expect(foo).to have_received(:bar)
#   end
#
#   # good
#   it do
#   foo = instance_spy(Foo)
#   expect(foo).to have_received(:bar)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:21
class RuboCop::Cop::RSpec::InstanceSpy < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:36
  def have_received_usage(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:28
  def null_double(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:45
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:61
  def autocorrect(corrector, node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_spy.rb:24
RuboCop::Cop::RSpec::InstanceSpy::MSG = T.let(T.unsafe(nil), String)

# Checks for instance variable usage in specs.
#
# This cop can be configured with the option `AssignmentOnly` which
# will configure the cop to only register offenses on instance
# variable usage if the instance variable is also assigned within
# the spec
#
# @example
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
# @example with AssignmentOnly configuration
#
#   # rubocop.yml
#   # RSpec/InstanceVariable:
#   #   AssignmentOnly: false
#
#   # bad
#   describe MyClass do
#   before { @foo = [] }
#   it { expect(@foo).to be_empty }
#   end
#
#   # allowed
#   describe MyClass do
#   it { expect(@foo).to be_empty }
#   end
#
#   # good
#   describe MyClass do
#   let(:foo) { [] }
#   it { expect(foo).to be_empty }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:49
class RuboCop::Cop::RSpec::InstanceVariable < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:61
  def custom_matcher?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:56
  def dynamic_class?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:72
  def ivar_assigned?(param0, param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:69
  def ivar_usage(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:74
  def on_top_level_group(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:91
  def assignment_only?; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:85
  def valid_usage?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/instance_variable.rb:52
RuboCop::Cop::RSpec::InstanceVariable::MSG = T.let(T.unsafe(nil), String)

# Checks that only one `it_behaves_like` style is used.
#
# @example `EnforcedStyle: it_behaves_like` (default)
#   # bad
#   it_should_behave_like 'a foo'
#
#   # good
#   it_behaves_like 'a foo'
# @example `EnforcedStyle: it_should_behave_like`
#   # bad
#   it_behaves_like 'a foo'
#
#   # good
#   it_should_behave_like 'a foo'
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:21
class RuboCop::Cop::RSpec::ItBehavesLike < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:30
  def example_inclusion_offense(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:32
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:42
  def message(_node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:25
RuboCop::Cop::RSpec::ItBehavesLike::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/it_behaves_like.rb:27
RuboCop::Cop::RSpec::ItBehavesLike::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check that `all` matcher is used instead of iterating over an array.
#
# @example
#   # bad
#   it 'validates users' do
#   [user1, user2, user3].each { |user| expect(user).to be_valid }
#   end
#
#   # good
#   it 'validates users' do
#   expect([user1, user2, user3]).to all(be_valid)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:18
class RuboCop::Cop::RSpec::IteratedExpectation < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:23
  def each?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:32
  def expectation?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:36
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:50
  def only_expectations?(body, arg); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:46
  def single_expectation?(body, arg); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/iterated_expectation.rb:19
RuboCop::Cop::RSpec::IteratedExpectation::MSG = T.let(T.unsafe(nil), String)

# Enforce that subject is the first definition in the test.
#
# @example
#   # bad
#   let(:params) { blah }
#   subject { described_class.new(params) }
#
#   before { do_something }
#   subject { described_class.new(params) }
#
#   it { expect_something }
#   subject { described_class.new(params) }
#   it { expect_something_else }
#
#   # good
#   subject { described_class.new(params) }
#   let(:params) { blah }
#
#   # good
#   subject { described_class.new(params) }
#   before { do_something }
#
#   # good
#   subject { described_class.new(params) }
#   it { expect_something }
#   it { expect_something_else }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:34
class RuboCop::Cop::RSpec::LeadingSubject < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::InsideExampleGroup
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:47
  def check_previous_nodes(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:40
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:70
  def autocorrect(corrector, node, sibling); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:76
  def offending?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:58
  def offending_node(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:66
  def parent(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leading_subject.rb:38
RuboCop::Cop::RSpec::LeadingSubject::MSG = T.let(T.unsafe(nil), String)

# Checks that no class, module, or constant is declared.
#
# Constants, including classes and modules, when declared in a block
# scope, are defined in global namespace, and leak between examples.
#
# If several examples may define a `DummyClass`, instead of being a
# blank slate class as it will be in the first example, subsequent
# examples will be reopening it and modifying its behavior in
# unpredictable ways.
# Even worse when a class that exists in the codebase is reopened.
#
# Anonymous classes are fine, since they don't result in global
# namespace name clashes.
#
# @example Constants leak between examples
#   # bad
#   describe SomeClass do
#   OtherClass = Struct.new
#   CONSTANT_HERE = 'I leak into global namespace'
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   stub_const('OtherClass', Struct.new)
#   stub_const('CONSTANT_HERE', 'I only exist during this example')
#   end
#   end
# @example
#   # bad
#   describe SomeClass do
#   class FooClass < described_class
#   def double_that
#   some_base_method * 2
#   end
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
#
#   # good - anonymous class, no constant needs to be defined
#   describe SomeClass do
#   let(:foo_class) do
#   Class.new(described_class) do
#   def double_that
#   some_base_method * 2
#   end
#   end
#   end
#
#   it { expect(foo_class.new.double_that).to eq(4) }
#   end
#
#   # good - constant is stubbed
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('FooClass', foo_class)
#   end
#
#   it { expect(FooClass.new.double_that).to eq(4) }
#   end
# @example
#   # bad
#   describe SomeClass do
#   module SomeModule
#   class SomeClass
#   def do_something
#   end
#   end
#   end
#   end
#
#   # good
#   describe SomeClass do
#   before do
#   foo_class = Class.new(described_class) do
#   def do_something
#   end
#   end
#   stub_const('SomeModule::SomeClass', foo_class)
#   end
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/mutating-constants
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:96
class RuboCop::Cop::RSpec::LeakyConstantDeclaration < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:101
  def on_casgn(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:107
  def on_class(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:113
  def on_module(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:121
  def inside_describe_block?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:98
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CLASS = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:97
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_CONST = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/leaky_constant_declaration.rb:99
RuboCop::Cop::RSpec::LeakyConstantDeclaration::MSG_MODULE = T.let(T.unsafe(nil), String)

# Checks for `let` definitions that come after an example.
#
# @example
#   # Bad
#   let(:foo) { bar }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   let(:some) { other }
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
#
#   # Good
#   let(:foo) { bar }
#   let(:some) { other }
#
#   it 'checks what foo does' do
#   expect(foo).to be
#   end
#
#   it 'checks what some does' do
#   expect(some).to be
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:33
class RuboCop::Cop::RSpec::LetBeforeExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:39
  def example_or_group?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:46
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:76
  def autocorrect(corrector, node, first_example); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:58
  def check_let_declarations(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:72
  def find_first_example(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:54
  def multiline_block?(block); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_before_examples.rb:36
RuboCop::Cop::RSpec::LetBeforeExamples::MSG = T.let(T.unsafe(nil), String)

# Checks unreferenced `let!` calls being used for test setup.
#
# @example
#   # Bad
#   let!(:my_widget) { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
#
#   # Good
#   it 'counts widgets' do
#   create(:widget)
#   expect(Widget.count).to eq(1)
#   end
#
#   # Good
#   before { create(:widget) }
#
#   it 'counts widgets' do
#   expect(Widget.count).to eq(1)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:28
class RuboCop::Cop::RSpec::LetSetup < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:32
  def example_or_shared_group_or_including?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:42
  def let_bang(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:50
  def method_called?(param0, param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:52
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:68
  def child_let_bang(node, &block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:62
  def unused_let_bang(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/let_setup.rb:29
RuboCop::Cop::RSpec::LetSetup::MSG = T.let(T.unsafe(nil), String)

# Check that chains of messages are not being stubbed.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar, :baz).and_return(42)
#
#   # better
#   thing = Thing.new(baz: 42)
#   allow(foo).to receive(:bar).and_return(thing)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_chain.rb:16
class RuboCop::Cop::RSpec::MessageChain < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_chain.rb:20
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_chain.rb:17
RuboCop::Cop::RSpec::MessageChain::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_chain.rb:18
RuboCop::Cop::RSpec::MessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for consistent message expectation style.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: allow` (default)
#
#   # bad
#   expect(foo).to receive(:bar)
#
#   # good
#   allow(foo).to receive(:bar)
# @example `EnforcedStyle: expect`
#
#   # bad
#   allow(foo).to receive(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:27
class RuboCop::Cop::RSpec::MessageExpectation < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:36
  def message_expectation(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:43
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:41
  def receive_message?(param0); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:56
  def preferred_style?(expectation); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:30
RuboCop::Cop::RSpec::MessageExpectation::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:33
RuboCop::Cop::RSpec::MessageExpectation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_expectation.rb:32
RuboCop::Cop::RSpec::MessageExpectation::SUPPORTED_STYLES = T.let(T.unsafe(nil), Array)

# Checks that message expectations are set using spies.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: have_received` (default)
#
#   # bad
#   expect(foo).to receive(:bar)
#   do_something
#
#   # good
#   allow(foo).to receive(:bar) # or use instance_spy
#   do_something
#   expect(foo).to have_received(:bar)
# @example `EnforcedStyle: receive`
#
#   # bad
#   allow(foo).to receive(:bar)
#   do_something
#   expect(foo).to have_received(:bar)
#
#   # good
#   expect(foo).to receive(:bar)
#   do_something
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:33
class RuboCop::Cop::RSpec::MessageSpies < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:45
  def message_expectation(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:54
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:50
  def receive_message(param0); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:77
  def error_message(receiver); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:73
  def preferred_style?(expectation); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:67
  def receive_message_matcher(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:38
RuboCop::Cop::RSpec::MessageSpies::MSG_HAVE_RECEIVED = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:36
RuboCop::Cop::RSpec::MessageSpies::MSG_RECEIVE = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/message_spies.rb:42
RuboCop::Cop::RSpec::MessageSpies::SUPPORTED_STYLES = T.let(T.unsafe(nil), Array)

# Checks that the first argument to an example group is not empty.
#
# @example
#   # bad
#   describe do
#   end
#
#   RSpec.describe do
#   end
#
#   # good
#   describe TestedClass do
#   end
#
#   describe "A feature example" do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/missing_example_group_argument.rb:22
class RuboCop::Cop::RSpec::MissingExampleGroupArgument < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/missing_example_group_argument.rb:25
  def on_block(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/missing_example_group_argument.rb:23
RuboCop::Cop::RSpec::MissingExampleGroupArgument::MSG = T.let(T.unsafe(nil), String)

# Checks for multiple top-level example groups.
#
# Multiple descriptions for the same class or module should either
# be nested or separated into different test files.
#
# @example
#   # bad
#   describe MyClass, '.do_something' do
#   end
#   describe MyClass, '.do_something_else' do
#   end
#
#   # good
#   describe MyClass do
#   describe '.do_something' do
#   end
#   describe '.do_something_else' do
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_describes.rb:25
class RuboCop::Cop::RSpec::MultipleDescribes < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_describes.rb:30
  def on_top_level_group(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_describes.rb:28
RuboCop::Cop::RSpec::MultipleDescribes::MSG = T.let(T.unsafe(nil), String)

# Checks if examples contain too many `expect` calls.
#
# This cop is configurable using the `Max` option
# and works with `--auto-gen-config`.
#
# @example
#
#   # bad
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
#
#   # good
#   describe UserCreator do
#   it 'sets the users name' do
#   expect(user.name).to eq("John")
#   end
#
#   it 'sets the users age' do
#   expect(user.age).to eq(22)
#   end
#   end
# @example `aggregate_failures: true` (default)
#
#   # good - the cop ignores when RSpec aggregates failures
#   describe UserCreator do
#   it 'builds a user', :aggregate_failures do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @example `aggregate_failures: false`
#
#   # Detected as an offense
#   describe UserCreator do
#   it 'builds a user', aggregate_failures: false do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @example configuration
#
#   # .rubocop.yml
#   # RSpec/MultipleExpectations:
#   #   Max: 2
#
#   # not flagged by rubocop
#   describe UserCreator do
#   it 'builds a user' do
#   expect(user.name).to eq("John")
#   expect(user.age).to eq(22)
#   end
#   end
# @see http://betterspecs.org/#single Single expectation test
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:68
class RuboCop::Cop::RSpec::MultipleExpectations < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:77
  def aggregate_failures?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:87
  def aggregate_failures_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:85
  def expect?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:91
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:107
  def example_with_aggregate_failures?(example_node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:114
  def find_aggregate_failures(example_node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:119
  def find_expectation(node, &block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:130
  def flag_example(node, expectation_count:); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:141
  def max_expectations; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:73
RuboCop::Cop::RSpec::MultipleExpectations::ANYTHING = T.let(T.unsafe(nil), Proc)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:71
RuboCop::Cop::RSpec::MultipleExpectations::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_expectations.rb:74
RuboCop::Cop::RSpec::MultipleExpectations::TRUE = T.let(T.unsafe(nil), Proc)

# Checks if example groups contain too many `let` and `subject` calls.
#
# This cop is configurable using the `Max` option and the `AllowSubject`
# which will configure the cop to only register offenses on calls to
# `let` and not calls to `subject`.
#
# @example
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#
#   context 'when stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
#
#   # good
#   describe MyClass do
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#
#   describe MyClass do
#   context 'when stuff' do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:booger) { [] }
#   end
#
#   context 'when other stuff' do
#   let(:qux) { [] }
#   let(:quux) { [] }
#   let(:quuz) { {} }
#   end
#   end
# @example when disabling AllowSubject configuration
#
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   AllowSubject: false
#
#   # bad - `subject` counts towards memoized helpers
#   describe MyClass do
#   subject { {} }
#   let(:foo) { [] }
#   let(:bar) { [] }
#   let!(:baz) { [] }
#   let(:qux) { [] }
#   let(:quux) { [] }
#   end
# @example with Max configuration
#
#   # rubocop.yml
#   # RSpec/MultipleMemoizedHelpers:
#   #   Max: 1
#
#   # bad
#   describe MyClass do
#   let(:foo) { [] }
#   let(:bar) { [] }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:86
class RuboCop::Cop::RSpec::MultipleMemoizedHelpers < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::Variable

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:92
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:103
  def on_new_investigation; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:112
  def all_helpers(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:144
  def allow_subject?; end

  # Returns the value of attribute example_group_memoized_helpers.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:110
  def example_group_memoized_helpers; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:119
  def helpers(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:140
  def max; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:130
  def variable_nodes(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_memoized_helpers.rb:90
RuboCop::Cop::RSpec::MultipleMemoizedHelpers::MSG = T.let(T.unsafe(nil), String)

# Checks if an example group defines `subject` multiple times.
#
# The autocorrect behavior for this cop depends on the type of
# duplication:
#
#   - If multiple named subjects are defined then this probably indicates
#     that the overwritten subjects (all subjects except the last
#     definition) are effectively being used to define helpers. In this
#     case they are replaced with `let`.
#
#   - If multiple unnamed subjects are defined though then this can *only*
#     be dead code and we remove the overwritten subject definitions.
#
#   - If subjects are defined with `subject!` then we don't autocorrect.
#     This is enough of an edge case that people can just move this to
#     a `before` hook on their own
#
# @example
#
#   # bad
#   describe Foo do
#   subject(:user) { User.new }
#   subject(:post) { Post.new }
#   end
#
#   # good
#   describe Foo do
#   let(:user) { User.new }
#   subject(:post) { Post.new }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:36
class RuboCop::Cop::RSpec::MultipleSubjects < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:42
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:56
  def autocorrect(corrector, subject); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:66
  def named_subject?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:74
  def remove_autocorrect(corrector, node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:70
  def rename_autocorrect(corrector, node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/multiple_subjects.rb:40
RuboCop::Cop::RSpec::MultipleSubjects::MSG = T.let(T.unsafe(nil), String)

# Checks for explicitly referenced test subjects.
#
# RSpec lets you declare an "implicit subject" using `subject { ... }`
# which allows for tests like `it { is_expected.to be_valid }`.
# If you need to reference your test subject you should explicitly
# name it using `subject(:your_subject_name) { ... }`. Your test subjects
# should be the most important object in your tests so they deserve
# a descriptive name.
#
# This cop can be configured in your configuration using the
# `IgnoreSharedExamples` which will not report offenses for implicit
# subjects in shared example groups.
#
# @example
#   # bad
#   RSpec.describe User do
#   subject { described_class.new }
#
#   it 'is valid' do
#   expect(subject.valid?).to be(true)
#   end
#   end
#
#   # good
#   RSpec.describe Foo do
#   subject(:user) { described_class.new }
#
#   it 'is valid' do
#   expect(user.valid?).to be(true)
#   end
#   end
#
#   # also good
#   RSpec.describe Foo do
#   subject(:user) { described_class.new }
#
#   it { is_expected.to be_valid }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:44
class RuboCop::Cop::RSpec::NamedSubject < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:48
  def example_or_hook_block?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:68
  def ignored_shared_example?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:58
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:52
  def shared_example?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:56
  def subject_usage(param0); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/named_subject.rb:45
RuboCop::Cop::RSpec::NamedSubject::MSG = T.let(T.unsafe(nil), String)

# Checks for nested example groups.
#
# This cop is configurable using the `Max` option
# and supports `--auto-gen-config`.
#
# @example
#   # bad
#   context 'when using some feature' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   context 'when user is signed in' do  # flagged by rubocop
#   let(:user) do
#   UserCreate.call(user_attributes)
#   end
#
#   let(:user_attributes) do
#   {
#   name: 'John',
#   age:  22,
#   role: role
#   }
#   end
#
#   context 'when user is an admin' do # flagged by rubocop
#   let(:role) { 'admin' }
#
#   it 'blah blah'
#   it 'yada yada'
#   end
#   end
#   end
#
#   # better
#   context 'using some feature as an admin' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   let(:user) do
#   UserCreate.call(
#   name: 'John',
#   age:  22,
#   role: 'admin'
#   )
#   end
#
#   it 'blah blah'
#   it 'yada yada'
#   end
# @example configuration
#
#   # .rubocop.yml
#   # RSpec/NestedGroups:
#   #   Max: 2
#
#   context 'when using some feature' do
#   let(:some)    { :various }
#   let(:feature) { :setup   }
#
#   context 'when user is signed in' do
#   let(:user) do
#   UserCreate.call(user_attributes)
#   end
#
#   let(:user_attributes) do
#   {
#   name: 'John',
#   age:  22,
#   role: role
#   }
#   end
#
#   context 'when user is an admin' do # flagged by rubocop
#   let(:role) { 'admin' }
#
#   it 'blah blah'
#   it 'yada yada'
#   end
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:88
class RuboCop::Cop::RSpec::NestedGroups < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:100
  def on_top_level_group(node); end

  private

  # @yield [node, nesting]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:112
  def find_nested_example_groups(node, nesting: T.unsafe(nil), &block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:127
  def max_nesting; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:131
  def max_nesting_config; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:123
  def message(nesting); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:94
RuboCop::Cop::RSpec::NestedGroups::DEPRECATED_MAX_KEY = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:96
RuboCop::Cop::RSpec::NestedGroups::DEPRECATION_WARNING = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/nested_groups.rb:92
RuboCop::Cop::RSpec::NestedGroups::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent method usage for negating expectations.
#
# @example `EnforcedStyle: not_to` (default)
#
#   # bad
#   it '...' do
#   expect(false).to_not be_true
#   end
#
#   # good
#   it '...' do
#   expect(false).not_to be_true
#   end
# @example `EnforcedStyle: to_not`
#
#   # bad
#   it '...' do
#   expect(false).not_to be_true
#   end
#
#   # good
#   it '...' do
#   expect(false).to_not be_true
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:31
class RuboCop::Cop::RSpec::NotToNot < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:39
  def not_to_not_offense(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:41
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:51
  def message(_node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:35
RuboCop::Cop::RSpec::NotToNot::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/not_to_not.rb:36
RuboCop::Cop::RSpec::NotToNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks if there is a let/subject that overwrites an existing one.
#
# @example
#   # bad
#   let(:foo) { bar }
#   let(:foo) { baz }
#
#   subject(:foo) { bar }
#   let(:foo) { baz }
#
#   let(:foo) { bar }
#   let!(:foo) { baz }
#
#   # good
#   subject(:test) { something }
#   let(:foo) { bar }
#   let(:baz) { baz }
#   let!(:other) { other }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:24
class RuboCop::Cop::RSpec::OverwritingSetup < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:31
  def first_argument_name(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:33
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:28
  def setup?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:61
  def common_setup?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:46
  def find_duplicates(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/overwriting_setup.rb:25
RuboCop::Cop::RSpec::OverwritingSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for any pending or skipped examples.
#
# @example
#   # bad
#   describe MyClass do
#   it "should be true"
#   end
#
#   describe MyClass do
#   it "should be true", skip: true do
#   expect(1).to eq(2)
#   end
#   end
#
#   describe MyClass do
#   it "should be true" do
#   pending
#   end
#   end
#
#   describe MyClass do
#   xit "should be true" do
#   end
#   end
#
#   # good
#   describe MyClass do
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:34
class RuboCop::Cop::RSpec::Pending < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:64
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:55
  def pending_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:52
  def skip_or_pending?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:38
  def skippable?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:44
  def skipped_in_metadata?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:72
  def skipped?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/pending.rb:35
RuboCop::Cop::RSpec::Pending::MSG = T.let(T.unsafe(nil), String)

# Prefer using predicate matcher over using predicate method directly.
#
# RSpec defines magic matchers for predicate methods.
# This cop recommends to use the predicate matcher instead of using
# predicate method directly.
#
# @example Strict: true, EnforcedStyle: inflected (default)
#   # bad
#   expect(foo.something?).to be_truthy
#
#   # good
#   expect(foo).to be_something
#
#   # also good - It checks "true" strictly.
#   expect(foo.something?).to be(true)
# @example Strict: false, EnforcedStyle: inflected
#   # bad
#   expect(foo.something?).to be_truthy
#   expect(foo.something?).to be(true)
#
#   # good
#   expect(foo).to be_something
# @example Strict: true, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be(true)
# @example Strict: false, EnforcedStyle: explicit
#   # bad
#   expect(foo).to be_something
#
#   # good - the above code is rewritten to it by this cop
#   expect(foo.something?).to be_truthy
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:279
class RuboCop::Cop::RSpec::PredicateMatcher < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::InflectedHelper
  include ::RuboCop::Cop::RSpec::ExplicitHelper
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:294
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:285
  def on_send(node); end

  private

  # returns args location with whitespace
  #
  # @example
  #   foo 1, 2
  #   ^^^^^
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:304
  def args_loc(send_node); end

  # returns block location with whitespace
  #
  # @example
  #   foo { bar }
  #   ^^^^^^^^
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/predicate_matcher.rb:314
  def block_loc(send_node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/avoid_setup_hook.rb:6
module RuboCop::Cop::RSpec::Rails; end

# Checks that tests use RSpec `before` hook over Rails `setup` method.
#
# @example
#
#   # bad
#   setup do
#   allow(foo).to receive(:bar)
#   end
#
#   # good
#   before do
#   allow(foo).to receive(:bar)
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/avoid_setup_hook.rb:21
class RuboCop::Cop::RSpec::Rails::AvoidSetupHook < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/avoid_setup_hook.rb:33
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/avoid_setup_hook.rb:27
  def setup_call(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/avoid_setup_hook.rb:24
RuboCop::Cop::RSpec::Rails::AvoidSetupHook::MSG = T.let(T.unsafe(nil), String)

# Checks that tests use `have_http_status` instead of equality matchers.
#
# @example
#   # bad
#   expect(response.status).to be(200)
#
#   # good
#   expect(response).to have_http_status(200)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/have_http_status.rb:16
class RuboCop::Cop::RSpec::Rails::HaveHttpStatus < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/have_http_status.rb:24
  def match_status(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/have_http_status.rb:34
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/have_http_status.rb:19
RuboCop::Cop::RSpec::Rails::HaveHttpStatus::MSG = T.let(T.unsafe(nil), String)

# Enforces use of symbolic or numeric value to describe HTTP status.
#
# @example `EnforcedStyle: symbolic` (default)
#   # bad
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#
#   # good
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
# @example `EnforcedStyle: numeric`
#   # bad
#   it { is_expected.to have_http_status :ok }
#   it { is_expected.to have_http_status :not_found }
#
#   # good
#   it { is_expected.to have_http_status 200 }
#   it { is_expected.to have_http_status 404 }
#   it { is_expected.to have_http_status :success }
#   it { is_expected.to have_http_status :error }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:33
class RuboCop::Cop::RSpec::Rails::HttpStatus < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:39
  def http_status(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:43
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:56
  def checker_class; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:105
class RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker
  # @return [NumericStyleChecker] a new instance of NumericStyleChecker
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:113
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:121
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:111
  def node; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:117
  def offensive?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:125
  def preferred_style; end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:139
  def allowed_symbol?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:131
  def number; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:135
  def symbol; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:109
RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker::ALLOWED_STATUSES = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:106
RuboCop::Cop::RSpec::Rails::HttpStatus::NumericStyleChecker::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:36
RuboCop::Cop::RSpec::Rails::HttpStatus::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:66
class RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker
  # @return [SymbolicStyleChecker] a new instance of SymbolicStyleChecker
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:72
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:80
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:70
  def node; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:76
  def offensive?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:84
  def preferred_style; end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:98
  def custom_http_status_code?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:94
  def number; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:90
  def symbol; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/rails/http_status.rb:67
RuboCop::Cop::RSpec::Rails::HttpStatus::SymbolicStyleChecker::MSG = T.let(T.unsafe(nil), String)

# Check for `once` and `twice` receive counts matchers usage.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).exactly(1).times
#   expect(foo).to receive(:bar).exactly(2).times
#   expect(foo).to receive(:bar).at_least(1).times
#   expect(foo).to receive(:bar).at_least(2).times
#   expect(foo).to receive(:bar).at_most(1).times
#   expect(foo).to receive(:bar).at_most(2).times
#
#   # good
#   expect(foo).to receive(:bar).once
#   expect(foo).to receive(:bar).twice
#   expect(foo).to receive(:bar).at_least(:once)
#   expect(foo).to receive(:bar).at_least(:twice)
#   expect(foo).to receive(:bar).at_most(:once)
#   expect(foo).to receive(:bar).at_most(:twice).times
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:26
class RuboCop::Cop::RSpec::ReceiveCounts < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:41
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:34
  def receive_counts(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:39
  def stub?(param0); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:56
  def autocorrect(corrector, node, range); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:73
  def matcher_for(method, count); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:65
  def message_for(node, source); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:82
  def range(node, offending_node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:29
RuboCop::Cop::RSpec::ReceiveCounts::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_counts.rb:31
RuboCop::Cop::RSpec::ReceiveCounts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Prefer `not_to receive(...)` over `receive(...).never`.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).never
#
#   # good
#   expect(foo).not_to receive(:bar)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:16
class RuboCop::Cop::RSpec::ReceiveNever < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:22
  def method_on_stub?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:24
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:34
  def autocorrect(corrector, node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:18
RuboCop::Cop::RSpec::ReceiveNever::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/receive_never.rb:19
RuboCop::Cop::RSpec::ReceiveNever::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Check for repeated description strings in example groups.
#
# @example
#
#   # bad
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid when first and last name are present' do
#   # ...
#   end
#
#   it 'is valid when last name only is present' do
#   # ...
#   end
#   end
#
#   # good
#   RSpec.describe User do
#   it 'is valid' do
#   # ...
#   end
#
#   it 'is valid', :flag do
#   # ...
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_description.rb:43
class RuboCop::Cop::RSpec::RepeatedDescription < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_description.rb:46
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_description.rb:70
  def example_signature(example); end

  # Select examples in the current scope with repeated description strings
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_description.rb:57
  def repeated_descriptions(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_description.rb:44
RuboCop::Cop::RSpec::RepeatedDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated examples within example groups.
#
# @example
#
#   it 'is valid' do
#   expect(user).to be_valid
#   end
#
#   it 'validates the user' do
#   expect(user).to be_valid
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example.rb:18
class RuboCop::Cop::RSpec::RepeatedExample < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example.rb:21
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example.rb:41
  def example_signature(example); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example.rb:31
  def repeated_examples(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example.rb:19
RuboCop::Cop::RSpec::RepeatedExample::MSG = T.let(T.unsafe(nil), String)

# Check for repeated describe and context block body.
#
# @example
#
#   # bad
#   describe 'cool feature x' do
#   it { cool_predicate }
#   end
#
#   describe 'cool feature y' do
#   it { cool_predicate }
#   end
#
#   # good
#   describe 'cool feature' do
#   it { cool_predicate }
#   end
#
#   describe 'another cool feature' do
#   it { another_predicate }
#   end
#
#   # good
#   context 'when case x', :tag do
#   it { cool_predicate }
#   end
#
#   context 'when case y' do
#   it { cool_predicate }
#   end
#
#   # good
#   context Array do
#   it { is_expected.to respond_to :each }
#   end
#
#   context Hash do
#   it { is_expected.to respond_to :each }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:46
class RuboCop::Cop::RSpec::RepeatedExampleGroupBody < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:58
  def body(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:61
  def const_arg(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:55
  def metadata(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:68
  def on_begin(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:50
  def several_example_groups?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:64
  def skip_or_pending?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:89
  def add_repeated_lines(groups); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:98
  def message(group, repeats); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:78
  def repeated_group_bodies(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:94
  def signature_keys(group); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_body.rb:47
RuboCop::Cop::RSpec::RepeatedExampleGroupBody::MSG = T.let(T.unsafe(nil), String)

# Check for repeated example group descriptions.
#
# @example
#
#   # bad
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'cool feature' do
#   # example group
#   end
#
#   # bad
#   context 'when case x' do
#   # example group
#   end
#
#   describe 'when case x' do
#   # example group
#   end
#
#   # good
#   describe 'cool feature' do
#   # example group
#   end
#
#   describe 'another cool feature' do
#   # example group
#   end
#
#   # good
#   context 'when case x' do
#   # example group
#   end
#
#   context 'when another case' do
#   # example group
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:46
class RuboCop::Cop::RSpec::RepeatedExampleGroupDescription < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:55
  def doc_string_and_metadata(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:65
  def empty_description?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:67
  def on_begin(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:50
  def several_example_groups?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:60
  def skip_or_pending?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:89
  def add_repeated_lines(groups); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:94
  def message(group, repeats); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:77
  def repeated_group_descriptions(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_example_group_description.rb:47
RuboCop::Cop::RSpec::RepeatedExampleGroupDescription::MSG = T.let(T.unsafe(nil), String)

# Check for repeated include of shared examples.
#
# @example
#
#   # bad
#   describe 'foo' do
#   include_examples 'cool stuff'
#   include_examples 'cool stuff'
#   end
#
#   # bad
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'thing'
#   end
#
#   # bad
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a duck'
#   end
#
#   # good
#   describe 'foo' do
#   include_examples 'cool stuff'
#   end
#
#   describe 'bar' do
#   include_examples 'cool stuff'
#   end
#
#   # good
#   describe 'foo' do
#   it_behaves_like 'a cool', 'thing'
#   it_behaves_like 'a cool', 'person'
#   end
#
#   # good
#   context 'foo' do
#   it_should_behave_like 'a duck'
#   it_should_behave_like 'a goose'
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:49
class RuboCop::Cop::RSpec::RepeatedIncludeExample < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:59
  def include_examples?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:67
  def on_begin(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:54
  def several_include_examples?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:63
  def shared_examples_name(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:92
  def add_repeated_lines(items); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:87
  def literal_include_examples?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:101
  def message(item, repeats); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:77
  def repeated_include_examples(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:97
  def signature_keys(item); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/repeated_include_example.rb:50
RuboCop::Cop::RSpec::RepeatedIncludeExample::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent style of stub's return setting.
#
# Enforces either `and_return` or block-style return in the cases
# where the returned value is constant. Ignores dynamic returned values
# are the result would be different
#
# This cop can be configured using the `EnforcedStyle` option
#
# @example `EnforcedStyle: and_return` (default)
#   # bad
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#
#   # good
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar) { bar.baz }
# @example `EnforcedStyle: block`
#   # bad
#   allow(Foo).to receive(:bar).and_return("baz")
#   expect(Foo).to receive(:bar).and_return("baz")
#
#   # good
#   allow(Foo).to receive(:bar) { "baz" }
#   expect(Foo).to receive(:bar) { "baz" }
#   # also good as the returned value is dynamic
#   allow(Foo).to receive(:bar).and_return(bar.baz)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:36
class RuboCop::Cop::RSpec::ReturnFromStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:51
  def and_return_value(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:45
  def contains_stub?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:62
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:55
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:48
  def stub_with_block?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:71
  def check_and_return_call(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:81
  def check_block_body(block); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:90
  def dynamic?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:95
class RuboCop::Cop::RSpec::ReturnFromStub::AndReturnCallCorrector
  # @return [AndReturnCallCorrector] a new instance of AndReturnCallCorrector
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:96
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:102
  def call(corrector); end

  private

  # Returns the value of attribute arg.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:111
  def arg; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:133
  def hash_without_braces?; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:113
  def heredoc?; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:111
  def node; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:117
  def range; end

  # Returns the value of attribute receiver.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:111
  def receiver; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:125
  def replacement; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:139
class RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector
  # @return [BlockBodyCorrector] a new instance of BlockBodyCorrector
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:140
  def initialize(block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:146
  def call(corrector); end

  private

  # Returns the value of attribute block.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:158
  def block; end

  # Returns the value of attribute body.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:158
  def body; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:160
  def heredoc?; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:158
  def node; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:164
RuboCop::Cop::RSpec::ReturnFromStub::BlockBodyCorrector::NULL_BLOCK_BODY = T.let(T.unsafe(nil), T.untyped)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:40
RuboCop::Cop::RSpec::ReturnFromStub::MSG_AND_RETURN = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:41
RuboCop::Cop::RSpec::ReturnFromStub::MSG_BLOCK = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/return_from_stub.rb:42
RuboCop::Cop::RSpec::ReturnFromStub::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for let scattered across the example group.
#
# Group lets together
#
# @example
#   # bad
#   describe Foo do
#   let(:foo) { 1 }
#   subject { Foo }
#   let(:bar) { 2 }
#   before { prepare }
#   let!(:baz) { 3 }
#   end
#
#   # good
#   describe Foo do
#   subject { Foo }
#   before { prepare }
#   let(:foo) { 1 }
#   let(:bar) { 2 }
#   let!(:baz) { 3 }
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_let.rb:29
class RuboCop::Cop::RSpec::ScatteredLet < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_let.rb:34
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_let.rb:42
  def check_let_declarations(body); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_let.rb:57
  def find_first_let(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_let.rb:32
RuboCop::Cop::RSpec::ScatteredLet::MSG = T.let(T.unsafe(nil), String)

# Checks for setup scattered across multiple hooks in an example group.
#
# Unify `before`, `after`, and `around` hooks when possible.
#
# @example
#   # bad
#   describe Foo do
#   before { setup1 }
#   before { setup2 }
#   end
#
#   # good
#   describe Foo do
#   before do
#   setup1
#   setup2
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_setup.rb:25
class RuboCop::Cop::RSpec::ScatteredSetup < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_setup.rb:57
  def lines_msg(numbers); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_setup.rb:29
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_setup.rb:44
  def repeated_hooks(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/scattered_setup.rb:26
RuboCop::Cop::RSpec::ScatteredSetup::MSG = T.let(T.unsafe(nil), String)

# Checks for proper shared_context and shared_examples usage.
#
# If there are no examples defined, use shared_context.
# If there is no setup defined, use shared_examples.
#
# @example
#   # bad
#   RSpec.shared_context 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
#
#   # good
#   RSpec.shared_examples 'only examples here' do
#   it 'does x' do
#   end
#
#   it 'does y' do
#   end
#   end
# @example
#   # bad
#   RSpec.shared_examples 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
#
#   # good
#   RSpec.shared_context 'only setup here' do
#   subject(:foo) { :bar }
#
#   let(:baz) { :bazz }
#
#   before do
#   something
#   end
#   end
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:53
class RuboCop::Cop::RSpec::SharedContext < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:64
  def context?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:60
  def examples?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:82
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:76
  def shared_context(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:79
  def shared_example(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:98
  def context_with_only_examples(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:102
  def examples_with_only_context(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:57
RuboCop::Cop::RSpec::SharedContext::MSG_CONTEXT = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_context.rb:56
RuboCop::Cop::RSpec::SharedContext::MSG_EXAMPLES = T.let(T.unsafe(nil), String)

# Enforces use of string to titleize shared examples.
#
# @example
#   # bad
#   it_behaves_like :foo_bar_baz
#   it_should_behave_like :foo_bar_baz
#   shared_examples :foo_bar_baz
#   shared_examples_for :foo_bar_baz
#   include_examples :foo_bar_baz
#
#   # good
#   it_behaves_like 'foo bar baz'
#   it_should_behave_like 'foo bar baz'
#   shared_examples 'foo bar baz'
#   shared_examples_for 'foo bar baz'
#   include_examples 'foo bar baz'
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:23
class RuboCop::Cop::RSpec::SharedExamples < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:32
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:27
  def shared_examples(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:45
class RuboCop::Cop::RSpec::SharedExamples::Checker
  # @return [Checker] a new instance of Checker
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:51
  def initialize(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:55
  def message; end

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:49
  def node; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:59
  def preferred_style; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:66
  def symbol; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:70
  def wrap_with_single_quotes(string); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/shared_examples.rb:46
RuboCop::Cop::RSpec::SharedExamples::Checker::MSG = T.let(T.unsafe(nil), String)

# Checks that chains of messages contain more than one element.
#
# @example
#   # bad
#   allow(foo).to receive_message_chain(:bar).and_return(42)
#
#   # good
#   allow(foo).to receive(:bar).and_return(42)
#
#   # also good
#   allow(foo).to receive(:bar, :baz)
#   allow(foo).to receive("bar.baz")
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:19
class RuboCop::Cop::RSpec::SingleArgumentMessageChain < ::RuboCop::Cop::RSpec::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:27
  def message_chain(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:34
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:32
  def single_key_hash?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:49
  def autocorrect(corrector, node, method, arg); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:77
  def autocorrect_array_arg(corrector, arg); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:69
  def autocorrect_hash_arg(corrector, arg); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:83
  def key_to_arg(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:88
  def replacement(method); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:65
  def single_element_array?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:55
  def valid_usage?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:22
RuboCop::Cop::RSpec::SingleArgumentMessageChain::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/single_argument_message_chain.rb:24
RuboCop::Cop::RSpec::SingleArgumentMessageChain::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks that message expectations do not have a configured response.
#
# @example
#
#   # bad
#   expect(foo).to receive(:bar).with(42).and_return("hello world")
#
#   # good (without spies)
#   allow(foo).to receive(:bar).with(42).and_return("hello world")
#   expect(foo).to receive(:bar).with(42)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:17
class RuboCop::Cop::RSpec::StubbedMock < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:43
  def configured_response?(param0 = T.unsafe(nil)); end

  # Match expectation
  #
  # @example source that matches
  #   is_expected.to be_in_the_bar
  # @example source that matches
  #   expect(cocktail).to contain_exactly(:fresh_orange_juice, :campari)
  # @example source that matches
  #   expect_any_instance_of(Officer).to be_alert
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] expectation, method name, matcher
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:62
  def expectation(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response in block-pass
  #
  # @example source that matches
  #   receive(:foo, &canned)
  # @example source that matches
  #   receive_message_chain(:foo, :bar, &canned)
  # @example source that matches
  #   receive(:foo).with('bar', &canned)
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:130
  def matcher_with_blockpass(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response
  #
  # @example source that matches
  #   receive(:foo).and_return('bar')
  # @example source that matches
  #   receive(:lower).and_raise(SomeError)
  # @example source that matches
  #   receive(:redirect).and_call_original
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:82
  def matcher_with_configured_response(param0 = T.unsafe(nil)); end

  # Match matcher with a configured response defined as a hash
  #
  # @example source that matches
  #   receive_messages(foo: 'bar', baz: 'qux')
  # @example source that matches
  #   receive_message_chain(:foo, bar: 'baz')
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:109
  def matcher_with_hash(param0 = T.unsafe(nil)); end

  # Match matcher with a return block
  #
  # @example source that matches
  #   receive(:foo) { 'bar' }
  # @param node [RuboCop::AST::Node]
  # @yield [RuboCop::AST::Node] matcher
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:94
  def matcher_with_return_block(param0 = T.unsafe(nil)); end

  # Match message expectation matcher
  #
  # @example source that matches
  #   receive(:foo)
  # @example source that matches
  #   receive_message_chain(:foo, :bar)
  # @example source that matches
  #   receive(:foo).with('bar')
  # @param node [RuboCop::AST::Node]
  # @return [Array<RuboCop::AST::Node>] matching nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:35
  def message_expectation?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:137
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:154
  def msg(method_name); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:143
  def on_expectation(expectation, method_name, matcher); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:160
  def replacement(method_name); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/stubbed_mock.rb:18
RuboCop::Cop::RSpec::StubbedMock::MSG = T.let(T.unsafe(nil), String)

# Ensure that subject is defined using subject helper.
#
# @example
#
#   # bad
#   let(:subject) { foo }
#   let!(:subject) { foo }
#   subject(:subject) { foo }
#   subject!(:subject) { foo }
#
#   # bad
#   block = -> {}
#   let(:subject, &block)
#
#   # good
#   subject(:test_subject) { foo }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:23
class RuboCop::Cop::RSpec::SubjectDeclaration < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:28
  def offensive_subject_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:32
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:41
  def message_for(offense); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:24
RuboCop::Cop::RSpec::SubjectDeclaration::MSG_LET = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_declaration.rb:25
RuboCop::Cop::RSpec::SubjectDeclaration::MSG_REDUNDANT = T.let(T.unsafe(nil), String)

# Checks for stubbed test subjects.
#
# Checks nested subject stubs for innermost subject definition
# when subject is also defined in parent example groups.
#
# @example
#   # bad
#   describe Article do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#
#   # bad
#   describe Article do
#   subject(:foo) { Article.new }
#
#   context 'nested subject' do
#   subject(:article) { Article.new }
#
#   it 'indicates that the author is unknown' do
#   allow(article).to receive(:author).and_return(nil)
#   expect(article.description).to include('by an unknown author')
#   end
#   end
#   end
#
#   # good
#   describe Article do
#   subject(:article) { Article.new(author: nil) }
#
#   it 'indicates that the author is unknown' do
#   expect(article.description).to include('by an unknown author')
#   end
#   end
# @see https://robots.thoughtbot.com/don-t-stub-the-system-under-test
# @see https://samphippen.com/introducing-rspec-smells-and-where-to-find-them#smell-1-stubject
# @see https://github.com/rubocop-hq/rspec-style-guide#dont-stub-subject
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:51
class RuboCop::Cop::RSpec::SubjectStub < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RSpec::TopLevelGroup

  # Find a memoized helper
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:81
  def let?(param0 = T.unsafe(nil)); end

  # Match `allow` and `expect(...).to receive`
  #
  # @example source that matches
  #   allow(foo).to  receive(:bar)
  #   allow(foo).to  receive(:bar).with(1)
  #   allow(foo).to  receive(:bar).with(1).and_return(2)
  #   expect(foo).to receive(:bar)
  #   expect(foo).to receive(:bar).with(1)
  #   expect(foo).to receive(:bar).with(1).and_return(2)
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:98
  def message_expectation?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:110
  def message_expectation_matcher?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:116
  def on_top_level_group(node); end

  # Find a named or unnamed subject definition
  #
  # @example anonymous subject
  #   subject?(parse('subject { foo }').ast) do |name|
  #   name # => :subject
  #   end
  # @example named subject
  #   subject?(parse('subject(:thing) { foo }').ast) do |name|
  #   name # => :thing
  #   end
  # @param node [RuboCop::AST::Node]
  # @yield [Symbol] subject name
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:72
  def subject?(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:127
  def find_all_explicit(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:141
  def find_subject_expectations(node, subject_names = T.unsafe(nil), &block); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/subject_stub.rb:54
RuboCop::Cop::RSpec::SubjectStub::MSG = T.let(T.unsafe(nil), String)

# Helper methods for top level example group cops
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:7
module RuboCop::Cop::RSpec::TopLevelGroup
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:10
  def on_new_investigation; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:19
  def top_level_groups; end

  private

  # Dummy methods to be overridden in the consumer
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:27
  def on_top_level_example_group(_node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:29
  def on_top_level_group(_node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:48
  def root_node; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:31
  def top_level_group?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/top_level_group.rb:35
  def top_level_nodes(node); end
end

# Checks for a specified error in checking raised errors.
#
# Enforces one of an Exception type, a string, or a regular
# expression to match against the exception message as a parameter
# to `raise_error`
#
# @example
#
#   # bad
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error
#
#   # good
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(StandardError)
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error('error')
#
#   expect {
#   raise StandardError.new('error')
#   }.to raise_error(/err/)
#
#   expect { do_something }.not_to raise_error
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:33
class RuboCop::Cop::RSpec::UnspecifiedException < ::RuboCop::Cop::RSpec::Base
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:57
  def block_with_args?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:53
  def empty_exception_matcher?(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:38
  def empty_raise_error_or_exception(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:47
  def on_send(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:34
RuboCop::Cop::RSpec::UnspecifiedException::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/unspecified_exception.rb:35
RuboCop::Cop::RSpec::UnspecifiedException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Helps check offenses with variable definitions
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/variable.rb:7
module RuboCop::Cop::RSpec::Variable
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/variable.rb:14
  def variable_definition?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/variable.rb:11
RuboCop::Cop::RSpec::Variable::Helpers = RuboCop::RSpec::Language::Helpers

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/mixin/variable.rb:10
RuboCop::Cop::RSpec::Variable::Subjects = RuboCop::RSpec::Language::Subjects

# Checks that memoized helpers names are symbols or strings.
#
# @example EnforcedStyle: symbols (default)
#   # bad
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
#
#   # good
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
# @example EnforcedStyle: strings
#   # bad
#   subject(:user) { create_user }
#   let(:user_name) { 'Adam' }
#
#   # good
#   subject('user') { create_user }
#   let('user_name') { 'Adam' }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:25
class RuboCop::Cop::RSpec::VariableDefinition < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RSpec::Variable
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:32
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:47
  def correct_variable(variable); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:63
  def string?(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:58
  def style_violation?(variable); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:67
  def symbol?(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_definition.rb:30
RuboCop::Cop::RSpec::VariableDefinition::MSG = T.let(T.unsafe(nil), String)

# Checks that memoized helper names use the configured style.
#
# Variables can be excluded from checking using the `IgnoredPatterns`
# option.
#
# @example EnforcedStyle: snake_case (default)
#   # bad
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
#
#   # good
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
# @example EnforcedStyle: camelCase
#   # bad
#   subject(:user_name_1) { 'Adam' }
#   let(:user_name_2) { 'Adam' }
#
#   # good
#   subject(:userName1) { 'Adam' }
#   let(:userName2) { 'Adam' }
# @example IgnoredPatterns configuration
#
#   # rubocop.yml
#   # RSpec/VariableName:
#   #   EnforcedStyle: snake_case
#   #   IgnoredPatterns:
#   #     - ^userFood
# @example
#   # okay because it matches the `^userFood` regex in `IgnoredPatterns`
#   subject(:userFood_1) { 'spaghetti' }
#   let(:userFood_2) { 'fettuccine' }
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_name.rb:42
class RuboCop::Cop::RSpec::VariableName < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RSpec::Variable

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_name.rb:49
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_name.rb:60
  def message(style); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/variable_name.rb:47
RuboCop::Cop::RSpec::VariableName::MSG = T.let(T.unsafe(nil), String)

# Checks for consistent verified double reference style.
#
# Only investigates references that are one of the supported styles.
#
# This cop can be configured in your configuration using the
# `EnforcedStyle` option and supports `--auto-gen-config`.
#
# @example `EnforcedStyle: constant` (default)
#   # bad
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
# @example `EnforcedStyle: string`
#   # bad
#   let(:foo) do
#   instance_double(ClassName, method_name: 'returned_value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double('ClassName', method_name: 'returned_value')
#   end
# @example Reference is not in the supported style list. No enforcement
#
#   # good
#   let(:foo) do
#   instance_double(@klass, method_name: 'returned_value')
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:43
class RuboCop::Cop::RSpec::VerifiedDoubleReference < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:74
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:66
  def verified_double(param0 = T.unsafe(nil)); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:101
  def correct_style(violation); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:92
  def opposing_style?(class_reference); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:47
RuboCop::Cop::RSpec::VerifiedDoubleReference::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:60
RuboCop::Cop::RSpec::VerifiedDoubleReference::REFERENCE_TYPE_STYLES = T.let(T.unsafe(nil), Hash)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_double_reference.rb:49
RuboCop::Cop::RSpec::VerifiedDoubleReference::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

# Prefer using verifying doubles over normal doubles.
#
# @example
#   # bad
#   let(:foo) do
#   double(method_name: 'returned value')
#   end
#
#   # bad
#   let(:foo) do
#   double("ClassName", method_name: 'returned value')
#   end
#
#   # good
#   let(:foo) do
#   instance_double("ClassName", method_name: 'returned value')
#   end
# @see https://relishapp.com/rspec/rspec-mocks/docs/verifying-doubles
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:25
class RuboCop::Cop::RSpec::VerifiedDoubles < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:34
  def on_send(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:30
  def unverified_double(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:45
  def symbol?(name); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:26
RuboCop::Cop::RSpec::VerifiedDoubles::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/verified_doubles.rb:27
RuboCop::Cop::RSpec::VerifiedDoubles::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks void `expect()`.
#
# @example
#   # bad
#   expect(something)
#
#   # good
#   expect(something).to be(1)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:14
class RuboCop::Cop::RSpec::VoidExpect < ::RuboCop::Cop::RSpec::Base
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:20
  def expect?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:25
  def expect_block?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:35
  def on_block(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:29
  def on_send(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:43
  def check_expect(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:49
  def void?(expect); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:15
RuboCop::Cop::RSpec::VoidExpect::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/void_expect.rb:17
RuboCop::Cop::RSpec::VoidExpect::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

# Checks for calling a block within a stub.
#
# @example
#   # bad
#   allow(foo).to receive(:bar) { |&block| block.call(1) }
#
#   # good
#   expect(foo).to receive(:bar).and_yield(1)
#
# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:14
class RuboCop::Cop::RSpec::Yield < ::RuboCop::Cop::RSpec::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:24
  def block_arg(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:27
  def block_call?(param0 = T.unsafe(nil), param1); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:21
  def method_on_stub?(param0); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:29
  def on_block(node); end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:45
  def autocorrect(corrector, node, range); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:60
  def block_range(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:52
  def calling_block?(node, block); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:72
  def convert_block_to_yield(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:64
  def generate_replacement(node); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/cop/rspec/yield.rb:18
RuboCop::Cop::RSpec::Yield::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-1.31.2/lib/rubocop/ast_aliases.rb:5
RuboCop::NodePattern = RuboCop::AST::NodePattern

# source://rubocop-1.31.2/lib/rubocop/ast_aliases.rb:6
RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/version.rb:4
module RuboCop::RSpec; end

# Shared behavior for aligning braces for single line lets
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:6
class RuboCop::RSpec::AlignLetBrace
  include ::RuboCop::RSpec::Language
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  # @return [AlignLetBrace] a new instance of AlignLetBrace
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:10
  def initialize(root, token); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:21
  def indent_for(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:15
  def offending_tokens; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:43
  def adjacent_let_chunks; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:35
  def let_group_for(let); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:27
  def let_token(node); end

  # Returns the value of attribute root.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:60
  def root; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:53
  def single_line_lets; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:31
  def target_column_for(let); end

  # Returns the value of attribute token.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/align_let_brace.rb:60
  def token; end
end

# Wrapper for RSpec DSL methods
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:6
class RuboCop::RSpec::Concept
  include ::RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  # @return [Concept] a new instance of Concept
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:11
  def initialize(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:15
  def ==(other); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:15
  def eql?(other); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:21
  def hash; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:25
  def to_node; end

  protected

  # Returns the value of attribute node.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/concept.rb:31
  def node; end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:5
module RuboCop::RSpec::Corrector; end

# Helper methods to move a node
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:7
class RuboCop::RSpec::Corrector::MoveNode
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RSpec::FinalEndLocation
  include ::RuboCop::Cop::RSpec::CommentsHelp

  # @return [MoveNode] a new instance of MoveNode
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:14
  def initialize(node, corrector, processed_source); end

  # Returns the value of attribute corrector.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:12
  def corrector; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:27
  def move_after(other); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:20
  def move_before(other); end

  # Returns the value of attribute original.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:12
  def original; end

  # Returns the value of attribute processed_source.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:12
  def processed_source; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:40
  def node_range(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:44
  def node_range_with_surrounding_space(node); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/corrector/move_node.rb:36
  def source(node); end
end

# Wrapper for RSpec examples
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:7
class RuboCop::RSpec::Example < ::RuboCop::RSpec::Concept
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:28
  def definition; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:16
  def doc_string; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:8
  def extract_doc_string(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:14
  def extract_implementation(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:11
  def extract_metadata(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:24
  def implementation; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example.rb:20
  def metadata; end
end

# Wrapper for RSpec example groups
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:12
class RuboCop::RSpec::ExampleGroup < ::RuboCop::RSpec::Concept
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:30
  def examples; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:36
  def hooks; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:22
  def lets; end

  # Detect if the node is an example group or shared example
  #
  # Selectors which indicate that we should stop searching
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:13
  def scope_change?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:26
  def subjects; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:58
  def find_all(node, predicate); end

  # Recursively search for predicate within the current scope
  #
  # Searches node and halts when a scope change is detected
  #
  # @param node [RuboCop::AST::Node] node to recursively search
  # @param predicate [Symbol] method to call with node as argument
  # @return [Array<RuboCop::AST::Node>] discovered nodes
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/example_group.rb:52
  def find_all_in_scope(node, predicate); end
end

# RuboCop FactoryBot project namespace
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot/language.rb:5
module RuboCop::RSpec::FactoryBot
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:55
    def attribute_defining_methods; end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:59
    def reserved_methods; end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:7
RuboCop::RSpec::FactoryBot::ATTRIBUTE_DEFINING_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:30
RuboCop::RSpec::FactoryBot::DEFINITION_PROXY_METHODS = T.let(T.unsafe(nil), Array)

# Contains node matchers for common FactoryBot DSL.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot/language.rb:7
module RuboCop::RSpec::FactoryBot::Language
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot/language.rb:11
  def factory_bot?(param0 = T.unsafe(nil)); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:43
RuboCop::RSpec::FactoryBot::RESERVED_METHODS = T.let(T.unsafe(nil), Array)

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/factory_bot.rb:15
RuboCop::RSpec::FactoryBot::UNPROXIED_METHODS = T.let(T.unsafe(nil), Array)

# Wrapper for RSpec hook
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:7
class RuboCop::RSpec::Hook < ::RuboCop::RSpec::Concept
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:24
  def example?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:8
  def extract_metadata(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:18
  def knowable_scope?; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:38
  def metadata; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:14
  def name; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:28
  def scope; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:74
  def scope_argument; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:70
  def scope_name; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:51
  def transform_metadata(meta); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:66
  def transform_true(node); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/hook.rb:47
  def valid_scope?(node); end
end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/inject.rb:7
module RuboCop::RSpec::Inject
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/inject.rb:8
    def defaults!; end
  end
end

# Contains node matchers for common RSpec DSL.
#
# RSpec allows for configuring aliases for commonly used DSL elements, e.g.
# example groups and hooks. It is possible to configure RuboCop RSpec to
# be able to properly detect these elements in the `RSpec/Language` section
# of the RuboCop YAML configuration file.
#
# In addition to providing useful matchers, this class is responsible for
# using the configured aliases.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language/node_pattern.rb:5
module RuboCop::RSpec::Language
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::RSpec::Language::NodePattern

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:41
  def example?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:26
  def example_group?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:36
  def example_group_with_body?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:44
  def hook?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:55
  def include?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:47
  def let?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:23
  def rspec?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:29
  def shared_group?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:32
  def spec_group?(param0 = T.unsafe(nil)); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:63
  def subject?(param0 = T.unsafe(nil)); end

  class << self
    # Returns the value of attribute config.
    #
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:19
    def config; end

    # Sets the attribute config
    #
    # @param value the value to set the attribute config to.
    #
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:19
    def config=(_arg0); end
  end
end

# This is used in Dialect and DescribeClass cops to detect RSpec blocks.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:185
module RuboCop::RSpec::Language::ALL
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:186
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:65
module RuboCop::RSpec::Language::ExampleGroups
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:67
    def all(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:77
    def focused(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:73
    def regular(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:81
    def skipped(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:87
module RuboCop::RSpec::Language::Examples
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:89
    def all(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:100
    def focused(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:108
    def pending(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:96
    def regular(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:104
    def skipped(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:114
module RuboCop::RSpec::Language::Expectations
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:115
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:120
module RuboCop::RSpec::Language::Helpers
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:121
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:132
module RuboCop::RSpec::Language::HookScopes
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:133
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:126
module RuboCop::RSpec::Language::Hooks
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:127
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:138
module RuboCop::RSpec::Language::Includes
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:140
    def all(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:149
    def context(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:145
    def examples(element); end
  end
end

# Helper methods to detect RSpec DSL used with send and block
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language/node_pattern.rb:7
module RuboCop::RSpec::Language::NodePattern
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language/node_pattern.rb:12
  def block_pattern(string); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language/node_pattern.rb:8
  def send_pattern(string); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:155
module RuboCop::RSpec::Language::Runners
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:156
    def all(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:161
module RuboCop::RSpec::Language::SharedGroups
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:163
    def all(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:172
    def context(element); end

    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:168
    def examples(element); end
  end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:178
module RuboCop::RSpec::Language::Subjects
  class << self
    # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/language.rb:179
    def all(element); end
  end
end

# RuboCop RSpec specific extensions of RuboCop::AST::Node
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/node.rb:6
module RuboCop::RSpec::Node
  # In various cops we want to regard const as literal although it's not
  # strictly literal.
  #
  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/node.rb:9
  def recursive_literal_or_const?; end
end

# Version information for the RSpec RuboCop plugin.
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/version.rb:6
module RuboCop::RSpec::Version; end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/version.rb:7
RuboCop::RSpec::Version::STRING = T.let(T.unsafe(nil), String)

# RSpec example wording rewriter
#
# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:6
class RuboCop::RSpec::Wording
  # @return [Wording] a new instance of Wording
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:12
  def initialize(text, ignore:, replace:); end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:18
  def rewrite; end

  private

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:72
  def append_suffix(word, suffix); end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:57
  def ignored_word?(word); end

  # Returns the value of attribute ignores.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:31
  def ignores; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:43
  def remove_should_and_pluralize; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:33
  def replace_prefix(pattern, replacement); end

  # Returns the value of attribute replacements.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:31
  def replacements; end

  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:61
  def substitute(word); end

  # Returns the value of attribute text.
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:31
  def text; end

  # @return [Boolean]
  #
  # source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:39
  def uppercase?(word); end
end

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:9
RuboCop::RSpec::Wording::ES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:10
RuboCop::RSpec::Wording::IES_SUFFIX_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:8
RuboCop::RSpec::Wording::SHOULDNT_BE_PREFIX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-rspec-2.12.1/lib/rubocop/rspec/wording.rb:7
RuboCop::RSpec::Wording::SHOULDNT_PREFIX = T.let(T.unsafe(nil), Regexp)

# source://rubocop-1.31.2/lib/rubocop/ast_aliases.rb:7
RuboCop::Token = RuboCop::AST::Token
