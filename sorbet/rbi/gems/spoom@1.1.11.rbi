# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `spoom` gem.
# Please instead update this file by running `bin/tapioca gem spoom`.

# source://spoom-1.1.11/lib/spoom.rb:7
module Spoom
  class << self
    # source://spoom-1.1.11/lib/spoom.rb:29
    sig { params(cmd: ::String, arg: ::String, path: ::String, capture_err: T::Boolean).returns(::Spoom::ExecResult) }
    def exec(cmd, *arg, path: T.unsafe(nil), capture_err: T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/cli/helper.rb:9
module Spoom::Cli; end

# source://spoom-1.1.11/lib/spoom/cli/bump.rb:9
class Spoom::Cli::Bump < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom-1.1.11/lib/spoom/cli/bump.rb:32
  sig { params(directory: ::String).void }
  def bump(directory = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/bump.rb:155
  def config_files(path: T.unsafe(nil)); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/bump.rb:130
  def print_changes(files, command:, from: T.unsafe(nil), to: T.unsafe(nil), dry: T.unsafe(nil), path: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/bump.rb:151
  def undo_changes(files, from_strictness); end
end

# source://spoom-1.1.11/lib/spoom/cli/config.rb:9
class Spoom::Cli::Config < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/config.rb:15
  def show; end
end

# source://spoom-1.1.11/lib/spoom/cli/coverage.rb:9
class Spoom::Cli::Coverage < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:183
  def bundle_install(path, sha); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:195
  def message_no_data(file); end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:159
  def open(file = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:175
  def parse_time(string, option); end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:128
  def report; end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:20
  def snapshot; end

  # source://spoom-1.1.11/lib/spoom/cli/coverage.rb:42
  def timeline; end
end

# source://spoom-1.1.11/lib/spoom/cli/coverage.rb:12
Spoom::Cli::Coverage::DATA_DIR = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/cli/helper.rb:10
module Spoom::Cli::Helper
  include ::Spoom::Colorize

  requires_ancestor { Thor }

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:142
  sig { params(string: ::String).returns(::String) }
  def blue(string); end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:87
  sig { params(exit_code: ::Integer, block: T.nilable(T.proc.void)).void }
  def check_sorbet_segfault(exit_code, &block); end

  # Is the `--color` option true?
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:107
  sig { returns(T::Boolean) }
  def color?; end

  # Colorize a string if `color?`
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:136
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def colorize(string, *color); end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:147
  sig { params(string: ::String).returns(::String) }
  def cyan(string); end

  # Return the path specified through `--path`
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:72
  sig { returns(::String) }
  def exec_path; end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:152
  sig { params(string: ::String).returns(::String) }
  def gray(string); end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:157
  sig { params(string: ::String).returns(::String) }
  def green(string); end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:112
  sig { params(string: ::String).returns(::String) }
  def highlight(string); end

  # Enforce that `spoom` is ran inside a project with a `sorbet/config` file
  #
  # Display an error message and exit otherwise.
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:59
  sig { void }
  def in_sorbet_project!; end

  # Is `spoom` ran inside a project with a `sorbet/config` file?
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:51
  sig { returns(T::Boolean) }
  def in_sorbet_project?; end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:162
  sig { params(string: ::String).returns(::String) }
  def red(string); end

  # Print `message` on `$stdout`
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:20
  sig { params(message: ::String).void }
  def say(message); end

  # Print `message` on `$stderr`
  #
  # The message is prefixed by a status (default: `Error`).
  #
  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:39
  sig { params(message: ::String, status: T.nilable(::String), nl: T::Boolean).void }
  def say_error(message, status: T.unsafe(nil), nl: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:82
  sig { returns(::Spoom::Sorbet::Config) }
  def sorbet_config; end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:77
  sig { returns(::String) }
  def sorbet_config_file; end

  # source://spoom-1.1.11/lib/spoom/cli/helper.rb:167
  sig { params(string: ::String).returns(::String) }
  def yellow(string); end
end

# source://spoom-1.1.11/lib/spoom/cli/lsp.rb:10
class Spoom::Cli::LSP < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:53
  def defs(file, line, col); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:63
  def find(query); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:39
  def hover(file, line, col); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:25
  def list; end

  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:112
  def lsp_client; end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:83
  def refs(file, line, col); end

  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:134
  def run(&block); end

  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:16
  def show; end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:93
  def sigs(file, line, col); end

  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:126
  def symbol_printer; end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:73
  def symbols(file); end

  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:159
  def to_uri(path); end

  # TODO: options, filter, limit, kind etc.. filter rbi
  #
  # source://spoom-1.1.11/lib/spoom/cli/lsp.rb:103
  def types(file, line, col); end
end

# source://spoom-1.1.11/lib/spoom/cli.rb:16
class Spoom::Cli::Main < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom-1.1.11/lib/spoom/cli.rb:68
  def __print_version; end

  # source://thor-1.2.1/lib/thor.rb:239
  def bump(*args); end

  # source://thor-1.2.1/lib/thor.rb:239
  def config(*args); end

  # source://thor-1.2.1/lib/thor.rb:239
  def coverage(*args); end

  # source://spoom-1.1.11/lib/spoom/cli.rb:43
  def files; end

  # source://thor-1.2.1/lib/thor.rb:239
  def lsp(*args); end

  # source://thor-1.2.1/lib/thor.rb:239
  def tc(*args); end

  class << self
    # Utils
    #
    # @return [Boolean]
    #
    # source://spoom-1.1.11/lib/spoom/cli.rb:74
    def exit_on_failure?; end
  end
end

# source://spoom-1.1.11/lib/spoom/cli/run.rb:6
class Spoom::Cli::Run < ::Thor
  include ::Spoom::Colorize
  include ::Spoom::Cli::Helper

  # source://spoom-1.1.11/lib/spoom/cli/run.rb:107
  def colorize_message(message); end

  # source://spoom-1.1.11/lib/spoom/cli/run.rb:98
  def format_error(error, format); end

  def help(command = T.unsafe(nil), subcommand = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/cli/run.rb:25
  def tc(*arg); end
end

# source://spoom-1.1.11/lib/spoom/cli/run.rb:15
Spoom::Cli::Run::DEFAULT_FORMAT = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/cli/run.rb:11
Spoom::Cli::Run::SORT_CODE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/cli/run.rb:13
Spoom::Cli::Run::SORT_ENUM = T.let(T.unsafe(nil), Array)

# source://spoom-1.1.11/lib/spoom/cli/run.rb:12
Spoom::Cli::Run::SORT_LOC = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/colors.rb:5
class Spoom::Color < ::T::Enum
  enums do
    CLEAR = new
    BOLD = new
    BLACK = new
    RED = new
    GREEN = new
    YELLOW = new
    BLUE = new
    MAGENTA = new
    CYAN = new
    WHITE = new
    LIGHT_BLACK = new
    LIGHT_RED = new
    LIGHT_GREEN = new
    LIGHT_YELLOW = new
    LIGHT_BLUE = new
    LIGHT_MAGENTA = new
    LIGHT_CYAN = new
    LIGHT_WHITE = new
  end

  # source://spoom-1.1.11/lib/spoom/colors.rb:32
  sig { returns(::String) }
  def ansi_code; end
end

# source://spoom-1.1.11/lib/spoom/colors.rb:37
module Spoom::Colorize
  # source://spoom-1.1.11/lib/spoom/colors.rb:41
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def set_color(string, *color); end
end

# source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:5
module Spoom::Coverage
  class << self
    # source://spoom-1.1.11/lib/spoom/coverage.rb:67
    sig do
      params(
        snapshots: T::Array[::Spoom::Coverage::Snapshot],
        palette: ::Spoom::Coverage::D3::ColorPalette,
        path: ::String
      ).returns(::Spoom::Coverage::Report)
    end
    def report(snapshots, palette:, path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/coverage.rb:87
    sig { params(path: ::String).returns(::Spoom::FileTree) }
    def sigils_tree(path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/coverage.rb:15
    sig do
      params(
        path: ::String,
        rbi: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(::Spoom::Coverage::Snapshot)
    end
    def snapshot(path: T.unsafe(nil), rbi: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/coverage.rb:82
    sig { params(path: ::String).returns(::Spoom::Sorbet::Config) }
    def sorbet_config(path: T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:88
module Spoom::Coverage::Cards; end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:89
class Spoom::Coverage::Cards::Card < ::Spoom::Coverage::Template
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:98
  sig { params(template: ::String, title: T.nilable(::String), body: T.nilable(::String)).void }
  def initialize(template: T.unsafe(nil), title: T.unsafe(nil), body: T.unsafe(nil)); end

  # @return [String, nil]
  #
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:95
  def body; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:95
  sig { returns(T.nilable(::String)) }
  def title; end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:92
Spoom::Coverage::Cards::Card::TEMPLATE = T.let(T.unsafe(nil), String)

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/report.rb:105
class Spoom::Coverage::Cards::Erb < ::Spoom::Coverage::Cards::Card
  abstract!

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:112
  sig { void }
  def initialize; end

  # @abstract
  #
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:120
  sig { abstract.returns(::String) }
  def erb; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:115
  sig { override.returns(::String) }
  def html; end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:153
class Spoom::Coverage::Cards::Map < ::Spoom::Coverage::Cards::Card
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:157
  sig { params(sigils_tree: ::Spoom::FileTree, title: ::String).void }
  def initialize(sigils_tree:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:123
class Spoom::Coverage::Cards::Snapshot < ::Spoom::Coverage::Cards::Card
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:132
  sig { params(snapshot: ::Spoom::Coverage::Snapshot, title: ::String).void }
  def initialize(snapshot:, title: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:143
  sig { returns(::Spoom::Coverage::D3::Pie::Calls) }
  def pie_calls; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:138
  sig { returns(::Spoom::Coverage::D3::Pie::Sigils) }
  def pie_sigils; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:148
  sig { returns(::Spoom::Coverage::D3::Pie::Sigs) }
  def pie_sigs; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:129
  sig { returns(::Spoom::Coverage::Snapshot) }
  def snapshot; end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:126
Spoom::Coverage::Cards::Snapshot::TEMPLATE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:225
class Spoom::Coverage::Cards::SorbetIntro < ::Spoom::Coverage::Cards::Erb
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:229
  sig { params(sorbet_intro_commit: T.nilable(::String), sorbet_intro_date: T.nilable(::Time)).void }
  def initialize(sorbet_intro_commit: T.unsafe(nil), sorbet_intro_date: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:235
  sig { override.returns(::String) }
  def erb; end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:162
class Spoom::Coverage::Cards::Timeline < ::Spoom::Coverage::Cards::Card
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:166
  sig { params(title: ::String, timeline: ::Spoom::Coverage::D3::Timeline).void }
  def initialize(title:, timeline:); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:179
class Spoom::Coverage::Cards::Timeline::Calls < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:183
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:197
class Spoom::Coverage::Cards::Timeline::RBIs < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:201
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:215
class Spoom::Coverage::Cards::Timeline::Runtimes < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:219
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:170
class Spoom::Coverage::Cards::Timeline::Sigils < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:174
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:188
class Spoom::Coverage::Cards::Timeline::Sigs < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:192
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:206
class Spoom::Coverage::Cards::Timeline::Versions < ::Spoom::Coverage::Cards::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:210
  sig { params(snapshots: T::Array[::Spoom::Coverage::Snapshot], title: ::String).void }
  def initialize(snapshots:, title: T.unsafe(nil)); end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:6
module Spoom::Coverage::D3
  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/d3.rb:60
    sig { params(palette: ::Spoom::Coverage::D3::ColorPalette).returns(::String) }
    def header_script(palette); end

    # source://spoom-1.1.11/lib/spoom/coverage/d3.rb:20
    sig { returns(::String) }
    def header_style; end
  end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:7
class Spoom::Coverage::D3::Base
  abstract!

  # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:17
  sig { params(id: ::String, data: T.untyped).void }
  def initialize(id, data); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:33
  sig { returns(::String) }
  def html; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:14
  sig { returns(::String) }
  def id; end

  # @abstract
  #
  # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:46
  sig { abstract.returns(::String) }
  def script; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:41
  sig { returns(::String) }
  def tooltip; end

  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:28
    sig { returns(::String) }
    def header_script; end

    # source://spoom-1.1.11/lib/spoom/coverage/d3/base.rb:23
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:14
Spoom::Coverage::D3::COLOR_FALSE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:13
Spoom::Coverage::D3::COLOR_IGNORE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:16
Spoom::Coverage::D3::COLOR_STRICT = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:17
Spoom::Coverage::D3::COLOR_STRONG = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:15
Spoom::Coverage::D3::COLOR_TRUE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:9
class Spoom::Coverage::D3::CircleMap < ::Spoom::Coverage::D3::Base
  # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:57
  sig { override.returns(::String) }
  def script; end

  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:39
    sig { returns(::String) }
    def header_script; end

    # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:13
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:146
class Spoom::Coverage::D3::CircleMap::Sigils < ::Spoom::Coverage::D3::CircleMap
  # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:150
  sig { params(id: ::String, sigils_tree: ::Spoom::FileTree).void }
  def initialize(id, sigils_tree); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:178
  sig { params(node: ::Spoom::FileTree::Node).returns(::Float) }
  def tree_node_score(node); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:170
  sig { params(node: ::Spoom::FileTree::Node).returns(T.nilable(::String)) }
  def tree_node_strictness(node); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/circle_map.rb:158
  sig { params(node: ::Spoom::FileTree::Node).returns(T::Hash[::Symbol, T.untyped]) }
  def tree_node_to_json(node); end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3.rb:101
class Spoom::Coverage::D3::ColorPalette < ::T::Struct
  prop :false, ::String
  prop :ignore, ::String
  prop :strict, ::String
  prop :strong, ::String
  prop :true, ::String

  class << self
    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:9
class Spoom::Coverage::D3::Pie < ::Spoom::Coverage::D3::Base
  abstract!

  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:16
  sig { params(id: ::String, title: ::String, data: T.untyped).void }
  def initialize(id, title, data); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:52
  sig { override.returns(::String) }
  def script; end

  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:40
    sig { returns(::String) }
    def header_script; end

    # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:22
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:137
class Spoom::Coverage::D3::Pie::Calls < ::Spoom::Coverage::D3::Pie
  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:141
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:146
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:119
class Spoom::Coverage::D3::Pie::Sigils < ::Spoom::Coverage::D3::Pie
  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:123
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:128
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:155
class Spoom::Coverage::D3::Pie::Sigs < ::Spoom::Coverage::D3::Pie
  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:159
  sig { params(id: ::String, title: ::String, snapshot: ::Spoom::Coverage::Snapshot).void }
  def initialize(id, title, snapshot); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/pie.rb:164
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:9
class Spoom::Coverage::D3::Timeline < ::Spoom::Coverage::D3::Base
  abstract!

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:16
  sig { params(id: ::String, data: T.untyped, keys: T::Array[::String]).void }
  def initialize(id, data, keys); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:183
  sig { params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def area(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:199
  sig { params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # @abstract
  #
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:122
  sig { abstract.returns(::String) }
  def plot; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:213
  sig { params(y: ::String).returns(::String) }
  def points(y:); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:97
  sig { override.returns(::String) }
  def script; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:125
  sig { returns(::String) }
  def x_scale; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:141
  sig { returns(::String) }
  def x_ticks; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:154
  sig { params(min: ::String, max: ::String, ticks: ::String).returns(::String) }
  def y_scale(min:, max:, ticks:); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:170
  sig { params(ticks: ::String, format: ::String, padding: ::Integer).returns(::String) }
  def y_ticks(ticks:, format:, padding:); end

  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:76
    sig { returns(::String) }
    def header_script; end

    # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:22
    sig { returns(::String) }
    def header_style; end
  end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:444
class Spoom::Coverage::D3::Timeline::Calls < ::Spoom::Coverage::D3::Timeline::Stacked
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:448
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:462
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:498
class Spoom::Coverage::D3::Timeline::RBIs < ::Spoom::Coverage::D3::Timeline::Stacked
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:502
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:570
  sig { override.params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:610
  sig { override.returns(::String) }
  def plot; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:530
  sig { override.returns(::String) }
  def script; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:516
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:278
class Spoom::Coverage::D3::Timeline::Runtimes < ::Spoom::Coverage::D3::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:282
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:307
  sig { override.returns(::String) }
  def plot; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:294
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:417
class Spoom::Coverage::D3::Timeline::Sigils < ::Spoom::Coverage::D3::Timeline::Stacked
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:421
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:435
  sig { override.returns(::String) }
  def tooltip; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:471
class Spoom::Coverage::D3::Timeline::Sigs < ::Spoom::Coverage::D3::Timeline::Stacked
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:475
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:489
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:325
class Spoom::Coverage::D3::Timeline::Stacked < ::Spoom::Coverage::D3::Timeline
  abstract!

  # source://sorbet-runtime-0.5.10233/lib/types/private/abstract/declare.rb:37
  def initialize(*args, **_arg1, &blk); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:384
  sig { override.params(y: ::String, color: ::String, curve: ::String).returns(::String) }
  def line(y:, color: T.unsafe(nil), curve: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:373
  sig { override.returns(::String) }
  def plot; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:332
  sig { override.returns(::String) }
  def script; end
end

# source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:228
class Spoom::Coverage::D3::Timeline::Versions < ::Spoom::Coverage::D3::Timeline
  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:232
  sig { params(id: ::String, snapshots: T::Array[::Spoom::Coverage::Snapshot]).void }
  def initialize(id, snapshots); end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:259
  sig { override.returns(::String) }
  def plot; end

  # source://spoom-1.1.11/lib/spoom/coverage/d3/timeline.rb:245
  sig { override.returns(::String) }
  def tooltip; end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/report.rb:38
class Spoom::Coverage::Page < ::Spoom::Coverage::Template
  abstract!

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:53
  sig { params(title: ::String, palette: ::Spoom::Coverage::D3::ColorPalette, template: ::String).void }
  def initialize(title:, palette:, template: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:75
  sig { returns(::String) }
  def body_html; end

  # @abstract
  #
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:80
  sig { abstract.returns(T::Array[::Spoom::Coverage::Cards::Card]) }
  def cards; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:83
  sig { returns(::String) }
  def footer_html; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:70
  sig { returns(::String) }
  def header_html; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:65
  sig { returns(::String) }
  def header_script; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:60
  sig { returns(::String) }
  def header_style; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:50
  sig { returns(::Spoom::Coverage::D3::ColorPalette) }
  def palette; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:47
  sig { returns(::String) }
  def title; end
end

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:44
Spoom::Coverage::Page::TEMPLATE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/coverage/report.rb:246
class Spoom::Coverage::Report < ::Spoom::Coverage::Page
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:274
  sig do
    params(
      project_name: ::String,
      palette: ::Spoom::Coverage::D3::ColorPalette,
      snapshots: T::Array[::Spoom::Coverage::Snapshot],
      sigils_tree: ::Spoom::FileTree,
      sorbet_intro_commit: T.nilable(::String),
      sorbet_intro_date: T.nilable(::Time)
    ).void
  end
  def initialize(project_name:, palette:, snapshots:, sigils_tree:, sorbet_intro_commit: T.unsafe(nil), sorbet_intro_date: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:302
  sig { override.returns(T::Array[::Spoom::Coverage::Cards::Card]) }
  def cards; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:291
  sig { override.returns(::String) }
  def header_html; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:250
  sig { returns(::String) }
  def project_name; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:262
  sig { returns(::Spoom::FileTree) }
  def sigils_tree; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:259
  sig { returns(T::Array[::Spoom::Coverage::Snapshot]) }
  def snapshots; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:253
  sig { returns(T.nilable(::String)) }
  def sorbet_intro_commit; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:256
  sig { returns(T.nilable(::Time)) }
  def sorbet_intro_date; end
end

# source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:6
class Spoom::Coverage::Snapshot < ::T::Struct
  prop :calls_typed, ::Integer, default: T.unsafe(nil)
  prop :calls_untyped, ::Integer, default: T.unsafe(nil)
  prop :classes, ::Integer, default: T.unsafe(nil)
  prop :commit_sha, T.nilable(::String), default: T.unsafe(nil)
  prop :commit_timestamp, T.nilable(::Integer), default: T.unsafe(nil)
  prop :duration, ::Integer, default: T.unsafe(nil)
  prop :files, ::Integer, default: T.unsafe(nil)
  prop :methods_with_sig, ::Integer, default: T.unsafe(nil)
  prop :methods_without_sig, ::Integer, default: T.unsafe(nil)
  prop :modules, ::Integer, default: T.unsafe(nil)
  prop :rbi_files, ::Integer, default: T.unsafe(nil)
  prop :sigils, T::Hash[::String, ::Integer], default: T.unsafe(nil)
  prop :singleton_classes, ::Integer, default: T.unsafe(nil)
  prop :timestamp, ::Integer, default: T.unsafe(nil)
  prop :version_runtime, T.nilable(::String), default: T.unsafe(nil)
  prop :version_static, T.nilable(::String), default: T.unsafe(nil)

  # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:30
  sig { params(out: T.any(::IO, ::StringIO), colors: T::Boolean, indent_level: ::Integer).void }
  def print(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:71
  sig { params(arg: T.untyped).returns(::String) }
  def to_json(*arg); end

  class << self
    # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:36
    sig { params(json: ::String).returns(::Spoom::Coverage::Snapshot) }
    def from_json(json); end

    # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:41
    sig { params(obj: T::Hash[::String, T.untyped]).returns(::Spoom::Coverage::Snapshot) }
    def from_obj(obj); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# The strictness name as found in the Sorbet metrics file
#
# source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:27
Spoom::Coverage::Snapshot::STRICTNESSES = T.let(T.unsafe(nil), Array)

# source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:76
class Spoom::Coverage::SnapshotPrinter < ::Spoom::Printer
  # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:80
  sig { params(snapshot: ::Spoom::Coverage::Snapshot).void }
  def print_snapshot(snapshot); end

  private

  # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:128
  sig { params(value: T.nilable(::Integer), total: T.nilable(::Integer)).returns(::String) }
  def percent(value, total); end

  # source://spoom-1.1.11/lib/spoom/coverage/snapshot.rb:118
  sig { params(hash: T::Hash[::String, ::Integer], total: ::Integer).void }
  def print_map(hash, total); end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/coverage/report.rb:10
class Spoom::Coverage::Template
  abstract!

  # Create a new template from an Erb file path
  #
  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:18
  sig { params(template: ::String).void }
  def initialize(template:); end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:23
  sig { returns(::String) }
  def erb; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:33
  sig { returns(::Binding) }
  def get_binding; end

  # source://spoom-1.1.11/lib/spoom/coverage/report.rb:28
  sig { returns(::String) }
  def html; end
end

# source://spoom-1.1.11/lib/spoom.rb:12
class Spoom::Error < ::StandardError; end

# source://spoom-1.1.11/lib/spoom.rb:14
class Spoom::ExecResult < ::T::Struct
  const :err, ::String
  const :exit_code, ::Integer
  const :out, ::String
  const :status, T::Boolean

  class << self
    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# Build a file hierarchy from a set of file paths.
#
# source://spoom-1.1.11/lib/spoom/file_tree.rb:6
class Spoom::FileTree
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:13
  sig { params(paths: T::Enumerable[::String], strip_prefix: T.nilable(::String)).void }
  def initialize(paths = T.unsafe(nil), strip_prefix: T.unsafe(nil)); end

  # Add a `path` to the tree
  #
  # This will create all nodes until the root of `path`.
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:29
  sig { params(path: ::String).returns(::Spoom::FileTree::Node) }
  def add_path(path); end

  # Add all `paths` to the tree
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:21
  sig { params(paths: T::Enumerable[::String]).void }
  def add_paths(paths); end

  # All the nodes in this tree
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:50
  sig { returns(T::Array[::Spoom::FileTree::Node]) }
  def nodes; end

  # All the paths in this tree
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:58
  sig { returns(T::Array[::String]) }
  def paths; end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:70
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      show_strictness: T::Boolean,
      colors: T::Boolean,
      indent_level: ::Integer
    ).void
  end
  def print(out: T.unsafe(nil), show_strictness: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # All root nodes
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:44
  sig { returns(T::Array[::Spoom::FileTree::Node]) }
  def roots; end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:10
  sig { returns(T.nilable(::String)) }
  def strip_prefix; end

  private

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:84
  sig do
    params(
      node: ::Spoom::FileTree::Node,
      collected_nodes: T::Array[::Spoom::FileTree::Node]
    ).returns(T::Array[::Spoom::FileTree::Node])
  end
  def collect_nodes(node, collected_nodes = T.unsafe(nil)); end
end

# A node representing either a file or a directory inside a FileTree
#
# source://spoom-1.1.11/lib/spoom/file_tree.rb:91
class Spoom::FileTree::Node < ::T::Struct
  const :children, T::Hash[::String, ::Spoom::FileTree::Node], default: T.unsafe(nil)
  const :name, ::String
  const :parent, T.nilable(::Spoom::FileTree::Node)

  # Full path to this node from root
  #
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:105
  sig { returns(::String) }
  def path; end

  class << self
    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# An internal class used to print a FileTree
#
# See `FileTree#print`
#
# source://spoom-1.1.11/lib/spoom/file_tree.rb:115
class Spoom::FileTree::TreePrinter < ::Spoom::Printer
  # source://spoom-1.1.11/lib/spoom/file_tree.rb:130
  sig do
    params(
      tree: ::Spoom::FileTree,
      out: T.any(::IO, ::StringIO),
      show_strictness: T::Boolean,
      colors: T::Boolean,
      indent_level: ::Integer
    ).void
  end
  def initialize(tree:, out: T.unsafe(nil), show_strictness: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:142
  sig { params(node: ::Spoom::FileTree::Node).void }
  def print_node(node); end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:169
  sig { params(nodes: T::Array[::Spoom::FileTree::Node]).void }
  def print_nodes(nodes); end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:137
  sig { void }
  def print_tree; end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:119
  sig { returns(::Spoom::FileTree) }
  def tree; end

  private

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:176
  sig { params(node: ::Spoom::FileTree::Node).returns(T.nilable(::String)) }
  def node_strictness(node); end

  # source://spoom-1.1.11/lib/spoom/file_tree.rb:184
  sig { params(strictness: T.nilable(::String)).returns(::Spoom::Color) }
  def strictness_color(strictness); end
end

# Execute git commands
#
# source://spoom-1.1.11/lib/spoom/git.rb:8
module Spoom::Git
  class << self
    # Git commands
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:35
    sig { params(arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def checkout(*arg, path: T.unsafe(nil)); end

    # Get the commit Time for a `sha`
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:78
    sig { params(sha: ::String, path: ::String).returns(T.nilable(::Time)) }
    def commit_time(sha, path: T.unsafe(nil)); end

    # Get the commit epoch timestamp for a `sha`
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:70
    sig { params(sha: ::String, path: ::String).returns(T.nilable(::Integer)) }
    def commit_timestamp(sha, path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/git.rb:60
    sig { params(path: ::String).returns(T.nilable(::String)) }
    def current_branch(path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/git.rb:40
    sig { params(arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def diff(*arg, path: T.unsafe(nil)); end

    # Translate a git epoch timestamp into a Time
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:94
    sig { params(timestamp: ::String).returns(::Time) }
    def epoch_to_time(timestamp); end

    # Execute a `command`
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:13
    sig { params(command: ::String, arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def exec(command, *arg, path: T.unsafe(nil)); end

    # Get the last commit sha
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:86
    sig { params(path: ::String).returns(T.nilable(::String)) }
    def last_commit(path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/git.rb:45
    sig { params(arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def log(*arg, path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/git.rb:50
    sig { params(arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def rev_parse(*arg, path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/git.rb:55
    sig { params(arg: ::String, path: ::String).returns(::Spoom::ExecResult) }
    def show(*arg, path: T.unsafe(nil)); end

    # Get the hash of the commit introducing the `sorbet/config` file
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:106
    sig { params(path: ::String).returns(T.nilable(::String)) }
    def sorbet_intro_commit(path: T.unsafe(nil)); end

    # Get the hash of the commit removing the `sorbet/config` file
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:116
    sig { params(path: ::String).returns(T.nilable(::String)) }
    def sorbet_removal_commit(path: T.unsafe(nil)); end

    # Is there uncommited changes in `path`?
    #
    # source://spoom-1.1.11/lib/spoom/git.rb:100
    sig { params(path: ::String).returns(T::Boolean) }
    def workdir_clean?(path: T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:5
module Spoom::LSP; end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:13
class Spoom::LSP::Client
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:17
  sig { params(sorbet_bin: ::String, sorbet_args: ::String, path: ::String).void }
  def initialize(sorbet_bin, *sorbet_args, path: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:221
  sig { void }
  def close; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:128
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::Location]) }
  def definitions(uri, line, column); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:205
  sig { params(uri: ::String).returns(T::Array[::Spoom::LSP::DocumentSymbol]) }
  def document_symbols(uri); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:88
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T.nilable(::Spoom::LSP::Hover)) }
  def hover(uri, line, column); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:27
  sig { returns(::Integer) }
  def next_id; end

  # LSP requests
  #
  # @raise [Error::AlreadyOpen]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:72
  sig { params(workspace_path: ::String).void }
  def open(workspace_path); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:54
  sig { returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def read; end

  # @raise [Error::BadHeaders]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:43
  sig { returns(T.nilable(::String)) }
  def read_raw; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:168
  sig do
    params(
      uri: ::String,
      line: ::Integer,
      column: ::Integer,
      include_decl: T::Boolean
    ).returns(T::Array[::Spoom::LSP::Location])
  end
  def references(uri, line, column, include_decl = T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:37
  sig { params(message: ::Spoom::LSP::Message).returns(T.nilable(T::Hash[T.untyped, T.untyped])) }
  def send(message); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:32
  sig { params(json_string: ::String).void }
  def send_raw(json_string); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:108
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::SignatureHelp]) }
  def signatures(uri, line, column); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:191
  sig { params(query: ::String).returns(T::Array[::Spoom::LSP::DocumentSymbol]) }
  def symbols(query); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp.rb:148
  sig { params(uri: ::String, line: ::Integer, column: ::Integer).returns(T::Array[::Spoom::LSP::Location]) }
  def type_definitions(uri, line, column); end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:158
class Spoom::LSP::Diagnostic < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :code, ::Integer
  const :informations, ::Object
  const :message, ::String
  const :range, ::Spoom::LSP::Range

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:178
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:183
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:168
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Diagnostic) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:188
class Spoom::LSP::DocumentSymbol < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :children, T::Array[::Spoom::LSP::DocumentSymbol]
  const :detail, T.nilable(::String)
  const :kind, ::Integer
  const :location, T.nilable(::Spoom::LSP::Location)
  const :name, ::String
  const :range, T.nilable(::Spoom::LSP::Range)

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:212
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:243
  sig { returns(::String) }
  def kind_string; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:238
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:200
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::DocumentSymbol) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:247
Spoom::LSP::DocumentSymbol::SYMBOL_KINDS = T.let(T.unsafe(nil), Hash)

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:6
class Spoom::LSP::Error < ::StandardError; end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:7
class Spoom::LSP::Error::AlreadyOpen < ::Spoom::LSP::Error; end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:8
class Spoom::LSP::Error::BadHeaders < ::Spoom::LSP::Error; end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:10
class Spoom::LSP::Error::Diagnostics < ::Spoom::LSP::Error
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:28
  sig { params(uri: ::String, diagnostics: T::Array[::Spoom::LSP::Diagnostic]).void }
  def initialize(uri, diagnostics); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:17
  sig { returns(T::Array[::Spoom::LSP::Diagnostic]) }
  def diagnostics; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:14
  sig { returns(::String) }
  def uri; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:20
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Error::Diagnostics) }
    def from_json(json); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:19
class Spoom::LSP::Hover < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :contents, ::String
  const :range, T.nilable(T::Range[T.untyped])

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:35
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:41
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:27
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Hover) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:100
class Spoom::LSP::Location < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :range, ::Spoom::LSP::Range
  const :uri, ::String

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:116
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:122
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:108
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Location) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# A general message as defined by JSON-RPC.
#
# The language server protocol always uses `"2.0"` as the `jsonrpc` version.
#
# source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:12
class Spoom::LSP::Message
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:19
  sig { void }
  def initialize; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:24
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def as_json; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:16
  sig { returns(::String) }
  def jsonrpc; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:32
  sig { params(args: T.untyped).returns(::String) }
  def to_json(*args); end
end

# A notification message.
#
# A processed notification message must not send a response back. They work like events.
#
# source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:64
class Spoom::LSP::Notification < ::Spoom::LSP::Message
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:74
  sig { params(method: ::String, params: T::Hash[T.untyped, T.untyped]).void }
  def initialize(method, params); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:68
  sig { returns(::String) }
  def method; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:71
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def params; end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:46
class Spoom::LSP::Position < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :char, ::Integer
  const :line, ::Integer

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:62
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:67
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:54
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Position) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:9
module Spoom::LSP::PrintableSymbol
  interface!

  # @abstract
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:16
  sig { abstract.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:72
class Spoom::LSP::Range < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :end, ::Spoom::LSP::Position
  const :start, ::Spoom::LSP::Position

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:88
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:95
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:80
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::Range) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# A request message to describe a request between the client and the server.
#
# Every processed request must send a response back to the sender of the request.
#
# source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:40
class Spoom::LSP::Request < ::Spoom::LSP::Message
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:53
  sig { params(id: ::Integer, method: ::String, params: T::Hash[T.untyped, T.untyped]).void }
  def initialize(id, method, params); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:44
  sig { returns(::Integer) }
  def id; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:47
  sig { returns(::String) }
  def method; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/base.rb:50
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def params; end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:35
class Spoom::LSP::ResponseError < ::Spoom::LSP::Error
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:57
  sig { params(code: ::Integer, message: ::String, data: T::Hash[T.untyped, T.untyped]).void }
  def initialize(code, message, data); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:39
  sig { returns(::Integer) }
  def code; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:45
  sig { returns(T::Hash[T.untyped, T.untyped]) }
  def data; end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:42
  sig { returns(::String) }
  def message; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/errors.rb:48
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::ResponseError) }
    def from_json(json); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:127
class Spoom::LSP::SignatureHelp < ::T::Struct
  include ::Spoom::LSP::PrintableSymbol

  const :doc, ::Object
  const :label, T.nilable(::String)
  const :params, T::Array[T.untyped]

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:145
  sig { override.params(printer: ::Spoom::LSP::SymbolPrinter).void }
  def accept_printer(printer); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:153
  sig { returns(::String) }
  def to_s; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:136
    sig { params(json: T::Hash[T.untyped, T.untyped]).returns(::Spoom::LSP::SignatureHelp) }
    def from_json(json); end

    # source://sorbet-runtime-0.5.10233/lib/types/struct.rb:13
    def inherited(s); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:277
class Spoom::LSP::SymbolPrinter < ::Spoom::Printer
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:294
  sig do
    params(
      out: T.any(::IO, ::StringIO),
      colors: T::Boolean,
      indent_level: ::Integer,
      prefix: T.nilable(::String)
    ).void
  end
  def initialize(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil), prefix: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:315
  sig { params(uri: ::String).returns(::String) }
  def clean_uri(uri); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:284
  sig { returns(T.nilable(::String)) }
  def prefix; end

  # @return [String, nil]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:284
  def prefix=(_arg0); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:322
  sig { params(objects: T::Array[::Spoom::LSP::PrintableSymbol]).void }
  def print_list(objects); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:304
  sig { params(object: T.nilable(::Spoom::LSP::PrintableSymbol)).void }
  def print_object(object); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:310
  sig { params(objects: T::Array[::Spoom::LSP::PrintableSymbol]).void }
  def print_objects(objects); end

  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:281
  sig { returns(T::Set[::Integer]) }
  def seen; end

  # @return [Set<Integer>]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/lsp/structures.rb:281
  def seen=(_arg0); end
end

# @abstract It cannont be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://spoom-1.1.11/lib/spoom/printer.rb:7
class Spoom::Printer
  include ::Spoom::Colorize

  abstract!

  # source://spoom-1.1.11/lib/spoom/printer.rb:19
  sig { params(out: T.any(::IO, ::StringIO), colors: T::Boolean, indent_level: ::Integer).void }
  def initialize(out: T.unsafe(nil), colors: T.unsafe(nil), indent_level: T.unsafe(nil)); end

  # Colorize `string` with color if `@colors`
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:77
  sig { params(string: ::String, color: ::Spoom::Color).returns(::String) }
  def colorize(string, *color); end

  # Decrease indent level
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:33
  sig { void }
  def dedent; end

  # Increase indent level
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:27
  sig { void }
  def indent; end

  # source://spoom-1.1.11/lib/spoom/printer.rb:16
  sig { returns(T.any(::IO, ::StringIO)) }
  def out; end

  # @return [IO, StringIO]
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:16
  def out=(_arg0); end

  # Print `string` into `out`
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:39
  sig { params(string: T.nilable(::String)).void }
  def print(string); end

  # Print `string` colored with `color` into `out`
  #
  # Does not use colors unless `@colors`.
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:48
  sig { params(string: T.nilable(::String), color: ::Spoom::Color).void }
  def print_colored(string, *color); end

  # Print `string` with indent and newline
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:62
  sig { params(string: T.nilable(::String)).void }
  def printl(string); end

  # Print a new line into `out`
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:56
  sig { void }
  def printn; end

  # Print an indent space into `out`
  #
  # source://spoom-1.1.11/lib/spoom/printer.rb:71
  sig { void }
  def printt; end
end

# source://spoom-1.1.11/lib/spoom.rb:10
Spoom::SPOOM_PATH = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/config.rb:5
module Spoom::Sorbet
  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet.rb:31
    sig do
      params(
        arg: ::String,
        path: ::String,
        capture_err: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(::Spoom::ExecResult)
    end
    def srb(*arg, path: T.unsafe(nil), capture_err: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end

    # List all files typechecked by Sorbet from its `config`
    #
    # source://spoom-1.1.11/lib/spoom/sorbet.rb:55
    sig { params(config: ::Spoom::Sorbet::Config, path: ::String).returns(T::Array[::String]) }
    def srb_files(config, path: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/sorbet.rb:92
    sig do
      params(
        arg: ::String,
        path: ::String,
        capture_err: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(T.nilable(T::Hash[::String, ::Integer]))
    end
    def srb_metrics(*arg, path: T.unsafe(nil), capture_err: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/sorbet.rb:48
    sig do
      params(
        arg: ::String,
        path: ::String,
        capture_err: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(::Spoom::ExecResult)
    end
    def srb_tc(*arg, path: T.unsafe(nil), capture_err: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/sorbet.rb:71
    sig do
      params(
        arg: ::String,
        path: ::String,
        capture_err: T::Boolean,
        sorbet_bin: T.nilable(::String)
      ).returns(T.nilable(::String))
    end
    def srb_version(*arg, path: T.unsafe(nil), capture_err: T.unsafe(nil), sorbet_bin: T.unsafe(nil)); end

    # Get `gem` version from the `Gemfile.lock` content
    #
    # Returns `nil` if `gem` cannot be found in the Gemfile.
    #
    # source://spoom-1.1.11/lib/spoom/sorbet.rb:115
    sig { params(gem: ::String, path: ::String).returns(T.nilable(::String)) }
    def version_from_gemfile_lock(gem: T.unsafe(nil), path: T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet.rb:16
Spoom::Sorbet::BIN_PATH = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet.rb:14
Spoom::Sorbet::CONFIG_PATH = T.let(T.unsafe(nil), String)

# Parse Sorbet config files
#
# Parses a Sorbet config file:
#
# ```ruby
# config = Spoom::Sorbet::Config.parse_file("sorbet/config")
# puts config.paths   # "."
# ```
#
# Parses a Sorbet config string:
#
# ```ruby
# config = Spoom::Sorbet::Config.parse_string(<<~CONFIG)
#   a
#   --file=b
#   --ignore=c
# CONFIG
# puts config.paths   # "a", "b"
# puts config.ignore  # "c"
# ```
#
# source://spoom-1.1.11/lib/spoom/sorbet/config.rb:26
class Spoom::Sorbet::Config
  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:36
  sig { void }
  def initialize; end

  # @return [Array<String>]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:30
  def allowed_extensions; end

  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:44
  sig { returns(::Spoom::Sorbet::Config) }
  def copy; end

  # @return [Array<String>]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:30
  def ignore; end

  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:33
  sig { returns(T::Boolean) }
  def no_stdlib; end

  # @return [Boolean]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:33
  def no_stdlib=(_arg0); end

  # Returns self as a string of options that can be passed to Sorbet
  #
  # Example:
  # ~~~rb
  # config = Sorbet::Config.new
  # config.paths << "/foo"
  # config.paths << "/bar"
  # config.ignore << "/baz"
  # config.allowed_extensions << ".rb"
  #
  # puts config.options_string # "/foo /bar --ignore /baz --allowed-extension .rb"
  # ~~~
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:66
  sig { returns(::String) }
  def options_string; end

  # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:30
  sig { returns(T::Array[::String]) }
  def paths; end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:79
    sig { params(sorbet_config_path: ::String).returns(::Spoom::Sorbet::Config) }
    def parse_file(sorbet_config_path); end

    # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:84
    sig { params(sorbet_config: ::String).returns(::Spoom::Sorbet::Config) }
    def parse_string(sorbet_config); end

    private

    # source://spoom-1.1.11/lib/spoom/sorbet/config.rb:148
    sig { params(line: ::String).returns(::String) }
    def parse_option(line); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:6
module Spoom::Sorbet::Errors
  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:149
    sig { params(errors: T::Array[::Spoom::Sorbet::Errors::Error]).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
    def sort_errors_by_code(errors); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:9
Spoom::Sorbet::Errors::DEFAULT_ERROR_URL_BASE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:105
class Spoom::Sorbet::Errors::Error
  include ::Comparable

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:127
  sig do
    params(
      file: T.nilable(::String),
      line: T.nilable(::Integer),
      message: T.nilable(::String),
      code: T.nilable(::Integer),
      more: T::Array[::String]
    ).void
  end
  def initialize(file, line, message, code, more = T.unsafe(nil)); end

  # By default errors are sorted by location
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:137
  sig { params(other: T.untyped).returns(::Integer) }
  def <=>(other); end

  # @return [Integer, nil]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:113
  def code; end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:110
  sig { returns(T.nilable(::String)) }
  def file; end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:113
  sig { returns(T.nilable(::Integer)) }
  def line; end

  # @return [String, nil]
  #
  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:110
  def message; end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:116
  sig { returns(T::Array[::String]) }
  def more; end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:143
  sig { returns(::String) }
  def to_s; end
end

# Parse errors from Sorbet output
#
# source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:12
class Spoom::Sorbet::Errors::Parser
  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:30
  sig { params(error_url_base: ::String).void }
  def initialize(error_url_base: T.unsafe(nil)); end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:37
  sig { params(output: ::String).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
  def parse(output); end

  private

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:99
  sig { params(line: ::String).void }
  def append_error(line); end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:92
  sig { void }
  def close_error; end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:60
  sig { params(error_url_base: ::String).returns(::Regexp) }
  def error_line_match_regexp(error_url_base); end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:77
  sig { params(line: ::String).returns(T.nilable(::Spoom::Sorbet::Errors::Error)) }
  def match_error_line(line); end

  # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:86
  sig { params(error: ::Spoom::Sorbet::Errors::Error).void }
  def open_error(error); end

  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:24
    sig { params(output: ::String, error_url_base: ::String).returns(T::Array[::Spoom::Sorbet::Errors::Error]) }
    def parse_string(output, error_url_base: T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/errors.rb:15
Spoom::Sorbet::Errors::Parser::HEADER = T.let(T.unsafe(nil), Array)

# source://spoom-1.1.11/lib/spoom/sorbet.rb:15
Spoom::Sorbet::GEM_PATH = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/metrics.rb:8
module Spoom::Sorbet::MetricsParser
  class << self
    # source://spoom-1.1.11/lib/spoom/sorbet/metrics.rb:14
    sig { params(path: ::String, prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_file(path, prefix = T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/sorbet/metrics.rb:24
    sig { params(obj: T::Hash[::String, T.untyped], prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_hash(obj, prefix = T.unsafe(nil)); end

    # source://spoom-1.1.11/lib/spoom/sorbet/metrics.rb:19
    sig { params(string: ::String, prefix: ::String).returns(T::Hash[::String, ::Integer]) }
    def parse_string(string, prefix = T.unsafe(nil)); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/metrics.rb:11
Spoom::Sorbet::MetricsParser::DEFAULT_PREFIX = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet.rb:18
Spoom::Sorbet::SEGFAULT_CODE = T.let(T.unsafe(nil), Integer)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:9
module Spoom::Sorbet::Sigils
  class << self
    # changes the sigil in the file at the passed path to the specified new strictness
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:65
    sig { params(path: T.any(::Pathname, ::String), new_strictness: ::String).returns(T::Boolean) }
    def change_sigil_in_file(path, new_strictness); end

    # changes the sigil to have a new strictness in a list of files
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:76
    sig { params(path_list: T::Array[::String], new_strictness: ::String).returns(T::Array[::String]) }
    def change_sigil_in_files(path_list, new_strictness); end

    # returns a string containing the strictness of a sigil in a file at the passed path
    # * returns nil if no sigil
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:57
    sig { params(path: T.any(::Pathname, ::String)).returns(T.nilable(::String)) }
    def file_strictness(path); end

    # finds all files in the specified directory with the passed strictness
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:90
    sig do
      params(
        directory: T.any(::Pathname, ::String),
        strictness: ::String,
        extension: ::String
      ).returns(T::Array[::String])
    end
    def files_with_sigil_strictness(directory, strictness, extension: T.unsafe(nil)); end

    # returns the full sigil comment string for the passed strictness
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:32
    sig { params(strictness: ::String).returns(::String) }
    def sigil_string(strictness); end

    # returns the strictness of a sigil in the passed file content string (nil if no sigil)
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:44
    sig { params(content: ::String).returns(T.nilable(::String)) }
    def strictness_in_content(content); end

    # returns a string which is the passed content but with the sigil updated to a new strictness
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:50
    sig { params(content: ::String, new_strictness: ::String).returns(::String) }
    def update_sigil(content, new_strictness); end

    # returns true if the passed string is a valid strictness (else false)
    #
    # source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:38
    sig { params(strictness: ::String).returns(T::Boolean) }
    def valid_strictness?(strictness); end
  end
end

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:28
Spoom::Sorbet::Sigils::SIGIL_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:13
Spoom::Sorbet::Sigils::STRICTNESS_FALSE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:12
Spoom::Sorbet::Sigils::STRICTNESS_IGNORE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:17
Spoom::Sorbet::Sigils::STRICTNESS_INTERNAL = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:15
Spoom::Sorbet::Sigils::STRICTNESS_STRICT = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:16
Spoom::Sorbet::Sigils::STRICTNESS_STRONG = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:14
Spoom::Sorbet::Sigils::STRICTNESS_TRUE = T.let(T.unsafe(nil), String)

# source://spoom-1.1.11/lib/spoom/sorbet/sigils.rb:19
Spoom::Sorbet::Sigils::VALID_STRICTNESS = T.let(T.unsafe(nil), Array)

# source://spoom-1.1.11/lib/spoom/timeline.rb:7
class Spoom::Timeline
  # source://spoom-1.1.11/lib/spoom/timeline.rb:11
  sig { params(from: ::Time, to: ::Time, path: ::String).void }
  def initialize(from, to, path: T.unsafe(nil)); end

  # Return one commit for each date in `dates`
  #
  # source://spoom-1.1.11/lib/spoom/timeline.rb:38
  sig { params(dates: T::Array[::Time]).returns(T::Array[::String]) }
  def commits_for_dates(dates); end

  # Return all months between `from` and `to`
  #
  # source://spoom-1.1.11/lib/spoom/timeline.rb:25
  sig { returns(T::Array[::Time]) }
  def months; end

  # Return one commit for each month between `from` and `to`
  #
  # source://spoom-1.1.11/lib/spoom/timeline.rb:19
  sig { returns(T::Array[::String]) }
  def ticks; end
end

# source://spoom-1.1.11/lib/spoom/version.rb:5
Spoom::VERSION = T.let(T.unsafe(nil), String)
