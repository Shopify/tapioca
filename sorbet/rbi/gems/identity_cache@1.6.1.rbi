# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `bin/tapioca gem identity_cache`.


# source://identity_cache//lib/identity_cache/version.rb#3
module IdentityCache
  extend ::ActiveSupport::Concern
  extend ::IdentityCache::CacheHash
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex
  include ::IdentityCache::WithPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # source://identity_cache//lib/identity_cache.rb#73
  def cache_namespace; end

  # source://identity_cache//lib/identity_cache.rb#73
  def cache_namespace=(val); end

  class << self
    # @raise [AlreadyIncludedError]
    #
    # source://identity_cache//lib/identity_cache.rb#88
    def append_features(base); end

    # source://identity_cache//lib/identity_cache.rb#108
    def cache; end

    # Sets the cache adaptor IdentityCache will be using
    #
    # == Parameters
    #
    # +cache_adaptor+ - A ActiveSupport::Cache::Store
    #
    # source://identity_cache//lib/identity_cache.rb#100
    def cache_backend=(cache_adaptor); end

    # source://identity_cache//lib/identity_cache.rb#73
    def cache_namespace; end

    # source://identity_cache//lib/identity_cache.rb#73
    def cache_namespace=(val); end

    # source://identity_cache//lib/identity_cache.rb#258
    def eager_load!; end

    # Cache retrieval and miss resolver primitive; given a key it will try to
    # retrieve the associated value from the cache otherwise it will return the
    # value of the execution of the block.
    #
    # == Parameters
    # +key+ A cache key string
    # +cache_fetcher_options+ A hash of options to pass to the cache backend
    #
    # source://identity_cache//lib/identity_cache.rb#161
    def fetch(key, cache_fetcher_options = T.unsafe(nil)); end

    # Same as +fetch+, except that it will try a collection of keys, using the
    # multiget operation of the cache adaptor.
    #
    # == Parameters
    # +keys+ A collection or array of key strings
    #
    # source://identity_cache//lib/identity_cache.rb#184
    def fetch_multi(*keys); end

    # source://identity_cache//lib/identity_cache.rb#251
    def fetch_read_only_records; end

    # Sets the attribute fetch_read_only_records
    #
    # @param value the value to set the attribute fetch_read_only_records to.
    #
    # source://identity_cache//lib/identity_cache.rb#84
    def fetch_read_only_records=(_arg0); end

    # source://identity_cache//lib/identity_cache.rb#112
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://identity_cache//lib/identity_cache.rb#86
    def logger=(_arg0); end

    # source://identity_cache//lib/identity_cache.rb#171
    def map_cached_nil_for(value); end

    # Returns the value of attribute readonly.
    #
    # source://identity_cache//lib/identity_cache.rb#85
    def readonly; end

    # Sets the attribute readonly
    #
    # @param value the value to set the attribute readonly to.
    #
    # source://identity_cache//lib/identity_cache.rb#85
    def readonly=(_arg0); end

    # @return [Boolean]
    #
    # source://identity_cache//lib/identity_cache.rb#116
    def should_fill_cache?; end

    # source://identity_cache//lib/identity_cache.rb#145
    def should_use_cache?; end

    # source://identity_cache//lib/identity_cache.rb#175
    def unmap_cached_nil_for(value); end

    # Executes a block with deferred parent expiration, ensuring that the parent
    # records' cache expiration is deferred until the block completes. When the block
    # completes, it triggers expiration of the primary index for the parent records.
    # Raises a NestedDeferredParentBlockError if a deferred parent expiration block
    # is already active on the current thread.
    #
    # == Parameters:
    # No parameters.
    #
    # == Raises:
    # NestedDeferredParentBlockError if a deferred parent expiration block is already active.
    #
    # == Yield:
    # Runs the provided block with deferred parent expiration.
    #
    # == Returns:
    # The result of executing the provided block.
    #
    # == Ensures:
    # Cleans up thread-local variables related to deferred parent expiration regardless
    # of whether the block raises an exception.
    #
    # source://identity_cache//lib/identity_cache.rb#226
    def with_deferred_parent_expiration; end

    # source://identity_cache//lib/identity_cache.rb#243
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    # source://identity_cache//lib/identity_cache.rb#264
    def fetch_in_batches(keys, &block); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache//lib/identity_cache.rb#57
class IdentityCache::AlreadyIncludedError < ::StandardError; end

# source://identity_cache//lib/identity_cache.rb#59
class IdentityCache::AssociationError < ::StandardError; end

# source://identity_cache//lib/identity_cache.rb#53
IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://identity_cache//lib/identity_cache/belongs_to_caching.rb#4
module IdentityCache::BelongsToCaching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods

  module GeneratedClassMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end

  module GeneratedInstanceMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end
end

# source://identity_cache//lib/identity_cache/belongs_to_caching.rb#12
module IdentityCache::BelongsToCaching::ClassMethods
  # source://identity_cache//lib/identity_cache/belongs_to_caching.rb#13
  def cache_belongs_to(association); end
end

# source://identity_cache//lib/identity_cache.rb#52
IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)

# source://identity_cache//lib/identity_cache/version.rb#5
IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

# source://identity_cache//lib/identity_cache/cache_fetcher.rb#6
class IdentityCache::CacheFetcher
  # @return [CacheFetcher] a new instance of CacheFetcher
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#51
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#7
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#7
  def cache_backend=(_arg0); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#63
  def clear; end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#59
  def delete(key); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#77
  def fetch(key, fill_lock_duration: T.unsafe(nil), lock_wait_tries: T.unsafe(nil), &block); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#67
  def fetch_multi(keys, &block); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#55
  def write(key, value); end

  private

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#311
  def add(key, value, expiration_options = T.unsafe(nil)); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#305
  def add_multi(keys); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#276
  def cas_multi(keys); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#272
  def client_id; end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#257
  def fallback_key_expiration_options(fill_lock_duration); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#199
  def fetch_or_take_lock(key, old_lock:, **expiration_options); end

  # @raise [ArgumentError]
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#103
  def fetch_with_fill_lock(key, fill_lock_duration, lock_wait_tries, &block); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#87
  def fetch_without_fill_lock(key); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#237
  def fill_with_lock(key, data, my_lock, expiration_options); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#253
  def lock_fill_fallback_key(key, lock); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#174
  def mark_fill_failure_on_lock(key, expiration_options); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#186
  def upsert(key, expiration_options = T.unsafe(nil)); end
end

# source://identity_cache//lib/identity_cache/cache_fetcher.rb#9
IdentityCache::CacheFetcher::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://identity_cache//lib/identity_cache/cache_fetcher.rb#11
class IdentityCache::CacheFetcher::FillLock
  # @return [FillLock] a new instance of FillLock
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#29
  def initialize(client_id:, data_version:); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#46
  def ==(other); end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#34
  def cache_value; end

  # Returns the value of attribute client_id.
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#27
  def client_id; end

  # Returns the value of attribute data_version.
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#27
  def data_version; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#42
  def fill_failed?; end

  # source://identity_cache//lib/identity_cache/cache_fetcher.rb#38
  def mark_failed; end

  class << self
    # @return [Boolean]
    #
    # source://identity_cache//lib/identity_cache/cache_fetcher.rb#22
    def cache_value?(cache_value); end

    # @raise [ArgumentError]
    #
    # source://identity_cache//lib/identity_cache/cache_fetcher.rb#16
    def from_cache(marker, client_id, data_version); end
  end
end

# source://identity_cache//lib/identity_cache/cache_fetcher.rb#13
IdentityCache::CacheFetcher::FillLock::FAILED_CLIENT_ID = T.let(T.unsafe(nil), String)

# source://identity_cache//lib/identity_cache/cache_fetcher.rb#12
IdentityCache::CacheFetcher::FillLock::FILL_LOCKED = T.let(T.unsafe(nil), Symbol)

# source://identity_cache//lib/identity_cache/cache_hash.rb#23
module IdentityCache::CacheHash
  # source://identity_cache//lib/identity_cache/cache_hash.rb#26
  def memcache_hash(key); end
end

# source://identity_cache//lib/identity_cache/cache_invalidation.rb#4
module IdentityCache::CacheInvalidation
  # source://identity_cache//lib/identity_cache/cache_invalidation.rb#7
  def reload(*_arg0); end

  private

  # source://identity_cache//lib/identity_cache/cache_invalidation.rb#14
  def clear_cached_associations; end
end

# source://identity_cache//lib/identity_cache/cache_invalidation.rb#5
IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

# source://identity_cache//lib/identity_cache/cache_key_generation.rb#4
module IdentityCache::CacheKeyGeneration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods

  class << self
    # source://identity_cache//lib/identity_cache/cache_key_generation.rb#30
    def denormalized_schema_hash(klass); end

    # source://identity_cache//lib/identity_cache/cache_key_generation.rb#13
    def denormalized_schema_string(klass); end

    # source://identity_cache//lib/identity_cache/cache_key_generation.rb#9
    def schema_to_string(columns); end
  end
end

# source://identity_cache//lib/identity_cache/cache_key_generation.rb#36
module IdentityCache::CacheKeyGeneration::ClassMethods
  # source://identity_cache//lib/identity_cache/cache_key_generation.rb#37
  def rails_cache_key_namespace; end
end

# source://identity_cache//lib/identity_cache/cache_key_generation.rb#6
IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

# A generic cache key loader that supports different types of
# cache fetchers, each of which can use their own cache key
# format and have their own cache miss resolvers.
#
# Here is the interface of a cache fetcher in the
# [ruby-signature](https://github.com/ruby/ruby-signature)'s
# format.
#
# ```
# interface _CacheFetcher[DbKey, DbValue, CacheableValue]
#   def cache_key: (DbKey) -> String
#   def cache_encode: (DbValue) -> CacheableValue
#   def cache_decode: (CacheableValue) -> DbValue
#   def load_one_from_db: (DbKey) -> DbValue
#   def load_multi_from_db: (Array[DbKey]) -> Hash[DbKey, DbValue]
# end
# ```
#
# source://identity_cache//lib/identity_cache/cache_key_loader.rb#21
module IdentityCache::CacheKeyLoader
  class << self
    # Load a single key for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key Reference to what to load from the database.
    # @return The database value corresponding to the database key.
    #
    # source://identity_cache//lib/identity_cache/cache_key_loader.rb#28
    def load(cache_fetcher, db_key, cache_fetcher_options = T.unsafe(nil)); end

    # Load multiple keys for multiple cache fetchers
    #
    # source://identity_cache//lib/identity_cache/cache_key_loader.rb#51
    def load_batch(cache_fetcher_to_db_keys_hash); end

    # Load multiple keys for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key [Array] Reference to what to load from the database.
    # @return [Hash] A hash mapping each database key to its corresponding value
    #
    # source://identity_cache//lib/identity_cache/cache_key_loader.rb#46
    def load_multi(cache_fetcher, db_keys); end

    private

    # source://identity_cache//lib/identity_cache/cache_key_loader.rb#99
    def cache_fetch_multi(cache_keys); end

    # source://identity_cache//lib/identity_cache/cache_key_loader.rb#106
    def resolve_multi_on_miss(cache_fetcher, unresolved_cache_keys, cache_key_to_db_key_hash, resolve_miss_result, db_keys_buffer: T.unsafe(nil)); end
  end
end

# source://identity_cache//lib/identity_cache/cached.rb#4
module IdentityCache::Cached; end

# source://identity_cache//lib/identity_cache/cached/association.rb#5
class IdentityCache::Cached::Association
  include ::IdentityCache::Cached::EmbeddedFetching

  # @return [Association] a new instance of Association
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#8
  def initialize(name, reflection:); end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#17
  def build; end

  # Returns the value of attribute cached_accessor_name.
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#15
  def cached_accessor_name; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#29
  def clear(_record); end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#41
  def embedded?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#45
  def embedded_by_reference?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#49
  def embedded_recursively?; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#33
  def fetch(_records); end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#37
  def fetch_async(_load_strategy, _records); end

  # source://identity_cache//lib/identity_cache/cached/association.rb#53
  def inverse_name; end

  # Returns the value of attribute name.
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#15
  def name; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#21
  def read(_record); end

  # Returns the value of attribute records_variable_name.
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#15
  def records_variable_name; end

  # Returns the value of attribute reflection.
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#15
  def reflection; end

  # source://identity_cache//lib/identity_cache/cached/association.rb#57
  def validate; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/association.rb#25
  def write(_record, _value); end
end

# @abstract
#
# source://identity_cache//lib/identity_cache/cached/attribute.rb#6
class IdentityCache::Cached::Attribute
  # @return [Attribute] a new instance of Attribute
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#9
  def initialize(model, attribute_or_proc, alias_name, key_fields, unique); end

  # Returns the value of attribute alias_name.
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#7
  def alias_name; end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#21
  def attribute; end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#103
  def cache_decode(db_value); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#103
  def cache_encode(db_value); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#54
  def cache_key(index_key); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#37
  def expire(record); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#25
  def fetch(db_key); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#66
  def fetch_multi(keys); end

  # Returns the value of attribute key_fields.
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#7
  def key_fields; end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#82
  def load_multi_from_db(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#59
  def load_one_from_db(key); end

  # Returns the value of attribute model.
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#7
  def model; end

  # Returns the value of attribute unique.
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#7
  def unique; end

  private

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#131
  def cache_key_from_key_values(_key_values); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#139
  def cache_key_prefix; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#111
  def cast_db_key(_index_key); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#169
  def fetch_method_suffix; end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#135
  def field_types; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#121
  def load_from_db_where_conditions(_index_key_or_keys); end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#126
  def load_multi_rows(_index_keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#149
  def new_cache_key(record); end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#154
  def old_cache_key(record); end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache//lib/identity_cache/cached/attribute.rb#116
  def unhashed_values_cache_key_string(_index_key); end
end

# source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#5
class IdentityCache::Cached::AttributeByMulti < ::IdentityCache::Cached::Attribute
  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#6
  def build; end

  # source://identity_cache//lib/identity_cache/cached/attribute.rb#54
  def cache_key_from_key_values(index_key); end

  private

  # Attribute method overrides
  #
  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#24
  def cast_db_key(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#35
  def load_from_db_where_conditions(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#39
  def load_multi_rows(keys); end

  # Helper methods
  #
  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#57
  def load_multi_rows_query(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#31
  def unhashed_values_cache_key_string(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_multi.rb#117
  def unsorted_model; end
end

# source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#5
class IdentityCache::Cached::AttributeByOne < ::IdentityCache::Cached::Attribute
  # @return [AttributeByOne] a new instance of AttributeByOne
  #
  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#8
  def initialize(*_arg0); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#13
  def build; end

  # Returns the value of attribute key_field.
  #
  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#6
  def key_field; end

  private

  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#47
  def cache_key_from_key_values(key_values); end

  # Attribute method overrides
  #
  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#31
  def cast_db_key(key); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#39
  def load_from_db_where_conditions(key_values); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#43
  def load_multi_rows(keys); end

  # source://identity_cache//lib/identity_cache/cached/attribute_by_one.rb#35
  def unhashed_values_cache_key_string(key); end
end

# source://identity_cache//lib/identity_cache/cached/belongs_to.rb#5
class IdentityCache::Cached::BelongsTo < ::IdentityCache::Cached::Association
  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#8
  def build; end

  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#25
  def clear(record); end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#102
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#98
  def embedded_recursively?; end

  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#35
  def fetch(records); end

  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#39
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute records_variable_name.
  #
  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#6
  def records_variable_name; end

  # source://identity_cache//lib/identity_cache/cached/belongs_to.rb#31
  def write(owner_record, associated_record); end
end

# source://identity_cache//lib/identity_cache/cached/embedded_fetching.rb#5
module IdentityCache::Cached::EmbeddedFetching
  private

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/embedded_fetching.rb#36
  def embedded_fetched?(records); end

  # source://identity_cache//lib/identity_cache/cached/embedded_fetching.rb#8
  def fetch_embedded(records); end

  # source://identity_cache//lib/identity_cache/cached/embedded_fetching.rb#12
  def fetch_embedded_async(load_strategy, records); end
end

# source://identity_cache//lib/identity_cache/cached/prefetcher.rb#5
module IdentityCache::Cached::Prefetcher
  class << self
    # source://identity_cache//lib/identity_cache/cached/prefetcher.rb#9
    def prefetch(klass, associations, records, load_strategy: T.unsafe(nil)); end

    private

    # source://identity_cache//lib/identity_cache/cached/prefetcher.rb#39
    def fetch_association(load_strategy, klass, association, records, &block); end

    # source://identity_cache//lib/identity_cache/cached/prefetcher.rb#54
    def preload_records(records, association); end
  end
end

# source://identity_cache//lib/identity_cache/cached/prefetcher.rb#6
IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache//lib/identity_cache/cached/primary_index.rb#5
class IdentityCache::Cached::PrimaryIndex
  # @return [PrimaryIndex] a new instance of PrimaryIndex
  #
  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#8
  def initialize(model); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#77
  def cache_decode(cache_value); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#73
  def cache_encode(record); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#51
  def cache_key(id); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#46
  def expire(id); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#12
  def fetch(id, cache_fetcher_options); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#34
  def fetch_multi(ids); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#64
  def load_multi_from_db(ids); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#55
  def load_one_from_db(id); end

  # Returns the value of attribute model.
  #
  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#6
  def model; end

  private

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#91
  def build_query(id_or_ids); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#95
  def cache_key_prefix; end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#83
  def cast_id(id); end

  # source://identity_cache//lib/identity_cache/cached/primary_index.rb#87
  def id_column; end
end

# source://identity_cache//lib/identity_cache/cached/recursive/association.rb#5
module IdentityCache::Cached::Recursive; end

# source://identity_cache//lib/identity_cache/cached/recursive/association.rb#6
class IdentityCache::Cached::Recursive::Association < ::IdentityCache::Cached::Association
  # @return [Association] a new instance of Association
  #
  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#7
  def initialize(name, reflection:); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#14
  def build; end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#53
  def clear(record); end

  # Returns the value of attribute dehydrated_variable_name.
  #
  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#12
  def dehydrated_variable_name; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#69
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#73
  def embedded_recursively?; end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#59
  def fetch(records); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#63
  def fetch_async(load_strategy, records); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#25
  def read(record); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#48
  def set_with_inverse(record, association_target); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#44
  def write(record, association_target); end

  private

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#104
  def embedded_fetched?(records); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#95
  def hydrate_association_target(associated_class, dehydrated_value); end

  # source://identity_cache//lib/identity_cache/cached/recursive/association.rb#79
  def set_inverse(record, association_target); end
end

# source://identity_cache//lib/identity_cache/cached/recursive/has_many.rb#6
class IdentityCache::Cached::Recursive::HasMany < ::IdentityCache::Cached::Recursive::Association; end

# source://identity_cache//lib/identity_cache/cached/recursive/has_one.rb#6
class IdentityCache::Cached::Recursive::HasOne < ::IdentityCache::Cached::Recursive::Association; end

# source://identity_cache//lib/identity_cache/cached/reference/association.rb#5
module IdentityCache::Cached::Reference; end

# source://identity_cache//lib/identity_cache/cached/reference/association.rb#6
class IdentityCache::Cached::Reference::Association < ::IdentityCache::Cached::Association
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/reference/association.rb#7
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/reference/association.rb#11
  def embedded_recursively?; end
end

# source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#6
class IdentityCache::Cached::Reference::HasMany < ::IdentityCache::Cached::Reference::Association
  # @return [HasMany] a new instance of HasMany
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#7
  def initialize(name, reflection:); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#15
  def build; end

  # Returns the value of attribute cached_ids_name.
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#13
  def cached_ids_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#44
  def clear(record); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#52
  def fetch(records); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#56
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute ids_variable_name.
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#13
  def ids_variable_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#36
  def read(record); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#40
  def write(record, ids); end

  private

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#87
  def embedded_fetched?(records); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#100
  def ids_cached_reader_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#96
  def ids_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_many.rb#92
  def singular_name; end
end

# source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#6
class IdentityCache::Cached::Reference::HasOne < ::IdentityCache::Cached::Reference::Association
  # @return [HasOne] a new instance of HasOne
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#7
  def initialize(name, reflection:); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#15
  def build; end

  # Returns the value of attribute cached_id_name.
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#13
  def cached_id_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#45
  def clear(record); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#53
  def fetch(records); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#57
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute id_variable_name.
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#13
  def id_variable_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#37
  def read(record); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#41
  def write(record, id); end

  private

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#86
  def embedded_fetched?(records); end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#95
  def id_cached_reader_name; end

  # source://identity_cache//lib/identity_cache/cached/reference/has_one.rb#91
  def id_name; end
end

# source://identity_cache//lib/identity_cache/configuration_dsl.rb#4
module IdentityCache::ConfigurationDSL
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end
end

# source://identity_cache//lib/identity_cache/configuration_dsl.rb#17
module IdentityCache::ConfigurationDSL::ClassMethods
  # Will cache a single attribute on its own blob, it will add a
  # fetch_attribute_by_id (or the value of the by option).
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     cache_attribute :quantity, by: :name
  #     cache_attribute :quantity, by: [:name, :vendor]
  #   end
  #
  # == Parameters
  # +attribute+ Symbol with the name of the attribute being cached
  #
  # == Options
  #
  # * by: Other attribute or attributes in the model to keep values indexed. Default is :id
  # * unique: if the index would only have unique values. Default is true
  #
  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#119
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # The embed option, if set, will make IdentityCache keep the association
  # values in the same cache entry as the parent.
  #
  # Embedded associations are more effective in offloading database work,
  # however they will increase the size of the cache entries and make the
  # whole entry expire when any of the embedded members change.
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     has_many :options
  #     has_many :orders
  #     cache_has_many :options, embed: :ids
  #     cache_has_many :orders
  #   end
  #
  # == Parameters
  # +association+ Name of the association being cached as a symbol
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated records
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:ids` (the default), it will only embed the ids for the associated
  #   records.
  #
  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#45
  def cache_has_many(association, embed: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # IdentityCache will keep the association values in the same cache entry
  # as the parent.
  #
  # == Example:
  #   class Product
  #     cache_has_one :store, embed: true
  #     cache_has_one :vendor, embed: :id
  #   end
  #
  # == Parameters
  # +association+ Symbol with the name of the association being cached
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated record
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:id`, it will only embed the id for the associated record.
  #
  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#83
  def cache_has_one(association, embed:); end

  private

  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#125
  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end

  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#144
  def check_association_for_caching(association); end

  # source://identity_cache//lib/identity_cache/configuration_dsl.rb#135
  def ensure_base_model; end
end

# source://identity_cache//lib/identity_cache.rb#54
IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)

# source://identity_cache//lib/identity_cache.rb#55
IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)

# source://identity_cache//lib/identity_cache.rb#69
class IdentityCache::DerivedModelError < ::StandardError; end

# source://identity_cache//lib/identity_cache/encoder.rb#4
module IdentityCache::Encoder
  class << self
    # source://identity_cache//lib/identity_cache/encoder.rb#17
    def decode(coder, klass); end

    # source://identity_cache//lib/identity_cache/encoder.rb#9
    def encode(record); end

    private

    # source://identity_cache//lib/identity_cache/encoder.rb#27
    def coder_from_record(record, klass); end

    # source://identity_cache//lib/identity_cache/encoder.rb#58
    def embedded_coder(record, _association, cached_association); end

    # source://identity_cache//lib/identity_cache/encoder.rb#70
    def record_from_coder(coder, klass); end
  end
end

# source://identity_cache//lib/identity_cache/encoder.rb#5
IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache//lib/identity_cache/encoder.rb#6
IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache//lib/identity_cache/expiry_hook.rb#4
class IdentityCache::ExpiryHook
  # @return [ExpiryHook] a new instance of ExpiryHook
  #
  # source://identity_cache//lib/identity_cache/expiry_hook.rb#5
  def initialize(cached_association); end

  # source://identity_cache//lib/identity_cache/expiry_hook.rb#9
  def install; end

  private

  # Returns the value of attribute cached_association.
  #
  # source://identity_cache//lib/identity_cache/expiry_hook.rb#17
  def cached_association; end

  # source://identity_cache//lib/identity_cache/expiry_hook.rb#31
  def child_class; end

  # source://identity_cache//lib/identity_cache/expiry_hook.rb#23
  def inverse_name; end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/expiry_hook.rb#19
  def only_on_foreign_key_change?; end

  # source://identity_cache//lib/identity_cache/expiry_hook.rb#27
  def parent_class; end
end

# source://identity_cache//lib/identity_cache/fallback_fetcher.rb#4
class IdentityCache::FallbackFetcher
  # @return [FallbackFetcher] a new instance of FallbackFetcher
  #
  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#7
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#5
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#5
  def cache_backend=(_arg0); end

  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#19
  def clear; end

  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#15
  def delete(key); end

  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#40
  def fetch(key, **cache_fetcher_options); end

  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#23
  def fetch_multi(keys); end

  # source://identity_cache//lib/identity_cache/fallback_fetcher.rb#11
  def write(key, value); end
end

# source://identity_cache//lib/identity_cache.rb#61
class IdentityCache::InverseAssociationError < ::StandardError; end

# source://identity_cache//lib/identity_cache/load_strategy/load_request.rb#4
module IdentityCache::LoadStrategy; end

# source://identity_cache//lib/identity_cache/load_strategy/eager.rb#5
module IdentityCache::LoadStrategy::Eager
  extend ::IdentityCache::LoadStrategy::Eager

  # @yield [lazy_loader]
  #
  # source://identity_cache//lib/identity_cache/load_strategy/eager.rb#20
  def lazy_load; end

  # @yield [CacheKeyLoader.load(cache_fetcher, db_key)]
  #
  # source://identity_cache//lib/identity_cache/load_strategy/eager.rb#8
  def load(cache_fetcher, db_key); end

  # @yield [CacheKeyLoader.load_batch(db_keys_by_cache_fetcher)]
  #
  # source://identity_cache//lib/identity_cache/load_strategy/eager.rb#16
  def load_batch(db_keys_by_cache_fetcher); end

  # @yield [CacheKeyLoader.load_multi(cache_fetcher, db_keys)]
  #
  # source://identity_cache//lib/identity_cache/load_strategy/eager.rb#12
  def load_multi(cache_fetcher, db_keys); end
end

# source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#5
class IdentityCache::LoadStrategy::Lazy
  # @return [Lazy] a new instance of Lazy
  #
  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#6
  def initialize; end

  # @yield [_self]
  # @yieldparam _self [IdentityCache::LoadStrategy::Lazy] the object that the method was called on
  #
  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#45
  def lazy_load; end

  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#10
  def load(cache_fetcher, db_key); end

  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#32
  def load_batch(db_keys_by_cache_fetcher); end

  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#17
  def load_multi(cache_fetcher, db_keys, &callback); end

  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#50
  def load_now; end

  private

  # source://identity_cache//lib/identity_cache/load_strategy/lazy.rb#60
  def load_pending(pending_loads); end
end

# source://identity_cache//lib/identity_cache/load_strategy/load_request.rb#5
class IdentityCache::LoadStrategy::LoadRequest
  # @return [LoadRequest] a new instance of LoadRequest
  #
  # source://identity_cache//lib/identity_cache/load_strategy/load_request.rb#8
  def initialize(db_keys, callback); end

  # source://identity_cache//lib/identity_cache/load_strategy/load_request.rb#13
  def after_load(results); end

  # Returns the value of attribute db_keys.
  #
  # source://identity_cache//lib/identity_cache/load_strategy/load_request.rb#6
  def db_keys; end
end

# source://identity_cache//lib/identity_cache/load_strategy/multi_load_request.rb#5
class IdentityCache::LoadStrategy::MultiLoadRequest
  # @return [MultiLoadRequest] a new instance of MultiLoadRequest
  #
  # source://identity_cache//lib/identity_cache/load_strategy/multi_load_request.rb#6
  def initialize(load_requests); end

  # source://identity_cache//lib/identity_cache/load_strategy/multi_load_request.rb#14
  def after_load(all_results); end

  # source://identity_cache//lib/identity_cache/load_strategy/multi_load_request.rb#10
  def db_keys; end
end

# source://identity_cache//lib/identity_cache.rb#71
class IdentityCache::LockWaitTimeout < ::StandardError; end

# source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#7
class IdentityCache::MemoizedCacheProxy
  # @return [MemoizedCacheProxy] a new instance of MemoizedCacheProxy
  #
  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#10
  def initialize(cache_adaptor = T.unsafe(nil)); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#15
  def cache_backend=(cache_adaptor); end

  # Returns the value of attribute cache_fetcher.
  #
  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#8
  def cache_fetcher; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#133
  def clear; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#60
  def delete(key); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#73
  def fetch(key, cache_fetcher_options = T.unsafe(nil), &block); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#102
  def fetch_multi(*keys); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#40
  def memoized_key_values; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#44
  def with_memoization; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#52
  def write(key, value); end

  private

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#189
  def clear_memoization; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#152
  def fetch_memoized(key); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#161
  def fetch_multi_memoized(keys); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#181
  def instrument_duration(payload, key); end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#197
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#193
  def memoizing?; end

  # source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#145
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

# source://identity_cache//lib/identity_cache/memoized_cache_proxy.rb#142
IdentityCache::MemoizedCacheProxy::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://identity_cache//lib/identity_cache.rb#63
class IdentityCache::NestedDeferredParentBlockError < ::StandardError; end

# source://identity_cache//lib/identity_cache/parent_model_expiration.rb#4
module IdentityCache::ParentModelExpiration
  include ::ArTransactionChanges
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#58
  def add_parents_to_cache_expiry_set(parents_to_expire); end

  # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#65
  def add_record_to_cache_expiry_set(parents_to_expire, record); end

  # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#45
  def expire_parent_caches; end

  # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#71
  def parents_to_expire_on_changes(parents_to_expire, association_name, cached_associations); end

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#105
  def should_expire_identity_cache_parent?(foreign_key, only_on_foreign_key_change); end

  class << self
    # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#9
    def add_parent_expiry_hook(cached_association); end

    # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#14
    def install_all_pending_parent_expiry_hooks; end

    # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#24
    def install_pending_parent_expiry_hooks(model); end

    private

    # source://identity_cache//lib/identity_cache/parent_model_expiration.rb#35
    def lazy_hooks; end
  end

  module GeneratedClassMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache//lib/identity_cache/query_api.rb#4
module IdentityCache::QueryAPI
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods

  # Override the method that is used to call after_commit callbacks so that we can
  # expire the caches before other after_commit callbacks. This way we can avoid stale
  # cache reads that happen from the ordering of callbacks. For example, if an after_commit
  # callback enqueues a background job, then we don't want it to be possible for the
  # background job to run and load data from the cache before it is invalidated.
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#168
  def _run_commit_callbacks; end

  # Invalidate the cache data associated with the record. Returns `true` on success,
  # `false` otherwise.
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#177
  def expire_cache; end

  # @api private
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#185
  def was_new_record?; end

  private

  # Even if we have problems with some attributes, carry over the results and expire
  # all possible attributes without array allocation.
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#194
  def expire_attribute_indexes; end
end

# source://identity_cache//lib/identity_cache/query_api.rb#7
module IdentityCache::QueryAPI::ClassMethods
  # @api private
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#19
  def all_cached_associations; end

  # @api private
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#14
  def cached_association(name); end

  # Prefetches cached associations on a collection of records
  #
  # source://identity_cache//lib/identity_cache/query_api.rb#9
  def prefetch_associations(includes, records); end

  private

  # source://identity_cache//lib/identity_cache/query_api.rb#139
  def cache_fetch_includes; end

  # source://identity_cache//lib/identity_cache/query_api.rb#32
  def check_association_scope(association_name); end

  # source://identity_cache//lib/identity_cache/query_api.rb#122
  def each_id_embedded_association; end

  # source://identity_cache//lib/identity_cache/query_api.rb#135
  def embedded_associations; end

  # source://identity_cache//lib/identity_cache/query_api.rb#43
  def preload_id_embedded_association(records, cached_association); end

  # source://identity_cache//lib/identity_cache/query_api.rb#25
  def raise_if_scoped; end

  # source://identity_cache//lib/identity_cache/query_api.rb#114
  def readonly_copy(record_or_records); end

  # source://identity_cache//lib/identity_cache/query_api.rb#108
  def readonly_record_copy(record); end

  # source://identity_cache//lib/identity_cache/query_api.rb#131
  def recursively_embedded_associations; end

  # source://identity_cache//lib/identity_cache/query_api.rb#69
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

# source://identity_cache//lib/identity_cache/railtie.rb#4
class IdentityCache::Railtie < ::Rails::Railtie; end

# source://identity_cache//lib/identity_cache/record_not_found.rb#4
class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound; end

# source://identity_cache//lib/identity_cache/should_use_cache.rb#4
module IdentityCache::ShouldUseCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods

  private

  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/should_use_cache.rb#19
  def loaded_by_idc?; end

  # source://identity_cache//lib/identity_cache/should_use_cache.rb#15
  def mark_as_loaded_by_idc; end
end

# source://identity_cache//lib/identity_cache/should_use_cache.rb#7
module IdentityCache::ShouldUseCache::ClassMethods
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/should_use_cache.rb#8
  def should_use_cache?; end
end

# source://identity_cache//lib/identity_cache.rb#67
class IdentityCache::UnsupportedAssociationError < ::StandardError; end

# source://identity_cache//lib/identity_cache.rb#65
class IdentityCache::UnsupportedScopeError < ::StandardError; end

# source://identity_cache//lib/identity_cache/version.rb#4
IdentityCache::VERSION = T.let(T.unsafe(nil), String)

# source://identity_cache//lib/identity_cache/with_primary_index.rb#4
module IdentityCache::WithPrimaryIndex
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # source://identity_cache//lib/identity_cache/with_primary_index.rb#9
  def expire_cache; end

  # @api private
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#16
  def expire_primary_index; end

  # @api private
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#21
  def primary_cache_index_key; end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache//lib/identity_cache/with_primary_index.rb#25
module IdentityCache::WithPrimaryIndex::ClassMethods
  # Declares a new index in the cache for the class where IdentityCache was
  # included.
  #
  # IdentityCache will add a fetch_by_field1_and_field2_and_...field and
  # fetch_multi_by_field1_and_field2_and_...field for every index.
  #
  # == Example:
  #
  #  class Product
  #    include IdentityCache
  #    cache_index :name, :vendor
  #  end
  #
  # Will add:
  #
  #   Product.fetch_by_name_and_vendor
  #   Product.fetch_multi_by_name_and_vendor
  #
  # == Parameters
  #
  # +fields+ Array of symbols or strings representing the fields in the index
  #
  # == Options
  # * unique: if the index would only have unique values. Default is false
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#60
  def cache_index(*fields, unique: T.unsafe(nil)); end

  # @api private
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#27
  def cached_primary_index; end

  # Similar to ActiveRecord::Base#exists? will return true if the id can be
  # found in the cache or in the DB.
  #
  # @return [Boolean]
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#99
  def exists_with_identity_cache?(id); end

  # Invalidates the primary cache index for the associated record. Will not invalidate cached attributes.
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#162
  def expire_primary_key_cache_index(id); end

  # Fetch the record by its primary key from the cache or read from
  # the database and fill the cache on a cache miss. This behaves like
  # `readonly.find(id)` being called on the model.
  #
  # @param id Primary key value for the record to fetch.
  # @param includes [Hash|Array|Symbol] Cached associations to prefetch from
  #   the cache on the returned record
  # @param fill_lock_duration [Float] If provided, take a fill lock around cache fills
  #   and wait for this duration for cache to be filled when reading a lock provided
  #   by another client. Defaults to not setting the fill lock and trying to fill the
  #   cache from the database regardless of the presence of another client's fill lock.
  #   Set this to just above the typical amount of time it takes to do a cache fill.
  # @param lock_wait_tries [Integer] Only applicable if fill_lock_duration is provided,
  #   in which case it specifies the number of times to do a lock wait. After the first
  #   lock wait it will try to take the lock, so will only do following lock waits due
  #   to another client taking the lock first. If another lock wait would be needed after
  #   reaching the limit, then a `LockWaitTimeout` exception is raised. Default is 2. Use
  #   this to control the maximum total lock wait duration
  #   (`lock_wait_tries * fill_lock_duration`).
  # @raise [ActiveRecord::RecordNotFound] if the record isn't found
  # @raise [LockWaitTimeout] Timeout after waiting `lock_wait_tries * fill_lock_duration`
  #   seconds for `lock_wait_tries` other clients to fill the cache.
  # @return [self] An instance of this model for the record with the specified id
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#142
  def fetch(id, **options); end

  # Fetch the record by its primary key from the cache or read from
  # the database and fill the cache on a cache miss. This behaves like
  # `where(id: id).readonly.first` being called on the model.
  #
  # @param id Primary key value for the record to fetch.
  # @param includes [Hash|Array|Symbol] Cached associations to prefetch from
  #   the cache on the returned record
  # @param fill_lock_duration [Float] If provided, take a fill lock around cache fills
  #   and wait for this duration for cache to be filled when reading a lock provided
  #   by another client. Defaults to not setting the fill lock and trying to fill the
  #   cache from the database regardless of the presence of another client's fill lock.
  #   Set this to just above the typical amount of time it takes to do a cache fill.
  # @param lock_wait_tries [Integer] Only applicable if fill_lock_duration is provided,
  #   in which case it specifies the number of times to do a lock wait. After the first
  #   lock wait it will try to take the lock, so will only do following lock waits due
  #   to another client taking the lock first. If another lock wait would be needed after
  #   reaching the limit, then a `LockWaitTimeout` exception is raised. Default is 2. Use
  #   this to control the maximum total lock wait duration
  #   (`lock_wait_tries * fill_lock_duration`).
  # @raise [LockWaitTimeout] Timeout after waiting `lock_wait_tries * fill_lock_duration`
  #   seconds for `lock_wait_tries` other clients to fill the cache.
  # @return [self|nil] An instance of this model for the record with the specified id or
  #   `nil` if no record with this `id` exists in the database
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#126
  def fetch_by_id(id, includes: T.unsafe(nil), **cache_fetcher_options); end

  # Default fetcher added to the model on inclusion, if behaves like
  # ActiveRecord::Base.find_all_by_id
  #
  # source://identity_cache//lib/identity_cache/with_primary_index.rb#150
  def fetch_multi(*ids, includes: T.unsafe(nil)); end

  # source://identity_cache//lib/identity_cache/with_primary_index.rb#31
  def primary_cache_index_enabled; end

  private

  # source://identity_cache//lib/identity_cache/with_primary_index.rb#168
  def inherited(subclass); end
end

# source://identity_cache//lib/identity_cache/without_primary_index.rb#4
module IdentityCache::WithoutPrimaryIndex
  include ::ArTransactionChanges
  include ::IdentityCache::CacheInvalidation
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods

  class << self
    # @raise [AlreadyIncludedError]
    #
    # source://identity_cache//lib/identity_cache/without_primary_index.rb#17
    def append_features(base); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache//lib/identity_cache/without_primary_index.rb#29
module IdentityCache::WithoutPrimaryIndex::ClassMethods
  # source://identity_cache//lib/identity_cache/without_primary_index.rb#30
  def primary_cache_index_enabled; end
end
