# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `unparser` gem.
# Please instead update this file by running `bin/tapioca gem unparser`.

# typed: true

module Unparser
  class << self
    def buffer(source, identification = T.unsafe(nil)); end
    def parse(source); end
    def parse_either(source); end
    def parse_with_comments(source); end
    def parser; end
    def unparse(node, comment_array = T.unsafe(nil)); end
    def unparse_either(node); end
    def unparse_validate(node, comment_array = T.unsafe(nil)); end
  end
end

module Unparser::AST
  class << self
    def local_variable_assignments(node); end
    def local_variable_reads(node); end
    def not_close_scope?(node); end
    def not_reset_scope?(node); end
  end
end

Unparser::AST::ASSIGN_NODES = T.let(T.unsafe(nil), Set)
Unparser::AST::CLOSE_NODES = T.let(T.unsafe(nil), Array)

class Unparser::AST::Enumerator
  include ::Enumerable
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def each(&block); end
  def type(type); end
  def types(types); end

  class << self
    def new(node, controller = T.unsafe(nil)); end

    private

    def set(enumerable); end
    def type(node, type); end
  end
end

Unparser::AST::FIRST_CHILD = T.let(T.unsafe(nil), Proc)
Unparser::AST::INHERIT_NODES = T.let(T.unsafe(nil), Array)

class Unparser::AST::LocalVariableScope
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Enumerable
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def initialize(node); end

  def first_assignment?(node); end
  def first_assignment_in?(left, right); end
  def local_variable_defined_for_node?(node, name); end

  private

  def match(needle); end
end

class Unparser::AST::LocalVariableScopeEnumerator
  include ::Enumerable

  def initialize; end

  def each(node, &block); end

  private

  def current; end
  def define(name); end
  def enter(node); end
  def leave(node); end
  def pop; end
  def push_inherit; end
  def push_reset; end
  def visit(node, &block); end

  class << self
    def each(node, &block); end
  end
end

Unparser::AST::RESET_NODES = T.let(T.unsafe(nil), Array)
Unparser::AST::TAUTOLOGY = T.let(T.unsafe(nil), Proc)

class Unparser::AST::Walker
  include ::Unparser::Equalizer::Methods

  def call(node); end

  class << self
    def call(node, controller = T.unsafe(nil), &block); end
  end
end

module Unparser::AbstractType
  mixes_in_class_methods ::Unparser::AbstractType::AbstractMethodDeclarations

  class << self
    private

    def create_new_method(abstract_class); end
    def included(descendant); end
  end
end

module Unparser::AbstractType::AbstractMethodDeclarations
  def abstract_method(*names); end
  def abstract_singleton_method(*names); end

  private

  def create_abstract_instance_method(name); end
  def create_abstract_singleton_method(name); end
end

module Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods

  mixes_in_class_methods ::Unparser::Adamantium::ModuleMethods
  mixes_in_class_methods ::Unparser::Adamantium::ClassMethods

  class << self
    private

    def included(descendant); end
  end
end

module Unparser::Adamantium::ClassMethods
  def new(*_arg0); end
end

module Unparser::Adamantium::InstanceMethods
  def dup; end
  def freeze; end

  private

  def memoized_method_cache; end
end

class Unparser::Adamantium::Memory
  def initialize(values); end

  def fetch(name); end
end

class Unparser::Adamantium::MethodBuilder
  def initialize(descendant, method_name); end

  def call; end

  private

  def assert_arity(arity); end
  def create_memoized_method; end
  def remove_original_method; end
  def set_method_visibility; end
  def visibility; end
end

class Unparser::Adamantium::MethodBuilder::BlockNotAllowedError < ::ArgumentError
  def initialize(descendant, method); end
end

class Unparser::Adamantium::MethodBuilder::InvalidArityError < ::ArgumentError
  def initialize(descendant, method, arity); end
end

module Unparser::Adamantium::ModuleMethods
  def memoize(*methods); end
  def memoized?(method_name); end
  def unmemoized_instance_method(method_name); end

  private

  def memoize_method(method_name); end
  def memoized_methods; end
end

class Unparser::Anima < ::Module
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def initialize(*names); end

  def add(*names); end
  def attribute_names(&block); end
  def attributes; end
  def attributes_hash(object); end
  def initialize_instance(object, attribute_hash); end
  def remove(*names); end

  private

  def assert_known_attributes(klass, attribute_hash); end
  def included(descendant); end
  def new(attributes); end
end

class Unparser::Anima::Attribute
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def initialize(name); end

  def get(object); end
  def instance_variable_name; end
  def load(object, attributes); end
  def name; end
  def set(object, value); end
end

class Unparser::Anima::Error < ::RuntimeError
  def initialize(klass, missing, unknown); end
end

Unparser::Anima::Error::FORMAT = T.let(T.unsafe(nil), String)

module Unparser::Anima::InstanceMethods
  def initialize(attributes); end

  def to_h; end
  def with(attributes); end
end

class Unparser::Buffer
  def initialize; end

  def append(string); end
  def append_without_prefix(string); end
  def capture_content; end
  def content; end
  def fresh_line?; end
  def indent; end
  def nl; end
  def root_indent; end
  def unindent; end
  def write(fragment); end

  private

  def prefix; end
end

Unparser::Buffer::INDENT_SPACE = T.let(T.unsafe(nil), String)
Unparser::Buffer::NL = T.let(T.unsafe(nil), String)

class Unparser::Builder < ::Parser::Builders::Default
  def initialize; end
end

class Unparser::CLI
  def initialize(arguments); end

  def add_options(builder); end
  def exit_status; end

  private

  def effective_targets; end
  def process_target(target); end
  def targets(file_name); end

  class << self
    def run(*arguments); end
  end
end

Unparser::CLI::EXIT_FAILURE = T.let(T.unsafe(nil), Integer)
Unparser::CLI::EXIT_SUCCESS = T.let(T.unsafe(nil), Integer)

class Unparser::CLI::Target
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  class << self
    def new(*args, &block); end
  end
end

class Unparser::CLI::Target::Path < ::Unparser::CLI::Target
  include ::Unparser::Equalizer::Methods

  def literal_validation; end
  def validation; end
end

class Unparser::CLI::Target::String
  include ::Unparser::Equalizer::Methods

  def literal_validation; end
  def validation; end
end

class Unparser::Color
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def format(text); end
end

Unparser::Color::GREEN = T.let(T.unsafe(nil), Unparser::Color)
Unparser::Color::NONE = T.let(T.unsafe(nil), T.untyped)
Unparser::Color::RED = T.let(T.unsafe(nil), Unparser::Color)

class Unparser::Comments
  def initialize(comments); end

  def consume(node, source_part = T.unsafe(nil)); end
  def source_range(*arguments); end
  def take_all; end
  def take_before(node, source_part); end
  def take_eol_comments; end

  private

  def take_up_to_line(line); end
  def take_while; end
  def unshift_documents(comments); end

  class << self
    def source_range(node, part); end
  end
end

class Unparser::Concord < ::Module
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def initialize(*names); end

  def names; end

  private

  def define_equalizer; end
  def define_initialize; end
  def define_readers; end
  def instance_variable_names; end
end

Unparser::Concord::MAX_NR_OF_OBJECTS = T.let(T.unsafe(nil), Integer)

class Unparser::Concord::Public < ::Unparser::Concord
  def included(descendant); end
end

module Unparser::Constants; end
Unparser::Constants::BINARY_OPERATORS = T.let(T.unsafe(nil), Set)
Unparser::Constants::KEYWORDS = T.let(T.unsafe(nil), Set)
Unparser::Constants::K_ALIAS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_AND = T.let(T.unsafe(nil), String)
Unparser::Constants::K_BEGIN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_BREAK = T.let(T.unsafe(nil), String)
Unparser::Constants::K_CASE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_CLASS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEFINE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DEFINED = T.let(T.unsafe(nil), String)
Unparser::Constants::K_DO = T.let(T.unsafe(nil), String)
Unparser::Constants::K_EEND = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ELSE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ELSIF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ENCODING = T.let(T.unsafe(nil), String)
Unparser::Constants::K_END = T.let(T.unsafe(nil), String)
Unparser::Constants::K_ENSURE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FALSE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FILE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_FOR = T.let(T.unsafe(nil), String)
Unparser::Constants::K_IF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_IN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_MODULE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NEXT = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NIL = T.let(T.unsafe(nil), String)
Unparser::Constants::K_NOT = T.let(T.unsafe(nil), String)
Unparser::Constants::K_OR = T.let(T.unsafe(nil), String)
Unparser::Constants::K_POSTEXE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_PREEXE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_REDO = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RESCUE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RETRY = T.let(T.unsafe(nil), String)
Unparser::Constants::K_RETURN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_SELF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_SUPER = T.let(T.unsafe(nil), String)
Unparser::Constants::K_THEN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_TRUE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNDEF = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNLESS = T.let(T.unsafe(nil), String)
Unparser::Constants::K_UNTIL = T.let(T.unsafe(nil), String)
Unparser::Constants::K_WHEN = T.let(T.unsafe(nil), String)
Unparser::Constants::K_WHILE = T.let(T.unsafe(nil), String)
Unparser::Constants::K_YIELD = T.let(T.unsafe(nil), String)
Unparser::Constants::UNARY_OPERATORS = T.let(T.unsafe(nil), Set)

module Unparser::DSL
  private

  def children(*names); end
  def define_child(name, index); end
  def define_group(name, range); end
  def define_remaining_children(names); end
end

class Unparser::Diff
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def colorized_diff(&block); end
  def diff(&block); end

  private

  def diffs; end
  def hunks; end
  def max_length; end
  def minimized_hunk; end

  class << self
    def build(old, new); end

    private

    def colorize_line(line); end
    def lines(source); end
  end
end

Unparser::Diff::ADDITION = T.let(T.unsafe(nil), String)
Unparser::Diff::DELETION = T.let(T.unsafe(nil), String)
Unparser::Diff::NEWLINE = T.let(T.unsafe(nil), String)
Unparser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Unparser::EMPTY_STRING = T.let(T.unsafe(nil), String)

class Unparser::Either
  include ::Unparser::RequireBlock
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def left?; end
  def right?; end

  class << self
    def wrap_error(*exceptions); end
  end
end

class Unparser::Either::Left < ::Unparser::Either
  def bind(&block); end
  def either(left, _right); end
  def fmap(&block); end
  def from_left; end
  def from_right; end
  def lmap; end
end

class Unparser::Either::Right < ::Unparser::Either
  def bind; end
  def either(_left, right); end
  def fmap; end
  def from_left; end
  def from_right; end
  def lmap(&block); end
end

class Unparser::Emitter
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Constants
  include ::Unparser::AbstractType
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch(*_arg0); end
  def emit_mlhs; end
  def local_variable_scope; end
  def node; end
  def node_type; end

  class << self
    def anima; end
    def emitter(buffer:, comments:, node:, local_variable_scope:); end
    def new(*args, &block); end

    private

    def handle(*types); end
  end
end

class Unparser::Emitter::Alias < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end

class Unparser::Emitter::Args < ::Unparser::Emitter
  def emit_block_arguments; end
  def emit_def_arguments; end
  def emit_lambda_arguments; end

  private

  def emit_shadowargs; end
  def normal_arguments(&block); end
  def shadowargs(&block); end
end

class Unparser::Emitter::Argument < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Array < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def emitters(&block); end
end

class Unparser::Emitter::ArrayPattern < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_member(node); end
end

class Unparser::Emitter::Assignment < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_left(*_arg0); end
  def symbol_name; end

  private

  def dispatch; end
  def emit_right; end
end

Unparser::Emitter::Assignment::BINARY_OPERATOR = T.let(T.unsafe(nil), Array)

class Unparser::Emitter::Assignment::Constant < ::Unparser::Emitter::Assignment
  private

  def base; end
  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end

class Unparser::Emitter::Assignment::Variable < ::Unparser::Emitter::Assignment
  private

  def emit_left; end
  def name; end
  def remaining_children; end
  def right; end
end

class Unparser::Emitter::Begin < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def body; end
  def dispatch; end
  def remaining_children; end
end

class Unparser::Emitter::Binary < ::Unparser::Emitter
  private

  def dispatch; end
  def writer(&block); end
end

class Unparser::Emitter::BinaryAssign < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def expression; end
  def remaining_children; end
  def target; end
end

Unparser::Emitter::BinaryAssign::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Block < ::Unparser::Emitter
  private

  def arguments; end
  def body; end
  def dispatch; end
  def emit_block_arguments; end
  def emit_lambda_arguments; end
  def emit_send_target; end
  def emit_target; end
  def need_do?; end
  def numblock?; end
  def remaining_children; end
  def target; end
  def target_writer(&block); end
  def write_close; end
  def write_open; end
end

class Unparser::Emitter::BlockPass < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::CBase < ::Unparser::Emitter
  private

  def dispatch; end
end

class Unparser::Emitter::Case < ::Unparser::Emitter
  private

  def condition; end
  def dispatch; end
  def emit_condition; end
  def emit_else; end
  def emit_whens; end
  def remaining_children; end
  def whens(&block); end
end

class Unparser::Emitter::CaseGuard < ::Unparser::Emitter
  private

  def condition; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::CaseGuard::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::CaseMatch < ::Unparser::Emitter
  private

  def dispatch; end
  def else_branch; end
  def emit_else_branch; end
  def patterns(&block); end
  def remaining_children; end
  def target; end
end

class Unparser::Emitter::Class < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body; end
  def dispatch; end
  def emit_superclass; end
  def name; end
  def remaining_children; end
  def superclass; end
end

class Unparser::Emitter::Const < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_scope; end
  def name; end
  def remaining_children; end
  def scope; end
end

class Unparser::Emitter::ConstPattern < ::Unparser::Emitter
  private

  def const; end
  def dispatch; end
  def pattern; end
  def remaining_children; end
end

class Unparser::Emitter::DStr < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
end

class Unparser::Emitter::DSym < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_begin_child(component); end
  def emit_str_child(value); end
end

class Unparser::Emitter::Def < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body(*_arg0); end
  def dispatch; end
  def emit_arguments; end
  def emit_name(*_arg0); end
end

class Unparser::Emitter::Def::Instance < ::Unparser::Emitter::Def
  private

  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Def::Singleton < ::Unparser::Emitter::Def
  private

  def arguments; end
  def body; end
  def emit_name; end
  def name; end
  def remaining_children; end
  def subject; end
  def subject_without_parens?; end
end

class Unparser::Emitter::Defined < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def subject; end
end

class Unparser::Emitter::FlipFlop < ::Unparser::Emitter
  def symbol_name; end

  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

Unparser::Emitter::FlipFlop::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::FlipFlop::SYMBOLS = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Float < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def value; end
end

Unparser::Emitter::Float::INFINITY = T.let(T.unsafe(nil), Float)
Unparser::Emitter::Float::NEG_INFINITY = T.let(T.unsafe(nil), Float)

class Unparser::Emitter::FlowModifier < ::Unparser::Emitter
  def emit_heredoc_reminders; end

  private

  def dispatch; end
  def emit_arguments; end
end

Unparser::Emitter::FlowModifier::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::For < ::Unparser::Emitter
  private

  def assignment; end
  def body; end
  def condition; end
  def dispatch; end
  def emit_condition; end
  def remaining_children; end
end

class Unparser::Emitter::Hash < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_last_argument_hash; end

  private

  def dispatch; end
  def emit_hash_body; end
  def emit_heredoc_reminder_member(node); end
end

class Unparser::Emitter::HashPattern < ::Unparser::Emitter
  def emit_const_pattern; end

  private

  def dispatch; end
  def emit_hash_body; end
  def emit_match_var(node); end
  def emit_member(node); end
  def emit_pair(node); end
  def write_symbol_body(symbol); end
end

class Unparser::Emitter::Hookexe < ::Unparser::Emitter
  private

  def body; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::Hookexe::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::If < ::Unparser::Emitter
  def emit_ternary; end

  private

  def condition; end
  def dispatch; end
  def else_branch; end
  def emit_condition; end
  def emit_else_branch; end
  def emit_if_branch; end
  def emit_normal; end
  def emit_postcondition; end
  def if_branch; end
  def keyword; end
  def postcondition?; end
  def remaining_children; end
  def unless?; end
end

class Unparser::Emitter::InMatch < ::Unparser::Emitter
  private

  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end

class Unparser::Emitter::InPattern < ::Unparser::Emitter
  private

  def branch; end
  def dispatch; end
  def else_branch; end
  def remaining_children; end
  def target; end
  def unless_guard; end
end

class Unparser::Emitter::Index < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_receiver; end
end

class Unparser::Emitter::Index::Assign < ::Unparser::Emitter::Index
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end

  private

  def emit_operation(indices); end
end

Unparser::Emitter::Index::Assign::NO_VALUE_PARENT = T.let(T.unsafe(nil), Set)
Unparser::Emitter::Index::Assign::VALUE_RANGE = T.let(T.unsafe(nil), Range)

class Unparser::Emitter::Index::Reference < ::Unparser::Emitter::Index
  private

  def emit_operation; end
  def indices(&block); end
end

class Unparser::Emitter::KWBegin < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_multiple_body; end
end

class Unparser::Emitter::KeywordOptional < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end

class Unparser::Emitter::KwSplat < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def subject; end
end

class Unparser::Emitter::Kwarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Kwargs < ::Unparser::Emitter
  def dispatch; end
end

class Unparser::Emitter::Lambda < ::Unparser::Emitter
  private

  def dispatch; end
end

module Unparser::Emitter::LocalVariableRoot
  def local_variable_scope; end

  class << self
    def included(descendant); end
  end
end

class Unparser::Emitter::MASGN < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def source; end
  def target; end
end

class Unparser::Emitter::MLHS < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_many; end
  def emit_one_child_mlhs; end
end

Unparser::Emitter::MLHS::NO_COMMA = T.let(T.unsafe(nil), Array)
class Unparser::Emitter::Match < ::Unparser::Emitter; end

class Unparser::Emitter::Match::CurrentLine < ::Unparser::Emitter::Match
  private

  def dispatch; end
  def regexp; end
  def remaining_children; end
end

class Unparser::Emitter::Match::Lvasgn < ::Unparser::Emitter::Match
  private

  def dispatch; end
  def lvasgn; end
  def regexp; end
  def remaining_children; end
end

class Unparser::Emitter::MatchAlt < ::Unparser::Emitter
  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

class Unparser::Emitter::MatchAs < ::Unparser::Emitter
  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def right; end
end

class Unparser::Emitter::MatchPattern < ::Unparser::Emitter
  private

  def dispatch; end
  def pattern; end
  def remaining_children; end
  def target; end
end

class Unparser::Emitter::MatchRest < ::Unparser::Emitter
  def emit_array_pattern; end
  def emit_hash_pattern; end

  private

  def emit_match_var; end
  def match_var; end
  def remaining_children; end
end

class Unparser::Emitter::MatchVar < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Module < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def local_variable_scope(&block); end

  private

  def body; end
  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Morearg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

Unparser::Emitter::Morearg::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::NO_INDENT = T.let(T.unsafe(nil), Array)

class Unparser::Emitter::NthRef < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

Unparser::Emitter::NthRef::PREFIX = T.let(T.unsafe(nil), String)

class Unparser::Emitter::OpAssign < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_operator; end
  def operator; end
  def remaining_children; end
  def target; end
  def value; end
end

class Unparser::Emitter::Optarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
  def value; end
end

class Unparser::Emitter::Pair < ::Unparser::Emitter
  private

  def colon?(key); end
  def dispatch; end
  def key; end
  def remaining_children; end
  def value; end
end

Unparser::Emitter::Pair::BAREWORD = T.let(T.unsafe(nil), Regexp)

class Unparser::Emitter::Pin < ::Unparser::Emitter
  private

  def dispatch; end
  def remaining_children; end
  def target; end
end

class Unparser::Emitter::Post < ::Unparser::Emitter
  private

  def body; end
  def condition; end
  def dispatch; end
  def remaining_children; end
end

Unparser::Emitter::Post::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Primitive < ::Unparser::Emitter
  private

  def remaining_children; end
  def value; end
end

class Unparser::Emitter::Primitive::Complex < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
  def emit_imaginary; end
  def imaginary_node; end
end

Unparser::Emitter::Primitive::Complex::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::Primitive::Complex::RATIONAL_FORMAT = T.let(T.unsafe(nil), String)

class Unparser::Emitter::Primitive::Inspect < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
end

class Unparser::Emitter::Primitive::Numeric < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
end

class Unparser::Emitter::Primitive::Rational < ::Unparser::Emitter::Primitive
  private

  def dispatch; end
  def write_rational(value); end
end

Unparser::Emitter::Primitive::Rational::RATIONAL_FORMAT = T.let(T.unsafe(nil), String)

class Unparser::Emitter::Procarg < ::Unparser::Emitter
  private

  def dispatch; end
  def needs_parens?; end
end

Unparser::Emitter::Procarg::PARENS = T.let(T.unsafe(nil), Array)
Unparser::Emitter::REGISTRY = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Range < ::Unparser::Emitter
  def symbol_name; end

  private

  def begin_node; end
  def dispatch; end
  def end_node; end
  def remaining_children; end
end

Unparser::Emitter::Range::SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Emitter::Range::TOKENS = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Regexp < ::Unparser::Emitter
  private

  def body(&block); end
  def dispatch; end
  def emit_body(node); end
  def emit_options; end
end

class Unparser::Emitter::Repetition < ::Unparser::Emitter
  private

  def body; end
  def condition; end
  def dispatch; end
  def emit_keyword; end
  def emit_normal; end
  def emit_postcontrol; end
  def postcontrol?; end
  def remaining_children; end
end

Unparser::Emitter::Repetition::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Rescue < ::Unparser::Emitter
  private

  def dispatch; end
end

class Unparser::Emitter::Restarg < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::Root < ::Unparser::Emitter
  include ::Unparser::Emitter::LocalVariableRoot

  def dispatch; end
  def local_variable_scope(&block); end
end

Unparser::Emitter::Root::END_NL = T.let(T.unsafe(nil), Array)

class Unparser::Emitter::SClass < ::Unparser::Emitter
  private

  def body; end
  def dispatch; end
  def object; end
  def remaining_children; end
end

class Unparser::Emitter::Send < ::Unparser::Emitter
  def emit_heredoc_reminders; end
  def emit_mlhs; end

  private

  def dispatch; end
  def writer(&block); end
end

class Unparser::Emitter::Simple < ::Unparser::Emitter
  private

  def dispatch; end
end

Unparser::Emitter::Simple::MAP = T.let(T.unsafe(nil), Hash)

class Unparser::Emitter::Splat < ::Unparser::Emitter
  def emit_mlhs; end

  private

  def dispatch; end
  def remaining_children; end
  def subject; end
  def subject_emitter(&block); end
end

class Unparser::Emitter::Super < ::Unparser::Emitter
  private

  def dispatch; end
end

class Unparser::Emitter::Undef < ::Unparser::Emitter
  private

  def dispatch; end
end

class Unparser::Emitter::Variable < ::Unparser::Emitter
  private

  def dispatch; end
  def name; end
  def remaining_children; end
end

class Unparser::Emitter::When < ::Unparser::Emitter
  private

  def captures(&block); end
  def dispatch; end
  def emit_captures; end
end

class Unparser::Emitter::XStr < ::Unparser::Emitter
  private

  def dispatch; end
  def emit_begin(component); end
  def emit_heredoc; end
  def emit_string(value); end
  def emit_xstr; end
  def escape_xstr(input); end
  def heredoc?; end
end

class Unparser::Emitter::Yield < ::Unparser::Emitter
  private

  def dispatch; end
end

class Unparser::Equalizer < ::Module
  def initialize(*keys); end

  private

  def define_cmp_method; end
  def define_hash_method; end
  def define_inspect_method; end
  def define_methods; end
  def included(descendant); end
end

module Unparser::Equalizer::Methods
  def ==(other); end
  def eql?(other); end
end

module Unparser::Generation
  def emit_heredoc_reminders; end
  def symbol_name; end
  def write_to_buffer; end

  private

  def children; end
  def conditional_parentheses(flag, &block); end
  def delimited(nodes, delimiter = T.unsafe(nil), &block); end
  def emit_body(node, indent: T.unsafe(nil)); end
  def emit_body_ensure_rescue(node); end
  def emit_body_inner(node); end
  def emit_body_member(node); end
  def emit_body_rescue(node); end
  def emit_comments(comments); end
  def emit_comments_before(source_part = T.unsafe(nil)); end
  def emit_ensure(node); end
  def emit_eof_comments; end
  def emit_eol_comments; end
  def emit_join(nodes, emit_node, emit_delimiter); end
  def emit_optional_body(node, indent: T.unsafe(nil)); end
  def emit_optional_body_ensure_rescue(node); end
  def emit_rescue_postcontrol(node); end
  def emit_rescue_regular(node); end
  def emitter(node); end
  def first_child; end
  def indented; end
  def k_end; end
  def nl; end
  def parentheses(open = T.unsafe(nil), close = T.unsafe(nil)); end
  def visit(node); end
  def visit_deep(node); end
  def with_comments; end
  def write(*strings); end
  def writer_with(klass, node); end
  def ws; end
end

Unparser::Generation::EXTRA_NL = T.let(T.unsafe(nil), Array)

class Unparser::InvalidNodeError < ::RuntimeError
  def initialize(message, node); end

  def node; end
end

module Unparser::NodeDetails
  include ::Unparser::NodeHelpers
  include ::Unparser::Constants

  private

  def children; end

  class << self
    def included(descendant); end
  end
end

class Unparser::NodeDetails::Send
  include ::Unparser::NodeHelpers
  include ::Unparser::Constants
  include ::Unparser::NodeDetails
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def arguments(&block); end
  def arguments?; end
  def assignment?(&block); end
  def assignment_operator?; end
  def binary_syntax_allowed?; end
  def non_assignment_selector; end
  def receiver; end
  def selector; end
  def selector_binary_operator?; end
  def selector_unary_operator?; end
  def string_selector(&block); end

  private

  def remaining_children; end
end

Unparser::NodeDetails::Send::ASSIGN_SUFFIX = T.let(T.unsafe(nil), String)
Unparser::NodeDetails::Send::NON_ASSIGN_RANGE = T.let(T.unsafe(nil), Range)

module Unparser::NodeHelpers
  def n(type, children = T.unsafe(nil)); end
  def n?(type, node); end
  def s(type, *children); end
  def unwrap_single_begin(node); end

  private

  def n_arg?(node); end
  def n_args?(node); end
  def n_array?(node); end
  def n_array_pattern?(node); end
  def n_begin?(node); end
  def n_block?(node); end
  def n_cbase?(node); end
  def n_const?(node); end
  def n_dstr?(node); end
  def n_empty_else?(node); end
  def n_ensure?(node); end
  def n_hash?(node); end
  def n_hash_pattern?(node); end
  def n_if?(node); end
  def n_in_pattern?(node); end
  def n_int?(node); end
  def n_kwsplat?(node); end
  def n_lambda?(node); end
  def n_match_rest?(node); end
  def n_pair?(node); end
  def n_rescue?(node); end
  def n_send?(node); end
  def n_shadowarg?(node); end
  def n_splat?(node); end
  def n_str?(node); end
  def n_sym?(node); end
end

module Unparser::RequireBlock
  private

  def require_block; end
end

class Unparser::UnknownNodeError < ::ArgumentError; end

class Unparser::Validation
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def generated_node; end
  def generated_source; end
  def identification; end
  def original_node; end
  def original_source; end
  def report(&block); end
  def success?; end

  private

  def make_report(label, attribute_name); end
  def node_diff_report; end
  def report_exception(exception); end

  class << self
    def anima; end
    def from_node(original_node); end
    def from_path(path); end
    def from_string(original_source); end

    private

    def const_unit(_value); end
  end
end

class Unparser::Validation::Literal < ::Unparser::Validation
  def report; end
  def success?; end

  private

  def source_diff_report; end
end

module Unparser::Writer
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  mixes_in_class_methods ::Unparser::DSL

  class << self
    def included(descendant); end
  end
end

class Unparser::Writer::Binary
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_operator; end
  def local_variable_scope; end
  def node; end
  def symbol_name; end

  private

  def effective_symbol; end
  def emit_with(map); end
  def keyword_symbol; end
  def left; end
  def left_emitter(&block); end
  def operator_symbol; end
  def remaining_children; end
  def right; end
  def right_emitter(&block); end

  class << self
    def anima; end
  end
end

Unparser::Writer::Binary::KEYWORD_SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::KEYWORD_TOKENS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::MAP = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::NEED_KEYWORD = T.let(T.unsafe(nil), Array)
Unparser::Writer::Binary::OPERATOR_SYMBOLS = T.let(T.unsafe(nil), Hash)
Unparser::Writer::Binary::OPERATOR_TOKENS = T.let(T.unsafe(nil), Hash)

class Unparser::Writer::DynamicString
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_heredoc_reminder; end
  def local_variable_scope; end
  def node; end

  private

  def breakpoint?(child, current); end
  def classify(node); end
  def classify_str(node); end
  def emit_body(children); end
  def emit_dstr; end
  def emit_dynamic(child); end
  def emit_dynamic_component(node); end
  def emit_heredoc_body; end
  def emit_heredoc_footer; end
  def emit_heredoc_header; end
  def emit_normal_heredoc_body; end
  def emit_segment(children, index); end
  def emit_squiggly_heredoc_body; end
  def escape_dynamic(string); end
  def heredoc?; end
  def heredoc_header; end
  def heredoc_pattern?; end
  def heredoc_pattern_2?; end
  def heredoc_pattern_3?; end
  def nl_last_child?; end
  def segments; end
  def str_empty?(node); end
  def str_nl?(node); end
  def str_ws?(node); end

  class << self
    def anima; end
  end
end

Unparser::Writer::DynamicString::FLAT_INTERPOLATION = T.let(T.unsafe(nil), Set)
Unparser::Writer::DynamicString::PATTERNS_2 = T.let(T.unsafe(nil), Array)
Unparser::Writer::DynamicString::PATTERNS_3 = T.let(T.unsafe(nil), Array)

class Unparser::Writer::Resbody
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def emit_postcontrol; end
  def emit_regular; end
  def local_variable_scope; end
  def node; end

  private

  def assignment; end
  def body; end
  def emit_assignment; end
  def emit_exception; end
  def exception; end
  def remaining_children; end

  class << self
    def anima; end
  end
end

class Unparser::Writer::Rescue
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def emit_heredoc_reminders; end
  def emit_postcontrol; end
  def emit_regular; end
  def local_variable_scope; end
  def node; end

  private

  def body; end
  def else_node; end
  def emit_rescue_body(node); end
  def remaining_children; end
  def rescue_bodies(&block); end
  def rescue_body; end

  class << self
    def anima; end
  end
end

class Unparser::Writer::Send
  include ::Unparser::NodeHelpers
  include ::Unparser::Generation
  include ::Unparser::Constants
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Writer
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::DSL

  def buffer; end
  def comments; end
  def dispatch; end
  def emit_heredoc_reminders; end
  def emit_mlhs; end
  def emit_selector; end
  def local_variable_scope; end
  def node; end

  private

  def arguments; end
  def avoid_clash?; end
  def details(&block); end
  def effective_writer(&block); end
  def effective_writer_class; end
  def emit_arguments; end
  def emit_heredoc_reminder(argument); end
  def emit_normal_arguments; end
  def emit_operator; end
  def emit_send_regular(node); end
  def local_variable_clash?; end
  def parses_as_constant?; end
  def receiver; end
  def remaining_children; end
  def selector; end
  def write_as_attribute_assignment?; end

  class << self
    def anima; end
  end
end

class Unparser::Writer::Send::AttributeAssignment < ::Unparser::Writer::Send
  def dispatch; end
  def emit_send_mlhs; end

  private

  def emit_attribute; end
  def emit_receiver; end
  def first_argument; end
  def receiver; end
  def remaining_children; end
  def selector; end
end

class Unparser::Writer::Send::Binary < ::Unparser::Writer::Send
  def dispatch; end

  private

  def emit_operator; end
  def emit_right; end
end

Unparser::Writer::Send::INDEX_ASSIGN = T.let(T.unsafe(nil), Symbol)
Unparser::Writer::Send::INDEX_REFERENCE = T.let(T.unsafe(nil), Symbol)
Unparser::Writer::Send::OPERATORS = T.let(T.unsafe(nil), Hash)

class Unparser::Writer::Send::Regular < ::Unparser::Writer::Send
  def dispatch; end
  def emit_arguments_without_heredoc_body; end
  def emit_receiver; end
  def emit_send_mlhs; end
end

class Unparser::Writer::Send::Unary < ::Unparser::Writer::Send
  def dispatch; end
end

Unparser::Writer::Send::Unary::MAP = T.let(T.unsafe(nil), Hash)
