# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `psych` gem.
# Please instead update this file by running `bin/tapioca gem psych`.


# pkg:gem/psych#lib/psych/core_ext.rb:2
class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  # call-seq: to_yaml(options = {})
  #
  # Convert an object to YAML.  See Psych.dump for more information on the
  # available +options+.
  #
  # pkg:gem/psych#lib/psych/core_ext.rb:12
  def to_yaml(options = T.unsafe(nil)); end

  class << self
    # pkg:gem/psych#lib/psych/core_ext.rb:3
    def yaml_tag(url); end
  end
end

# = Overview
#
# Psych is a YAML parser and emitter.
# Psych leverages libyaml [Home page: https://pyyaml.org/wiki/LibYAML]
# or [git repo: https://github.com/yaml/libyaml] for its YAML parsing
# and emitting capabilities. In addition to wrapping libyaml, Psych also
# knows how to serialize and de-serialize most Ruby objects to and from
# the YAML format.
#
# = I NEED TO PARSE OR EMIT YAML RIGHT NOW!
#
#   # Parse some YAML
#   Psych.load("--- foo") # => "foo"
#
#   # Emit some YAML
#   Psych.dump("foo")     # => "--- foo\n...\n"
#   { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
#
# Got more time on your hands?  Keep on reading!
#
# == YAML Parsing
#
# Psych provides a range of interfaces for parsing a YAML document ranging from
# low level to high level, depending on your parsing needs.  At the lowest
# level, is an event based parser.  Mid level is access to the raw YAML AST,
# and at the highest level is the ability to unmarshal YAML to Ruby objects.
#
# == YAML Emitting
#
# Psych provides a range of interfaces ranging from low to high level for
# producing YAML documents.  Very similar to the YAML parsing interfaces, Psych
# provides at the lowest level, an event based system, mid-level is building
# a YAML AST, and the highest level is converting a Ruby object straight to
# a YAML document.
#
# == High-level API
#
# === Parsing
#
# The high level YAML parser provided by Psych simply takes YAML as input and
# returns a Ruby data structure.  For information on using the high level parser
# see Psych.load
#
# ==== Reading from a string
#
#   Psych.safe_load("--- a")             # => 'a'
#   Psych.safe_load("---\n - a\n - b")   # => ['a', 'b']
#   # From a trusted string:
#   Psych.load("--- !ruby/range\nbegin: 0\nend: 42\nexcl: false\n") # => 0..42
#
# ==== Reading from a file
#
#   Psych.safe_load_file("data.yml", permitted_classes: [Date])
#   Psych.load_file("trusted_database.yml")
#
# ==== \Exception handling
#
#   begin
#     # The second argument changes only the exception contents
#     Psych.parse("--- `", "file.txt")
#   rescue Psych::SyntaxError => ex
#     ex.file    # => 'file.txt'
#     ex.message # => "(file.txt): found character that cannot start any token"
#   end
#
# === Emitting
#
# The high level emitter has the easiest interface.  Psych simply takes a Ruby
# data structure and converts it to a YAML document.  See Psych.dump for more
# information on dumping a Ruby data structure.
#
# ==== Writing to a string
#
#   # Dump an array, get back a YAML string
#   Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
#
#   # Dump an array to an IO object
#   Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
#
#   # Dump an array with indentation set
#   Psych.dump(['a', ['b']], :indentation => 3) # => "---\n- a\n-  - b\n"
#
#   # Dump an array to an IO with indentation set
#   Psych.dump(['a', ['b']], StringIO.new, :indentation => 3)
#
# ==== Writing to a file
#
# Currently there is no direct API for dumping Ruby structure to file:
#
#   File.open('database.yml', 'w') do |file|
#     file.write(Psych.dump(['a', 'b']))
#   end
#
# == Mid-level API
#
# === Parsing
#
# Psych provides access to an AST produced from parsing a YAML document.  This
# tree is built using the Psych::Parser and Psych::TreeBuilder.  The AST can
# be examined and manipulated freely.  Please see Psych::parse_stream,
# Psych::Nodes, and Psych::Nodes::Node for more information on dealing with
# YAML syntax trees.
#
# ==== Reading from a string
#
#   # Returns Psych::Nodes::Stream
#   Psych.parse_stream("---\n - a\n - b")
#
#   # Returns Psych::Nodes::Document
#   Psych.parse("---\n - a\n - b")
#
# ==== Reading from a file
#
#   # Returns Psych::Nodes::Stream
#   Psych.parse_stream(File.read('database.yml'))
#
#   # Returns Psych::Nodes::Document
#   Psych.parse_file('database.yml')
#
# ==== \Exception handling
#
#   begin
#     # The second argument changes only the exception contents
#     Psych.parse("--- `", "file.txt")
#   rescue Psych::SyntaxError => ex
#     ex.file    # => 'file.txt'
#     ex.message # => "(file.txt): found character that cannot start any token"
#   end
#
# === Emitting
#
# At the mid level is building an AST.  This AST is exactly the same as the AST
# used when parsing a YAML document.  Users can build an AST by hand and the
# AST knows how to emit itself as a YAML document.  See Psych::Nodes,
# Psych::Nodes::Node, and Psych::TreeBuilder for more information on building
# a YAML AST.
#
# ==== Writing to a string
#
#   # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#   stream = Psych.parse_stream("---\n - a\n - b")
#
#   stream.to_yaml # => "---\n- a\n- b\n"
#
# ==== Writing to a file
#
#   # We need Psych::Nodes::Stream (not Psych::Nodes::Document)
#   stream = Psych.parse_stream(File.read('database.yml'))
#
#   File.open('database.yml', 'w') do |file|
#     file.write(stream.to_yaml)
#   end
#
# == Low-level API
#
# === Parsing
#
# The lowest level parser should be used when the YAML input is already known,
# and the developer does not want to pay the price of building an AST or
# automatic detection and conversion to Ruby objects.  See Psych::Parser for
# more information on using the event based parser.
#
# ==== Reading to Psych::Nodes::Stream structure
#
#   parser = Psych::Parser.new(TreeBuilder.new) # => #<Psych::Parser>
#   parser = Psych.parser                       # it's an alias for the above
#
#   parser.parse("---\n - a\n - b")             # => #<Psych::Parser>
#   parser.handler                              # => #<Psych::TreeBuilder>
#   parser.handler.root                         # => #<Psych::Nodes::Stream>
#
# ==== Receiving an events stream
#
#   recorder = Psych::Handlers::Recorder.new
#   parser = Psych::Parser.new(recorder)
#
#   parser.parse("---\n - a\n - b")
#   recorder.events # => [list of [event, args] lists]
#                   # event is one of: Psych::Handler::EVENTS
#                   # args are the arguments passed to the event
#
# === Emitting
#
# The lowest level emitter is an event based system.  Events are sent to a
# Psych::Emitter object.  That object knows how to convert the events to a YAML
# document.  This interface should be used when document format is known in
# advance or speed is a concern.  See Psych::Emitter for more information.
#
# ==== Writing to a Ruby structure
#
#   Psych.parser.parse("--- a")       # => #<Psych::Parser>
#
#   parser.handler.first              # => #<Psych::Nodes::Stream>
#   parser.handler.first.to_ruby      # => ["a"]
#
#   parser.handler.root.first         # => #<Psych::Nodes::Document>
#   parser.handler.root.first.to_ruby # => "a"
#
#   # You can instantiate an Emitter manually
#   Psych::Visitors::ToRuby.new.accept(parser.handler.root.first)
#   # => "a"
#
# pkg:gem/psych#lib/psych/versions.rb:3
module Psych
  class << self
    # pkg:gem/psych#lib/psych.rb:729
    def add_builtin_type(type_tag, &block); end

    # :stopdoc:
    #
    # pkg:gem/psych#lib/psych.rb:723
    def add_domain_type(domain, type_tag, &block); end

    # pkg:gem/psych#lib/psych.rb:739
    def add_tag(tag, klass); end

    # pkg:gem/psych#lib/psych.rb:755
    def config; end

    # pkg:gem/psych#lib/psych.rb:767
    def domain_types; end

    # pkg:gem/psych#lib/psych.rb:779
    def domain_types=(value); end

    # call-seq:
    #   Psych.dump(o)               -> string of yaml
    #   Psych.dump(o, options)      -> string of yaml
    #   Psych.dump(o, io)           -> io object passed in
    #   Psych.dump(o, io, options)  -> io object passed in
    #
    # Dump Ruby object +o+ to a YAML string.  Optional +options+ may be passed in
    # to control the output format.  If an IO object is passed in, the YAML will
    # be dumped to that IO object.
    #
    # Currently supported options are:
    #
    # [<tt>:indentation</tt>]   Number of space characters used to indent.
    #                           Acceptable value should be in <tt>0..9</tt> range,
    #                           otherwise option is ignored.
    #
    #                           Default: <tt>2</tt>.
    # [<tt>:line_width</tt>]    Max character to wrap line at.
    #                           For unlimited line width use <tt>-1</tt>.
    #
    #                           Default: <tt>0</tt> (meaning "wrap at 81").
    # [<tt>:canonical</tt>]     Write "canonical" YAML form (very verbose, yet
    #                           strictly formal).
    #
    #                           Default: <tt>false</tt>.
    # [<tt>:header</tt>]        Write <tt>%YAML [version]</tt> at the beginning of document.
    #
    #                           Default: <tt>false</tt>.
    #
    # [<tt>:stringify_names</tt>] Dump symbol keys in Hash objects as string.
    #
    #                             Default: <tt>false</tt>.
    #
    # Example:
    #
    #   # Dump an array, get back a YAML string
    #   Psych.dump(['a', 'b'])  # => "---\n- a\n- b\n"
    #
    #   # Dump an array to an IO object
    #   Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
    #
    #   # Dump an array with indentation set
    #   Psych.dump(['a', ['b']], indentation: 3) # => "---\n- a\n-  - b\n"
    #
    #   # Dump an array to an IO with indentation set
    #   Psych.dump(['a', ['b']], StringIO.new, indentation: 3)
    #
    #   # Dump hash with symbol keys as string
    #   Psych.dump({a: "b"}, stringify_names: true) # => "---\na: b\n"
    #
    # pkg:gem/psych#lib/psych.rb:515
    def dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end

    # Dump a list of objects as separate documents to a document stream.
    #
    # Example:
    #
    #   Psych.dump_stream("foo\n  ", {}) # => "--- ! \"foo\\n  \"\n--- {}\n"
    #
    # pkg:gem/psych#lib/psych.rb:613
    def dump_stream(*objects); end

    # pkg:gem/psych#lib/psych.rb:763
    def dump_tags; end

    # pkg:gem/psych#lib/psych.rb:775
    def dump_tags=(value); end

    # pkg:gem/psych#lib/psych.rb:15
    def libyaml_version; end

    # Load +yaml+ in to a Ruby data structure.  If multiple documents are
    # provided, the object contained in the first document will be returned.
    # +filename+ will be used in the exception message if any exception
    # is raised while parsing.  If +yaml+ is empty, it returns
    # the specified +fallback+ return value, which defaults to +nil+.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.load("--- a")             # => 'a'
    #   Psych.load("---\n - a\n - b")   # => ['a', 'b']
    #
    #   begin
    #     Psych.load("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    #
    # Raises a TypeError when `yaml` parameter is NilClass.  This method is
    # similar to `safe_load` except that `Symbol` objects are allowed by default.
    #
    # pkg:gem/psych#lib/psych.rb:369
    def load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

    # Loads the document contained in +filename+.  Returns the yaml contained in
    # +filename+ as a Ruby object, or if the file is empty, it returns
    # the specified +fallback+ return value, which defaults to +nil+.
    # See load for options.
    #
    # pkg:gem/psych#lib/psych.rb:716
    def load_file(filename, **kwargs); end

    # Load multiple documents given in +yaml+.  Returns the parsed documents
    # as a list.  If a block is given, each document will be converted to Ruby
    # and passed to the block during parsing
    #
    # Example:
    #
    #   Psych.load_stream("--- foo\n...\n--- bar\n...") # => ['foo', 'bar']
    #
    #   list = []
    #   Psych.load_stream("--- foo\n...\n--- bar\n...") do |ruby|
    #     list << ruby
    #   end
    #   list # => ['foo', 'bar']
    #
    # pkg:gem/psych#lib/psych.rb:644
    def load_stream(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), **kwargs); end

    # pkg:gem/psych#lib/psych.rb:759
    def load_tags; end

    # pkg:gem/psych#lib/psych.rb:771
    def load_tags=(value); end

    # Parse a YAML string in +yaml+.  Returns the Psych::Nodes::Document.
    # +filename+ is used in the exception message if a Psych::SyntaxError is
    # raised.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.parse("---\n - a\n - b") # => #<Psych::Nodes::Document:0x00>
    #
    #   begin
    #     Psych.parse("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # See Psych::Nodes for more information about YAML AST.
    #
    # pkg:gem/psych#lib/psych.rb:400
    def parse(yaml, filename: T.unsafe(nil)); end

    # Parse a file at +filename+. Returns the Psych::Nodes::Document.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # pkg:gem/psych#lib/psych.rb:412
    def parse_file(filename, fallback: T.unsafe(nil)); end

    # Parse a YAML string in +yaml+.  Returns the Psych::Nodes::Stream.
    # This method can handle multiple YAML documents contained in +yaml+.
    # +filename+ is used in the exception message if a Psych::SyntaxError is
    # raised.
    #
    # If a block is given, a Psych::Nodes::Document node will be yielded to the
    # block as it's being parsed.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.parse_stream("---\n - a\n - b") # => #<Psych::Nodes::Stream:0x00>
    #
    #   Psych.parse_stream("--- a\n--- b") do |node|
    #     node # => #<Psych::Nodes::Document:0x00>
    #   end
    #
    #   begin
    #     Psych.parse_stream("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # Raises a TypeError when NilClass is passed.
    #
    # See Psych::Nodes for more information about YAML AST.
    #
    # pkg:gem/psych#lib/psych.rb:454
    def parse_stream(yaml, filename: T.unsafe(nil), &block); end

    # Returns a default parser
    #
    # pkg:gem/psych#lib/psych.rb:421
    def parser; end

    # pkg:gem/psych#lib/psych.rb:735
    def remove_type(type_tag); end

    # call-seq:
    #   Psych.safe_dump(o)               -> string of yaml
    #   Psych.safe_dump(o, options)      -> string of yaml
    #   Psych.safe_dump(o, io)           -> io object passed in
    #   Psych.safe_dump(o, io, options)  -> io object passed in
    #
    # Safely dump Ruby object +o+ to a YAML string. Optional +options+ may be passed in
    # to control the output format.  If an IO object is passed in, the YAML will
    # be dumped to that IO object. By default, only the following
    # classes are allowed to be serialized:
    #
    # * TrueClass
    # * FalseClass
    # * NilClass
    # * Integer
    # * Float
    # * String
    # * Array
    # * Hash
    #
    # Arbitrary classes can be allowed by adding those classes to the +permitted_classes+
    # keyword argument.  They are additive.  For example, to allow Date serialization:
    #
    #   Psych.safe_dump(yaml, permitted_classes: [Date])
    #
    # Now the Date class can be dumped in addition to the classes listed above.
    #
    # A Psych::DisallowedClass exception will be raised if the object contains a
    # class that isn't in the +permitted_classes+ list.
    #
    # Currently supported options are:
    #
    # [<tt>:indentation</tt>]   Number of space characters used to indent.
    #                           Acceptable value should be in <tt>0..9</tt> range,
    #                           otherwise option is ignored.
    #
    #                           Default: <tt>2</tt>.
    # [<tt>:line_width</tt>]    Max character to wrap line at.
    #                           For unlimited line width use <tt>-1</tt>.
    #
    #                           Default: <tt>0</tt> (meaning "wrap at 81").
    # [<tt>:canonical</tt>]     Write "canonical" YAML form (very verbose, yet
    #                           strictly formal).
    #
    #                           Default: <tt>false</tt>.
    # [<tt>:header</tt>]        Write <tt>%YAML [version]</tt> at the beginning of document.
    #
    #                           Default: <tt>false</tt>.
    #
    # [<tt>:stringify_names</tt>] Dump symbol keys in Hash objects as string.
    #
    #                             Default: <tt>false</tt>.
    #
    # Example:
    #
    #   # Dump an array, get back a YAML string
    #   Psych.safe_dump(['a', 'b'])  # => "---\n- a\n- b\n"
    #
    #   # Dump an array to an IO object
    #   Psych.safe_dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>
    #
    #   # Dump an array with indentation set
    #   Psych.safe_dump(['a', ['b']], indentation: 3) # => "---\n- a\n-  - b\n"
    #
    #   # Dump an array to an IO with indentation set
    #   Psych.safe_dump(['a', ['b']], StringIO.new, indentation: 3)
    #
    #   # Dump hash with symbol keys as string
    #   Psych.dump({a: "b"}, stringify_names: true) # => "---\na: b\n"
    #
    # pkg:gem/psych#lib/psych.rb:596
    def safe_dump(o, io = T.unsafe(nil), options = T.unsafe(nil)); end

    # Safely load the yaml string in +yaml+.  By default, only the following
    # classes are allowed to be deserialized:
    #
    # * TrueClass
    # * FalseClass
    # * NilClass
    # * Integer
    # * Float
    # * String
    # * Array
    # * Hash
    #
    # Recursive data structures are not allowed by default.  Arbitrary classes
    # can be allowed by adding those classes to the +permitted_classes+ keyword argument.  They are
    # additive.  For example, to allow Date deserialization:
    #
    #   Psych.safe_load(yaml, permitted_classes: [Date])
    #
    # Now the Date class can be loaded in addition to the classes listed above.
    #
    # Aliases can be explicitly allowed by changing the +aliases+ keyword argument.
    # For example:
    #
    #   x = []
    #   x << x
    #   yaml = Psych.dump x
    #   Psych.safe_load yaml               # => raises an exception
    #   Psych.safe_load yaml, aliases: true # => loads the aliases
    #
    # A Psych::DisallowedClass exception will be raised if the yaml contains a
    # class that isn't in the +permitted_classes+ list.
    #
    # A Psych::AliasesNotEnabled exception will be raised if the yaml contains aliases
    # but the +aliases+ keyword argument is set to false.
    #
    # +filename+ will be used in the exception message if any exception is raised
    # while parsing.
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.safe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.safe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    #
    # pkg:gem/psych#lib/psych.rb:323
    def safe_load(yaml, permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

    # Safely loads the document contained in +filename+.  Returns the yaml contained in
    # +filename+ as a Ruby object, or if the file is empty, it returns
    # the specified +fallback+ return value, which defaults to +nil+.
    # See safe_load for options.
    #
    # pkg:gem/psych#lib/psych.rb:705
    def safe_load_file(filename, **kwargs); end

    # Load multiple documents given in +yaml+. Returns the parsed documents
    # as a list.
    #
    # Example:
    #
    #   Psych.safe_load_stream("--- foo\n...\n--- bar\n...") # => ['foo', 'bar']
    #
    #   list = []
    #   Psych.safe_load_stream("--- foo\n...\n--- bar\n...") do |ruby|
    #     list << ruby
    #   end
    #   list # => ['foo', 'bar']
    #
    # pkg:gem/psych#lib/psych.rb:671
    def safe_load_stream(yaml, filename: T.unsafe(nil), permitted_classes: T.unsafe(nil), aliases: T.unsafe(nil)); end

    # Dump Ruby +object+ to a JSON string.
    #
    # pkg:gem/psych#lib/psych.rb:623
    def to_json(object); end

    # Load +yaml+ in to a Ruby data structure.  If multiple documents are
    # provided, the object contained in the first document will be returned.
    # +filename+ will be used in the exception message if any exception
    # is raised while parsing.  If +yaml+ is empty, it returns
    # the specified +fallback+ return value, which defaults to +false+.
    #
    # Raises a Psych::SyntaxError when a YAML syntax error is detected.
    #
    # Example:
    #
    #   Psych.unsafe_load("--- a")             # => 'a'
    #   Psych.unsafe_load("---\n - a\n - b")   # => ['a', 'b']
    #
    #   begin
    #     Psych.unsafe_load("--- `", filename: "file.txt")
    #   rescue Psych::SyntaxError => ex
    #     ex.file    # => 'file.txt'
    #     ex.message # => "(file.txt): found character that cannot start any token"
    #   end
    #
    # When the optional +symbolize_names+ keyword argument is set to a
    # true value, returns symbols for keys in Hash objects (default: strings).
    #
    #   Psych.unsafe_load("---\n foo: bar")                         # => {"foo"=>"bar"}
    #   Psych.unsafe_load("---\n foo: bar", symbolize_names: true)  # => {:foo=>"bar"}
    #
    # Raises a TypeError when `yaml` parameter is NilClass
    #
    # NOTE: This method *should not* be used to parse untrusted documents, such as
    # YAML documents that are supplied via user input.  Instead, please use the
    # load method or the safe_load method.
    #
    # pkg:gem/psych#lib/psych.rb:272
    def unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

    # Load the document contained in +filename+.  Returns the yaml contained in
    # +filename+ as a Ruby object, or if the file is empty, it returns
    # the specified +fallback+ return value, which defaults to +false+.
    #
    # NOTE: This method *should not* be used to parse untrusted documents, such as
    # YAML documents that are supplied via user input.  Instead, please use the
    # safe_load_file method.
    #
    # pkg:gem/psych#lib/psych.rb:694
    def unsafe_load_file(filename, **kwargs); end
  end
end

# Subclasses `BadAlias` for backwards compatibility
#
# pkg:gem/psych#lib/psych/exception.rb:10
class Psych::AliasesNotEnabled < ::Psych::BadAlias
  # @return [AliasesNotEnabled] a new instance of AliasesNotEnabled
  #
  # pkg:gem/psych#lib/psych/exception.rb:11
  def initialize; end
end

# Subclasses `BadAlias` for backwards compatibility
#
# pkg:gem/psych#lib/psych/exception.rb:17
class Psych::AnchorNotDefined < ::Psych::BadAlias
  # @return [AnchorNotDefined] a new instance of AnchorNotDefined
  #
  # pkg:gem/psych#lib/psych/exception.rb:18
  def initialize(anchor_name); end
end

# pkg:gem/psych#lib/psych.rb:15
class Psych::ClassLoader
  # @return [ClassLoader] a new instance of ClassLoader
  #
  # pkg:gem/psych#lib/psych/class_loader.rb:22
  def initialize; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def big_decimal; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def complex; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def data; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def date; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def date_time; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def exception; end

  # pkg:gem/psych#lib/psych/class_loader.rb:26
  def load(klassname); end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def object; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def psych_omap; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def psych_set; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def range; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def rational; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def regexp; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def struct; end

  # pkg:gem/psych#lib/psych/class_loader.rb:39
  def symbol; end

  # pkg:gem/psych#lib/psych/class_loader.rb:32
  def symbolize(sym); end

  private

  # pkg:gem/psych#lib/psych/class_loader.rb:48
  def find(klassname); end

  # pkg:gem/psych#lib/psych.rb:15
  def path2class(_arg0); end

  # pkg:gem/psych#lib/psych/class_loader.rb:52
  def resolve(klassname); end
end

# pkg:gem/psych#lib/psych/class_loader.rb:9
Psych::ClassLoader::DATA = T.let(T.unsafe(nil), String)

# pkg:gem/psych#lib/psych/class_loader.rb:77
class Psych::ClassLoader::Restricted < ::Psych::ClassLoader
  # @return [Restricted] a new instance of Restricted
  #
  # pkg:gem/psych#lib/psych/class_loader.rb:78
  def initialize(classes, symbols); end

  # pkg:gem/psych#lib/psych/class_loader.rb:84
  def symbolize(sym); end

  private

  # pkg:gem/psych#lib/psych/class_loader.rb:96
  def find(klassname); end
end

# If an object defines +encode_with+, then an instance of Psych::Coder will
# be passed to the method when the object is being serialized.  The Coder
# automatically assumes a Psych::Nodes::Mapping is being emitted.  Other
# objects like Sequence and Scalar may be emitted if +seq=+ or +scalar=+ are
# called, respectively.
#
# pkg:gem/psych#lib/psych/coder.rb:9
class Psych::Coder
  # @return [Coder] a new instance of Coder
  #
  # pkg:gem/psych#lib/psych/coder.rb:13
  def initialize(tag); end

  # pkg:gem/psych#lib/psych/coder.rb:84
  def [](k); end

  # pkg:gem/psych#lib/psych/coder.rb:78
  def []=(k, v); end

  # pkg:gem/psych#lib/psych/coder.rb:82
  def add(k, v); end

  # Returns the value of attribute implicit.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def implicit; end

  # Sets the attribute implicit
  #
  # @param value the value to set the attribute implicit to.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def implicit=(_arg0); end

  # Emit a map.  The coder will be yielded to the block.
  #
  # @yield [_self]
  # @yieldparam _self [Psych::Coder] the object that the method was called on
  #
  # pkg:gem/psych#lib/psych/coder.rb:34
  def map(tag = T.unsafe(nil), style = T.unsafe(nil)); end

  # Emit a map with +value+
  #
  # pkg:gem/psych#lib/psych/coder.rb:73
  def map=(map); end

  # Returns the value of attribute object.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def object; end

  # Sets the attribute object
  #
  # @param value the value to set the attribute object to.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def object=(_arg0); end

  # Emit a sequence with +map+ and +tag+
  #
  # pkg:gem/psych#lib/psych/coder.rb:54
  def represent_map(tag, map); end

  # Emit an arbitrary object +obj+ and +tag+
  #
  # pkg:gem/psych#lib/psych/coder.rb:60
  def represent_object(tag, obj); end

  # Emit a scalar with +value+ and +tag+
  #
  # pkg:gem/psych#lib/psych/coder.rb:42
  def represent_scalar(tag, value); end

  # Emit a sequence with +list+ and +tag+
  #
  # pkg:gem/psych#lib/psych/coder.rb:48
  def represent_seq(tag, list); end

  # pkg:gem/psych#lib/psych/coder.rb:24
  def scalar(*args); end

  # Emit a scalar with +value+
  #
  # pkg:gem/psych#lib/psych/coder.rb:67
  def scalar=(value); end

  # Returns the value of attribute seq.
  #
  # pkg:gem/psych#lib/psych/coder.rb:11
  def seq; end

  # Emit a sequence of +list+
  #
  # pkg:gem/psych#lib/psych/coder.rb:90
  def seq=(list); end

  # Returns the value of attribute style.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def style; end

  # Sets the attribute style
  #
  # @param value the value to set the attribute style to.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def style=(_arg0); end

  # Returns the value of attribute tag.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def tag; end

  # Sets the attribute tag
  #
  # @param value the value to set the attribute tag to.
  #
  # pkg:gem/psych#lib/psych/coder.rb:10
  def tag=(_arg0); end

  # Returns the value of attribute type.
  #
  # pkg:gem/psych#lib/psych/coder.rb:11
  def type; end
end

# pkg:gem/psych#lib/psych/exception.rb:23
class Psych::DisallowedClass < ::Psych::Exception
  # @return [DisallowedClass] a new instance of DisallowedClass
  #
  # pkg:gem/psych#lib/psych/exception.rb:24
  def initialize(action, klass_name); end
end

# pkg:gem/psych#lib/psych.rb:15
class Psych::Emitter < ::Psych::Handler
  # pkg:gem/psych#lib/psych.rb:15
  def initialize(*_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def alias(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def canonical; end

  # pkg:gem/psych#lib/psych.rb:15
  def canonical=(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def end_document(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def end_mapping; end

  # pkg:gem/psych#lib/psych.rb:15
  def end_sequence; end

  # pkg:gem/psych#lib/psych.rb:15
  def end_stream; end

  # pkg:gem/psych#lib/psych.rb:15
  def indentation; end

  # pkg:gem/psych#lib/psych.rb:15
  def indentation=(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def line_width; end

  # pkg:gem/psych#lib/psych.rb:15
  def line_width=(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def scalar(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end

  # pkg:gem/psych#lib/psych.rb:15
  def start_document(_arg0, _arg1, _arg2); end

  # pkg:gem/psych#lib/psych.rb:15
  def start_mapping(_arg0, _arg1, _arg2, _arg3); end

  # pkg:gem/psych#lib/psych.rb:15
  def start_sequence(_arg0, _arg1, _arg2, _arg3); end

  # pkg:gem/psych#lib/psych.rb:15
  def start_stream(_arg0); end
end

# Psych::Handler is an abstract base class that defines the events used
# when dealing with Psych::Parser.  Clients who want to use Psych::Parser
# should implement a class that inherits from Psych::Handler and define
# events that they can handle.
#
# Psych::Handler defines all events that Psych::Parser can possibly send to
# event handlers.
#
# See Psych::Parser for more details
#
# pkg:gem/psych#lib/psych.rb:15
class Psych::Handler
  # Called when an alias is found to +anchor+.  +anchor+ will be the name
  # of the anchor found.
  #
  # === Example
  #
  # Here we have an example of an array that references itself in YAML:
  #
  #   --- &ponies
  #   - first element
  #   - *ponies
  #
  # &ponies is the anchor, *ponies is the alias.  In this case, alias is
  # called with "ponies".
  #
  # pkg:gem/psych#lib/psych/handler.rb:110
  def alias(anchor); end

  # Called when an empty event happens. (Which, as far as I can tell, is
  # never).
  #
  # pkg:gem/psych#lib/psych/handler.rb:236
  def empty; end

  # Called with the document ends.  +implicit+ is a boolean value indicating
  # whether or not the document has an implicit ending.
  #
  # === Example
  #
  # Given the following YAML:
  #
  #   ---
  #     hello world
  #
  # +implicit+ will be true.  Given this YAML:
  #
  #   ---
  #     hello world
  #   ...
  #
  # +implicit+ will be false.
  #
  # pkg:gem/psych#lib/psych/handler.rb:93
  def end_document(implicit); end

  # Called when a map ends
  #
  # pkg:gem/psych#lib/psych/handler.rb:230
  def end_mapping; end

  # Called when a sequence ends.
  #
  # pkg:gem/psych#lib/psych/handler.rb:191
  def end_sequence; end

  # Called when the YAML stream ends
  #
  # pkg:gem/psych#lib/psych/handler.rb:241
  def end_stream; end

  # Called before each event with line/column information.
  #
  # pkg:gem/psych#lib/psych/handler.rb:246
  def event_location(start_line, start_column, end_line, end_column); end

  # Called when a scalar +value+ is found.  The scalar may have an
  # +anchor+, a +tag+, be implicitly +plain+ or implicitly +quoted+
  #
  # +value+ is the string value of the scalar
  # +anchor+ is an associated anchor or nil
  # +tag+ is an associated tag or nil
  # +plain+ is a boolean value
  # +quoted+ is a boolean value
  # +style+ is an integer indicating the string style
  #
  # See the constants in Psych::Nodes::Scalar for the possible values of
  # +style+
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   - !str "foo"
  #   - &anchor fun
  #   - many
  #     lines
  #   - |
  #     many
  #     newlines
  #
  # The above YAML document contains a list with four strings.  Here are
  # the parameters sent to this method in the same order:
  #
  #   # value               anchor    tag     plain   quoted  style
  #   ["foo",               nil,      "!str", false,  false,  3    ]
  #   ["fun",               "anchor", nil,    true,   false,  1    ]
  #   ["many lines",        nil,      nil,    true,   false,  1    ]
  #   ["many\nnewlines\n",  nil,      nil,    false,  true,   4    ]
  #
  # pkg:gem/psych#lib/psych/handler.rb:150
  def scalar(value, anchor, tag, plain, quoted, style); end

  # Called when the document starts with the declared +version+,
  # +tag_directives+, if the document is +implicit+.
  #
  # +version+ will be an array of integers indicating the YAML version being
  # dealt with, +tag_directives+ is a list of tuples indicating the prefix
  # and suffix of each tag, and +implicit+ is a boolean indicating whether
  # the document is started implicitly.
  #
  # === Example
  #
  # Given the following YAML:
  #
  #   %YAML 1.1
  #   %TAG ! tag:tenderlovemaking.com,2009:
  #   --- !squee
  #
  # The parameters for start_document must be this:
  #
  #   version         # => [1, 1]
  #   tag_directives  # => [["!", "tag:tenderlovemaking.com,2009:"]]
  #   implicit        # => false
  #
  # pkg:gem/psych#lib/psych/handler.rb:72
  def start_document(version, tag_directives, implicit); end

  # Called when a map starts.
  #
  # +anchor+ is the anchor associated with the map or +nil+.
  # +tag+ is the tag associated with the map or +nil+.
  # +implicit+ is a boolean indicating whether or not the map was implicitly
  # started.
  # +style+ is an integer indicating the mapping style.
  #
  # See the constants in Psych::Nodes::Mapping for the possible values of
  # +style+.
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   k: !!map { hello: world }
  #   v: &pewpew
  #     hello: world
  #
  # The above YAML document consists of three maps, an outer map that contains
  # two inner maps.  Below is a matrix of the parameters sent in order to
  # represent these three maps:
  #
  #   # anchor    tag                       implicit  style
  #   [nil,       nil,                      true,     1     ]
  #   [nil,       "tag:yaml.org,2002:map",  false,    2     ]
  #   ["pewpew",  nil,                      true,     1     ]
  #
  # pkg:gem/psych#lib/psych/handler.rb:225
  def start_mapping(anchor, tag, implicit, style); end

  # Called when a sequence is started.
  #
  # +anchor+ is the anchor associated with the sequence or nil.
  # +tag+ is the tag associated with the sequence or nil.
  # +implicit+ a boolean indicating whether or not the sequence was implicitly
  # started.
  # +style+ is an integer indicating the list style.
  #
  # See the constants in Psych::Nodes::Sequence for the possible values of
  # +style+.
  #
  # === Example
  #
  # Here is a YAML document that exercises most of the possible ways this
  # method can be called:
  #
  #   ---
  #   - !!seq [
  #     a
  #   ]
  #   - &pewpew
  #     - b
  #
  # The above YAML document consists of three lists, an outer list that
  # contains two inner lists.  Here is a matrix of the parameters sent
  # to represent these lists:
  #
  #   # anchor    tag                       implicit  style
  #   [nil,       nil,                      true,     1     ]
  #   [nil,       "tag:yaml.org,2002:seq",  false,    2     ]
  #   ["pewpew",  nil,                      true,     1     ]
  #
  # pkg:gem/psych#lib/psych/handler.rb:186
  def start_sequence(anchor, tag, implicit, style); end

  # Called with +encoding+ when the YAML stream starts.  This method is
  # called once per stream.  A stream may contain multiple documents.
  #
  # See the constants in Psych::Parser for the possible values of +encoding+.
  #
  # pkg:gem/psych#lib/psych/handler.rb:47
  def start_stream(encoding); end

  # Is this handler a streaming handler?
  #
  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/handler.rb:251
  def streaming?; end
end

# Configuration options for dumping YAML.
#
# pkg:gem/psych#lib/psych/handler.rb:16
class Psych::Handler::DumperOptions
  # @return [DumperOptions] a new instance of DumperOptions
  #
  # pkg:gem/psych#lib/psych/handler.rb:19
  def initialize; end

  # Returns the value of attribute canonical.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def canonical; end

  # Sets the attribute canonical
  #
  # @param value the value to set the attribute canonical to.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def canonical=(_arg0); end

  # Returns the value of attribute indentation.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def indentation; end

  # Sets the attribute indentation
  #
  # @param value the value to set the attribute indentation to.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def indentation=(_arg0); end

  # Returns the value of attribute line_width.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def line_width; end

  # Sets the attribute line_width
  #
  # @param value the value to set the attribute line_width to.
  #
  # pkg:gem/psych#lib/psych/handler.rb:17
  def line_width=(_arg0); end
end

# pkg:gem/psych#lib/psych/handlers/document_stream.rb:6
class Psych::Handlers::DocumentStream < ::Psych::TreeBuilder
  # @return [DocumentStream] a new instance of DocumentStream
  #
  # pkg:gem/psych#lib/psych/handlers/document_stream.rb:7
  def initialize(&block); end

  # pkg:gem/psych#lib/psych/handlers/document_stream.rb:17
  def end_document(implicit_end = T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/handlers/document_stream.rb:12
  def start_document(version, tag_directives, implicit); end
end

# pkg:gem/psych#lib/psych/json/ruby_events.rb:4
module Psych::JSON::RubyEvents
  # pkg:gem/psych#lib/psych/json/ruby_events.rb:10
  def visit_DateTime(o); end

  # pkg:gem/psych#lib/psych/json/ruby_events.rb:14
  def visit_String(o); end

  # pkg:gem/psych#lib/psych/json/ruby_events.rb:17
  def visit_Symbol(o); end

  # pkg:gem/psych#lib/psych/json/ruby_events.rb:5
  def visit_Time(o); end
end

# pkg:gem/psych#lib/psych/json/stream.rb:7
class Psych::JSON::Stream < ::Psych::Visitors::JSONTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

# pkg:gem/psych#lib/psych/json/stream.rb:12
class Psych::JSON::Stream::Emitter < ::Psych::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

# Psych::JSON::TreeBuilder is an event based AST builder.  Events are sent
# to an instance of Psych::JSON::TreeBuilder and a JSON AST is constructed.
#
# pkg:gem/psych#lib/psych/json/tree_builder.rb:9
class Psych::JSON::TreeBuilder < ::Psych::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

# pkg:gem/psych#lib/psych/json/yaml_events.rb:4
module Psych::JSON::YAMLEvents
  # pkg:gem/psych#lib/psych/json/yaml_events.rb:9
  def end_document(implicit_end = T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/json/yaml_events.rb:21
  def scalar(value, anchor, tag, plain, quoted, style); end

  # pkg:gem/psych#lib/psych/json/yaml_events.rb:5
  def start_document(version, tag_directives, implicit); end

  # pkg:gem/psych#lib/psych/json/yaml_events.rb:13
  def start_mapping(anchor, tag, implicit, style); end

  # pkg:gem/psych#lib/psych/json/yaml_events.rb:17
  def start_sequence(anchor, tag, implicit, style); end
end

# This class represents a {YAML Alias}[http://yaml.org/spec/1.1/#alias].
# It points to an +anchor+.
#
# A Psych::Nodes::Alias is a terminal node and may have no children.
#
# pkg:gem/psych#lib/psych/nodes/alias.rb:9
class Psych::Nodes::Alias < ::Psych::Nodes::Node
  # Create a new Alias that points to an +anchor+
  #
  # @return [Alias] a new instance of Alias
  #
  # pkg:gem/psych#lib/psych/nodes/alias.rb:14
  def initialize(anchor); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/alias.rb:18
  def alias?; end

  # The anchor this alias links to
  #
  # pkg:gem/psych#lib/psych/nodes/alias.rb:11
  def anchor; end

  # The anchor this alias links to
  #
  # pkg:gem/psych#lib/psych/nodes/alias.rb:11
  def anchor=(_arg0); end
end

# This represents a YAML Document.  This node must be a child of
# Psych::Nodes::Stream.  A Psych::Nodes::Document must have one child,
# and that child may be one of the following:
#
# * Psych::Nodes::Sequence
# * Psych::Nodes::Mapping
# * Psych::Nodes::Scalar
#
# pkg:gem/psych#lib/psych/nodes/document.rb:12
class Psych::Nodes::Document < ::Psych::Nodes::Node
  # Create a new Psych::Nodes::Document object.
  #
  # +version+ is a list indicating the YAML version.
  # +tags_directives+ is a list of tag directive declarations
  # +implicit+ is a flag indicating whether the document will be implicitly
  # started.
  #
  # == Example:
  # This creates a YAML document object that represents a YAML 1.1 document
  # with one tag directive, and has an implicit start:
  #
  #   Psych::Nodes::Document.new(
  #     [1,1],
  #     [["!", "tag:tenderlovemaking.com,2009:"]],
  #     true
  #   )
  #
  # == See Also
  # See also Psych::Handler#start_document
  #
  # @return [Document] a new instance of Document
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:45
  def initialize(version = T.unsafe(nil), tag_directives = T.unsafe(nil), implicit = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:60
  def document?; end

  # Was this document implicitly created?
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:20
  def implicit; end

  # Was this document implicitly created?
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:20
  def implicit=(_arg0); end

  # Is the end of the document implicit?
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:23
  def implicit_end; end

  # Is the end of the document implicit?
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:23
  def implicit_end=(_arg0); end

  # Returns the root node.  A Document may only have one root node:
  # http://yaml.org/spec/1.1/#id898031
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:56
  def root; end

  # A list of tag directives for this document
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:17
  def tag_directives; end

  # A list of tag directives for this document
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:17
  def tag_directives=(_arg0); end

  # The version of the YAML document
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:14
  def version; end

  # The version of the YAML document
  #
  # pkg:gem/psych#lib/psych/nodes/document.rb:14
  def version=(_arg0); end
end

# This class represents a {YAML Mapping}[http://yaml.org/spec/1.1/#mapping].
#
# A Psych::Nodes::Mapping node may have 0 or more children, but must have
# an even number of children.  Here are the valid children a
# Psych::Nodes::Mapping node may have:
#
# * Psych::Nodes::Sequence
# * Psych::Nodes::Mapping
# * Psych::Nodes::Scalar
# * Psych::Nodes::Alias
#
# pkg:gem/psych#lib/psych/nodes/mapping.rb:15
class Psych::Nodes::Mapping < ::Psych::Nodes::Node
  # Create a new Psych::Nodes::Mapping object.
  #
  # +anchor+ is the anchor associated with the map or +nil+.
  # +tag+ is the tag associated with the map or +nil+.
  # +implicit+ is a boolean indicating whether or not the map was implicitly
  # started.
  # +style+ is an integer indicating the mapping style.
  #
  # == See Also
  # See also Psych::Handler#start_mapping
  #
  # @return [Mapping] a new instance of Mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:48
  def initialize(anchor = T.unsafe(nil), tag = T.unsafe(nil), implicit = T.unsafe(nil), style = T.unsafe(nil)); end

  # The optional anchor for this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:26
  def anchor; end

  # The optional anchor for this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:26
  def anchor=(_arg0); end

  # Is this an implicit mapping?
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:32
  def implicit; end

  # Is this an implicit mapping?
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:32
  def implicit=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:56
  def mapping?; end

  # The style of this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:35
  def style; end

  # The style of this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:35
  def style=(_arg0); end

  # The optional tag for this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:29
  def tag; end

  # The optional tag for this mapping
  #
  # pkg:gem/psych#lib/psych/nodes/mapping.rb:29
  def tag=(_arg0); end
end

# The base class for any Node in a YAML parse tree.  This class should
# never be instantiated.
#
# pkg:gem/psych#lib/psych/nodes/node.rb:10
class Psych::Nodes::Node
  include ::Enumerable

  # Create a new Psych::Nodes::Node
  #
  # @return [Node] a new instance of Node
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:32
  def initialize; end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:68
  def alias?; end

  # The children of this node
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:14
  def children; end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:69
  def document?; end

  # Iterate over each node in the tree. Yields each node to +block+ depth
  # first.
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:39
  def each(&block); end

  # The column number where this node ends
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:29
  def end_column; end

  # The column number where this node ends
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:29
  def end_column=(_arg0); end

  # The line number where this node ends
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:26
  def end_line; end

  # The line number where this node ends
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:26
  def end_line=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:70
  def mapping?; end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:71
  def scalar?; end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:72
  def sequence?; end

  # The column number where this node start
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:23
  def start_column; end

  # The column number where this node start
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:23
  def start_column=(_arg0); end

  # The line number where this node start
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:20
  def start_line; end

  # The line number where this node start
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:20
  def start_line=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:73
  def stream?; end

  # An associated tag
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:17
  def tag; end

  # Convert this node to Ruby.
  #
  # See also Psych::Visitors::ToRuby
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:48
  def to_ruby(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

  # Convert this node to YAML.
  #
  # See also Psych::Visitors::Emitter
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:66
  def to_yaml(io = T.unsafe(nil), options = T.unsafe(nil)); end

  # Convert this node to Ruby.
  #
  # See also Psych::Visitors::ToRuby
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:51
  def transform(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

  # Convert this node to YAML.
  #
  # See also Psych::Visitors::Emitter
  #
  # pkg:gem/psych#lib/psych/nodes/node.rb:57
  def yaml(io = T.unsafe(nil), options = T.unsafe(nil)); end
end

# This class represents a {YAML Scalar}[http://yaml.org/spec/1.1/#id858081].
#
# This node type is a terminal node and should not have any children.
#
# pkg:gem/psych#lib/psych/nodes/scalar.rb:8
class Psych::Nodes::Scalar < ::Psych::Nodes::Node
  # Create a new Psych::Nodes::Scalar object.
  #
  # +value+ is the string value of the scalar
  # +anchor+ is an associated anchor or nil
  # +tag+ is an associated tag or nil
  # +plain+ is a boolean value
  # +quoted+ is a boolean value
  # +style+ is an integer indicating the string style
  #
  # == See Also
  #
  # See also Psych::Handler#scalar
  #
  # @return [Scalar] a new instance of Scalar
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:58
  def initialize(value, anchor = T.unsafe(nil), tag = T.unsafe(nil), plain = T.unsafe(nil), quoted = T.unsafe(nil), style = T.unsafe(nil)); end

  # The anchor value (if there is one)
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:31
  def anchor; end

  # The anchor value (if there is one)
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:31
  def anchor=(_arg0); end

  # Is this a plain scalar?
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:37
  def plain; end

  # Is this a plain scalar?
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:37
  def plain=(_arg0); end

  # Is this scalar quoted?
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:40
  def quoted; end

  # Is this scalar quoted?
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:40
  def quoted=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:67
  def scalar?; end

  # The style of this scalar
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:43
  def style; end

  # The style of this scalar
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:43
  def style=(_arg0); end

  # The tag value (if there is one)
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:34
  def tag; end

  # The tag value (if there is one)
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:34
  def tag=(_arg0); end

  # The scalar value
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:28
  def value; end

  # The scalar value
  #
  # pkg:gem/psych#lib/psych/nodes/scalar.rb:28
  def value=(_arg0); end
end

# This class represents a
# {YAML sequence}[http://yaml.org/spec/1.1/#sequence/syntax].
#
# A YAML sequence is basically a list, and looks like this:
#
#   %YAML 1.1
#   ---
#   - I am
#   - a Sequence
#
# A YAML sequence may have an anchor like this:
#
#   %YAML 1.1
#   ---
#   &A [
#     "This sequence",
#     "has an anchor"
#   ]
#
# A YAML sequence may also have a tag like this:
#
#   %YAML 1.1
#   ---
#   !!seq [
#     "This sequence",
#     "has a tag"
#   ]
#
# This class represents a sequence in a YAML document.  A
# Psych::Nodes::Sequence node may have 0 or more children.  Valid children
# for this node are:
#
# * Psych::Nodes::Sequence
# * Psych::Nodes::Mapping
# * Psych::Nodes::Scalar
# * Psych::Nodes::Alias
#
# pkg:gem/psych#lib/psych/nodes/sequence.rb:41
class Psych::Nodes::Sequence < ::Psych::Nodes::Node
  # Create a new object representing a YAML sequence.
  #
  # +anchor+ is the anchor associated with the sequence or nil.
  # +tag+ is the tag associated with the sequence or nil.
  # +implicit+ a boolean indicating whether or not the sequence was
  # implicitly started.
  # +style+ is an integer indicating the list style.
  #
  # See Psych::Handler#start_sequence
  #
  # @return [Sequence] a new instance of Sequence
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:73
  def initialize(anchor = T.unsafe(nil), tag = T.unsafe(nil), implicit = T.unsafe(nil), style = T.unsafe(nil)); end

  # The anchor for this sequence (if any)
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:52
  def anchor; end

  # The anchor for this sequence (if any)
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:52
  def anchor=(_arg0); end

  # Is this sequence started implicitly?
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:58
  def implicit; end

  # Is this sequence started implicitly?
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:58
  def implicit=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:81
  def sequence?; end

  # The sequence style used
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:61
  def style; end

  # The sequence style used
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:61
  def style=(_arg0); end

  # The tag name for this sequence (if any)
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:55
  def tag; end

  # The tag name for this sequence (if any)
  #
  # pkg:gem/psych#lib/psych/nodes/sequence.rb:55
  def tag=(_arg0); end
end

# Represents a YAML stream.  This is the root node for any YAML parse
# tree.  This node must have one or more child nodes.  The only valid
# child node for a Psych::Nodes::Stream node is Psych::Nodes::Document.
#
# pkg:gem/psych#lib/psych/nodes/stream.rb:8
class Psych::Nodes::Stream < ::Psych::Nodes::Node
  # Create a new Psych::Nodes::Stream node with an +encoding+ that
  # defaults to Psych::Nodes::Stream::UTF8.
  #
  # See also Psych::Handler#start_stream
  #
  # @return [Stream] a new instance of Stream
  #
  # pkg:gem/psych#lib/psych/nodes/stream.rb:32
  def initialize(encoding = T.unsafe(nil)); end

  # The encoding used for this stream
  #
  # pkg:gem/psych#lib/psych/nodes/stream.rb:25
  def encoding; end

  # The encoding used for this stream
  #
  # pkg:gem/psych#lib/psych/nodes/stream.rb:25
  def encoding=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/nodes/stream.rb:37
  def stream?; end
end

# YAML event parser class.  This class parses a YAML document and calls
# events on the handler that is passed to the constructor.  The events can
# be used for things such as constructing a YAML AST or deserializing YAML
# documents.  It can even be fed back to Psych::Emitter to emit the same
# document that was parsed.
#
# See Psych::Handler for documentation on the events that Psych::Parser emits.
#
# Here is an example that prints out ever scalar found in a YAML document:
#
#   # Handler for detecting scalar values
#   class ScalarHandler < Psych::Handler
#     def scalar value, anchor, tag, plain, quoted, style
#       puts value
#     end
#   end
#
#   parser = Psych::Parser.new(ScalarHandler.new)
#   parser.parse(yaml_document)
#
# Here is an example that feeds the parser back in to Psych::Emitter.  The
# YAML document is read from STDIN and written back out to STDERR:
#
#   parser = Psych::Parser.new(Psych::Emitter.new($stderr))
#   parser.parse($stdin)
#
# Psych uses Psych::Parser in combination with Psych::TreeBuilder to
# construct an AST of the parsed YAML document.
#
# pkg:gem/psych#lib/psych.rb:15
class Psych::Parser
  # Creates a new Psych::Parser instance with +handler+.  YAML events will
  # be called on +handler+.  See Psych::Parser for more details.
  #
  # @return [Parser] a new instance of Parser
  #
  # pkg:gem/psych#lib/psych/parser.rb:47
  def initialize(handler = T.unsafe(nil)); end

  # Set the encoding for this parser to +encoding+
  #
  # pkg:gem/psych#lib/psych/parser.rb:41
  def external_encoding=(_arg0); end

  # The handler on which events will be called
  #
  # pkg:gem/psych#lib/psych/parser.rb:38
  def handler; end

  # The handler on which events will be called
  #
  # pkg:gem/psych#lib/psych/parser.rb:38
  def handler=(_arg0); end

  # pkg:gem/psych#lib/psych.rb:15
  def mark; end

  # call-seq:
  #    parser.parse(yaml)
  #
  # Parse the YAML document contained in +yaml+.  Events will be called on
  # the handler set on the parser instance.
  #
  # See Psych::Parser and Psych::Parser#handler
  #
  # pkg:gem/psych#lib/psych/parser.rb:61
  def parse(yaml, path = T.unsafe(nil)); end

  private

  # pkg:gem/psych#lib/psych.rb:15
  def _native_parse(_arg0, _arg1, _arg2); end
end

# Scan scalars for built in types
#
# pkg:gem/psych#lib/psych/scalar_scanner.rb:6
class Psych::ScalarScanner
  # Create a new scanner
  #
  # @return [ScalarScanner] a new instance of ScalarScanner
  #
  # pkg:gem/psych#lib/psych/scalar_scanner.rb:30
  def initialize(class_loader, strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end

  # Returns the value of attribute class_loader.
  #
  # pkg:gem/psych#lib/psych/scalar_scanner.rb:27
  def class_loader; end

  # Parse and return an int from +string+
  #
  # pkg:gem/psych#lib/psych/scalar_scanner.rb:109
  def parse_int(string); end

  # Parse and return a Time from +string+
  #
  # pkg:gem/psych#lib/psych/scalar_scanner.rb:115
  def parse_time(string); end

  # Tokenize +string+ returning the Ruby object
  #
  # pkg:gem/psych#lib/psych/scalar_scanner.rb:38
  def tokenize(string); end
end

# Same as above, but allows commas.
# Not to YML spec, but kept for backwards compatibility
#
# pkg:gem/psych#lib/psych/scalar_scanner.rb:22
Psych::ScalarScanner::INTEGER_LEGACY = T.let(T.unsafe(nil), Regexp)

# Taken from http://yaml.org/type/int.html and modified to ensure at least one numerical symbol exists
#
# pkg:gem/psych#lib/psych/scalar_scanner.rb:15
Psych::ScalarScanner::INTEGER_STRICT = T.let(T.unsafe(nil), Regexp)

# Psych::Stream is a streaming YAML emitter.  It will not buffer your YAML,
# but send it straight to an IO.
#
# Here is an example use:
#
#   stream = Psych::Stream.new($stdout)
#   stream.start
#   stream.push({:foo => 'bar'})
#   stream.finish
#
# YAML will be immediately emitted to $stdout with no buffering.
#
# Psych::Stream#start will take a block and ensure that Psych::Stream#finish
# is called, so you can do this form:
#
#   stream = Psych::Stream.new($stdout)
#   stream.start do |em|
#     em.push(:foo => 'bar')
#   end
#
# pkg:gem/psych#lib/psych/stream.rb:24
class Psych::Stream < ::Psych::Visitors::YAMLTree
  include ::Psych::Streaming
  extend ::Psych::Streaming::ClassMethods
end

# pkg:gem/psych#lib/psych/stream.rb:25
class Psych::Stream::Emitter < ::Psych::Emitter
  # pkg:gem/psych#lib/psych/stream.rb:26
  def end_document(implicit_end = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/stream.rb:30
  def streaming?; end
end

# pkg:gem/psych#lib/psych/streaming.rb:3
module Psych::Streaming
  # Start streaming using +encoding+
  #
  # pkg:gem/psych#lib/psych/streaming.rb:18
  def start(encoding = T.unsafe(nil)); end

  private

  # pkg:gem/psych#lib/psych/streaming.rb:25
  def register(target, obj); end
end

# pkg:gem/psych#lib/psych/streaming.rb:4
module Psych::Streaming::ClassMethods
  # Create a new streaming emitter.  Emitter will print to +io+.  See
  # Psych::Stream for an example.
  #
  # pkg:gem/psych#lib/psych/streaming.rb:8
  def new(io); end
end

# pkg:gem/psych#lib/psych/syntax_error.rb:5
class Psych::SyntaxError < ::Psych::Exception
  # @return [SyntaxError] a new instance of SyntaxError
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:8
  def initialize(file, line, col, offset, problem, context); end

  # Returns the value of attribute column.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def column; end

  # Returns the value of attribute context.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def context; end

  # Returns the value of attribute file.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def file; end

  # Returns the value of attribute line.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def line; end

  # Returns the value of attribute offset.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def offset; end

  # Returns the value of attribute problem.
  #
  # pkg:gem/psych#lib/psych/syntax_error.rb:6
  def problem; end
end

# This class works in conjunction with Psych::Parser to build an in-memory
# parse tree that represents a YAML document.
#
# == Example
#
#   parser = Psych::Parser.new Psych::TreeBuilder.new
#   parser.parse('--- foo')
#   tree = parser.handler.root
#
# See Psych::Handler for documentation on the event methods used in this
# class.
#
# pkg:gem/psych#lib/psych/tree_builder.rb:17
class Psych::TreeBuilder < ::Psych::Handler
  # Create a new TreeBuilder instance
  #
  # @return [TreeBuilder] a new instance of TreeBuilder
  #
  # pkg:gem/psych#lib/psych/tree_builder.rb:22
  def initialize; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:103
  def alias(anchor); end

  # Handles end_document events with +version+, +tag_directives+,
  # and +implicit+ styling.
  #
  # See Psych::Handler#start_document
  #
  # pkg:gem/psych#lib/psych/tree_builder.rb:77
  def end_document(implicit_end = T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:44
  def end_mapping; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:44
  def end_sequence; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:90
  def end_stream; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:33
  def event_location(start_line, start_column, end_line, end_column); end

  # Returns the root node for the built tree
  #
  # pkg:gem/psych#lib/psych/tree_builder.rb:19
  def root; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:96
  def scalar(value, anchor, tag, plain, quoted, style); end

  # Handles start_document events with +version+, +tag_directives+,
  # and +implicit+ styling.
  #
  # See Psych::Handler#start_document
  #
  # pkg:gem/psych#lib/psych/tree_builder.rb:65
  def start_document(version, tag_directives, implicit); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:44
  def start_mapping(anchor, tag, implicit, style); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:44
  def start_sequence(anchor, tag, implicit, style); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:84
  def start_stream(encoding); end

  private

  # pkg:gem/psych#lib/psych/tree_builder.rb:116
  def pop; end

  # pkg:gem/psych#lib/psych/tree_builder.rb:111
  def push(value); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:132
  def set_end_location(node); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:122
  def set_location(node); end

  # pkg:gem/psych#lib/psych/tree_builder.rb:127
  def set_start_location(node); end
end

# The version of Psych you are using
#
# pkg:gem/psych#lib/psych/versions.rb:5
Psych::VERSION = T.let(T.unsafe(nil), String)

# pkg:gem/psych#lib/psych/visitors/depth_first.rb:4
class Psych::Visitors::DepthFirst < ::Psych::Visitors::Visitor
  # @return [DepthFirst] a new instance of DepthFirst
  #
  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:5
  def initialize(block); end

  private

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:11
  def nary(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:20
  def terminal(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:24
  def visit_Psych_Nodes_Alias(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:16
  def visit_Psych_Nodes_Document(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:18
  def visit_Psych_Nodes_Mapping(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:23
  def visit_Psych_Nodes_Scalar(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:17
  def visit_Psych_Nodes_Sequence(o); end

  # pkg:gem/psych#lib/psych/visitors/depth_first.rb:15
  def visit_Psych_Nodes_Stream(o); end
end

# pkg:gem/psych#lib/psych/visitors/emitter.rb:4
class Psych::Visitors::Emitter < ::Psych::Visitors::Visitor
  # @return [Emitter] a new instance of Emitter
  #
  # pkg:gem/psych#lib/psych/visitors/emitter.rb:5
  def initialize(io, options = T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:47
  def visit_Psych_Nodes_Alias(o); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:25
  def visit_Psych_Nodes_Document(o); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:41
  def visit_Psych_Nodes_Mapping(o); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:31
  def visit_Psych_Nodes_Scalar(o); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:35
  def visit_Psych_Nodes_Sequence(o); end

  # pkg:gem/psych#lib/psych/visitors/emitter.rb:19
  def visit_Psych_Nodes_Stream(o); end
end

# pkg:gem/psych#lib/psych/visitors/json_tree.rb:6
class Psych::Visitors::JSONTree < ::Psych::Visitors::YAMLTree
  include ::Psych::JSON::RubyEvents

  # pkg:gem/psych#lib/psych/visitors/json_tree.rb:16
  def accept(target); end

  class << self
    # pkg:gem/psych#lib/psych/visitors/json_tree.rb:9
    def create(options = T.unsafe(nil)); end
  end
end

# pkg:gem/psych#lib/psych/visitors/to_ruby.rb:473
class Psych::Visitors::NoAliasRuby < ::Psych::Visitors::ToRuby
  # @raise [AliasesNotEnabled]
  #
  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:474
  def visit_Psych_Nodes_Alias(o); end
end

# pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:580
class Psych::Visitors::RestrictedYAMLTree < ::Psych::Visitors::YAMLTree
  # @return [RestrictedYAMLTree] a new instance of RestrictedYAMLTree
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:592
  def initialize(emitter, ss, options); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:605
  def accept(target); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:617
  def visit_Symbol(sym); end
end

# pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:581
Psych::Visitors::RestrictedYAMLTree::DEFAULT_PERMITTED_CLASSES = T.let(T.unsafe(nil), Hash)

# This class walks a YAML AST, converting each node to Ruby
#
# pkg:gem/psych#lib/psych.rb:15
class Psych::Visitors::ToRuby < ::Psych::Visitors::Visitor
  # @return [ToRuby] a new instance of ToRuby
  #
  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:27
  def initialize(ss, class_loader, symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:38
  def accept(target); end

  # Returns the value of attribute class_loader.
  #
  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:25
  def class_loader; end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:356
  def visit_Psych_Nodes_Alias(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:348
  def visit_Psych_Nodes_Document(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:168
  def visit_Psych_Nodes_Mapping(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:132
  def visit_Psych_Nodes_Scalar(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:136
  def visit_Psych_Nodes_Sequence(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:352
  def visit_Psych_Nodes_Stream(o); end

  private

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:373
  def allocate_anon_data(node, members); end

  # pkg:gem/psych#lib/psych.rb:15
  def build_exception(_arg0, _arg1); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:438
  def deduplicate(key); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:55
  def deserialize(o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:455
  def init_with(o, h, node); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:447
  def merge_key(hash, key, val); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:362
  def register(node, object); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:367
  def register_empty(object); end

  # Convert +klassname+ to a Class
  #
  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:468
  def resolve_class(klassname); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:450
  def revive(klass, node); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:378
  def revive_data_members(hash, o); end

  # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:387
  def revive_hash(hash, o, tagged = T.unsafe(nil)); end

  class << self
    # pkg:gem/psych#lib/psych/visitors/to_ruby.rb:19
    def create(symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil), parse_symbols: T.unsafe(nil)); end
  end
end

# pkg:gem/psych#lib/psych/visitors/to_ruby.rb:16
Psych::Visitors::ToRuby::DATA_INITIALIZE = T.let(T.unsafe(nil), UnboundMethod)

# pkg:gem/psych#lib/psych.rb:15
class Psych::Visitors::Visitor
  # pkg:gem/psych#lib/psych/visitors/visitor.rb:5
  def accept(target); end

  private

  # pkg:gem/psych#lib/psych/visitors/visitor.rb:19
  def dispatch; end

  # pkg:gem/psych#lib/psych/visitors/visitor.rb:29
  def visit(target); end

  class << self
    # @api private
    #
    # pkg:gem/psych#lib/psych/visitors/visitor.rb:12
    def dispatch_cache; end
  end
end

# YAMLTree builds a YAML ast given a Ruby object.  For example:
#
#   builder = Psych::Visitors::YAMLTree.new
#   builder << { :foo => 'bar' }
#   builder.tree # => #<Psych::Nodes::Stream .. }
#
# pkg:gem/psych#lib/psych.rb:15
class Psych::Visitors::YAMLTree < ::Psych::Visitors::Visitor
  # @return [YAMLTree] a new instance of YAMLTree
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:51
  def initialize(emitter, ss, options); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:117
  def <<(object); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:119
  def accept(target); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:88
  def finish; end

  # Returns the value of attribute finished.
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:40
  def finished; end

  # Returns the value of attribute finished.
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:41
  def finished?; end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:99
  def push(object); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:82
  def start(encoding = T.unsafe(nil)); end

  # Returns the value of attribute started.
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:40
  def started; end

  # Returns the value of attribute started.
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:42
  def started?; end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:94
  def tree; end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:386
  def visit_Array(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:412
  def visit_BasicObject(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:286
  def visit_BigDecimal(o); end

  # @raise [TypeError]
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:349
  def visit_Class(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:259
  def visit_Complex(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:165
  def visit_Data(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:229
  def visit_Date(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:234
  def visit_DateTime(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:163
  def visit_Delegator(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:144
  def visit_Encoding(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:394
  def visit_Enumerator(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:217
  def visit_Exception(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:273
  def visit_FalseClass(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:275
  def visit_Float(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:362
  def visit_Hash(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:269
  def visit_Integer(o); end

  # @raise [TypeError]
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:344
  def visit_Module(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:221
  def visit_NameError(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:400
  def visit_NilClass(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:149
  def visit_Object(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:136
  def visit_Psych_Omap(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:375
  def visit_Psych_Set(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:354
  def visit_Range(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:246
  def visit_Rational(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:225
  def visit_Regexp(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:290
  def visit_String(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:203
  def visit_Struct(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:404
  def visit_Symbol(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:241
  def visit_Time(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:272
  def visit_TrueClass(o); end

  private

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:426
  def binary?(string); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:537
  def dump_coder(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:502
  def dump_exception(o, msg); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:572
  def dump_ivars(target); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:499
  def dump_list(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:550
  def emit_coder(c, o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:528
  def format_date(date); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:520
  def format_time(time, utc = T.unsafe(nil)); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:532
  def register(target, yaml_obj); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:430
  def visit_array_subclass(o); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:461
  def visit_hash_subclass(o); end

  class << self
    # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:44
    def create(options = T.unsafe(nil), emitter = T.unsafe(nil)); end
  end
end

# pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:16
class Psych::Visitors::YAMLTree::Registrar
  # @return [Registrar] a new instance of Registrar
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:17
  def initialize; end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:31
  def id_for(target); end

  # @return [Boolean]
  #
  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:27
  def key?(target); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:35
  def node_for(target); end

  # pkg:gem/psych#lib/psych/visitors/yaml_tree.rb:23
  def register(target, node); end
end

# pkg:gem/psych#lib/psych/core_ext.rb:22
class Set
  include ::Enumerable

  # pkg:gem/psych#lib/psych/core_ext.rb:23
  def encode_with(coder); end

  # pkg:gem/psych#lib/psych/core_ext.rb:32
  def init_with(coder); end
end

class Set::CoreSet < ::Set; end
