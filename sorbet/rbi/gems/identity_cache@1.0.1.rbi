# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

module IdentityCache
  extend(::ActiveSupport::Concern)
  extend(::IdentityCache::CacheHash)

  include(::IdentityCache::BelongsToCaching)
  include(::IdentityCache::CacheKeyGeneration)
  include(::IdentityCache::ConfigurationDSL)
  include(::IdentityCache::QueryAPI)
  include(::IdentityCache::ShouldUseCache)
  include(::IdentityCache::WithoutPrimaryIndex)
  include(::IdentityCache::WithPrimaryIndex)

  def cache_namespace; end
  def cache_namespace=(obj); end
  def fetch_read_only_records; end
  def fetch_read_only_records=(obj); end

  class << self
    def append_features(base); end
    def cache; end
    def cache_backend=(cache_adaptor); end
    def cache_namespace; end
    def cache_namespace=(obj); end
    def eager_load!; end
    def fetch(key); end
    def fetch_multi(*keys); end
    def fetch_read_only_records; end
    def fetch_read_only_records=(obj); end
    def logger; end
    def logger=(_); end
    def map_cached_nil_for(value); end
    def readonly; end
    def readonly=(_); end
    def should_fill_cache?; end
    def should_use_cache?; end
    def unmap_cached_nil_for(value); end
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    def fetch_in_batches(keys); end
  end
end

class IdentityCache::AlreadyIncludedError < ::StandardError
end

class IdentityCache::AssociationError < ::StandardError
end

IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

module IdentityCache::BelongsToCaching
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::IdentityCache::BelongsToCaching::ClassMethods)
end

module IdentityCache::BelongsToCaching::ClassMethods
  def cache_belongs_to(association); end
end

IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)

IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

class IdentityCache::CacheFetcher
  def initialize(cache_backend); end

  def cache_backend; end
  def cache_backend=(_); end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys, &block); end
  def write(key, value); end

  private

  def add(key, value); end
  def add_multi(keys); end
  def cas_multi(keys); end
end

module IdentityCache::CacheHash
  def memcache_hash(key); end
end

module IdentityCache::CacheInvalidation
  def reload(*_); end

  private

  def clear_cached_associations; end
end

IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

module IdentityCache::CacheKeyGeneration
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::IdentityCache::CacheKeyGeneration::ClassMethods)

  class << self
    def denormalized_schema_hash(klass); end
    def denormalized_schema_string(klass); end
    def schema_to_string(columns); end
  end
end

module IdentityCache::CacheKeyGeneration::ClassMethods
  def rails_cache_key_namespace; end
end

IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

module IdentityCache::ConfigurationDSL
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::IdentityCache::ConfigurationDSL::ClassMethods)
end

module IdentityCache::ConfigurationDSL::ClassMethods
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end
  def cache_has_many(association, embed: T.unsafe(nil)); end
  def cache_has_one(association, embed:); end

  private

  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end
  def check_association_for_caching(association); end
  def ensure_base_model; end
end

IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)

IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)

class IdentityCache::DerivedModelError < ::StandardError
end

class IdentityCache::FallbackFetcher
  def initialize(cache_backend); end

  def cache_backend; end
  def cache_backend=(_); end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys); end
  def write(key, value); end
end

class IdentityCache::InverseAssociationError < ::StandardError
end

module IdentityCache::LoadStrategy
end

module IdentityCache::LoadStrategy::Eager
  extend(::IdentityCache::LoadStrategy::Eager)

  def lazy_load; end
  def load(cache_fetcher, db_key); end
  def load_batch(db_keys_by_cache_fetcher); end
  def load_multi(cache_fetcher, db_keys); end
end

class IdentityCache::MemoizedCacheProxy
  def initialize(cache_adaptor = T.unsafe(nil)); end

  def cache_backend=(cache_adaptor); end
  def cache_fetcher; end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(*keys); end
  def memoized_key_values; end
  def with_memoization; end
  def write(key, value); end

  private

  def clear_memoization; end
  def fetch_memoized(key); end
  def fetch_multi_memoized(keys); end
  def instrument_duration(payload, key); end
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end
  def memoizing?; end
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

module IdentityCache::QueryAPI
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::IdentityCache::QueryAPI::ClassMethods)

  def expire_cache; end
  def was_new_record?; end

  private

  def expire_attribute_indexes; end
  def fetch_recursively_cached_association(ivar_name, dehydrated_ivar_name, association_name); end
  def hydrate_association_target(associated_class, dehydrated_value); end
  def set_embedded_association(association_name, association_target); end
  def set_inverse_of_cached_association(cached_association, association_target); end
end

module IdentityCache::QueryAPI::ClassMethods
  def cached_association(name); end
  def prefetch_associations(includes, records); end

  private

  def all_cached_associations; end
  def cache_fetch_includes; end
  def check_association_scope(association_name); end
  def each_id_embedded_association; end
  def embedded_associations; end
  def preload_id_embedded_association(records, cached_association); end
  def raise_if_scoped; end
  def readonly_copy(record_or_records); end
  def readonly_record_copy(record); end
  def recursively_embedded_associations; end
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

class IdentityCache::Railtie < ::Rails::Railtie
end

class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound
end

module IdentityCache::ShouldUseCache
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::IdentityCache::ShouldUseCache::ClassMethods)
end

module IdentityCache::ShouldUseCache::ClassMethods
  def should_use_cache?; end
end

class IdentityCache::UnsupportedAssociationError < ::StandardError
end

class IdentityCache::UnsupportedScopeError < ::StandardError
end

IdentityCache::VERSION = T.let(T.unsafe(nil), String)

module IdentityCache::WithPrimaryIndex
  extend(::ActiveSupport::Concern)

  include(::IdentityCache::BelongsToCaching)
  include(::IdentityCache::CacheKeyGeneration)
  include(::IdentityCache::ConfigurationDSL)
  include(::IdentityCache::QueryAPI)
  include(::IdentityCache::ShouldUseCache)
  include(::IdentityCache::WithoutPrimaryIndex)

  mixes_in_class_methods(::IdentityCache::WithPrimaryIndex::ClassMethods)

  def expire_cache; end
  def expire_primary_index; end
  def primary_cache_index_key; end
end

module IdentityCache::WithPrimaryIndex::ClassMethods
  def cache_index(*fields, unique: T.unsafe(nil)); end
  def cached_primary_index; end
  def exists_with_identity_cache?(id); end
  def expire_primary_key_cache_index(id); end
  def fetch(id, includes: T.unsafe(nil)); end
  def fetch_by_id(id, includes: T.unsafe(nil)); end
  def fetch_multi(*ids, includes: T.unsafe(nil)); end
  def primary_cache_index_enabled; end
end

module IdentityCache::WithoutPrimaryIndex
  include(::ArTransactionChanges)
  include(::IdentityCache::CacheInvalidation)
  extend(::ActiveSupport::Concern)

  include(::IdentityCache::BelongsToCaching)
  include(::IdentityCache::CacheKeyGeneration)
  include(::IdentityCache::ConfigurationDSL)
  include(::IdentityCache::QueryAPI)
  include(::IdentityCache::ShouldUseCache)

  mixes_in_class_methods(::IdentityCache::WithoutPrimaryIndex::ClassMethods)

  class << self
    def append_features(base); end
  end
end

module IdentityCache::WithoutPrimaryIndex::ClassMethods
  def primary_cache_index_enabled; end
end

IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)

IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)
