# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca generate

# typed: true

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames = _, increment = _); end
end

RSpec::CallerFilter::ADDITIONAL_TOP_LEVEL_FILES = T.let(T.unsafe(nil), Array)

RSpec::CallerFilter::IGNORE_REGEX = T.let(T.unsafe(nil), Regexp)

RSpec::CallerFilter::LIB_REGEX = T.let(T.unsafe(nil), Regexp)

RSpec::CallerFilter::RSPEC_LIBS = T.let(T.unsafe(nil), Array)

module RSpec::Support
  def self.class_of(object); end
  def self.define_optimized_require_for_rspec(lib, &require_relative); end
  def self.deregister_matcher_definition(&block); end
  def self.failure_notifier; end
  def self.failure_notifier=(callable); end
  def self.is_a_matcher?(object); end
  def self.matcher_definitions; end
  def self.method_handle_for(object, method_name); end
  def self.notify_failure(failure, options = _); end
  def self.register_matcher_definition(&block); end
  def self.require_rspec_core(f); end
  def self.require_rspec_expectations(f); end
  def self.require_rspec_matchers(f); end
  def self.require_rspec_mocks(f); end
  def self.require_rspec_support(f); end
  def self.rspec_description_for_object(object); end
  def self.thread_local_data; end
  def self.warning_notifier; end
  def self.warning_notifier=(_); end
  def self.with_failure_notifier(callable); end
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue::AVOID_RESCUING = T.let(T.unsafe(nil), Array)

class RSpec::Support::BlockSignature < ::RSpec::Support::MethodSignature
  def classify_parameters; end
end

class RSpec::Support::ComparableVersion
  include(::Comparable)

  def initialize(string); end

  def <=>(other); end
  def segments; end
  def string; end
end

RSpec::Support::DEFAULT_FAILURE_NOTIFIER = T.let(T.unsafe(nil), Proc)

RSpec::Support::DEFAULT_WARNING_NOTIFIER = T.let(T.unsafe(nil), Proc)

class RSpec::Support::Differ
  def initialize(opts = _); end

  def color?; end
  def diff(actual, expected); end
  def diff_as_object(actual, expected); end
  def diff_as_string(actual, expected); end

  private

  def add_old_hunk_to_hunk(hunk, oldhunk); end
  def add_to_output(output, string); end
  def all_strings?(*args); end
  def any_multiline_strings?(*args); end
  def blue(text); end
  def build_hunks(actual, expected); end
  def coerce_to_string(string_or_array); end
  def color(text, color_code); end
  def color_diff(diff); end
  def diffably_stringify(array); end
  def finalize_output(output, final_line); end
  def format_type; end
  def green(text); end
  def handle_encoding_errors(actual, expected); end
  def hash_to_string(hash); end
  def multiline?(string); end
  def no_numbers?(*args); end
  def no_procs?(*args); end
  def normal(text); end
  def object_to_string(object); end
  def red(text); end
  def safely_flatten(array); end
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def initialize(string, encoding = _); end

  def <<(string); end
  def ==(*args, &block); end
  def empty?(*args, &block); end
  def encoding(*args, &block); end
  def eql?(*args, &block); end
  def lines(*args, &block); end
  def source_encoding; end
  def split(regex_or_string); end
  def to_s; end
  def to_str; end

  private

  def detect_source_encoding(string); end
  def matching_encoding(string); end
  def remove_invalid_bytes(string); end

  def self.pick_encoding(source_a, source_b); end
end

RSpec::Support::EncodedString::ENCODE_NO_CONVERTER = T.let(T.unsafe(nil), Hash)

RSpec::Support::EncodedString::ENCODE_UNCONVERTABLE_BYTES = T.let(T.unsafe(nil), Hash)

RSpec::Support::EncodedString::REPLACE = T.let(T.unsafe(nil), String)

RSpec::Support::EncodedString::US_ASCII = T.let(T.unsafe(nil), String)

RSpec::Support::EncodedString::UTF_8 = T.let(T.unsafe(nil), String)

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

RSpec::Support::KERNEL_METHOD_METHOD = T.let(T.unsafe(nil), UnboundMethod)

class RSpec::Support::LooseSignatureVerifier < ::RSpec::Support::MethodSignatureVerifier

  private

  def split_args(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def initialize(signature); end

  def has_kw_args_in?(args); end
  def invalid_kw_args_from(_kw_args); end
  def missing_kw_args_from(_kw_args); end
  def non_kw_args_arity_description; end
  def valid_non_kw_args?(*args); end
end

class RSpec::Support::MethodSignature
  def initialize(method); end

  def arbitrary_kw_args?; end
  def classify_arity(arity = _); end
  def classify_parameters; end
  def could_contain_kw_args?(args); end
  def description; end
  def has_kw_args_in?(args); end
  def invalid_kw_args_from(given_kw_args); end
  def max_non_kw_args; end
  def min_non_kw_args; end
  def missing_kw_args_from(given_kw_args); end
  def non_kw_args_arity_description; end
  def optional_kw_args; end
  def required_kw_args; end
  def unlimited_args?; end
  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count = _); end
end

RSpec::Support::MethodSignature::INFINITY = T.let(T.unsafe(nil), Float)

class RSpec::Support::MethodSignatureExpectation
  def initialize; end

  def empty?; end
  def expect_arbitrary_keywords; end
  def expect_arbitrary_keywords=(_); end
  def expect_unlimited_arguments; end
  def expect_unlimited_arguments=(_); end
  def keywords; end
  def keywords=(values); end
  def max_count; end
  def max_count=(number); end
  def min_count; end
  def min_count=(number); end
end

class RSpec::Support::MethodSignatureVerifier
  def initialize(signature, args = _); end

  def error_message; end
  def kw_args; end
  def max_non_kw_args; end
  def min_non_kw_args; end
  def non_kw_args; end
  def valid?; end
  def with_expectation(expectation); end

  private

  def arbitrary_kw_args?; end
  def invalid_kw_args; end
  def missing_kw_args; end
  def split_args(*args); end
  def unlimited_args?; end
  def valid_non_kw_args?; end
end

RSpec::Support::Mutex = Thread::Mutex

module RSpec::Support::OS

  private

  def windows?; end
  def windows_file_path?; end

  def self.windows?; end
  def self.windows_file_path?; end
end

class RSpec::Support::ObjectFormatter
  def initialize(max_formatted_output_length = _); end

  def format(object); end
  def max_formatted_output_length; end
  def max_formatted_output_length=(_); end
  def prepare_array(array); end
  def prepare_element(element); end
  def prepare_for_inspection(object); end
  def prepare_hash(input_hash); end
  def recursive_structure?(object); end
  def sort_hash_keys(input_hash); end
  def with_entering_structure(structure); end

  private

  def truncate_string(str, start_index, end_index); end

  def self.default_instance; end
  def self.format(object); end
  def self.prepare_for_inspection(object); end
end

class RSpec::Support::ObjectFormatter::BaseInspector < ::Struct
  def formatter; end
  def formatter=(_); end
  def inspect; end
  def object; end
  def object=(_); end
  def pretty_print(pp); end

  def self.[](*_); end
  def self.can_inspect?(_object); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

RSpec::Support::ObjectFormatter::DateTimeInspector::FORMAT = T.let(T.unsafe(nil), String)

class RSpec::Support::ObjectFormatter::DelegatorInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

RSpec::Support::ObjectFormatter::ELLIPSIS = T.let(T.unsafe(nil), String)

RSpec::Support::ObjectFormatter::INSPECTOR_CLASSES = T.let(T.unsafe(nil), Array)

class RSpec::Support::ObjectFormatter::InspectableItem < ::Struct
  def inspect; end
  def pretty_print(pp); end
  def text; end
  def text=(_); end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end

  def self.can_inspect?(object); end
end

RSpec::Support::ObjectFormatter::TimeInspector::FORMAT = T.let(T.unsafe(nil), String)

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector < ::RSpec::Support::ObjectFormatter::BaseInspector
  def inspect; end
  def klass; end
  def native_object_id; end

  def self.can_inspect?(object); end
end

RSpec::Support::ObjectFormatter::UninspectableObjectInspector::OBJECT_ID_FORMAT = T.let(T.unsafe(nil), String)

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end
  def constants_defined_on(mod); end
  def get_const_defined_on(mod, const_name); end
  def normalize_const_name(const_name); end
  def recursive_const_defined?(const_name); end
  def recursive_const_get(const_name); end
end

class RSpec::Support::ReentrantMutex
  def initialize; end

  def synchronize; end

  private

  def enter; end
  def exit; end
end

module RSpec::Support::Ruby

  private

  def jruby?; end
  def jruby_9000?; end
  def jruby_version; end
  def mri?; end
  def non_mri?; end
  def rbx?; end

  def self.jruby?; end
  def self.jruby_9000?; end
  def self.jruby_version; end
  def self.mri?; end
  def self.non_mri?; end
  def self.rbx?; end
end

module RSpec::Support::RubyFeatures

  private

  def caller_locations_supported?; end
  def fork_supported?; end
  def kw_args_supported?; end
  def module_prepends_supported?; end
  def module_refinement_supported?; end
  def optional_and_splat_args_supported?; end
  def required_kw_args_supported?; end
  def ripper_supported?; end
  def supports_exception_cause?; end
  def supports_rebinding_module_methods?; end

  def self.caller_locations_supported?; end
  def self.fork_supported?; end
  def self.kw_args_supported?; end
  def self.module_prepends_supported?; end
  def self.module_refinement_supported?; end
  def self.optional_and_splat_args_supported?; end
  def self.required_kw_args_supported?; end
  def self.ripper_supported?; end
  def self.supports_exception_cause?; end
  def self.supports_rebinding_module_methods?; end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
end

RSpec::Support::Version::STRING = T.let(T.unsafe(nil), String)

module RSpec::Support::Warnings
  def deprecate(deprecated, options = _); end
  def warn_deprecation(message, options = _); end
  def warn_with(message, options = _); end
  def warning(text, options = _); end
end

class RSpec::Support::HunkGenerator
  def initialize(actual, expected); end

  def hunks; end

  private

  def actual_lines; end
  def build_hunk(piece); end
  def context_lines; end
  def diffs; end
  def expected_lines; end
end
