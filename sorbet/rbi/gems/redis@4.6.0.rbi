# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis` gem.
# Please instead update this file by running `bin/tapioca gem redis`.

class Redis
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands
  include ::ActiveSupport::Cache::ConnectionPoolLike

  # Create a new client instance
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [Redis] a new client instance
  def initialize(options = T.unsafe(nil)); end

  def _client; end

  # Disconnect the client as quickly and silently as possible.
  def close; end

  # See http://redis.io/topics/pipelining for more details.
  #
  # @deprecated Sends all commands in the queue.
  def commit; end

  # Test whether or not the client is connected
  #
  # @return [Boolean]
  def connected?; end

  def connection; end

  # Disconnect the client as quickly and silently as possible.
  def disconnect!; end

  def dup; end
  def id; end
  def inspect; end

  # Mark the start of a transaction block.
  #
  # Passing a block is optional.
  #
  # @example With a block
  #   redis.multi do |multi|
  #   multi.set("key", "value")
  #   multi.incr("counter")
  #   end # => ["OK", 6]
  # @example Without a block
  #   redis.multi
  #   # => "OK"
  #   redis.set("key", "value")
  #   # => "QUEUED"
  #   redis.incr("counter")
  #   # => "QUEUED"
  #   redis.exec
  #   # => ["OK", 6]
  # @return [String, Array<...>] - when a block is not given, `OK`
  #   - when a block is given, an array with replies
  # @see #watch
  # @see #unwatch
  # @yield [multi] the commands that are called inside this block are cached
  #   and written to the server upon returning from it
  # @yieldparam multi [Redis] `self`
  def multi(&block); end

  def pipelined(&block); end

  # Commands in the queue are executed with the Redis#commit method.
  #
  # See http://redis.io/topics/pipelining for more details.
  #
  # @deprecated Queues a command for pipelining.
  def queue(*command); end

  # Run code with the client reconnecting
  def with_reconnect(val = T.unsafe(nil), &blk); end

  # Run code without the client reconnecting
  def without_reconnect(&blk); end

  private

  def _subscription(method, timeout, channels, block); end
  def send_blocking_command(command, timeout, &block); end
  def send_command(command, &block); end
  def synchronize; end

  class << self
    def current; end
    def current=(redis); end
    def deprecate!(message); end

    # Returns the value of attribute exists_returns_integer.
    def exists_returns_integer; end

    def exists_returns_integer=(value); end

    # Returns the value of attribute raise_deprecations.
    def raise_deprecations; end

    # Sets the attribute raise_deprecations
    #
    # @param value the value to set the attribute raise_deprecations to.
    def raise_deprecations=(_arg0); end

    # Returns the value of attribute silence_deprecations.
    def silence_deprecations; end

    # Sets the attribute silence_deprecations
    #
    # @param value the value to set the attribute silence_deprecations to.
    def silence_deprecations=(_arg0); end
  end
end

Redis::BASE_PATH = T.let(T.unsafe(nil), String)

# Base error for connection related errors.
class Redis::BaseConnectionError < ::Redis::BaseError; end

# Base error for all redis-rb errors.
class Redis::BaseError < ::RuntimeError; end

# Raised when connection to a Redis server cannot be made.
class Redis::CannotConnectError < ::Redis::BaseConnectionError; end

class Redis::Client
  # @return [Client] a new instance of Client
  def initialize(options = T.unsafe(nil)); end

  def call(command); end
  def call_loop(command, timeout = T.unsafe(nil)); end
  def call_pipeline(pipeline); end
  def call_pipelined(pipeline); end
  def call_with_timeout(command, extra_timeout, &blk); end
  def call_without_timeout(command, &blk); end
  def close; end

  # Returns the value of attribute command_map.
  def command_map; end

  def connect; end
  def connect_timeout; end

  # @return [Boolean]
  def connected?; end

  # Returns the value of attribute connection.
  def connection; end

  def db; end
  def db=(db); end
  def disconnect; end
  def driver; end
  def host; end
  def id; end

  # @return [Boolean]
  def inherit_socket?; end

  def io; end
  def location; end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  def password; end
  def path; end
  def port; end
  def process(commands); end
  def read; end
  def read_timeout; end
  def reconnect; end
  def scheme; end
  def timeout; end
  def username; end
  def with_reconnect(val = T.unsafe(nil)); end
  def with_socket_timeout(timeout); end
  def without_reconnect(&blk); end
  def without_socket_timeout(&blk); end
  def write(command); end

  protected

  def _parse_driver(driver); end
  def _parse_options(options); end
  def ensure_connected; end
  def establish_connection; end
  def logging(commands); end
end

class Redis::Client::Connector
  # @return [Connector] a new instance of Connector
  def initialize(options); end

  def check(client); end
  def resolve; end
end

class Redis::Client::Connector::Sentinel < ::Redis::Client::Connector
  # @return [Sentinel] a new instance of Sentinel
  def initialize(options); end

  def check(client); end
  def resolve; end
  def resolve_master; end
  def resolve_slave; end

  # @raise [CannotConnectError]
  def sentinel_detect; end
end

# Defaults are also used for converting string keys to symbols.
Redis::Client::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Redis::Cluster
  # @return [Cluster] a new instance of Cluster
  def initialize(options = T.unsafe(nil)); end

  def call(command, &block); end
  def call_loop(command, timeout = T.unsafe(nil), &block); end
  def call_pipeline(pipeline); end
  def call_with_timeout(command, timeout, &block); end
  def call_without_timeout(command, &block); end

  # @return [Boolean]
  def connected?; end

  def connection_info; end

  # db feature is disabled in cluster mode
  def db; end

  # db feature is disabled in cluster mode
  def db=(_db); end

  def disconnect; end
  def id; end
  def process(commands, &block); end
  def timeout; end
  def with_reconnect(val = T.unsafe(nil), &block); end

  private

  def _scan(command, &block); end
  def assign_asking_node(err_msg); end
  def assign_node(command); end
  def assign_redirection_node(err_msg); end
  def fetch_cluster_info!(option); end
  def fetch_command_details(nodes); end
  def find_node(node_key); end
  def find_node_key(command, primary_only: T.unsafe(nil)); end
  def send_client_command(command, &block); end
  def send_cluster_command(command, &block); end
  def send_command(command, &block); end
  def send_config_command(command, &block); end
  def send_memory_command(command, &block); end
  def send_pubsub_command(command, &block); end
  def send_script_command(command, &block); end

  # @see https://redis.io/topics/cluster-spec#redirection-and-resharding Redirection and resharding
  def try_send(node, method_name, *args, retry_count: T.unsafe(nil), &block); end

  def update_cluster_info!(node_key = T.unsafe(nil)); end
end

# Raised when cluster client can't select node.
class Redis::Cluster::AmbiguousNodeError < ::Redis::BaseError
  # @return [AmbiguousNodeError] a new instance of AmbiguousNodeError
  def initialize(command); end
end

# Keep details about Redis commands for Redis Cluster Client.
#
# @see https://redis.io/commands/command
class Redis::Cluster::Command
  # @return [Command] a new instance of Command
  def initialize(details); end

  def extract_first_key(command); end

  # @return [Boolean]
  def should_send_to_master?(command); end

  # @return [Boolean]
  def should_send_to_slave?(command); end

  private

  def determine_first_key_position(command); end
  def determine_optional_key_position(command, option_name); end
  def dig_details(command, key); end

  # @see https://redis.io/topics/cluster-spec#keys-hash-tags Keys hash tags
  def extract_hash_tag(key); end

  def pick_details(details); end
end

# Raised when error occurs on any node of cluster.
class Redis::Cluster::CommandErrorCollection < ::Redis::BaseError
  # @param errors [Hash{String => Redis::CommandError}]
  # @param error_message [String]
  # @return [CommandErrorCollection] a new instance of CommandErrorCollection
  def initialize(errors, error_message = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  def errors; end
end

# Load details about Redis commands for Redis Cluster Client
#
# @see https://redis.io/commands/command
module Redis::Cluster::CommandLoader
  private

  def fetch_command_details(node); end
  def load(nodes); end

  class << self
    # @raise [CannotConnectError]
    def load(nodes); end

    private

    def fetch_command_details(node); end
  end
end

# Raised when commands in pipelining include cross slot keys.
class Redis::Cluster::CrossSlotPipeliningError < ::Redis::BaseError
  # @return [CrossSlotPipeliningError] a new instance of CrossSlotPipeliningError
  def initialize(keys); end
end

module Redis::Cluster::KeySlotConverter
  private

  # Convert key into slot.
  #
  # @param key [String] the key of the redis command
  # @return [Integer] slot number
  def convert(key); end

  class << self
    # Convert key into slot.
    #
    # @param key [String] the key of the redis command
    # @return [Integer] slot number
    def convert(key); end
  end
end

Redis::Cluster::KeySlotConverter::HASH_SLOTS = T.let(T.unsafe(nil), Integer)
Redis::Cluster::KeySlotConverter::XMODEM_CRC16_LOOKUP = T.let(T.unsafe(nil), Array)

# Keep client list of node for Redis Cluster Client
class Redis::Cluster::Node
  include ::Enumerable

  # @return [Node] a new instance of Node
  def initialize(options, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  def call_all(command, &block); end
  def call_master(command, &block); end
  def call_slave(command, &block); end
  def each(&block); end
  def find_by(node_key); end
  def process_all(commands, &block); end
  def sample; end
  def scale_reading_clients; end

  private

  def build_clients(options); end

  # @return [Boolean]
  def master?(node_key); end

  # @return [Boolean]
  def replica_disabled?; end

  # @return [Boolean]
  def slave?(node_key); end

  # @raise [CommandErrorCollection]
  def try_map; end
end

Redis::Cluster::Node::ROLE_SLAVE = T.let(T.unsafe(nil), String)
class Redis::Cluster::Node::ReloadNeeded < ::StandardError; end

# Node key's format is `<ip>:<port>`.
# It is different from node id.
# Node id is internal identifying code in Redis Cluster.
module Redis::Cluster::NodeKey
  private

  def build_from_host_port(host, port); end
  def build_from_uri(uri); end
  def optionize(node_key); end
  def split(node_key); end

  class << self
    def build_from_host_port(host, port); end
    def build_from_uri(uri); end
    def optionize(node_key); end
    def split(node_key); end
  end
end

Redis::Cluster::NodeKey::DELIMITER = T.let(T.unsafe(nil), String)

# Load and hashify node info for Redis Cluster Client
module Redis::Cluster::NodeLoader
  private

  def fetch_node_info(node); end
  def load_flags(nodes); end

  class << self
    # @raise [CannotConnectError]
    def load_flags(nodes); end

    private

    def fetch_node_info(node); end
  end
end

# Keep options for Redis Cluster Client
class Redis::Cluster::Option
  # @return [Option] a new instance of Option
  def initialize(options); end

  def add_node(host, port); end
  def per_node_key; end
  def update_node(addrs); end

  # @return [Boolean]
  def use_replica?; end

  private

  # Redis cluster node returns only host and port information.
  # So we should complement additional information such as:
  #   scheme, username, password and so on.
  def add_common_node_option_if_needed(options, node_opts, key); end

  # @raise [InvalidClientOptionError]
  def build_node_options(addrs); end

  def parse_node_addr(addr); end
  def parse_node_option(addr); end
  def parse_node_url(addr); end
end

Redis::Cluster::Option::DEFAULT_SCHEME = T.let(T.unsafe(nil), String)
Redis::Cluster::Option::SECURE_SCHEME = T.let(T.unsafe(nil), String)
Redis::Cluster::Option::VALID_SCHEMES = T.let(T.unsafe(nil), Array)

# Raised when client connected to redis as cluster mode
# and some cluster subcommands were called.
class Redis::Cluster::OrchestrationCommandNotSupported < ::Redis::BaseError
  # @return [OrchestrationCommandNotSupported] a new instance of OrchestrationCommandNotSupported
  def initialize(command, subcommand = T.unsafe(nil)); end
end

# Keep slot and node key map for Redis Cluster Client
class Redis::Cluster::Slot
  # @return [Slot] a new instance of Slot
  def initialize(available_slots, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  # @return [Boolean]
  def exists?(slot); end

  def find_node_key_of_master(slot); end
  def find_node_key_of_slave(slot); end
  def put(slot, node_key); end

  private

  # available_slots is mapping of node_key to list of slot ranges
  def build_slot_node_key_map(available_slots); end

  # @return [Boolean]
  def master?(node_key); end

  # @return [Boolean]
  def replica_disabled?; end

  # @return [Boolean]
  def slave?(node_key); end
end

Redis::Cluster::Slot::ROLE_SLAVE = T.let(T.unsafe(nil), String)

# Load and hashify slot info for Redis Cluster Client
module Redis::Cluster::SlotLoader
  private

  def fetch_slot_info(node); end
  def load(nodes); end
  def parse_slot_info(arr, default_ip:); end
  def stringify_node_key(arr, default_ip); end

  class << self
    # @raise [CannotConnectError]
    def load(nodes); end

    private

    def fetch_slot_info(node); end
    def parse_slot_info(arr, default_ip:); end
    def stringify_node_key(arr, default_ip); end
  end
end

# Raised by the client when command execution returns an error reply.
class Redis::CommandError < ::Redis::BaseError; end

module Redis::Commands
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions

  # Sends a command to Redis and returns its reply.
  #
  # Replies are converted to Ruby objects according to the RESP protocol, so
  # you can expect a Ruby array, integer or nil when Redis sends one. Higher
  # level transformations, such as converting an array of pairs into a Ruby
  # hash, are up to consumers.
  #
  # Redis error replies are raised as Ruby exceptions.
  def call(*command); end

  # Interact with the sentinel command (masters, master, slaves, failover)
  #
  # @param subcommand [String] e.g. `masters`, `master`, `slaves`
  # @param args [Array<String>] depends on subcommand
  # @return [Array<String>, Hash<String, String>, String] depends on subcommand
  def sentinel(subcommand, *args); end

  private

  def method_missing(*command); end
end

module Redis::Commands::Bitmaps
  # Count the number of set bits in a range of the string value stored at key.
  #
  # @param key [String]
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @return [Integer] the number of bits set to 1
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  #
  # @param operation [String] e.g. `and`, `or`, `xor`, `not`
  # @param destkey [String] destination key
  # @param keys [String, Array<String>] one or more source keys to perform `operation`
  # @return [Integer] the length of the string stored in `destkey`
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  #
  # @param key [String]
  # @param bit [Integer] whether to look for the first 1 or 0 bit
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @raise [ArgumentError]
  # @return [Integer] the position of the first 1/0 bit.
  #   -1 if looking for 1 and it is not found or start and stop are given.
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Returns the bit value at offset in the string value stored at key.
  #
  # @param key [String]
  # @param offset [Integer] bit offset
  # @return [Integer] `0` or `1`
  def getbit(key, offset); end

  # Sets or clears the bit at offset in the string value stored at key.
  #
  # @param key [String]
  # @param offset [Integer] bit offset
  # @param value [Integer] bit value `0` or `1`
  # @return [Integer] the original bit value stored at `offset`
  def setbit(key, offset, value); end
end

# Commands returning 1 for true and 0 for false may be executed in a pipeline
# where the method call will return nil. Propagate the nil instead of falsely
# returning false.
Redis::Commands::Boolify = T.let(T.unsafe(nil), Proc)

Redis::Commands::BoolifySet = T.let(T.unsafe(nil), Proc)

module Redis::Commands::Cluster
  # Sends `ASKING` command to random node and returns its reply.
  #
  # @return [String] `'OK'`
  # @see https://redis.io/topics/cluster-spec#ask-redirection ASK redirection
  def asking; end

  # Sends `CLUSTER *` command to random node and returns its reply.
  #
  # @param subcommand [String, Symbol] the subcommand of cluster command
  #   e.g. `:slots`, `:nodes`, `:slaves`, `:info`
  # @return [Object] depends on the subcommand
  # @see https://redis.io/commands#cluster Reference of cluster command
  def cluster(subcommand, *args); end
end

module Redis::Commands::Connection
  # Authenticate to the server.
  #
  # @param args [Array<String>] includes both username and password
  #   or only password
  # @return [String] `OK`
  # @see https://redis.io/commands/auth AUTH command
  def auth(*args); end

  # Echo the given string.
  #
  # @param value [String]
  # @return [String]
  def echo(value); end

  # Ping the server.
  #
  # @param message [optional, String]
  # @return [String] `PONG`
  def ping(message = T.unsafe(nil)); end

  # Close the connection.
  #
  # @return [String] `OK`
  def quit; end

  # Change the selected database for the current connection.
  #
  # @param db [Integer] zero-based index of the DB to use (0 to 15)
  # @return [String] `OK`
  def select(db); end
end

Redis::Commands::EMPTY_STREAM_RESPONSE = T.let(T.unsafe(nil), Array)
Redis::Commands::Floatify = T.let(T.unsafe(nil), Proc)
Redis::Commands::FloatifyPairs = T.let(T.unsafe(nil), Proc)

module Redis::Commands::Geo
  # Adds the specified geospatial items (latitude, longitude, name) to the specified key
  #
  # @param key [String]
  # @param member [Array] arguemnts for member or members: longitude, latitude, name
  # @return [Integer] number of elements added to the sorted set
  def geoadd(key, *member); end

  # Returns the distance between two members of a geospatial index
  #
  # @param key [String]
  # @param members [Array<String>]
  # @param unit ['m', 'km', 'mi', 'ft']
  # @return [String, nil] returns distance in spefied unit if both members present, nil otherwise.
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # Returns geohash string representing position for specified members of the specified key.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member or array of members
  # @return [Array<String, nil>] returns array containg geohash string if member is present, nil otherwise
  def geohash(key, member); end

  # Returns longitude and latitude of members of a geospatial index
  #
  # @param key [String]
  # @param member [String, Array<String>] one member or array of members
  # @return [Array<Array<String>, nil>] returns array of elements, where each
  #   element is either array of longitude and latitude or nil
  def geopos(key, member); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from a point
  #
  # @param args [Array] key, longitude, latitude, radius, unit(m|km|ft|mi)
  # @param sort ['asc', 'desc'] sort returned items from the nearest to the farthest
  #   or the farthest to the nearest relative to the center
  # @param count [Integer] limit the results to the first N matching items
  # @param options ['WITHDIST', 'WITHCOORD', 'WITHHASH'] to return additional information
  # @return [Array<String>] may be changed with `options`
  def georadius(*args, **geoptions); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from an already existing member
  #
  # @param args [Array] key, member, radius, unit(m|km|ft|mi)
  # @param sort ['asc', 'desc'] sort returned items from the nearest to the farthest or the farthest
  #   to the nearest relative to the center
  # @param count [Integer] limit the results to the first N matching items
  # @param options ['WITHDIST', 'WITHCOORD', 'WITHHASH'] to return additional information
  # @return [Array<String>] may be changed with `options`
  def georadiusbymember(*args, **geoptions); end

  private

  def _geoarguments(*args, options: T.unsafe(nil), sort: T.unsafe(nil), count: T.unsafe(nil)); end
end

module Redis::Commands::Hashes
  # Delete one or more hash fields.
  #
  # @param key [String]
  # @param field [String, Array<String>]
  # @return [Integer] the number of fields that were removed from the hash
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  #
  # @param key [String]
  # @param field [String]
  # @return [Boolean] whether or not the field exists in the hash
  def hexists(key, field); end

  # Get the value of a hash field.
  #
  # @param key [String]
  # @param field [String]
  # @return [String]
  def hget(key, field); end

  # Get all the fields and values in a hash.
  #
  # @param key [String]
  # @return [Hash<String, String>]
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  #
  # @param key [String]
  # @param field [String]
  # @param increment [Integer]
  # @return [Integer] value of the field after incrementing it
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  #
  # @param key [String]
  # @param field [String]
  # @param increment [Float]
  # @return [Float] value of the field after incrementing it
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  #
  # @param key [String]
  # @return [Array<String>]
  def hkeys(key); end

  # Get the number of fields in a hash.
  #
  # @param key [String]
  # @return [Integer] number of fields in the hash
  def hlen(key); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.hmget("hash", "f1", "f2")
  #   # => ["v1", "v2"]
  # @param key [String]
  # @param fields [Array<String>] array of fields
  # @return [Array<String>] an array of values for the specified fields
  # @see #mapped_hmget
  def hmget(key, *fields, &blk); end

  # Set one or more hash values.
  #
  # @example
  #   redis.hmset("hash", "f1", "v1", "f2", "v2")
  #   # => "OK"
  # @param key [String]
  # @param attrs [Array<String>] array of fields and values
  # @return [String] `"OK"`
  # @see #mapped_hmset
  def hmset(key, *attrs); end

  # Get one or more random fields from a hash.
  #
  # @example Get one random field
  #   redis.hrandfield("hash")
  #   # => "f1"
  # @example Get multiple random fields
  #   redis.hrandfield("hash", 2)
  #   # => ["f1, "f2"]
  # @example Get multiple random fields with values
  #   redis.hrandfield("hash", 2, with_values: true)
  #   # => [["f1", "s1"], ["f2", "s2"]]
  # @param key [String]
  # @param count [Integer]
  # @param options [Hash] - `:with_values => true`: include values in output
  # @return [nil, String, Array<String>, Array<[String, Float]>] - when `key` does not exist, `nil`
  #   - when `count` is not specified, a field name
  #   - when `count` is specified and `:with_values` is not specified, an array of field names
  #   - when `:with_values` is specified, an array with `[field, value]` pairs
  def hrandfield(key, count = T.unsafe(nil), withvalues: T.unsafe(nil), with_values: T.unsafe(nil)); end

  # Scan a hash
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.hscan("hash", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<[String, String]>] the next cursor and all found keys
  def hscan(key, cursor, **options); end

  # Scan a hash
  #
  # @example Retrieve all of the key/value pairs in a hash
  #   redis.hscan_each("hash").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all found keys
  def hscan_each(key, **options, &block); end

  # Set one or more hash values.
  #
  # @example
  #   redis.hset("hash", "f1", "v1", "f2", "v2") # => 2
  #   redis.hset("hash", { "f1" => "v1", "f2" => "v2" }) # => 2
  # @param key [String]
  # @param attrs [Array<String> | Hash<String, String>] array or hash of fields and values
  # @return [Integer] The number of fields that were added to the hash
  def hset(key, *attrs); end

  # Set the value of a hash field, only if the field does not exist.
  #
  # @param key [String]
  # @param field [String]
  # @param value [String]
  # @return [Boolean] whether or not the field was **added** to the hash
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  #
  # @param key [String]
  # @return [Array<String>]
  def hvals(key); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.mapped_hmget("hash", "f1", "f2")
  #   # => { "f1" => "v1", "f2" => "v2" }
  # @param key [String]
  # @param fields [Array<String>] array of fields
  # @return [Hash] a hash mapping the specified fields to their values
  # @see #hmget
  def mapped_hmget(key, *fields); end

  # Set one or more hash values.
  #
  # @example
  #   redis.mapped_hmset("hash", { "f1" => "v1", "f2" => "v2" })
  #   # => "OK"
  # @param key [String]
  # @param hash [Hash] a non-empty hash with fields mapping to values
  # @return [String] `"OK"`
  # @see #hmset
  def mapped_hmset(key, hash); end
end

Redis::Commands::Hashify = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyClusterNodeInfo = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyClusterNodes = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyClusterSlaves = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyClusterSlots = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyInfo = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreamAutoclaim = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreamAutoclaimJustId = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreamEntries = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreamPendingDetails = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreamPendings = T.let(T.unsafe(nil), Proc)
Redis::Commands::HashifyStreams = T.let(T.unsafe(nil), Proc)

module Redis::Commands::HyperLogLog
  # Add one or more members to a HyperLogLog structure.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean] true if at least 1 HyperLogLog internal register was altered. false otherwise.
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  #
  # If called with multiple keys, returns the approximate cardinality of the
  # union of the HyperLogLogs contained in the keys.
  #
  # @param keys [String, Array<String>]
  # @return [Integer]
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  #
  # @param dest_key [String] destination key
  # @param source_key [String, Array<String>] source key, or array of keys
  # @return [Boolean]
  def pfmerge(dest_key, *source_key); end
end

module Redis::Commands::Keys
  def _exists(*keys); end

  # Copy a value from one key to another.
  #
  # @example Copy a value to another key
  #   redis.set "foo", "value"
  #   # => "OK"
  #   redis.copy "foo", "bar"
  #   # => true
  #   redis.get "bar"
  #   # => "value"
  # @example Copy a value to a key in another database
  #   redis.set "foo", "value"
  #   # => "OK"
  #   redis.copy "foo", "bar", db: 2
  #   # => true
  #   redis.select 2
  #   # => "OK"
  #   redis.get "bar"
  #   # => "value"
  # @param source [String]
  # @param destination [String]
  # @param db [Integer]
  # @param replace [Boolean] removes the `destination` key before copying value to it
  # @return [Boolean] whether the key was copied or not
  def copy(source, destination, db: T.unsafe(nil), replace: T.unsafe(nil)); end

  # Delete one or more keys.
  #
  # @param keys [String, Array<String>]
  # @return [Integer] number of keys that were deleted
  def del(*keys); end

  # Return a serialized version of the value stored at a key.
  #
  # @param key [String]
  # @return [String] serialized_value
  def dump(key); end

  # Determine how many of the keys exists.
  #
  # @param keys [String, Array<String>]
  # @return [Integer]
  def exists(*keys); end

  # Determine if any of the keys exists.
  #
  # @param keys [String, Array<String>]
  # @return [Boolean]
  def exists?(*keys); end

  # Set a key's time to live in seconds.
  #
  # @param key [String]
  # @param seconds [Integer] time to live
  # @return [Boolean] whether the timeout was set or not
  def expire(key, seconds); end

  # Set the expiration for a key as a UNIX timestamp.
  #
  # @param key [String]
  # @param unix_time [Integer] expiry time specified as a UNIX timestamp
  # @return [Boolean] whether the timeout was set or not
  def expireat(key, unix_time); end

  # Find all keys matching the given pattern.
  #
  # @param pattern [String]
  # @return [Array<String>]
  def keys(pattern = T.unsafe(nil)); end

  # Transfer a key from the connected instance to another instance.
  #
  # @param key [String, Array<String>]
  # @param options [Hash] - `:host => String`: host of instance to migrate to
  #   - `:port => Integer`: port of instance to migrate to
  #   - `:db => Integer`: database to migrate to (default: same as source)
  #   - `:timeout => Integer`: timeout (default: same as connection timeout)
  #   - `:copy => Boolean`: Do not remove the key from the local instance.
  #   - `:replace => Boolean`: Replace existing key on the remote instance.
  # @return [String] `"OK"`
  def migrate(key, options); end

  # Move a key to another database.
  #
  # @example Move a key to another database
  #   redis.set "foo", "bar"
  #   # => "OK"
  #   redis.move "foo", 2
  #   # => true
  #   redis.exists "foo"
  #   # => false
  #   redis.select 2
  #   # => "OK"
  #   redis.exists "foo"
  #   # => true
  #   redis.get "foo"
  #   # => "bar"
  # @param key [String]
  # @param db [Integer]
  # @return [Boolean] whether the key was moved or not
  def move(key, db); end

  def object(*args); end

  # Remove the expiration from a key.
  #
  # @param key [String]
  # @return [Boolean] whether the timeout was removed or not
  def persist(key); end

  # Set a key's time to live in milliseconds.
  #
  # @param key [String]
  # @param milliseconds [Integer] time to live
  # @return [Boolean] whether the timeout was set or not
  def pexpire(key, milliseconds); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # @param key [String]
  # @param ms_unix_time [Integer] expiry time specified as number of milliseconds from UNIX Epoch.
  # @return [Boolean] whether the timeout was set or not
  def pexpireat(key, ms_unix_time); end

  # Get the time to live (in milliseconds) for a key.
  #
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # @param key [String]
  # @return [Integer] remaining time to live in milliseconds
  def pttl(key); end

  # Return a random key from the keyspace.
  #
  # @return [String]
  def randomkey; end

  # Rename a key. If the new key already exists it is overwritten.
  #
  # @param old_name [String]
  # @param new_name [String]
  # @return [String] `OK`
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  #
  # @param old_name [String]
  # @param new_name [String]
  # @return [Boolean] whether the key was renamed or not
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  #
  # @param key [String]
  # @param ttl [String]
  # @param serialized_value [String]
  # @param options [Hash] - `:replace => Boolean`: if false, raises an error if key already exists
  # @raise [Redis::CommandError]
  # @return [String] `"OK"`
  def restore(key, ttl, serialized_value, replace: T.unsafe(nil)); end

  # Scan the keyspace
  #
  # @example Retrieve the first batch of keys
  #   redis.scan(0)
  #   # => ["4", ["key:21", "key:47", "key:42"]]
  # @example Retrieve a batch of keys matching a pattern
  #   redis.scan(4, :match => "key:1?")
  #   # => ["92", ["key:13", "key:18"]]
  # @example Retrieve a batch of keys of a certain type
  #   redis.scan(92, :type => "zset")
  #   # => ["173", ["sortedset:14", "sortedset:78"]]
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #   - `:type => String`: return keys only of the given type
  # @return [String, Array<String>] the next cursor and all found keys
  def scan(cursor, **options); end

  # Scan the keyspace
  #
  # @example Retrieve all of the keys (with possible duplicates)
  #   redis.scan_each.to_a
  #   # => ["key:21", "key:47", "key:42"]
  # @example Execute block for each key matching a pattern
  #   redis.scan_each(:match => "key:1?") {|key| puts key}
  #   # => key:13
  #   # => key:18
  # @example Execute block for each key of a type
  #   redis.scan_each(:type => "hash") {|key| puts redis.type(key)}
  #   # => "hash"
  #   # => "hash"
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  #   - `:type => String`: return keys only of the given type
  # @return [Enumerator] an enumerator for all found keys
  def scan_each(**options, &block); end

  # Sort the elements in a list, set or sorted set.
  #
  # @example Retrieve the first 2 elements from an alphabetically sorted "list"
  #   redis.sort("list", :order => "alpha", :limit => [0, 2])
  #   # => ["a", "b"]
  # @example Store an alphabetically descending list in "target"
  #   redis.sort("list", :order => "desc alpha", :store => "target")
  #   # => 26
  # @param key [String]
  # @param options [Hash] - `:by => String`: use external key to sort elements by
  #   - `:limit => [offset, count]`: skip `offset` elements, return a maximum
  #   of `count` elements
  #   - `:get => [String, Array<String>]`: single key or array of keys to
  #   retrieve per element in the result
  #   - `:order => String`: combination of `ASC`, `DESC` and optionally `ALPHA`
  #   - `:store => String`: key to store the result at
  # @return [Array<String>, Array<Array<String>>, Integer] - when `:get` is not specified, or holds a single element, an array of elements
  #   - when `:get` is specified, and holds more than one element, an array of
  #   elements where every element is an array with the result for every
  #   element specified in `:get`
  #   - when `:store` is specified, the number of elements in the stored result
  def sort(key, by: T.unsafe(nil), limit: T.unsafe(nil), get: T.unsafe(nil), order: T.unsafe(nil), store: T.unsafe(nil)); end

  # Get the time to live (in seconds) for a key.
  #
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # @param key [String]
  # @return [Integer] remaining time to live in seconds.
  def ttl(key); end

  # Determine the type stored at key.
  #
  # @param key [String]
  # @return [String] `string`, `list`, `set`, `zset`, `hash` or `none`
  def type(key); end

  # Unlink one or more keys.
  #
  # @param keys [String, Array<String>]
  # @return [Integer] number of keys that were unlinked
  def unlink(*keys); end

  private

  def _scan(command, cursor, args, match: T.unsafe(nil), count: T.unsafe(nil), type: T.unsafe(nil), &block); end
end

module Redis::Commands::Lists
  # Remove the first/last element in a list and append/prepend it
  # to another list and return it, or block until one is available.
  #
  # @example Without timeout
  #   element = redis.blmove("foo", "bar", "LEFT", "RIGHT")
  #   # => "element"
  # @example With timeout
  #   element = redis.blmove("foo", "bar", "LEFT", "RIGHT", timeout: 5)
  #   # => nil on timeout
  #   # => "element" on success
  # @param destination [String] destination key
  # @param where_destination [String, Symbol] where to push the element to the source list
  #   e.g. 'LEFT' - to head, 'RIGHT' - to tail
  # @param options [Hash] - `:timeout => Numeric`: timeout in seconds, defaults to no timeout
  # @param where_source [String, Symbol] from where to remove the element from the source list
  #   e.g. 'LEFT' - from head, 'RIGHT' - from tail
  # @param source [String] source key
  # @return [nil, String] the element, or nil when the source key does not exist or the timeout expired
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is available.
  #
  # @example With timeout
  #   list, element = redis.blpop("list", :timeout => 5)
  #   # => nil on timeout
  #   # => ["list", "element"] on success
  # @example Without timeout
  #   list, element = redis.blpop("list")
  #   # => ["list", "element"]
  # @example Blocking pop on multiple lists
  #   list, element = redis.blpop(["list", "another_list"])
  #   # => ["list", "element"]
  # @param keys [String, Array<String>] one or more keys to perform the
  #   blocking pop on
  # @param options [Hash] - `:timeout => Integer`: timeout in seconds, defaults to no timeout
  # @return [nil, [String, String]] - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is available.
  #
  # @param keys [String, Array<String>] one or more keys to perform the
  #   blocking pop on
  # @param options [Hash] - `:timeout => Integer`: timeout in seconds, defaults to no timeout
  # @return [nil, [String, String]] - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  # @see #blpop
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @param options [Hash] - `:timeout => Integer`: timeout in seconds, defaults to no timeout
  # @return [nil, String] - `nil` when the operation timed out
  #   - the element was popped and pushed otherwise
  def brpoplpush(source, destination, deprecated_timeout = T.unsafe(nil), timeout: T.unsafe(nil)); end

  # Get an element from a list by its index.
  #
  # @param key [String]
  # @param index [Integer]
  # @return [String]
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  #
  # @param key [String]
  # @param where [String, Symbol] `BEFORE` or `AFTER`
  # @param pivot [String] reference element
  # @param value [String]
  # @return [Integer] length of the list after the insert operation, or `-1`
  #   when the element `pivot` was not found
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  #
  # @param key [String]
  # @return [Integer]
  def llen(key); end

  # Remove the first/last element in a list, append/prepend it to another list and return it.
  #
  # @note This command comes in place of the now deprecated RPOPLPUSH.
  #   Doing LMOVE RIGHT LEFT is equivalent.
  # @param source [String] source key
  # @param destination [String] destination key
  # @param where_source [String, Symbol] from where to remove the element from the source list
  #   e.g. 'LEFT' - from head, 'RIGHT' - from tail
  # @param where_destination [String, Symbol] where to push the element to the source list
  #   e.g. 'LEFT' - to head, 'RIGHT' - to tail
  # @return [nil, String] the element, or nil when the source key does not exist
  def lmove(source, destination, where_source, where_destination); end

  # Remove and get the first elements in a list.
  #
  # @param key [String]
  # @param count [Integer] number of elements to remove
  # @return [String, Array<String>] the values of the first elements
  def lpop(key, count = T.unsafe(nil)); end

  # Prepend one or more values to a list, creating the list if it doesn't exist
  #
  # @param key [String]
  # @param value [String, Array<String>] string value, or array of string values to push
  # @return [Integer] the length of the list after the push operation
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  #
  # @param key [String]
  # @param value [String]
  # @return [Integer] the length of the list after the push operation
  def lpushx(key, value); end

  # Get a range of elements from a list.
  #
  # @param key [String]
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @return [Array<String>]
  def lrange(key, start, stop); end

  # Remove elements from a list.
  #
  # @param key [String]
  # @param count [Integer] number of elements to remove. Use a positive
  #   value to remove the first `count` occurrences of `value`. A negative
  #   value to remove the last `count` occurrences of `value`. Or zero, to
  #   remove all occurrences of `value` from the list.
  # @param value [String]
  # @return [Integer] the number of removed elements
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  #
  # @param key [String]
  # @param index [Integer]
  # @param value [String]
  # @return [String] `OK`
  def lset(key, index, value); end

  # Trim a list to the specified range.
  #
  # @param key [String]
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @return [String] `OK`
  def ltrim(key, start, stop); end

  # Remove and get the last elements in a list.
  #
  # @param key [String]
  # @param count [Integer] number of elements to remove
  # @return [String, Array<String>] the values of the last elements
  def rpop(key, count = T.unsafe(nil)); end

  # Remove the last element in a list, append it to another list and return it.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @return [nil, String] the element, or nil when the source key does not exist
  def rpoplpush(source, destination); end

  # Append one or more values to a list, creating the list if it doesn't exist
  #
  # @param key [String]
  # @param value [String, Array<String>] string value, or array of string values to push
  # @return [Integer] the length of the list after the push operation
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  #
  # @param key [String]
  # @param value [String]
  # @return [Integer] the length of the list after the push operation
  def rpushx(key, value); end

  private

  def _bpop(cmd, args, &blk); end
  def _normalize_move_wheres(where_source, where_destination); end
end

Redis::Commands::Noop = T.let(T.unsafe(nil), Proc)
Redis::Commands::Pairify = T.let(T.unsafe(nil), Proc)

module Redis::Commands::Pubsub
  # Listen for messages published to channels matching the given patterns.
  def psubscribe(*channels, &block); end

  # Listen for messages published to channels matching the given patterns.
  # Throw a timeout error if there is no messages for a timeout period.
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # Post a message to a channel.
  def publish(channel, message); end

  # Inspect the state of the Pub/Sub subsystem.
  # Possible subcommands: channels, numsub, numpat.
  def pubsub(subcommand, *args); end

  # Stop listening for messages posted to channels matching the given patterns.
  def punsubscribe(*channels); end

  # Listen for messages published to the given channels.
  def subscribe(*channels, &block); end

  # Listen for messages published to the given channels. Throw a timeout error
  # if there is no messages for a timeout period.
  def subscribe_with_timeout(timeout, *channels, &block); end

  # @return [Boolean]
  def subscribed?; end

  # Stop listening for messages posted to the given channels.
  def unsubscribe(*channels); end
end

module Redis::Commands::Scripting
  # Evaluate Lua script.
  #
  # @example EVAL with KEYS and ARGV as array arguments
  #   redis.eval("return { KEYS, ARGV }", ["k1", "k2"], ["a1", "a2"])
  #   # => [["k1", "k2"], ["a1", "a2"]]
  # @example EVAL without KEYS nor ARGV
  #   redis.eval("return 1")
  #   # => 1
  # @example EVAL with KEYS and ARGV in a hash argument
  #   redis.eval("return { KEYS, ARGV }", :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #   # => [["k1", "k2"], ["a1", "a2"]]
  # @param argv [Array<String>] optional array with arguments to pass to the script
  # @param keys [Array<String>] optional array with keys to pass to the script
  # @param options [Hash] - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  # @see #script
  # @see #evalsha
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  #
  # @example EVALSHA with KEYS and ARGV as array arguments
  #   redis.evalsha(sha, ["k1", "k2"], ["a1", "a2"])
  #   # => <depends on script>
  # @example EVALSHA without KEYS nor ARGV
  #   redis.evalsha(sha)
  #   # => <depends on script>
  # @example EVALSHA with KEYS and ARGV in a hash argument
  #   redis.evalsha(sha, :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #   # => <depends on script>
  # @param argv [Array<String>] optional array with arguments to pass to the script
  # @param keys [Array<String>] optional array with keys to pass to the script
  # @param options [Hash] - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  # @see #script
  # @see #eval
  def evalsha(*args); end

  # Control remote script registry.
  #
  # @example Load a script
  #   sha = redis.script(:load, "return 1")
  #   # => <sha of this script>
  # @example Check if a script exists
  #   redis.script(:exists, sha)
  #   # => true
  # @example Check if multiple scripts exist
  #   redis.script(:exists, [sha, other_sha])
  #   # => [true, false]
  # @example Flush the script registry
  #   redis.script(:flush)
  #   # => "OK"
  # @example Kill a running script
  #   redis.script(:kill)
  #   # => "OK"
  # @param subcommand [String] e.g. `exists`, `flush`, `load`, `kill`
  # @param args [Array<String>] depends on subcommand
  # @return [String, Boolean, Array<Boolean>, ...] depends on subcommand
  # @see #eval
  # @see #evalsha
  def script(subcommand, *args); end

  private

  def _eval(cmd, args); end
end

module Redis::Commands::Server
  # Asynchronously rewrite the append-only file.
  #
  # @return [String] `OK`
  def bgrewriteaof; end

  # Asynchronously save the dataset to disk.
  #
  # @return [String] `OK`
  def bgsave; end

  # Manage client connections.
  #
  # @param subcommand [String, Symbol] e.g. `kill`, `list`, `getname`, `setname`
  # @return [String, Hash] depends on subcommand
  def client(subcommand = T.unsafe(nil), *args); end

  # Get or set server configuration parameters.
  #
  # @param action [Symbol] e.g. `:get`, `:set`, `:resetstat`
  # @return [String, Hash] string reply, or hash when retrieving more than one
  #   property with `CONFIG GET`
  def config(action, *args); end

  # Return the number of keys in the selected database.
  #
  # @return [Integer]
  def dbsize; end

  def debug(*args); end

  # Remove all keys from all databases.
  #
  # @param options [Hash] - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  def flushall(options = T.unsafe(nil)); end

  # Remove all keys from the current database.
  #
  # @param options [Hash] - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  def flushdb(options = T.unsafe(nil)); end

  # Get information and statistics about the server.
  #
  # @param cmd [String, Symbol] e.g. "commandstats"
  # @return [Hash<String, String>]
  def info(cmd = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  #
  # @return [Integer]
  def lastsave; end

  # Listen for all requests received by the server in real time.
  #
  # There is no way to interrupt this command.
  #
  # @yield a block to be called for every line of output
  # @yieldparam line [String] timestamp and command that was executed
  def monitor(&block); end

  # Synchronously save the dataset to disk.
  #
  # @return [String]
  def save; end

  # Synchronously save the dataset to disk and then shut down the server.
  def shutdown; end

  # Make the server a slave of another instance, or promote it as master.
  def slaveof(host, port); end

  # Interact with the slowlog (get, len, reset)
  #
  # @param subcommand [String] e.g. `get`, `len`, `reset`
  # @param length [Integer] maximum number of entries to return
  # @return [Array<String>, Integer, String] depends on subcommand
  def slowlog(subcommand, length = T.unsafe(nil)); end

  # Internal command used for replication.
  def sync; end

  # Return the server time.
  #
  # @example
  #   r.time # => [ 1333093196, 606806 ]
  # @return [Array<Integer>] tuple of seconds since UNIX epoch and
  #   microseconds in the current second
  def time; end
end

module Redis::Commands::Sets
  # Add one or more members to a set.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean, Integer] `Boolean` when a single member is specified,
  #   holding whether or not adding the member succeeded, or `Integer` when an
  #   array of members is specified, holding the number of members that were
  #   successfully added
  def sadd(key, member); end

  # Get the number of members in a set.
  #
  # @param key [String]
  # @return [Integer]
  def scard(key); end

  # Subtract multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to subtract
  # @return [Array<String>] members in the difference
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to subtract
  # @return [Integer] number of elements in the resulting set
  def sdiffstore(destination, *keys); end

  # Intersect multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to intersect
  # @return [Array<String>] members in the intersection
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to intersect
  # @return [Integer] number of elements in the resulting set
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  #
  # @param key [String]
  # @param member [String]
  # @return [Boolean]
  def sismember(key, member); end

  # Get all the members in a set.
  #
  # @param key [String]
  # @return [Array<String>]
  def smembers(key); end

  # Determine if multiple values are members of a set.
  #
  # @param key [String]
  # @param members [String, Array<String>]
  # @return [Array<Boolean>]
  def smismember(key, *members); end

  # Move a member from one set to another.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @param member [String] member to move from `source` to `destination`
  # @return [Boolean]
  def smove(source, destination, member); end

  # Remove and return one or more random member from a set.
  #
  # @param key [String]
  # @param count [Integer]
  # @return [String]
  def spop(key, count = T.unsafe(nil)); end

  # Get one or more random members from a set.
  #
  # @param key [String]
  # @param count [Integer]
  # @return [String]
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean, Integer] `Boolean` when a single member is specified,
  #   holding whether or not removing the member succeeded, or `Integer` when an
  #   array of members is specified, holding the number of members that were
  #   successfully removed
  def srem(key, member); end

  # Scan a set
  #
  # @example Retrieve the first batch of keys in a set
  #   redis.sscan("set", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<String>] the next cursor and all found members
  def sscan(key, cursor, **options); end

  # Scan a set
  #
  # @example Retrieve all of the keys in a set
  #   redis.sscan_each("set").to_a
  #   # => ["key1", "key2", "key3"]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all keys in the set
  def sscan_each(key, **options, &block); end

  # Add multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to unify
  # @return [Array<String>] members in the union
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to unify
  # @return [Integer] number of elements in the resulting set
  def sunionstore(destination, *keys); end
end

module Redis::Commands::SortedSets
  # Removes and returns up to count members with the highest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmax('zset', 1)
  #   #=> ['zset', 'b', 2.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmax('zset1', 'zset2', 1)
  #   #=> ['zset1', 'b', 2.0]
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  def bzpopmax(*args); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmin('zset', 1)
  #   #=> ['zset', 'a', 1.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmin('zset1', 'zset2', 1)
  #   #=> ['zset1', 'a', 1.0]
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  def bzpopmin(*args); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  #
  # @example Add a single `[score, member]` pair to a sorted set
  #   redis.zadd("zset", 32.0, "member")
  # @example Add an array of `[score, member]` pairs to a sorted set
  #   redis.zadd("zset", [[32.0, "a"], [64.0, "b"]])
  # @param key [String]
  # @param args [[Float, String], Array<[Float, String]>] - a single `[score, member]` pair
  #   - an array of `[score, member]` pairs
  # @param options [Hash] - `:xx => true`: Only update elements that already exist (never
  #   add elements)
  #   - `:nx => true`: Don't update already existing elements (always
  #   add new elements)
  #   - `:lt => true`: Only update existing elements if the new score
  #   is less than the current score
  #   - `:gt => true`: Only update existing elements if the new score
  #   is greater than the current score
  #   - `:ch => true`: Modify the return value from the number of new
  #   elements added, to the total number of elements changed (CH is an
  #   abbreviation of changed); changed elements are new elements added
  #   and elements already existing for which the score was updated
  #   - `:incr => true`: When this option is specified ZADD acts like
  #   ZINCRBY; only one score-element pair can be specified in this mode
  # @return [Boolean, Integer, Float] - `Boolean` when a single pair is specified, holding whether or not it was
  #   **added** to the sorted set.
  #   - `Integer` when an array of pairs is specified, holding the number of
  #   pairs that were **added** to the sorted set.
  #   - `Float` when option :incr is specified, holding the score of the member
  #   after incrementing it.
  def zadd(key, *args, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil), ch: T.unsafe(nil), incr: T.unsafe(nil)); end

  # Get the number of members in a sorted set.
  #
  # @example
  #   redis.zcard("zset")
  #   # => 4
  # @param key [String]
  # @return [Integer]
  def zcard(key); end

  # Count the members in a sorted set with scores within the given values.
  #
  # @example Count members with score `>= 5` and `< 100`
  #   redis.zcount("zset", "5", "(100")
  #   # => 2
  # @example Count members with scores `> 5`
  #   redis.zcount("zset", "(5", "+inf")
  #   # => 2
  # @param key [String]
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Integer] number of members in within the specified range
  def zcount(key, min, max); end

  # Return the difference between the first and all successive input sorted sets
  #
  # @example
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiff("zsetA", "zsetB")
  #   => ["v1"]
  # @example With scores
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiff("zsetA", "zsetB", :with_scores => true)
  #   => [["v1", 1.0]]
  # @param keys [String, Array<String>] one or more keys to compute the difference
  # @param options [Hash] - `:with_scores => true`: include scores in output
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zdiff(*keys, with_scores: T.unsafe(nil)); end

  # Compute the difference between the first and all successive input sorted sets
  # and store the resulting sorted set in a new key
  #
  # @example
  #   redis.zadd("zsetA", [[1.0, "v1"], [2.0, "v2"]])
  #   redis.zadd("zsetB", [[3.0, "v2"], [2.0, "v3"]])
  #   redis.zdiffstore("zsetA", "zsetB")
  #   # => 1
  # @param destination [String] destination key
  # @param keys [Array<String>] source keys
  # @return [Integer] number of elements in the resulting sorted set
  def zdiffstore(*args, **_arg1); end

  # Increment the score of a member in a sorted set.
  #
  # @example
  #   redis.zincrby("zset", 32.0, "a")
  #   # => 64.0
  # @param key [String]
  # @param increment [Float]
  # @param member [String]
  # @return [Float] score of the member after incrementing it
  def zincrby(key, increment, member); end

  # Return the intersection of multiple sorted sets
  #
  # @example Retrieve the intersection of `2*zsetA` and `1*zsetB`
  #   redis.zinter("zsetA", "zsetB", :weights => [2.0, 1.0])
  #   # => ["v1", "v2"]
  # @example Retrieve the intersection of `2*zsetA` and `1*zsetB`, and their scores
  #   redis.zinter("zsetA", "zsetB", :weights => [2.0, 1.0], :with_scores => true)
  #   # => [["v1", 3.0], ["v2", 6.0]]
  # @param keys [String, Array<String>] one or more keys to intersect
  # @param options [Hash] - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  #   - `:with_scores => true`: include scores in output
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zinter(*args, **_arg1); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  #
  # @example Compute the intersection of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zinterstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #   # => 4
  # @param destination [String] destination key
  # @param keys [Array<String>] source keys
  # @param options [Hash] - `:weights => [Array<Float>]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max)
  # @return [Integer] number of elements in the resulting sorted set
  def zinterstore(*args, **_arg1); end

  # Count the members, with the same score in a sorted set, within the given lexicographical range.
  #
  # @example Count members matching a
  #   redis.zlexcount("zset", "[a", "[a\xff")
  #   # => 1
  # @example Count members matching a-z
  #   redis.zlexcount("zset", "[a", "[z\xff")
  #   # => 26
  # @param key [String]
  # @param min [String] - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param max [String] - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  # @return [Integer] number of members within the specified lexicographical range
  def zlexcount(key, min, max); end

  # Get the scores associated with the given members in a sorted set.
  #
  # @example Get the scores for members "a" and "b"
  #   redis.zmscore("zset", "a", "b")
  #   # => [32.0, 48.0]
  # @param key [String]
  # @param members [String, Array<String>]
  # @return [Array<Float>] scores of the members
  def zmscore(key, *members); end

  # Removes and returns up to count members with the highest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmax('zset')
  #   #=> ['b', 2.0]
  # @example With count option
  #   redis.zpopmax('zset', 2)
  #   #=> [['b', 2.0], ['a', 1.0]]
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  def zpopmax(key, count = T.unsafe(nil)); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmin('zset')
  #   #=> ['a', 1.0]
  # @example With count option
  #   redis.zpopmin('zset', 2)
  #   #=> [['a', 1.0], ['b', 2.0]]
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  def zpopmin(key, count = T.unsafe(nil)); end

  # Get one or more random members from a sorted set.
  #
  # @example Get one random member
  #   redis.zrandmember("zset")
  #   # => "a"
  # @example Get multiple random members
  #   redis.zrandmember("zset", 2)
  #   # => ["a", "b"]
  # @example Get multiple random members with scores
  #   redis.zrandmember("zset", 2, with_scores: true)
  #   # => [["a", 2.0], ["b", 3.0]]
  # @param key [String]
  # @param count [Integer]
  # @param options [Hash] - `:with_scores => true`: include scores in output
  # @return [nil, String, Array<String>, Array<[String, Float]>] - when `key` does not exist or set is empty, `nil`
  #   - when `count` is not specified, a member
  #   - when `count` is specified and `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zrandmember(key, count = T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by index, score or lexicographical ordering.
  #
  # @example Retrieve all members from a sorted set, by index
  #   redis.zrange("zset", 0, -1)
  #   # => ["a", "b"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrange("zset", 0, -1, :with_scores => true)
  #   # => [["a", 32.0], ["b", 64.0]]
  # @param key [String]
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @param options [Hash] - `:by_score => false`: return members by score
  #   - `:by_lex => false`: return members by lexicographical ordering
  #   - `:rev => false`: reverse the ordering, from highest to lowest
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  #   - `:with_scores => true`: include scores in output
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zrange(key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil), withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by lexicographical ordering
  #
  # @example Retrieve members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff")
  #   # => ["aaren", "aarika", "abagael", "abby"]
  # @example Retrieve the first 2 members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #   # => ["aaren", "aarika"]
  # @param key [String]
  # @param min [String] - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param max [String] - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  # @param options [Hash] - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  # @return [Array<String>, Array<[String, Float]>]
  def zrangebylex(key, min, max, limit: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score.
  #
  # @example Retrieve members with score `>= 5` and `< 100`
  #   redis.zrangebyscore("zset", "5", "(100")
  #   # => ["a", "b"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrangebyscore("zset", "(5", "+inf", :with_scores => true)
  #   # => [["a", 32.0], ["b", 64.0]]
  # @example Retrieve the first 2 members with score `>= 0`
  #   redis.zrangebyscore("zset", "0", "+inf", :limit => [0, 2])
  #   # => ["a", "b"]
  # @param options [Hash] - `:with_scores => true`: include scores in output
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param key [String]
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zrangebyscore(key, min, max, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Select a range of members in a sorted set, by index, score or lexicographical ordering
  # and store the resulting sorted set in a new key.
  #
  # @example
  #   redis.zadd("foo", [[1.0, "s1"], [2.0, "s2"], [3.0, "s3"]])
  #   redis.zrangestore("bar", "foo", 0, 1)
  #   # => 2
  #   redis.zrange("bar", 0, -1)
  #   # => ["s1", "s2"]
  # @return [Integer] the number of elements in the resulting sorted set
  # @see #zrange
  def zrangestore(dest_key, src_key, start, stop, byscore: T.unsafe(nil), by_score: T.unsafe(nil), bylex: T.unsafe(nil), by_lex: T.unsafe(nil), rev: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Determine the index of a member in a sorted set.
  #
  # @param key [String]
  # @param member [String]
  # @return [Integer]
  def zrank(key, member); end

  # Remove one or more members from a sorted set.
  #
  # @example Remove a single member from a sorted set
  #   redis.zrem("zset", "a")
  # @example Remove an array of members from a sorted set
  #   redis.zrem("zset", ["a", "b"])
  # @param key [String]
  # @param member [String, Array<String>] - a single member
  #   - an array of members
  # @return [Boolean, Integer] - `Boolean` when a single member is specified, holding whether or not it
  #   was removed from the sorted set
  #   - `Integer` when an array of pairs is specified, holding the number of
  #   members that were removed to the sorted set
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  #
  # @example Remove first 5 members
  #   redis.zremrangebyrank("zset", 0, 4)
  #   # => 5
  # @example Remove last 5 members
  #   redis.zremrangebyrank("zset", -5, -1)
  #   # => 5
  # @param key [String]
  # @param start [Integer] start index
  # @param stop [Integer] stop index
  # @return [Integer] number of members that were removed
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  #
  # @example Remove members with score `>= 5` and `< 100`
  #   redis.zremrangebyscore("zset", "5", "(100")
  #   # => 2
  # @example Remove members with scores `> 5`
  #   redis.zremrangebyscore("zset", "(5", "+inf")
  #   # => 2
  # @param key [String]
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Integer] number of members that were removed
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  #
  # @example Retrieve all members from a sorted set
  #   redis.zrevrange("zset", 0, -1)
  #   # => ["b", "a"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrevrange("zset", 0, -1, :with_scores => true)
  #   # => [["b", 64.0], ["a", 32.0]]
  # @see #zrange
  def zrevrange(key, start, stop, withscores: T.unsafe(nil), with_scores: T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by reversed lexicographical ordering.
  # Apart from the reversed ordering, #zrevrangebylex is similar to #zrangebylex.
  #
  # @example Retrieve members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff")
  #   # => ["abbygail", "abby", "abagael", "aaren"]
  # @example Retrieve the last 2 members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #   # => ["abbygail", "abby"]
  # @see #zrangebylex
  def zrevrangebylex(key, max, min, limit: T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  #
  # @example Retrieve members with score `< 100` and `>= 5`
  #   redis.zrevrangebyscore("zset", "(100", "5")
  #   # => ["b", "a"]
  # @example Retrieve the first 2 members with score `<= 0`
  #   redis.zrevrangebyscore("zset", "0", "-inf", :limit => [0, 2])
  #   # => ["b", "a"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrevrangebyscore("zset", "+inf", "(5", :with_scores => true)
  #   # => [["b", 64.0], ["a", 32.0]]
  # @see #zrangebyscore
  def zrevrangebyscore(key, max, min, withscores: T.unsafe(nil), with_scores: T.unsafe(nil), limit: T.unsafe(nil)); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  #
  # @param key [String]
  # @param member [String]
  # @return [Integer]
  def zrevrank(key, member); end

  # Scan a sorted set
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.zscan("zset", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<[String, Float]>] the next cursor and all found
  #   members and scores
  def zscan(key, cursor, **options); end

  # Scan a sorted set
  #
  # @example Retrieve all of the members/scores in a sorted set
  #   redis.zscan_each("zset").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all found scores and members
  def zscan_each(key, **options, &block); end

  # Get the score associated with the given member in a sorted set.
  #
  # @example Get the score for member "a"
  #   redis.zscore("zset", "a")
  #   # => 32.0
  # @param key [String]
  # @param member [String]
  # @return [Float] score of the member
  def zscore(key, member); end

  # Return the union of multiple sorted sets
  #
  # @example Retrieve the union of `2*zsetA` and `1*zsetB`
  #   redis.zunion("zsetA", "zsetB", :weights => [2.0, 1.0])
  #   # => ["v1", "v2"]
  # @example Retrieve the union of `2*zsetA` and `1*zsetB`, and their scores
  #   redis.zunion("zsetA", "zsetB", :weights => [2.0, 1.0], :with_scores => true)
  #   # => [["v1", 3.0], ["v2", 6.0]]
  # @param keys [String, Array<String>] one or more keys to union
  # @param options [Hash] - `:weights => [Array<Float>]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max)
  #   - `:with_scores => true`: include scores in output
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  def zunion(*args, **_arg1); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  #
  # @example Compute the union of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zunionstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #   # => 8
  # @param destination [String] destination key
  # @param keys [Array<String>] source keys
  # @param options [Hash] - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  # @return [Integer] number of elements in the resulting sorted set
  def zunionstore(*args, **_arg1); end

  private

  def _zsets_operation(cmd, *keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil), with_scores: T.unsafe(nil)); end
  def _zsets_operation_store(cmd, destination, keys, weights: T.unsafe(nil), aggregate: T.unsafe(nil)); end
end

module Redis::Commands::Streams
  # Removes one or multiple entries from the pending entries list of a stream consumer group.
  #
  # @example With a entry id
  #   redis.xack('mystream', 'mygroup', '1526569495631-0')
  # @example With splatted entry ids
  #   redis.xack('mystream', 'mygroup', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xack('mystream', 'mygroup', %w[0-1 0-2])
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param ids [Array<String>] one or multiple entry ids
  # @return [Integer] the number of entries successfully acknowledged
  def xack(key, group, *ids); end

  # Add new entry to the stream.
  #
  # @example With options
  #   redis.xadd('mystream', { f1: 'v1', f2: 'v2' }, id: '0-0', maxlen: 1000, approximate: true)
  # @example Without options
  #   redis.xadd('mystream', f1: 'v1', f2: 'v2')
  # @option opts
  # @option opts
  # @option opts
  # @param key [String] the stream key
  # @param entry [Hash] one or multiple field-value pairs
  # @param opts [Hash] several options for `XADD` command
  # @return [String] the entry id
  def xadd(key, entry, approximate: T.unsafe(nil), maxlen: T.unsafe(nil), id: T.unsafe(nil)); end

  # Transfers ownership of pending stream entries that match the specified criteria.
  #
  # @example Claim next pending message after this id stuck > 5 minutes and mark as retry
  #   redis.xautoclaim('mystream', 'mygroup', 'consumer1', 3600000, '1641321233-0')
  # @example Claim 50 next pending messages stuck > 5 minutes and mark as retry
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0', count: 50)
  # @example Claim next pending message stuck > 5 minutes and don't mark as retry
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0', justid: true)
  # @example Claim next pending message stuck > 5 minutes and mark as retry
  #   redis.xautoclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-0')
  # @param start [String] entry id to start scanning from or 0-0 for everything
  # @param count [Integer] number of messages to claim (default 1)
  # @param justid [Boolean] whether to fetch just an array of entry ids or not.
  #   Does not increment retry count when true
  # @param consumer [String] the consumer name
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param min_idle_time [Integer] the number of milliseconds
  # @return [Hash{String => Hash}] the entries successfully claimed
  # @return [Array<String>] the entry ids successfully claimed if justid option is `true`
  def xautoclaim(key, group, consumer, min_idle_time, start, count: T.unsafe(nil), justid: T.unsafe(nil)); end

  # Changes the ownership of a pending entry
  #
  # @example With arrayed entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2])
  # @example With idle option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], idle: 1000)
  # @example With time option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], time: 1542866959000)
  # @example With splatted entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-1', '0-2')
  # @example With retrycount option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], retrycount: 10)
  # @example With force option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], force: true)
  # @example With justid option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], justid: true)
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param consumer [String] the consumer name
  # @param min_idle_time [Integer] the number of milliseconds
  # @param ids [Array<String>] one or multiple entry ids
  # @param opts [Hash] several options for `XCLAIM` command
  # @return [Hash{String => Hash}] the entries successfully claimed
  # @return [Array<String>] the entry ids successfully claimed if justid option is `true`
  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  # Delete entries by entry ids.
  #
  # @example With splatted entry ids
  #   redis.xdel('mystream', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xdel('mystream', ['0-1', '0-2'])
  # @param key [String] the stream key
  # @param ids [Array<String>] one or multiple entry ids
  # @return [Integer] the number of entries actually deleted
  def xdel(key, *ids); end

  # Manages the consumer group of the stream.
  #
  # @example With `create` subcommand
  #   redis.xgroup(:create, 'mystream', 'mygroup', '$')
  # @example With `destroy` subcommand
  #   redis.xgroup(:destroy, 'mystream', 'mygroup')
  # @example With `delconsumer` subcommand
  #   redis.xgroup(:delconsumer, 'mystream', 'mygroup', 'consumer1')
  # @example With `setid` subcommand
  #   redis.xgroup(:setid, 'mystream', 'mygroup', '$')
  # @param mkstream [Boolean] whether to create an empty stream automatically or not
  # @param key [String] the stream key
  # @param subcommand [String] `create` `setid` `destroy` `delconsumer`
  # @param group [String] the consumer group name
  # @param id_or_consumer [String] * the entry id or `$`, required if subcommand is `create` or `setid`
  #   * the consumer name, required if subcommand is `delconsumer`
  # @return [String] `OK` if subcommand is `create` or `setid`
  # @return [Integer] effected count if subcommand is `destroy` or `delconsumer`
  def xgroup(subcommand, key, group, id_or_consumer = T.unsafe(nil), mkstream: T.unsafe(nil)); end

  # Returns the stream information each subcommand.
  #
  # @example groups
  #   redis.xinfo(:groups, 'mystream')
  # @example stream
  #   redis.xinfo(:stream, 'mystream')
  # @example consumers
  #   redis.xinfo(:consumers, 'mystream', 'mygroup')
  # @param key [String] the stream key
  # @param subcommand [String] e.g. `stream` `groups` `consumers`
  # @param group [String] the consumer group name, required if subcommand is `consumers`
  # @return [Hash] information of the stream if subcommand is `stream`
  # @return [Array<Hash>] information of the consumer groups if subcommand is `groups`
  # @return [Array<Hash>] information of the consumers if subcommand is `consumers`
  def xinfo(subcommand, key, group = T.unsafe(nil)); end

  # Returns the number of entries inside a stream.
  #
  # @example With key
  #   redis.xlen('mystream')
  # @param key [String] the stream key
  # @return [Integer] the number of entries
  def xlen(key); end

  # Fetches not acknowledging pending entries
  #
  # @example With range options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10)
  # @example With range and consumer options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10, 'consumer1')
  # @example With key and group
  #   redis.xpending('mystream', 'mygroup')
  # @param end [String] end   last entry id of range
  # @param count [Integer] count the number of entries as limit
  # @param consumer [String] the consumer name
  # @param start [String] start first entry id of range
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @return [Hash] the summary of pending entries
  # @return [Array<Hash>] the pending entries details if options were specified
  def xpending(key, group, *args); end

  # Fetches entries of the stream in ascending order.
  #
  # @example Without options
  #   redis.xrange('mystream')
  # @example With a specific start
  #   redis.xrange('mystream', '0-1')
  # @example With a specific start and end
  #   redis.xrange('mystream', '0-1', '0-3')
  # @example With count options
  #   redis.xrange('mystream', count: 10)
  # @param key [String] the stream key
  # @param start [String] first entry id of range, default value is `-`
  # @param end [String] last entry id of range, default value is `+`
  # @param count [Integer] the number of entries as limit
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  def xrange(key, start = T.unsafe(nil), range_end = T.unsafe(nil), count: T.unsafe(nil)); end

  # Fetches entries from one or multiple streams. Optionally blocking.
  #
  # @example With a key
  #   redis.xread('mystream', '0-0')
  # @example With multiple keys
  #   redis.xread(%w[mystream1 mystream2], %w[0-0 0-0])
  # @example With count option
  #   redis.xread('mystream', '0-0', count: 2)
  # @example With block option
  #   redis.xread('mystream', '$', block: 1000)
  # @param keys [Array<String>] one or multiple stream keys
  # @param ids [Array<String>] one or multiple entry ids
  # @param count [Integer] the number of entries as limit per stream
  # @param block [Integer] the number of milliseconds as blocking timeout
  # @return [Hash{String => Hash{String => Hash}}] the entries
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # Fetches a subset of the entries from one or multiple streams related with the consumer group.
  # Optionally blocking.
  #
  # @example With multiple keys
  #   redis.xreadgroup('mygroup', 'consumer1', %w[mystream1 mystream2], %w[> >])
  # @example With count option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', count: 2)
  # @example With a key
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>')
  # @example With block option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', block: 1000)
  # @example With noack option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', noack: true)
  # @option opts
  # @option opts
  # @option opts
  # @param group [String] the consumer group name
  # @param consumer [String] the consumer name
  # @param keys [Array<String>] one or multiple stream keys
  # @param ids [Array<String>] one or multiple entry ids
  # @param opts [Hash] several options for `XREADGROUP` command
  # @return [Hash{String => Hash{String => Hash}}] the entries
  def xreadgroup(group, consumer, keys, ids, count: T.unsafe(nil), block: T.unsafe(nil), noack: T.unsafe(nil)); end

  # Fetches entries of the stream in descending order.
  #
  # @example Without options
  #   redis.xrevrange('mystream')
  # @example With a specific end
  #   redis.xrevrange('mystream', '0-3')
  # @example With a specific end and start
  #   redis.xrevrange('mystream', '0-3', '0-1')
  # @example With count options
  #   redis.xrevrange('mystream', count: 10)
  # @param key [String] the stream key
  # @param end [String] first entry id of range, default value is `+`
  # @param start [String] last entry id of range, default value is `-`
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  def xrevrange(key, range_end = T.unsafe(nil), start = T.unsafe(nil), count: T.unsafe(nil)); end

  # Trims older entries of the stream if needed.
  #
  # @example Without options
  #   redis.xtrim('mystream', 1000)
  # @example With options
  #   redis.xtrim('mystream', 1000, approximate: true)
  # @param key [String] the stream key
  # @param mexlen [Integer] max length of entries
  # @param approximate [Boolean] whether to add `~` modifier of maxlen or not
  # @return [Integer] the number of entries actually deleted
  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end

  private

  def _xread(args, keys, ids, blocking_timeout_msec); end
end

module Redis::Commands::Strings
  # Append a value to a key.
  #
  # @param key [String]
  # @param value [String] value to append
  # @return [Integer] length of the string after appending
  def append(key, value); end

  # Decrement the integer value of a key by one.
  #
  # @example
  #   redis.decr("value")
  #   # => 4
  # @param key [String]
  # @return [Integer] value after decrementing it
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  #
  # @example
  #   redis.decrby("value", 5)
  #   # => 0
  # @param key [String]
  # @param decrement [Integer]
  # @return [Integer] value after decrementing it
  def decrby(key, decrement); end

  # Get the value of a key.
  #
  # @param key [String]
  # @return [String]
  def get(key); end

  # Get the value of key and delete the key. This command is similar to GET,
  # except for the fact that it also deletes the key on success.
  #
  # @param key [String]
  # @return [String] the old value stored in the key, or `nil` if the key
  #   did not exist
  def getdel(key); end

  # Get the value of key and optionally set its expiration. GETEX is similar to
  # GET, but is a write command with additional options. When no options are
  # provided, GETEX behaves like GET.
  #
  # @param key [String]
  # @param options [Hash] - `:ex => Integer`: Set the specified expire time, in seconds.
  #   - `:px => Integer`: Set the specified expire time, in milliseconds.
  #   - `:exat => true`: Set the specified Unix time at which the key will
  #   expire, in seconds.
  #   - `:pxat => true`: Set the specified Unix time at which the key will
  #   expire, in milliseconds.
  #   - `:persist => true`: Remove the time to live associated with the key.
  # @return [String] The value of key, or nil when key does not exist.
  def getex(key, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), persist: T.unsafe(nil)); end

  # Get a substring of the string stored at a key.
  #
  # @param key [String]
  # @param start [Integer] zero-based start offset
  # @param stop [Integer] zero-based end offset. Use -1 for representing
  #   the end of the string
  # @return [Integer] `0` or `1`
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  #
  # @param key [String]
  # @param value [String] value to replace the current value with
  # @return [String] the old value stored in the key, or `nil` if the key
  #   did not exist
  def getset(key, value); end

  # Increment the integer value of a key by one.
  #
  # @example
  #   redis.incr("value")
  #   # => 6
  # @param key [String]
  # @return [Integer] value after incrementing it
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  #
  # @example
  #   redis.incrby("value", 5)
  #   # => 10
  # @param key [String]
  # @param increment [Integer]
  # @return [Integer] value after incrementing it
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  #
  # @example
  #   redis.incrbyfloat("value", 1.23)
  #   # => 1.23
  # @param key [String]
  # @param increment [Float]
  # @return [Float] value after incrementing it
  def incrbyfloat(key, increment); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mapped_mget("key1", "key2")
  #   # => { "key1" => "v1", "key2" => "v2" }
  # @param keys [Array<String>] array of keys
  # @return [Hash] a hash mapping the specified keys to their values
  # @see #mget
  def mapped_mget(*keys); end

  # Set one or more values.
  #
  # @example
  #   redis.mapped_mset({ "f1" => "v1", "f2" => "v2" })
  #   # => "OK"
  # @param hash [Hash] keys mapping to values
  # @return [String] `"OK"`
  # @see #mset
  def mapped_mset(hash); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.mapped_msetnx({ "key1" => "v1", "key2" => "v2" })
  #   # => true
  # @param hash [Hash] keys mapping to values
  # @return [Boolean] whether or not all values were set
  # @see #msetnx
  def mapped_msetnx(hash); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mget("key1", "key2")
  #   # => ["v1", "v2"]
  # @param keys [Array<String>]
  # @return [Array<String>] an array of values for the specified keys
  # @see #mapped_mget
  def mget(*keys, &blk); end

  # Set one or more values.
  #
  # @example
  #   redis.mset("key1", "v1", "key2", "v2")
  #   # => "OK"
  # @param args [Array<String>] array of keys and values
  # @return [String] `"OK"`
  # @see #mapped_mset
  def mset(*args); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.msetnx("key1", "v1", "key2", "v2")
  #   # => true
  # @param args [Array<String>] array of keys and values
  # @return [Boolean] whether or not all values were set
  # @see #mapped_msetnx
  def msetnx(*args); end

  # Set the time to live in milliseconds of a key.
  #
  # @param key [String]
  # @param ttl [Integer]
  # @param value [String]
  # @return [String] `"OK"`
  def psetex(key, ttl, value); end

  # Set the string value of a key.
  #
  # @param key [String]
  # @param value [String]
  # @param options [Hash] - `:ex => Integer`: Set the specified expire time, in seconds.
  #   - `:px => Integer`: Set the specified expire time, in milliseconds.
  #   - `:exat => Integer` : Set the specified Unix time at which the key will expire, in seconds.
  #   - `:pxat => Integer` : Set the specified Unix time at which the key will expire, in milliseconds.
  #   - `:nx => true`: Only set the key if it does not already exist.
  #   - `:xx => true`: Only set the key if it already exist.
  #   - `:keepttl => true`: Retain the time to live associated with the key.
  #   - `:get => true`: Return the old string stored at key, or nil if key did not exist.
  # @return [String, Boolean] `"OK"` or true, false if `:nx => true` or `:xx => true`
  def set(key, value, ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil), get: T.unsafe(nil)); end

  # Set the time to live in seconds of a key.
  #
  # @param key [String]
  # @param ttl [Integer]
  # @param value [String]
  # @return [String] `"OK"`
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  #
  # @param key [String]
  # @param value [String]
  # @return [Boolean] whether the key was set or not
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  #
  # @param key [String]
  # @param offset [Integer] byte offset
  # @param value [String]
  # @return [Integer] length of the string after it was modified
  def setrange(key, offset, value); end

  # Get the length of the value stored in a key.
  #
  # @param key [String]
  # @return [Integer] the length of the value stored in the key, or 0
  #   if the key does not exist
  def strlen(key); end
end

module Redis::Commands::Transactions
  # Discard all commands issued after MULTI.
  #
  # Only call this method when `#multi` was called **without** a block.
  #
  # @return [String] `"OK"`
  # @see #multi
  # @see #exec
  def discard; end

  # Execute all commands issued after MULTI.
  #
  # Only call this method when `#multi` was called **without** a block.
  #
  # @return [nil, Array<...>] - when commands were not executed, `nil`
  #   - when commands were executed, an array with their replies
  # @see #multi
  # @see #discard
  def exec; end

  # Forget about all watched keys.
  #
  # @return [String] `OK`
  # @see #watch
  # @see #multi
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  #
  # Using a block is optional, but is necessary for thread-safety.
  #
  # An `#unwatch` is automatically issued if an exception is raised within the
  # block that is a subclass of StandardError and is not a ConnectionError.
  #
  # @example With a block
  #   redis.watch("key") do
  #   if redis.get("key") == "some value"
  #   redis.multi do |multi|
  #   multi.set("key", "other value")
  #   multi.incr("counter")
  #   end
  #   else
  #   redis.unwatch
  #   end
  #   end
  #   # => ["OK", 6]
  # @example Without a block
  #   redis.watch("key")
  #   # => "OK"
  # @param keys [String, Array<String>] one or more keys to watch
  # @return [Object] if using a block, returns the return value of the block
  # @return [String] if not using a block, returns `OK`
  # @see #unwatch
  # @see #multi
  def watch(*keys); end
end

module Redis::Connection
  class << self
    # Store a list of loaded connection drivers in the Connection module.
    # Redis::Client uses the last required driver by default, and will be aware
    # of the loaded connection drivers if the user chooses to override the
    # default connection driver.
    def drivers; end
  end
end

module Redis::Connection::CommandHelper
  def build_command(args); end

  protected

  def encode(string); end
end

Redis::Connection::CommandHelper::COMMAND_DELIMITER = T.let(T.unsafe(nil), String)

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper

  # @return [Ruby] a new instance of Ruby
  def initialize(sock); end

  # @return [Boolean]
  def connected?; end

  def disconnect; end
  def format_bulk_reply(line); end
  def format_error_reply(line); end
  def format_integer_reply(line); end
  def format_multi_bulk_reply(line); end
  def format_reply(reply_type, line); end
  def format_status_reply(line); end
  def get_tcp_keepalive; end
  def read; end
  def set_tcp_keepalive(keepalive); end
  def set_tcp_nodelay; end
  def timeout=(timeout); end
  def write(command); end
  def write_timeout=(timeout); end

  class << self
    def connect(config); end
  end
end

Redis::Connection::Ruby::ASTERISK = T.let(T.unsafe(nil), String)
Redis::Connection::Ruby::COLON = T.let(T.unsafe(nil), String)
Redis::Connection::Ruby::DOLLAR = T.let(T.unsafe(nil), String)
Redis::Connection::Ruby::MINUS = T.let(T.unsafe(nil), String)
Redis::Connection::Ruby::PLUS = T.let(T.unsafe(nil), String)

class Redis::Connection::SSLSocket < ::OpenSSL::SSL::SSLSocket
  include ::Redis::Connection::SocketMixin

  def wait_readable(timeout = T.unsafe(nil)); end
  def wait_writable(timeout = T.unsafe(nil)); end

  class << self
    def connect(host, port, timeout, ssl_params); end
  end
end

module Redis::Connection::SocketMixin
  def initialize(*args); end

  def _read_from_socket(nbytes, buffer = T.unsafe(nil)); end
  def gets; end
  def read(nbytes); end
  def timeout=(timeout); end
  def write(buffer); end
  def write_timeout=(timeout); end
end

Redis::Connection::SocketMixin::CRLF = T.let(T.unsafe(nil), String)

class Redis::Connection::TCPSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    def connect(host, port, timeout); end
    def connect_addrinfo(addrinfo, port, timeout); end
  end
end

class Redis::Connection::UNIXSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    def connect(path, timeout); end
  end
end

# Raised when connection to a Redis server is lost.
class Redis::ConnectionError < ::Redis::BaseConnectionError; end

class Redis::Deprecated < ::StandardError; end

class Redis::DeprecatedMulti
  # @return [DeprecatedMulti] a new instance of DeprecatedMulti
  def initialize(pipeline); end

  def __getobj__; end
end

class Redis::DeprecatedPipeline
  # @return [DeprecatedPipeline] a new instance of DeprecatedPipeline
  def initialize(pipeline); end

  def __getobj__; end
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike

  # @return [Distributed] a new instance of Distributed
  def initialize(node_configs, options = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def _bpop(cmd, args); end
  def _eval(cmd, args); end
  def add_node(options); end

  # Append a value to a key.
  def append(key, value); end

  # Asynchronously save the dataset to disk.
  def bgsave; end

  # Count the number of set bits in a range of the string value stored at key.
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Remove the first/last element in a list and append/prepend it
  # to another list and return it, or block until one is available.
  def blmove(source, destination, where_source, where_destination, timeout: T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is
  # available.
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is
  # available.
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  def brpoplpush(source, destination, deprecated_timeout = T.unsafe(nil), **options); end

  # Copy a value from one key to another.
  def copy(source, destination, **options); end

  # Return the number of keys in the selected database.
  def dbsize; end

  # Decrement the integer value of a key by one.
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  def decrby(key, decrement); end

  # Delete a key.
  def del(*args); end

  # Discard all commands issued after MULTI.
  #
  # @raise [CannotDistribute]
  def discard; end

  # Return a serialized version of the value stored at a key.
  def dump(key); end

  def dup; end

  # Echo the given string.
  def echo(value); end

  # Evaluate Lua script.
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  def evalsha(*args); end

  # Execute all commands issued after MULTI.
  #
  # @raise [CannotDistribute]
  def exec; end

  # Determine if a key exists.
  def exists(*args); end

  # Determine if any of the keys exists.
  #
  # @return [Boolean]
  def exists?(*args); end

  # Set a key's time to live in seconds.
  def expire(key, seconds); end

  # Set the expiration for a key as a UNIX timestamp.
  def expireat(key, unix_time); end

  # Remove all keys from all databases.
  def flushall; end

  # Remove all keys from the current database.
  def flushdb; end

  # Get the value of a key.
  def get(key); end

  # Returns the bit value at offset in the string value stored at key.
  def getbit(key, offset); end

  # Get the value of a key and delete it.
  def getdel(key); end

  # Get the value of a key and sets its time to live based on options.
  def getex(key, **options); end

  # Get a substring of the string stored at a key.
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  def getset(key, value); end

  # Delete one or more hash fields.
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  def hexists(key, field); end

  # Get the value of a hash field.
  def hget(key, field); end

  # Get all the fields and values in a hash.
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  def hkeys(key); end

  # Get the number of fields in a hash.
  def hlen(key); end

  # Get the values of all the given hash fields.
  def hmget(key, *fields); end

  # Set multiple hash fields to multiple values.
  def hmset(key, *attrs); end

  def hrandfield(key, count = T.unsafe(nil), **options); end

  # Set multiple hash fields to multiple values.
  def hset(key, *attrs); end

  # Set the value of a hash field, only if the field does not exist.
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  def hvals(key); end

  # Increment the integer value of a key by one.
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  def incrbyfloat(key, increment); end

  # Get information and statistics about the server.
  def info(cmd = T.unsafe(nil)); end

  def inspect; end

  # Find all keys matching the given pattern.
  def keys(glob = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  def lastsave; end

  # Get an element from a list by its index.
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  def llen(key); end

  # Remove the first/last element in a list, append/prepend it to another list and return it.
  def lmove(source, destination, where_source, where_destination); end

  # Remove and get the first elements in a list.
  def lpop(key, count = T.unsafe(nil)); end

  # Prepend one or more values to a list.
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  def lpushx(key, value); end

  # Get a range of elements from a list.
  def lrange(key, start, stop); end

  # Remove elements from a list.
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  def lset(key, index, value); end

  # Trim a list to the specified range.
  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end
  def mapped_hmset(key, hash); end

  # Get the values of all the given keys as a Hash.
  def mapped_mget(*keys); end

  # @raise [CannotDistribute]
  def mapped_mset(_hash); end

  # @raise [CannotDistribute]
  def mapped_msetnx(_hash); end

  # Get the values of all the given keys as an Array.
  def mget(*keys); end

  # Transfer a key from the connected instance to another instance.
  #
  # @raise [CannotDistribute]
  def migrate(_key, _options); end

  # Listen for all requests received by the server in real time.
  #
  # @raise [NotImplementedError]
  def monitor; end

  # Move a key to another database.
  def move(key, db); end

  # Set multiple keys to multiple values.
  #
  # @raise [CannotDistribute]
  def mset(*_args); end

  # Set multiple keys to multiple values, only if none of the keys exist.
  #
  # @raise [CannotDistribute]
  def msetnx(*_args); end

  # Mark the start of a transaction block.
  #
  # @raise [CannotDistribute]
  def multi(&block); end

  # @raise [CannotDistribute]
  def node_for(key); end

  def nodes; end

  # Remove the expiration from a key.
  def persist(key); end

  # Set a key's time to live in milliseconds.
  def pexpire(key, milliseconds); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  def pexpireat(key, ms_unix_time); end

  # Add one or more members to a HyperLogLog structure.
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  def pfmerge(dest_key, *source_key); end

  # Ping the server.
  def ping; end

  # @raise [CannotDistribute]
  def pipelined; end

  # Set the time to live in milliseconds of a key.
  def psetex(key, ttl, value); end

  # Listen for messages published to channels matching the given patterns.
  #
  # @raise [NotImplementedError]
  def psubscribe(*channels, &block); end

  # Get the time to live (in milliseconds) for a key.
  def pttl(key); end

  # Post a message to a channel.
  def publish(channel, message); end

  # Stop listening for messages posted to channels matching the given
  # patterns.
  #
  # @raise [NotImplementedError]
  def punsubscribe(*channels); end

  # Close the connection.
  def quit; end

  # Return a random key from the keyspace.
  #
  # @raise [CannotDistribute]
  def randomkey; end

  # Rename a key.
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  def restore(key, ttl, serialized_value, **options); end

  # Returns the value of attribute ring.
  def ring; end

  # Remove and get the last elements in a list.
  def rpop(key, count = T.unsafe(nil)); end

  # Remove the last element in a list, append it to another list and return
  # it.
  def rpoplpush(source, destination); end

  # Append one or more values to a list.
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  def rpushx(key, value); end

  # Add one or more members to a set.
  def sadd(key, member); end

  # Synchronously save the dataset to disk.
  def save; end

  # Get the number of members in a set.
  def scard(key); end

  # Control remote script registry.
  def script(subcommand, *args); end

  # Subtract multiple sets.
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  def sdiffstore(destination, *keys); end

  # Change the selected database for the current connection.
  def select(db); end

  # Set the string value of a key.
  def set(key, value, **options); end

  # Sets or clears the bit at offset in the string value stored at key.
  def setbit(key, offset, value); end

  # Set the time to live in seconds of a key.
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  def setrange(key, offset, value); end

  # Intersect multiple sets.
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  def sismember(key, member); end

  # Get all the members in a set.
  def smembers(key); end

  # Determine if multiple values are members of a set.
  def smismember(key, *members); end

  # Move a member from one set to another.
  def smove(source, destination, member); end

  # Sort the elements in a list, set or sorted set.
  def sort(key, **options); end

  # Remove and return a random member from a set.
  def spop(key, count = T.unsafe(nil)); end

  # Get a random member from a set.
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  def srem(key, member); end

  # Scan a set
  def sscan(key, cursor, **options); end

  # Scan a set and return an enumerator
  def sscan_each(key, **options, &block); end

  # Get the length of the value stored in a key.
  def strlen(key); end

  # Listen for messages published to the given channels.
  def subscribe(channel, *channels, &block); end

  # @return [Boolean]
  def subscribed?; end

  # Add multiple sets.
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  def sunionstore(destination, *keys); end

  # Get server time: an UNIX timestamp and the elapsed microseconds in the current second.
  def time; end

  # Get the time to live (in seconds) for a key.
  def ttl(key); end

  # Determine the type stored at key.
  def type(key); end

  # Unlink keys.
  def unlink(*args); end

  # Stop listening for messages posted to the given channels.
  def unsubscribe(*channels); end

  # Forget about all watched keys.
  #
  # @raise [CannotDistribute]
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  def watch(*keys, &block); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  def zadd(key, *args, **_arg2); end

  # Get the number of members in a sorted set.
  def zcard(key); end

  # Get the number of members in a particular score range.
  def zcount(key, min, max); end

  # Return the difference between the first and all successive input sorted sets.
  def zdiff(*keys, **options); end

  # Compute the difference between the first and all successive input sorted sets
  # and store the resulting sorted set in a new key.
  def zdiffstore(destination, keys, **options); end

  # Increment the score of a member in a sorted set.
  def zincrby(key, increment, member); end

  # Get the intersection of multiple sorted sets
  def zinter(*keys, **options); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  def zinterstore(destination, keys, **options); end

  # Get the scores associated with the given members in a sorted set.
  def zmscore(key, *members); end

  # Get one or more random members from a sorted set.
  def zrandmember(key, count = T.unsafe(nil), **options); end

  # Return a range of members in a sorted set, by index, score or lexicographical ordering.
  def zrange(key, start, stop, **options); end

  # Return a range of members in a sorted set, by score.
  def zrangebyscore(key, min, max, **options); end

  # Select a range of members in a sorted set, by index, score or lexicographical ordering
  # and store the resulting sorted set in a new key.
  def zrangestore(dest_key, src_key, start, stop, **options); end

  # Determine the index of a member in a sorted set.
  def zrank(key, member); end

  # Remove one or more members from a sorted set.
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  def zrevrange(key, start, stop, **options); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  def zrevrangebyscore(key, max, min, **options); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  def zrevrank(key, member); end

  # Get the score associated with the given member in a sorted set.
  def zscore(key, member); end

  # Return the union of multiple sorted sets.
  def zunion(*keys, **options); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  def zunionstore(destination, keys, **options); end

  protected

  # @yield [node_for(keys.first)]
  def ensure_same_node(command, keys); end

  def key_tag(key); end
  def node_index_for(key); end
  def on_each_node(command, *args); end
end

class Redis::Distributed::CannotDistribute < ::RuntimeError
  # @return [CannotDistribute] a new instance of CannotDistribute
  def initialize(command); end

  def message; end
end

class Redis::Future < ::BasicObject
  # @return [Future] a new instance of Future
  def initialize(command, transformation, timeout); end

  def ==(_other); end
  def _command; end
  def _set(object); end
  def class; end
  def inspect; end

  # @return [Boolean]
  def is_a?(other); end

  # Returns the value of attribute timeout.
  def timeout; end

  def value; end
end

Redis::Future::FutureNotReady = T.let(T.unsafe(nil), Redis::FutureNotReady)

class Redis::FutureNotReady < ::RuntimeError
  # @return [FutureNotReady] a new instance of FutureNotReady
  def initialize; end
end

class Redis::HashRing
  # nodes is a list of objects that have a proper to_s representation.
  # replicas indicates how many virtual points should be used pr. node,
  # replicas are required to improve the distribution.
  #
  # @return [HashRing] a new instance of HashRing
  def initialize(nodes = T.unsafe(nil), replicas = T.unsafe(nil)); end

  # Adds a `node` to the hash ring (including a number of replicas).
  def add_node(node); end

  # get the node in the hash ring for this key
  def get_node(key); end

  def get_node_pos(key); end
  def iter_nodes(key); end

  # Returns the value of attribute nodes.
  def nodes; end

  def remove_node(node); end

  # Returns the value of attribute replicas.
  def replicas; end

  # Returns the value of attribute ring.
  def ring; end

  # Returns the value of attribute sorted_keys.
  def sorted_keys; end

  class << self
    # Find the closest index in HashRing with value <= the given value
    def binary_search(ary, value); end
  end
end

# this is the default in libmemcached
Redis::HashRing::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)

# Raised when the connection was inherited by a child process.
class Redis::InheritedError < ::Redis::BaseConnectionError; end

# Raised when client options are invalid.
class Redis::InvalidClientOptionError < ::Redis::BaseError; end

class Redis::Pipeline
  # @return [Pipeline] a new instance of Pipeline
  def initialize(client); end

  def call(command, timeout: T.unsafe(nil), &block); end
  def call_pipeline(pipeline); end
  def call_with_timeout(command, timeout, &block); end

  # Returns the value of attribute client.
  def client; end

  def commands; end

  # Returns the value of attribute db.
  def db; end

  # Sets the attribute db
  #
  # @param value the value to set the attribute db to.
  def db=(_arg0); end

  # @return [Boolean]
  def empty?; end

  def finish(replies, &blk); end

  # Returns the value of attribute futures.
  def futures; end

  # @return [Boolean]
  def shutdown?; end

  def timeout; end
  def timeouts; end
  def with_reconnect(val = T.unsafe(nil)); end

  # @return [Boolean]
  def with_reconnect?; end

  def without_reconnect(&blk); end

  # @return [Boolean]
  def without_reconnect?; end

  class << self
    def deprecation_warning(method, caller_locations); end
  end
end

class Redis::Pipeline::Multi < ::Redis::Pipeline
  def commands; end
  def finish(replies); end
  def timeouts; end
end

Redis::Pipeline::REDIS_INTERNAL_PATH = T.let(T.unsafe(nil), String)

# Redis use MonitorMixin#synchronize and this class use DelegateClass which we want to filter out.
# Both are in the stdlib so we can simply filter the entire stdlib out.
Redis::Pipeline::STDLIB_PATH = T.let(T.unsafe(nil), String)

class Redis::PipelinedConnection
  include ::Redis::Commands::Bitmaps
  include ::Redis::Commands::Cluster
  include ::Redis::Commands::Connection
  include ::Redis::Commands::Geo
  include ::Redis::Commands::Hashes
  include ::Redis::Commands::HyperLogLog
  include ::Redis::Commands::Keys
  include ::Redis::Commands::Lists
  include ::Redis::Commands::Pubsub
  include ::Redis::Commands::Scripting
  include ::Redis::Commands::Server
  include ::Redis::Commands::Sets
  include ::Redis::Commands::SortedSets
  include ::Redis::Commands::Streams
  include ::Redis::Commands::Strings
  include ::Redis::Commands::Transactions
  include ::Redis::Commands

  # @return [PipelinedConnection] a new instance of PipelinedConnection
  def initialize(pipeline); end

  def db; end
  def db=(db); end

  # @yield [_self]
  # @yieldparam _self [Redis::PipelinedConnection] the object that the method was called on
  def pipelined; end

  private

  def send_blocking_command(command, timeout, &block); end
  def send_command(command, &block); end

  # @yield [_self]
  # @yieldparam _self [Redis::PipelinedConnection] the object that the method was called on
  def synchronize; end
end

# Raised by the connection when a protocol error occurs.
class Redis::ProtocolError < ::Redis::BaseError
  # @return [ProtocolError] a new instance of ProtocolError
  def initialize(reply_type); end
end

class Redis::SubscribedClient
  # @return [SubscribedClient] a new instance of SubscribedClient
  def initialize(client); end

  def call(command); end
  def psubscribe(*channels, &block); end
  def psubscribe_with_timeout(timeout, *channels, &block); end
  def punsubscribe(*channels); end
  def subscribe(*channels, &block); end
  def subscribe_with_timeout(timeout, *channels, &block); end
  def unsubscribe(*channels); end

  protected

  def subscription(start, stop, channels, block, timeout = T.unsafe(nil)); end
end

class Redis::Subscription
  # @return [Subscription] a new instance of Subscription
  # @yield [_self]
  # @yieldparam _self [Redis::Subscription] the object that the method was called on
  def initialize; end

  # Returns the value of attribute callbacks.
  def callbacks; end

  def message(&block); end
  def pmessage(&block); end
  def psubscribe(&block); end
  def punsubscribe(&block); end
  def subscribe(&block); end
  def unsubscribe(&block); end
end

# Raised when performing I/O times out.
class Redis::TimeoutError < ::Redis::BaseConnectionError; end

Redis::VERSION = T.let(T.unsafe(nil), String)
