# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reline` gem.
# Please instead update this file by running `bin/tapioca gem reline`.


# pkg:gem/reline#lib/reline/version.rb:1
module Reline
  extend ::Forwardable
  extend ::SingleForwardable

  # pkg:gem/reline#lib/reline.rb:466
  def eof?(*_arg0, **_arg1, &_arg2); end

  private

  # pkg:gem/reline#lib/reline.rb:455
  def readline(*_arg0, **_arg1, &_arg2); end

  # pkg:gem/reline#lib/reline.rb:487
  def readmultiline(*_arg0, **_arg1, &_arg2); end

  class << self
    # pkg:gem/reline#lib/reline.rb:483
    def add_dialog_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:480
    def ambiguous_width(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def auto_indent_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def auto_indent_proc=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:485
    def autocompletion(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:485
    def autocompletion=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def basic_quote_characters(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def basic_quote_characters=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def basic_word_break_characters(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def basic_word_break_characters=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completer_quote_characters(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completer_quote_characters=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completer_word_break_characters(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completer_word_break_characters=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completion_append_character(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completion_append_character=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:453
    def completion_case_fold(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:453
    def completion_case_fold=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completion_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def completion_proc=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:454
    def completion_quote_character(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:494
    def core; end

    # pkg:gem/reline#lib/reline.rb:467
    def delete_text(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:484
    def dialog_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def dig_perfect_match_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def dig_perfect_match_proc=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:440
    def emacs_editing_mode(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:479
    def emacs_editing_mode?(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:490
    def encoding_system_needs; end

    # pkg:gem/reline#lib/reline.rb:465
    def eof?(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def filename_quote_characters(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def filename_quote_characters=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:464
    def get_screen_size(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:439
    def input=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:472
    def insert_text(text); end

    # pkg:gem/reline#lib/reline.rb:481
    def last_incremental_search(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:482
    def last_incremental_search=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:468
    def line_buffer(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:514
    def line_editor; end

    # pkg:gem/reline#lib/reline.rb:439
    def output=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def output_modifier_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def output_modifier_proc=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:469
    def point(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:470
    def point=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def pre_input_hook(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def pre_input_hook=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def prompt_proc(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def prompt_proc=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:452
    def readline(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:446
    def readmultiline(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:478
    def redisplay(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def special_prefixes(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:437
    def special_prefixes=(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:510
    def ungetc(c); end

    # pkg:gem/reline#lib/reline.rb:440
    def vi_editing_mode(*_arg0, **_arg1, &_arg2); end

    # pkg:gem/reline#lib/reline.rb:479
    def vi_editing_mode?(*_arg0, **_arg1, &_arg2); end
  end
end

# pkg:gem/reline#lib/reline/io/ansi.rb:4
class Reline::ANSI < ::Reline::IO
  # pkg:gem/reline#lib/reline/io/ansi.rb:22
  def initialize; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:211
  def both_tty?; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:223
  def buffered_output; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:271
  def clear_screen; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:206
  def cursor_pos; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:304
  def deprep(otio); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:159
  def empty_buffer?; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:30
  def encoding; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:259
  def erase_after_cursor; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:170
  def get_screen_size; end

  # if the usage expects to wait indefinitely, use Float::INFINITY for timeout_second
  #
  # pkg:gem/reline#lib/reline/io/ansi.rb:151
  def getc(timeout_second); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:251
  def hide_cursor; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:155
  def in_pasting?; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:116
  def inner_getc(timeout_second); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:20
  def input=(_arg0); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:231
  def move_cursor_column(x); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:243
  def move_cursor_down(x); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:235
  def move_cursor_up(x); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:20
  def output=(_arg0); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:298
  def prep; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:139
  def read_bracketed_paste; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:291
  def read_single_char(timeout_second); end

  # This only works when the cursor is at the bottom of the scroll range
  # For more details, see https://github.com/ruby/reline/pull/577#issuecomment-1646679623
  #
  # pkg:gem/reline#lib/reline/io/ansi.rb:265
  def scroll_down(x); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:56
  def set_bracketed_paste_key_bindings(config); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:37
  def set_default_key_bindings(config); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:62
  def set_default_key_bindings_ansi_cursor(config); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:87
  def set_default_key_bindings_comprehensive_list(config); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:180
  def set_screen_size(rows, columns); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:276
  def set_winch_handler(&handler); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:255
  def show_cursor; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:166
  def ungetc(c); end

  # pkg:gem/reline#lib/reline/io/ansi.rb:108
  def with_raw_input; end

  # pkg:gem/reline#lib/reline/io/ansi.rb:215
  def write(string); end

  private

  # pkg:gem/reline#lib/reline/io/ansi.rb:187
  def cursor_pos_internal(timeout:); end
end

# pkg:gem/reline#lib/reline/io/ansi.rb:5
Reline::ANSI::ANSI_CURSOR_KEY_BINDINGS = T.let(T.unsafe(nil), Hash)

# pkg:gem/reline#lib/reline/io/ansi.rb:138
Reline::ANSI::END_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

# pkg:gem/reline#lib/reline/io/ansi.rb:137
Reline::ANSI::START_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

# pkg:gem/reline#lib/reline/config.rb:1
class Reline::Config
  # pkg:gem/reline#lib/reline/config.rb:31
  def initialize; end

  # pkg:gem/reline#lib/reline/config.rb:162
  def add_default_key_binding(keystroke, target); end

  # pkg:gem/reline#lib/reline/config.rb:158
  def add_default_key_binding_by_keymap(keymap, keystroke, target); end

  # pkg:gem/reline#lib/reline/config.rb:147
  def add_oneshot_key_binding(keystroke, target); end

  # pkg:gem/reline#lib/reline/config.rb:29
  def autocompletion; end

  # pkg:gem/reline#lib/reline/config.rb:29
  def autocompletion=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:319
  def bind_key(key, value); end

  # pkg:gem/reline#lib/reline/config.rb:252
  def bind_variable(name, value, raw_value); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def completion_ignore_case; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def completion_ignore_case=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def convert_meta; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def convert_meta=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def disable_completion; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def disable_completion=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:72
  def editing_mode; end

  # pkg:gem/reline#lib/reline/config.rb:76
  def editing_mode=(val); end

  # pkg:gem/reline#lib/reline/config.rb:80
  def editing_mode_is?(*val); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def emacs_mode_string; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def emacs_mode_string=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def enable_bracketed_paste; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def enable_bracketed_paste=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:217
  def handle_directive(directive, file, no, if_stack); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def history_size; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def history_size=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:92
  def inputrc_path; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def isearch_terminators; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def isearch_terminators=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:142
  def key_bindings; end

  # pkg:gem/reline#lib/reline/config.rb:338
  def key_notation_to_code(notation); end

  # pkg:gem/reline#lib/reline/config.rb:84
  def keymap; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def keyseq_timeout; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def keyseq_timeout=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:88
  def loaded?; end

  # pkg:gem/reline#lib/reline/config.rb:324
  def parse_key_binding(key, func_name); end

  # pkg:gem/reline#lib/reline/config.rb:364
  def parse_keyseq(str); end

  # pkg:gem/reline#lib/reline/config.rb:122
  def read(file = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/config.rb:166
  def read_lines(lines, file = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/config.rb:370
  def reload; end

  # pkg:gem/reline#lib/reline/config.rb:35
  def reset; end

  # pkg:gem/reline#lib/reline/config.rb:154
  def reset_oneshot_key_bindings; end

  # pkg:gem/reline#lib/reline/config.rb:42
  def reset_variables; end

  # pkg:gem/reline#lib/reline/config.rb:314
  def retrieve_string(str); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def show_all_if_ambiguous; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def show_all_if_ambiguous=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def show_mode_in_prompt; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def show_mode_in_prompt=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:2
  def test_mode; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def vi_cmd_mode_string; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def vi_cmd_mode_string=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:26
  def vi_ins_mode_string; end

  # pkg:gem/reline#lib/reline/config.rb:26
  def vi_ins_mode_string=(_arg0); end

  private

  # pkg:gem/reline#lib/reline/config.rb:118
  def default_inputrc_path; end

  # pkg:gem/reline#lib/reline/config.rb:375
  def seven_bit_encoding?(encoding); end
end

# pkg:gem/reline#lib/reline/config.rb:6
class Reline::Config::InvalidInputrc < ::RuntimeError
  # pkg:gem/reline#lib/reline/config.rb:7
  def file; end

  # pkg:gem/reline#lib/reline/config.rb:7
  def file=(_arg0); end

  # pkg:gem/reline#lib/reline/config.rb:7
  def lineno; end

  # pkg:gem/reline#lib/reline/config.rb:7
  def lineno=(_arg0); end
end

# pkg:gem/reline#lib/reline/config.rb:4
Reline::Config::KEYSEQ_PATTERN = T.let(T.unsafe(nil), Regexp)

# pkg:gem/reline#lib/reline/config.rb:10
Reline::Config::VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/config.rb:24
Reline::Config::VARIABLE_NAME_SYMBOLS = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline.rb:40
class Reline::Core
  extend ::Forwardable

  # pkg:gem/reline#lib/reline.rb:68
  def initialize; end

  # pkg:gem/reline#lib/reline.rb:162
  def add_dialog_proc(name_sym, p, context = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline.rb:407
  def ambiguous_width; end

  # pkg:gem/reline#lib/reline.rb:55
  def auto_indent_proc; end

  # pkg:gem/reline#lib/reline.rb:147
  def auto_indent_proc=(p); end

  # pkg:gem/reline#lib/reline.rb:64
  def autocompletion(*_arg0, **_arg1, &_arg2); end

  # pkg:gem/reline#lib/reline.rb:64
  def autocompletion=(*_arg0, **_arg1, &_arg2); end

  # pkg:gem/reline#lib/reline.rb:55
  def basic_quote_characters; end

  # pkg:gem/reline#lib/reline.rb:104
  def basic_quote_characters=(v); end

  # pkg:gem/reline#lib/reline.rb:55
  def basic_word_break_characters; end

  # pkg:gem/reline#lib/reline.rb:96
  def basic_word_break_characters=(v); end

  # pkg:gem/reline#lib/reline.rb:55
  def completer_quote_characters; end

  # pkg:gem/reline#lib/reline.rb:108
  def completer_quote_characters=(v); end

  # pkg:gem/reline#lib/reline.rb:55
  def completer_word_break_characters; end

  # pkg:gem/reline#lib/reline.rb:100
  def completer_word_break_characters=(v); end

  # pkg:gem/reline#lib/reline.rb:55
  def completion_append_character; end

  # pkg:gem/reline#lib/reline.rb:84
  def completion_append_character=(val); end

  # pkg:gem/reline#lib/reline.rb:124
  def completion_case_fold; end

  # pkg:gem/reline#lib/reline.rb:120
  def completion_case_fold=(v); end

  # pkg:gem/reline#lib/reline.rb:55
  def completion_proc; end

  # pkg:gem/reline#lib/reline.rb:132
  def completion_proc=(p); end

  # pkg:gem/reline#lib/reline.rb:128
  def completion_quote_character; end

  # pkg:gem/reline#lib/reline.rb:57
  def config; end

  # pkg:gem/reline#lib/reline.rb:57
  def config=(_arg0); end

  # pkg:gem/reline#lib/reline.rb:172
  def dialog_proc(name_sym); end

  # pkg:gem/reline#lib/reline.rb:55
  def dig_perfect_match_proc; end

  # pkg:gem/reline#lib/reline.rb:156
  def dig_perfect_match_proc=(p); end

  # pkg:gem/reline#lib/reline.rb:194
  def emacs_editing_mode; end

  # pkg:gem/reline#lib/reline.rb:203
  def emacs_editing_mode?; end

  # pkg:gem/reline#lib/reline.rb:80
  def encoding; end

  # pkg:gem/reline#lib/reline.rb:55
  def filename_quote_characters; end

  # pkg:gem/reline#lib/reline.rb:112
  def filename_quote_characters=(v); end

  # pkg:gem/reline#lib/reline.rb:207
  def get_screen_size; end

  # pkg:gem/reline#lib/reline.rb:176
  def input=(val); end

  # pkg:gem/reline#lib/reline.rb:76
  def io_gate; end

  # pkg:gem/reline#lib/reline.rb:58
  def key_stroke; end

  # pkg:gem/reline#lib/reline.rb:58
  def key_stroke=(_arg0); end

  # pkg:gem/reline#lib/reline.rb:60
  def last_incremental_search; end

  # pkg:gem/reline#lib/reline.rb:60
  def last_incremental_search=(_arg0); end

  # pkg:gem/reline#lib/reline.rb:59
  def line_editor; end

  # pkg:gem/reline#lib/reline.rb:59
  def line_editor=(_arg0); end

  # pkg:gem/reline#lib/reline.rb:61
  def output; end

  # pkg:gem/reline#lib/reline.rb:183
  def output=(val); end

  # pkg:gem/reline#lib/reline.rb:55
  def output_modifier_proc; end

  # pkg:gem/reline#lib/reline.rb:137
  def output_modifier_proc=(p); end

  # pkg:gem/reline#lib/reline.rb:55
  def pre_input_hook; end

  # pkg:gem/reline#lib/reline.rb:152
  def pre_input_hook=(p); end

  # pkg:gem/reline#lib/reline.rb:55
  def prompt_proc; end

  # pkg:gem/reline#lib/reline.rb:142
  def prompt_proc=(p); end

  # pkg:gem/reline#lib/reline.rb:276
  def readline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline.rb:250
  def readmultiline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil), &confirm_multiline_termination); end

  # pkg:gem/reline#lib/reline.rb:55
  def special_prefixes; end

  # pkg:gem/reline#lib/reline.rb:116
  def special_prefixes=(v); end

  # pkg:gem/reline#lib/reline.rb:189
  def vi_editing_mode; end

  # pkg:gem/reline#lib/reline.rb:199
  def vi_editing_mode?; end

  private

  # pkg:gem/reline#lib/reline.rb:293
  def inner_readline(prompt, add_hist, multiline, &confirm_multiline_termination); end

  # pkg:gem/reline#lib/reline.rb:412
  def may_req_ambiguous_char_width; end

  # GNU Readline watis for "keyseq-timeout" milliseconds when the input is
  # ambiguous whether it is matching or matched.
  # If the next character does not arrive within the specified timeout, input
  # is considered as matched.
  # `ESC` is ambiguous because it can be a standalone ESC (matched) or part of
  # `ESC char` or part of CSI sequence (matching).
  #
  # pkg:gem/reline#lib/reline.rb:377
  def read_io(keyseq_timeout, &block); end
end

# pkg:gem/reline#lib/reline.rb:41
Reline::Core::ATTR_READER_NAMES = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline.rb:161
class Reline::Core::DialogProc < ::Struct
  # pkg:gem/reline#lib/reline.rb:161
  def context; end

  # pkg:gem/reline#lib/reline.rb:161
  def context=(_); end

  # pkg:gem/reline#lib/reline.rb:161
  def dialog_proc; end

  # pkg:gem/reline#lib/reline.rb:161
  def dialog_proc=(_); end

  class << self
    # pkg:gem/reline#lib/reline.rb:161
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline.rb:161
    def inspect; end

    # pkg:gem/reline#lib/reline.rb:161
    def keyword_init?; end

    # pkg:gem/reline#lib/reline.rb:161
    def members; end

    # pkg:gem/reline#lib/reline.rb:161
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline.rb:28
class Reline::CursorPos < ::Struct
  # pkg:gem/reline#lib/reline.rb:28
  def x; end

  # pkg:gem/reline#lib/reline.rb:28
  def x=(_); end

  # pkg:gem/reline#lib/reline.rb:28
  def y; end

  # pkg:gem/reline#lib/reline.rb:28
  def y=(_); end

  class << self
    # pkg:gem/reline#lib/reline.rb:28
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline.rb:28
    def inspect; end

    # pkg:gem/reline#lib/reline.rb:28
    def keyword_init?; end

    # pkg:gem/reline#lib/reline.rb:28
    def members; end

    # pkg:gem/reline#lib/reline.rb:28
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline.rb:248
Reline::DEFAULT_DIALOG_CONTEXT = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline.rb:211
Reline::DEFAULT_DIALOG_PROC_AUTOCOMPLETE = T.let(T.unsafe(nil), Proc)

# pkg:gem/reline#lib/reline.rb:29
class Reline::DialogRenderInfo < ::Struct
  # pkg:gem/reline#lib/reline.rb:29
  def bg_color; end

  # pkg:gem/reline#lib/reline.rb:29
  def bg_color=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def contents; end

  # pkg:gem/reline#lib/reline.rb:29
  def contents=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def face; end

  # pkg:gem/reline#lib/reline.rb:29
  def face=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def height; end

  # pkg:gem/reline#lib/reline.rb:29
  def height=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def pos; end

  # pkg:gem/reline#lib/reline.rb:29
  def pos=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def scrollbar; end

  # pkg:gem/reline#lib/reline.rb:29
  def scrollbar=(_); end

  # pkg:gem/reline#lib/reline.rb:29
  def width; end

  # pkg:gem/reline#lib/reline.rb:29
  def width=(_); end

  class << self
    # pkg:gem/reline#lib/reline.rb:29
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline.rb:29
    def inspect; end

    # pkg:gem/reline#lib/reline.rb:29
    def keyword_init?; end

    # pkg:gem/reline#lib/reline.rb:29
    def members; end

    # pkg:gem/reline#lib/reline.rb:29
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/io/dumb.rb:3
class Reline::Dumb < ::Reline::IO
  # pkg:gem/reline#lib/reline/io/dumb.rb:8
  def initialize(encoding: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:49
  def buffered_output; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:101
  def clear_screen; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:76
  def cursor_pos; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:118
  def deprep(otio); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:17
  def dumb?; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:21
  def encoding; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:95
  def erase_after_cursor; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:72
  def get_screen_size; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:53
  def getc(_timeout_second); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:80
  def hide_cursor; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:111
  def in_pasting?; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:37
  def input=(val); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:86
  def move_cursor_column(val); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:92
  def move_cursor_down(val); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:89
  def move_cursor_up(val); end

  # Do not send color reset sequence
  #
  # pkg:gem/reline#lib/reline/io/dumb.rb:6
  def output=(_arg0); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:115
  def prep; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:98
  def scroll_down(val); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:34
  def set_default_key_bindings(_); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:104
  def set_screen_size(rows, columns); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:108
  def set_winch_handler(&handler); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:83
  def show_cursor; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:68
  def ungetc(c); end

  # pkg:gem/reline#lib/reline/io/dumb.rb:41
  def with_raw_input; end

  # pkg:gem/reline#lib/reline/io/dumb.rb:45
  def write(string); end
end

# pkg:gem/reline#lib/reline/io/dumb.rb:4
Reline::Dumb::RESET_COLOR = T.let(T.unsafe(nil), String)

# NOTE: For making compatible with the rb-readline gem
#
# pkg:gem/reline#lib/reline.rb:15
Reline::FILENAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

# pkg:gem/reline#lib/reline/face.rb:3
class Reline::Face
  class << self
    # pkg:gem/reline#lib/reline/face.rb:169
    def [](name); end

    # pkg:gem/reline#lib/reline/face.rb:173
    def config(name, &block); end

    # pkg:gem/reline#lib/reline/face.rb:178
    def configs; end

    # pkg:gem/reline#lib/reline/face.rb:164
    def force_truecolor; end

    # pkg:gem/reline#lib/reline/face.rb:182
    def load_initial_configs; end

    # pkg:gem/reline#lib/reline/face.rb:195
    def reset_to_initial_configs; end

    # pkg:gem/reline#lib/reline/face.rb:160
    def truecolor?; end
  end
end

# pkg:gem/reline#lib/reline/face.rb:58
class Reline::Face::Config
  # pkg:gem/reline#lib/reline/face.rb:62
  def initialize(name, &block); end

  # pkg:gem/reline#lib/reline/face.rb:84
  def [](name); end

  # pkg:gem/reline#lib/reline/face.rb:72
  def define(name, **values); end

  # pkg:gem/reline#lib/reline/face.rb:70
  def definition; end

  # pkg:gem/reline#lib/reline/face.rb:77
  def reconfigure; end

  private

  # pkg:gem/reline#lib/reline/face.rb:126
  def format_to_sgr(ordered_values); end

  # pkg:gem/reline#lib/reline/face.rb:153
  def rgb_expression?(color); end

  # pkg:gem/reline#lib/reline/face.rb:90
  def sgr_rgb(key, value); end

  # pkg:gem/reline#lib/reline/face.rb:108
  def sgr_rgb_256color(key, value); end

  # pkg:gem/reline#lib/reline/face.rb:99
  def sgr_rgb_truecolor(key, value); end
end

# pkg:gem/reline#lib/reline/face.rb:59
Reline::Face::Config::ESSENTIAL_DEFINE_NAMES = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/face.rb:60
Reline::Face::Config::RESET_SGR = T.let(T.unsafe(nil), String)

# pkg:gem/reline#lib/reline/face.rb:4
Reline::Face::SGR_PARAMETERS = T.let(T.unsafe(nil), Hash)

# pkg:gem/reline#lib/reline.rb:527
Reline::HISTORY = T.let(T.unsafe(nil), Reline::History)

# pkg:gem/reline#lib/reline/history.rb:1
class Reline::History < ::Array
  # pkg:gem/reline#lib/reline/history.rb:2
  def initialize(config); end

  # pkg:gem/reline#lib/reline/history.rb:52
  def <<(val); end

  # pkg:gem/reline#lib/reline/history.rb:15
  def [](index); end

  # pkg:gem/reline#lib/reline/history.rb:20
  def []=(index, val); end

  # pkg:gem/reline#lib/reline/history.rb:25
  def concat(*val); end

  # pkg:gem/reline#lib/reline/history.rb:10
  def delete_at(index); end

  # pkg:gem/reline#lib/reline/history.rb:31
  def push(*val); end

  # pkg:gem/reline#lib/reline/history.rb:6
  def to_s; end

  private

  # pkg:gem/reline#lib/reline/history.rb:62
  def check_index(index); end
end

# pkg:gem/reline#lib/reline/io.rb:3
class Reline::IO
  # pkg:gem/reline#lib/reline/io.rb:27
  def dumb?; end

  # Read a single encoding valid character from the input.
  #
  # pkg:gem/reline#lib/reline/io.rb:40
  def read_single_char(timeout_second); end

  # pkg:gem/reline#lib/reline/io.rb:35
  def reset_color_sequence; end

  # pkg:gem/reline#lib/reline/io.rb:31
  def win?; end

  class << self
    # pkg:gem/reline#lib/reline/io.rb:6
    def decide_io_gate; end
  end
end

# pkg:gem/reline#lib/reline.rb:520
Reline::IOGate = T.let(T.unsafe(nil), Reline::ANSI)

# EOF key: { char: nil, method_symbol: nil }
# Other key: { char: String, method_symbol: Symbol }
#
# pkg:gem/reline#lib/reline.rb:22
class Reline::Key < ::Struct
  # pkg:gem/reline#lib/reline.rb:22
  def char; end

  # pkg:gem/reline#lib/reline.rb:22
  def char=(_); end

  # pkg:gem/reline#lib/reline.rb:24
  def match?(sym); end

  # pkg:gem/reline#lib/reline.rb:22
  def method_symbol; end

  # pkg:gem/reline#lib/reline.rb:22
  def method_symbol=(_); end

  # pkg:gem/reline#lib/reline.rb:22
  def unused_boolean; end

  # pkg:gem/reline#lib/reline.rb:22
  def unused_boolean=(_); end

  class << self
    # pkg:gem/reline#lib/reline.rb:22
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline.rb:22
    def inspect; end

    # pkg:gem/reline#lib/reline.rb:22
    def keyword_init?; end

    # pkg:gem/reline#lib/reline.rb:22
    def members; end

    # pkg:gem/reline#lib/reline.rb:22
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/key_actor/base.rb:1
class Reline::KeyActor::Base
  # pkg:gem/reline#lib/reline/key_actor/base.rb:2
  def initialize(mappings = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/key_actor/base.rb:18
  def add(key, func); end

  # pkg:gem/reline#lib/reline/key_actor/base.rb:8
  def add_mappings(mappings); end

  # pkg:gem/reline#lib/reline/key_actor/base.rb:33
  def clear; end

  # pkg:gem/reline#lib/reline/key_actor/base.rb:29
  def get(key); end

  # pkg:gem/reline#lib/reline/key_actor/base.rb:25
  def matching?(key); end
end

# pkg:gem/reline#lib/reline/key_actor/composite.rb:1
class Reline::KeyActor::Composite
  # pkg:gem/reline#lib/reline/key_actor/composite.rb:2
  def initialize(key_actors); end

  # pkg:gem/reline#lib/reline/key_actor/composite.rb:10
  def get(key); end

  # pkg:gem/reline#lib/reline/key_actor/composite.rb:6
  def matching?(key); end
end

# pkg:gem/reline#lib/reline/key_actor/emacs.rb:2
Reline::KeyActor::EMACS_MAPPING = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/key_actor/vi_command.rb:2
Reline::KeyActor::VI_COMMAND_MAPPING = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/key_actor/vi_insert.rb:2
Reline::KeyActor::VI_INSERT_MAPPING = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/key_stroke.rb:1
class Reline::KeyStroke
  # pkg:gem/reline#lib/reline/key_stroke.rb:8
  def initialize(config, encoding); end

  # pkg:gem/reline#lib/reline/key_stroke.rb:6
  def encoding; end

  # pkg:gem/reline#lib/reline/key_stroke.rb:6
  def encoding=(_arg0); end

  # pkg:gem/reline#lib/reline/key_stroke.rb:44
  def expand(input); end

  # pkg:gem/reline#lib/reline/key_stroke.rb:22
  def match_status(input); end

  private

  # pkg:gem/reline#lib/reline/key_stroke.rb:116
  def key_mapping; end

  # returns match status of CSI/SS3 sequence and matched length
  #
  # pkg:gem/reline#lib/reline/key_stroke.rb:80
  def match_unknown_escape_sequence(input, vi_mode: T.unsafe(nil)); end
end

# pkg:gem/reline#lib/reline/key_stroke.rb:4
Reline::KeyStroke::CSI_INTERMEDIATE_BYTES_RANGE = T.let(T.unsafe(nil), Range)

# pkg:gem/reline#lib/reline/key_stroke.rb:3
Reline::KeyStroke::CSI_PARAMETER_BYTES_RANGE = T.let(T.unsafe(nil), Range)

# pkg:gem/reline#lib/reline/key_stroke.rb:2
Reline::KeyStroke::ESC_BYTE = T.let(T.unsafe(nil), Integer)

# Input partially matches to a key sequence
#
# pkg:gem/reline#lib/reline/key_stroke.rb:16
Reline::KeyStroke::MATCHED = T.let(T.unsafe(nil), Symbol)

# Input exactly matches to a key sequence
#
# pkg:gem/reline#lib/reline/key_stroke.rb:14
Reline::KeyStroke::MATCHING = T.let(T.unsafe(nil), Symbol)

# Input matches to a key sequence and the key sequence is a prefix of another key sequence
#
# pkg:gem/reline#lib/reline/key_stroke.rb:18
Reline::KeyStroke::MATCHING_MATCHED = T.let(T.unsafe(nil), Symbol)

# Input does not match to any key sequence
#
# pkg:gem/reline#lib/reline/key_stroke.rb:20
Reline::KeyStroke::UNMATCHED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/kill_ring.rb:1
class Reline::KillRing
  include ::Enumerable

  # pkg:gem/reline#lib/reline/kill_ring.rb:61
  def initialize(max = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:68
  def append(string, before_p = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:116
  def each; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:83
  def process; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:96
  def yank; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:106
  def yank_pop; end
end

# pkg:gem/reline#lib/reline/kill_ring.rb:21
class Reline::KillRing::RingBuffer
  # pkg:gem/reline#lib/reline/kill_ring.rb:25
  def initialize(max = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:31
  def <<(point); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:56
  def empty?; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:23
  def head; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:22
  def size; end
end

# pkg:gem/reline#lib/reline/kill_ring.rb:11
class Reline::KillRing::RingPoint < ::Struct
  # pkg:gem/reline#lib/reline/kill_ring.rb:12
  def initialize(str); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:16
  def ==(other); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def backward; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def backward=(_); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def forward; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def forward=(_); end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def str; end

  # pkg:gem/reline#lib/reline/kill_ring.rb:11
  def str=(_); end

  class << self
    # pkg:gem/reline#lib/reline/kill_ring.rb:11
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline/kill_ring.rb:11
    def inspect; end

    # pkg:gem/reline#lib/reline/kill_ring.rb:11
    def keyword_init?; end

    # pkg:gem/reline#lib/reline/kill_ring.rb:11
    def members; end

    # pkg:gem/reline#lib/reline/kill_ring.rb:11
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/kill_ring.rb:6
Reline::KillRing::State::CONTINUED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/kill_ring.rb:5
Reline::KillRing::State::FRESH = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/kill_ring.rb:7
Reline::KillRing::State::PROCESSED = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/kill_ring.rb:8
Reline::KillRing::State::YANK = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/line_editor.rb:6
class Reline::LineEditor
  # pkg:gem/reline#lib/reline/line_editor.rb:73
  def initialize(config); end

  # pkg:gem/reline#lib/reline/line_editor.rb:685
  def add_dialog_proc(name, p, context = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:14
  def auto_indent_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:14
  def auto_indent_proc=(_arg0); end

  # TODO: Use "private alias_method" idiom after drop Ruby 2.5.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:8
  def byte_pointer; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1234
  def byte_pointer=(val); end

  # pkg:gem/reline#lib/reline/line_editor.rb:398
  def calculate_overlay_levels(overlay_levels); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1074
  def call_completion_proc(pre, target, post, quote); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1081
  def call_completion_proc_with_checking_args(pre, target, post); end

  # pkg:gem/reline#lib/reline/line_editor.rb:446
  def clear_dialogs; end

  # pkg:gem/reline#lib/reline/line_editor.rb:11
  def completion_append_character; end

  # pkg:gem/reline#lib/reline/line_editor.rb:11
  def completion_append_character=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:10
  def completion_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:10
  def completion_proc=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1175
  def confirm_multiline_termination; end

  # pkg:gem/reline#lib/reline/line_editor.rb:9
  def confirm_multiline_termination_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:9
  def confirm_multiline_termination_proc=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:304
  def current_byte_pointer_cursor; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1124
  def current_line; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1200
  def delete_text(start = T.unsafe(nil), length = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:867
  def dialog_proc_scope_completion_journey_data; end

  # pkg:gem/reline#lib/reline/line_editor.rb:15
  def dig_perfect_match_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:15
  def dig_perfect_match_proc=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:794
  def editing_mode; end

  # pkg:gem/reline#lib/reline/line_editor.rb:84
  def encoding; end

  # pkg:gem/reline#lib/reline/line_editor.rb:220
  def eof?; end

  # pkg:gem/reline#lib/reline/line_editor.rb:216
  def finalize; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1254
  def finish; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1250
  def finished?; end

  # pkg:gem/reline#lib/reline/line_editor.rb:168
  def handle_signal; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1006
  def input_key(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1180
  def insert_multiline_text(text); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1190
  def insert_text(text); end

  # pkg:gem/reline#lib/reline/line_editor.rb:80
  def io_gate; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1120
  def line; end

  # pkg:gem/reline#lib/reline/line_editor.rb:351
  def modified_lines; end

  # pkg:gem/reline#lib/reline/line_editor.rb:273
  def multiline_off; end

  # pkg:gem/reline#lib/reline/line_editor.rb:269
  def multiline_on; end

  # pkg:gem/reline#lib/reline/line_editor.rb:12
  def output_modifier_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:12
  def output_modifier_proc=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:357
  def prompt_list; end

  # pkg:gem/reline#lib/reline/line_editor.rb:13
  def prompt_proc; end

  # pkg:gem/reline#lib/reline/line_editor.rb:13
  def prompt_proc=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1051
  def push_undo_redo(modified); end

  # pkg:gem/reline#lib/reline/line_editor.rb:473
  def render; end

  # pkg:gem/reline#lib/reline/line_editor.rb:461
  def render_finished; end

  # pkg:gem/reline#lib/reline/line_editor.rb:406
  def render_line_differential(old_items, new_items); end

  # pkg:gem/reline#lib/reline/line_editor.rb:557
  def rerender; end

  # pkg:gem/reline#lib/reline/line_editor.rb:141
  def reset(prompt = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:261
  def reset_line; end

  # pkg:gem/reline#lib/reline/line_editor.rb:224
  def reset_variables(prompt = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:553
  def rest_height(wrapped_cursor_y); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1139
  def retrieve_completion_block; end

  # pkg:gem/reline#lib/reline/line_editor.rb:363
  def screen_height; end

  # pkg:gem/reline#lib/reline/line_editor.rb:371
  def screen_scroll_top; end

  # pkg:gem/reline#lib/reline/line_editor.rb:367
  def screen_width; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1064
  def scroll_into_view; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1128
  def set_current_line(line, byte_pointer = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:88
  def set_pasting_state(in_pasting); end

  # pkg:gem/reline#lib/reline/line_editor.rb:207
  def set_signal_handlers; end

  # pkg:gem/reline#lib/reline/line_editor.rb:996
  def update(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:453
  def update_dialogs(key = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:549
  def upper_space_height(wrapped_cursor_y); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1242
  def whole_buffer; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1238
  def whole_lines; end

  # pkg:gem/reline#lib/reline/line_editor.rb:343
  def with_cache(key, *deps); end

  # pkg:gem/reline#lib/reline/line_editor.rb:949
  def wrap_method_call(method_symbol, key, with_operator); end

  # Calculate cursor position in word wrapped content.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:437
  def wrapped_cursor_position; end

  # pkg:gem/reline#lib/reline/line_editor.rb:375
  def wrapped_prompt_and_input_lines; end

  private

  # pkg:gem/reline#lib/reline/line_editor.rb:939
  def argumentable?(method_obj); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1413
  def backward_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1700
  def backward_delete_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1838
  def backward_kill_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1818
  def backward_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1652
  def beginning_of_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1422
  def beginning_of_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1246
  def buffer_empty?; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1265
  def byteinsert(str, byte_pointer, other); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1259
  def byteslice!(str, byte_pointer, size); end

  # pkg:gem/reline#lib/reline/line_editor.rb:308
  def calculate_nearest_cursor(cursor); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1272
  def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1878
  def capitalize_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:95
  def check_mode_string; end

  # pkg:gem/reline#lib/reline/line_editor.rb:109
  def check_multiline_prompt(buffer, mode_string); end

  # pkg:gem/reline#lib/reline/line_editor.rb:972
  def cleanup_waiting; end

  # pkg:gem/reline#lib/reline/line_editor.rb:544
  def clear_rendered_screen_cache; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1802
  def clear_screen(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1292
  def complete(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1310
  def completion_journey_move(direction); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1326
  def completion_journey_up(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1916
  def copy_for_vi(text); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1764
  def delete_char(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1778
  def delete_char_or_list(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:696
  def dialog_range(dialog, dialog_y); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1891
  def downcase_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2169
  def ed_argument_digit(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1649
  def ed_beginning_of_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1796
  def ed_clear_screen(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2115
  def ed_delete_next_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2027
  def ed_delete_prev_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1830
  def ed_delete_prev_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1370
  def ed_digit(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1654
  def ed_end_of_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1681
  def ed_force_submit(_key); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, â€¦) Insert yourself.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1353
  def ed_insert(str); end

  # Editline:: +ed-kill-line+ (vi command: +D+, +Ctrl-K+; emacs: +Ctrl-K+,
  #            +Ctrl-U+) + Kill from the cursor to the end of the line.
  # GNU Readline:: +kill-line+ (+C-k+) Kill the text from point to the end of
  #                the line. With a negative numeric argument, kill backward
  #                from the cursor to the beginning of the current line.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1707
  def ed_kill_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1419
  def ed_move_to_beg(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1432
  def ed_move_to_end(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1659
  def ed_newline(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1389
  def ed_next_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1632
  def ed_next_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1402
  def ed_prev_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1615
  def ed_prev_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1812
  def ed_prev_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1578
  def ed_search_next_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1563
  def ed_search_prev_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1840
  def ed_transpose_chars(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1857
  def ed_transpose_words(key); end

  # Editline:: +ed-unassigned+ This  editor command always results in an error.
  # GNU Readline:: There is no corresponding macro.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1332
  def ed_unassigned(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1870
  def em_capitol_case(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1751
  def em_delete(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1820
  def em_delete_next_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1766
  def em_delete_or_list(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1686
  def em_delete_prev_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2310
  def em_exchange_mark(key); end

  # Editline:: +em-kill-line+ (not bound) Delete the entire contents of the
  #            edit buffer and save it to the cut buffer. +vi-kill-line-prev+
  # GNU Readline:: +kill-whole-line+ (not bound) Kill all characters on the
  #                current line, no matter where point is.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1743
  def em_kill_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1906
  def em_kill_region(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1880
  def em_lower_case(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1804
  def em_next_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2305
  def em_set_mark(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1893
  def em_upper_case(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1780
  def em_yank(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1786
  def em_yank_pop(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2318
  def emacs_editing_mode(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1657
  def end_of_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1435
  def end_of_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2316
  def exchange_point_and_mark(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:802
  def filter_normalize_candidates(target, list); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1400
  def forward_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1551
  def forward_search_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1810
  def forward_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1437
  def generate_searcher(direction); end

  # pkg:gem/reline#lib/reline/line_editor.rb:185
  def handle_interrupted; end

  # pkg:gem/reline#lib/reline/line_editor.rb:173
  def handle_resized; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1576
  def history_search_backward(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1591
  def history_search_forward(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:943
  def inclusive?(method_obj); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1514
  def incremental_search_history(direction); end

  # pkg:gem/reline#lib/reline/line_editor.rb:277
  def insert_new_line(cursor_line, next_line); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1378
  def insert_raw_char(str, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1276
  def key_delete(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1284
  def key_newline(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1716
  def kill_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1749
  def kill_whole_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1828
  def kill_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:798
  def menu(list); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1318
  def menu_complete(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1322
  def menu_complete_backward(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:786
  def modify_lines(before, complete); end

  # pkg:gem/reline#lib/reline/line_editor.rb:880
  def move_completed_list(direction); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1593
  def move_history(history_pointer, line:, cursor:); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2326
  def move_undo_redo(direction); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1647
  def next_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:825
  def perform_completion(preposing, target, postposing, quote, list); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2345
  def prev_action_state_value(type); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1630
  def previous_history(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1103
  def process_auto_indent(line_index = T.unsafe(nil), cursor_dependent: T.unsafe(nil), add_newline: T.unsafe(nil)); end

  # do nothing
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1334
  def process_insert(force: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:983
  def process_key(key, method_symbol); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2353
  def re_read_init_file(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2341
  def redo(_key); end

  # Reflects lines to be rendered and new cursor position to the screen
  # by calculating the difference from the previous render.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:507
  def render_differential(new_lines, new_cursor_x, new_cursor_y); end

  # pkg:gem/reline#lib/reline/line_editor.rb:892
  def retrieve_completion_journey_state; end

  # pkg:gem/reline#lib/reline/line_editor.rb:1546
  def reverse_search_history(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:907
  def run_for_operators(key, method_symbol); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1553
  def search_history(prefix, pointer_range); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2216
  def search_next_char(key, arg, need_prev_char: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2263
  def search_prev_char(key, arg, need_next_char = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1368
  def self_insert(str); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2308
  def set_mark(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2349
  def set_next_action_state(type, value); end

  # pkg:gem/reline#lib/reline/line_editor.rb:300
  def split_line_by_width(str, max_width, offset: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1855
  def transpose_chars(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1868
  def transpose_words(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2337
  def undo(_key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1737
  def unix_line_discard(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1914
  def unix_word_rubout(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1904
  def upcase_word(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:702
  def update_each_dialog(dialog, cursor_column, cursor_row, key = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1926
  def vi_add(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2022
  def vi_add_at_eol(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2041
  def vi_change_meta(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2053
  def vi_change_meta_confirm(byte_pointer_diff); end

  # Editline:: +vi_change_to_eol+ (vi command: +C+) + Kill and change from the cursor to the end of the line.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1719
  def vi_change_to_eol(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1931
  def vi_command_mode(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2059
  def vi_delete_meta(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2070
  def vi_delete_meta_confirm(byte_pointer_diff); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2003
  def vi_delete_prev_char(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2322
  def vi_editing_mode(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1988
  def vi_end_big_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2112
  def vi_end_of_transmission(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1955
  def vi_end_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2113
  def vi_eof_maybe(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1415
  def vi_first_print(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2138
  def vi_histedit(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1922
  def vi_insert(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2017
  def vi_insert_at_bol(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2296
  def vi_join_lines(key, arg: T.unsafe(nil)); end

  # Editline:: +vi-kill-line-prev+ (vi: +Ctrl-U+) Delete the string from the
  #            beginning  of the edit buffer to the cursor and save it to the
  #            cut buffer.
  # GNU Readline:: +unix-line-discard+ (+C-u+) Kill backward from the cursor
  #                to the beginning of the current line.
  #
  # pkg:gem/reline#lib/reline/line_editor.rb:1730
  def vi_kill_line_prev(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2104
  def vi_list_or_eof(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1935
  def vi_movement_mode(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1970
  def vi_next_big_word(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2208
  def vi_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1937
  def vi_next_word(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2159
  def vi_paste_next(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2150
  def vi_paste_prev(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1979
  def vi_prev_big_word(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2255
  def vi_prev_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1946
  def vi_prev_word(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2184
  def vi_replace_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1548
  def vi_search_next(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1543
  def vi_search_prev(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2175
  def vi_to_column(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2131
  def vi_to_history_line(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2212
  def vi_to_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2259
  def vi_to_prev_char(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2082
  def vi_yank(key, arg: T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:2093
  def vi_yank_confirm(byte_pointer_diff); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1424
  def vi_zero(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1784
  def yank(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:1794
  def yank_pop(key); end
end

# pkg:gem/reline#lib/reline/line_editor.rb:980
Reline::LineEditor::ARGUMENT_DIGIT_METHODS = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/line_editor.rb:45
class Reline::LineEditor::CompletionJourneyState < ::Struct
  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def line_index; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def line_index=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def list; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def list=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def pointer; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def pointer=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def post; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def post=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def pre; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def pre=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def target; end

  # pkg:gem/reline#lib/reline/line_editor.rb:45
  def target=(_); end

  class << self
    # pkg:gem/reline#lib/reline/line_editor.rb:45
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline/line_editor.rb:45
    def inspect; end

    # pkg:gem/reline#lib/reline/line_editor.rb:45
    def keyword_init?; end

    # pkg:gem/reline#lib/reline/line_editor.rb:45
    def members; end

    # pkg:gem/reline#lib/reline/line_editor.rb:45
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/line_editor.rb:38
Reline::LineEditor::CompletionState::MENU = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/line_editor.rb:39
Reline::LineEditor::CompletionState::MENU_WITH_PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/line_editor.rb:37
Reline::LineEditor::CompletionState::NORMAL = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/line_editor.rb:40
Reline::LineEditor::CompletionState::PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# pkg:gem/reline#lib/reline/line_editor.rb:694
Reline::LineEditor::DIALOG_DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

# pkg:gem/reline#lib/reline/line_editor.rb:640
class Reline::LineEditor::Dialog
  # pkg:gem/reline#lib/reline/line_editor.rb:644
  def initialize(name, config, proc_scope); end

  # pkg:gem/reline#lib/reline/line_editor.rb:668
  def call(key); end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def column; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def column=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:641
  def contents; end

  # pkg:gem/reline#lib/reline/line_editor.rb:661
  def contents=(contents); end

  # pkg:gem/reline#lib/reline/line_editor.rb:641
  def name; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def pointer; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def pointer=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def scroll_top; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def scroll_top=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:653
  def set_cursor_pos(col, row); end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def trap_key; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def trap_key=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def vertical_offset; end

  # pkg:gem/reline#lib/reline/line_editor.rb:642
  def vertical_offset=(_arg0); end

  # pkg:gem/reline#lib/reline/line_editor.rb:641
  def width; end

  # pkg:gem/reline#lib/reline/line_editor.rb:657
  def width=(v); end
end

# pkg:gem/reline#lib/reline/line_editor.rb:561
class Reline::LineEditor::DialogProcScope
  # pkg:gem/reline#lib/reline/line_editor.rb:564
  def initialize(line_editor, config, proc_to_exec, context); end

  # pkg:gem/reline#lib/reline/line_editor.rb:635
  def call; end

  # pkg:gem/reline#lib/reline/line_editor.rb:581
  def call_completion_proc_with_checking_args(pre, target, post); end

  # pkg:gem/reline#lib/reline/line_editor.rb:627
  def completion_journey_data; end

  # pkg:gem/reline#lib/reline/line_editor.rb:631
  def config; end

  # pkg:gem/reline#lib/reline/line_editor.rb:572
  def context; end

  # pkg:gem/reline#lib/reline/line_editor.rb:606
  def cursor_pos; end

  # pkg:gem/reline#lib/reline/line_editor.rb:589
  def dialog; end

  # pkg:gem/reline#lib/reline/line_editor.rb:610
  def just_cursor_moving; end

  # pkg:gem/reline#lib/reline/line_editor.rb:602
  def key; end

  # pkg:gem/reline#lib/reline/line_editor.rb:622
  def preferred_dialog_height; end

  # pkg:gem/reline#lib/reline/line_editor.rb:576
  def retrieve_completion_block(_unused = T.unsafe(nil)); end

  # pkg:gem/reline#lib/reline/line_editor.rb:618
  def screen_height; end

  # pkg:gem/reline#lib/reline/line_editor.rb:614
  def screen_width; end

  # pkg:gem/reline#lib/reline/line_editor.rb:593
  def set_cursor_pos(col, row); end

  # pkg:gem/reline#lib/reline/line_editor.rb:585
  def set_dialog(dialog); end

  # pkg:gem/reline#lib/reline/line_editor.rb:598
  def set_key(key); end
end

# pkg:gem/reline#lib/reline/line_editor.rb:562
class Reline::LineEditor::DialogProcScope::CompletionJourneyData < ::Struct
  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def list; end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def list=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def pointer; end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def pointer=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def postposing; end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def postposing=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def preposing; end

  # pkg:gem/reline#lib/reline/line_editor.rb:562
  def preposing=(_); end

  class << self
    # pkg:gem/reline#lib/reline/line_editor.rb:562
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline/line_editor.rb:562
    def inspect; end

    # pkg:gem/reline#lib/reline/line_editor.rb:562
    def keyword_init?; end

    # pkg:gem/reline#lib/reline/line_editor.rb:562
    def members; end

    # pkg:gem/reline#lib/reline/line_editor.rb:562
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/line_editor.rb:1050
Reline::LineEditor::MAX_UNDO_REDO_HISTORY_SIZE = T.let(T.unsafe(nil), Integer)

# pkg:gem/reline#lib/reline/line_editor.rb:71
Reline::LineEditor::MINIMUM_SCROLLBAR_HEIGHT = T.let(T.unsafe(nil), Integer)

# pkg:gem/reline#lib/reline/line_editor.rb:48
class Reline::LineEditor::MenuInfo
  # pkg:gem/reline#lib/reline/line_editor.rb:51
  def initialize(list); end

  # pkg:gem/reline#lib/reline/line_editor.rb:55
  def lines(screen_width); end

  # pkg:gem/reline#lib/reline/line_editor.rb:49
  def list; end
end

# pkg:gem/reline#lib/reline/line_editor.rb:46
Reline::LineEditor::NullActionState = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/line_editor.rb:43
class Reline::LineEditor::RenderedScreen < ::Struct
  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def base_y; end

  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def base_y=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def cursor_y; end

  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def cursor_y=(_); end

  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def lines; end

  # pkg:gem/reline#lib/reline/line_editor.rb:43
  def lines=(_); end

  class << self
    # pkg:gem/reline#lib/reline/line_editor.rb:43
    def [](*_arg0); end

    # pkg:gem/reline#lib/reline/line_editor.rb:43
    def inspect; end

    # pkg:gem/reline#lib/reline/line_editor.rb:43
    def keyword_init?; end

    # pkg:gem/reline#lib/reline/line_editor.rb:43
    def members; end

    # pkg:gem/reline#lib/reline/line_editor.rb:43
    def new(*_arg0); end
  end
end

# pkg:gem/reline#lib/reline/line_editor.rb:17
Reline::LineEditor::VI_MOTIONS = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/line_editor.rb:981
Reline::LineEditor::VI_WAITING_ACCEPT_METHODS = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline.rb:16
Reline::USERNAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

# pkg:gem/reline#lib/reline/unicode.rb:1
class Reline::Unicode
  class << self
    # pkg:gem/reline#lib/reline/unicode.rb:104
    def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

    # pkg:gem/reline#lib/reline/unicode.rb:393
    def common_prefix(list, ignore_case: T.unsafe(nil)); end

    # pkg:gem/reline#lib/reline/unicode.rb:75
    def east_asian_width(ord); end

    # pkg:gem/reline#lib/reline/unicode.rb:298
    def ed_transpose_words(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:284
    def em_backward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:291
    def em_big_backward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:270
    def em_forward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:277
    def em_forward_word_with_capitalization(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:44
    def escape_for_print(str); end

    # pkg:gem/reline#lib/reline/unicode.rb:81
    def get_mbchar_width(mbchar); end

    # pkg:gem/reline#lib/reline/unicode.rb:256
    def get_next_mbchar_size(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:261
    def get_prev_mbchar_size(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:57
    def safe_encode(str, encoding); end

    # pkg:gem/reline#lib/reline/unicode.rb:418
    def space_character?(s); end

    # This method is used by IRB
    #
    # pkg:gem/reline#lib/reline/unicode.rb:131
    def split_by_width(str, max_width); end

    # pkg:gem/reline#lib/reline/unicode.rb:136
    def split_line_by_width(str, max_width, encoding = T.unsafe(nil), offset: T.unsafe(nil)); end

    # pkg:gem/reline#lib/reline/unicode.rb:178
    def strip_non_printing_start_end(prompt); end

    # pkg:gem/reline#lib/reline/unicode.rb:187
    def take_mbchar_range(str, start_col, width, cover_begin: T.unsafe(nil), cover_end: T.unsafe(nil), padding: T.unsafe(nil)); end

    # Take a chunk of a String cut by width with escape sequences.
    #
    # pkg:gem/reline#lib/reline/unicode.rb:183
    def take_range(str, start_col, max_width); end

    # pkg:gem/reline#lib/reline/unicode.rb:384
    def vi_backward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:339
    def vi_big_backward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:329
    def vi_big_forward_end_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:322
    def vi_big_forward_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:406
    def vi_first_print(line); end

    # pkg:gem/reline#lib/reline/unicode.rb:366
    def vi_forward_end_word(line, byte_pointer); end

    # pkg:gem/reline#lib/reline/unicode.rb:346
    def vi_forward_word(line, byte_pointer, drop_terminate_spaces = T.unsafe(nil)); end

    # pkg:gem/reline#lib/reline/unicode.rb:412
    def word_character?(s); end
  end
end

# pkg:gem/reline#lib/reline/unicode.rb:40
Reline::Unicode::CSI_REGEXP = T.let(T.unsafe(nil), Regexp)

# This is based on EastAsianWidth.txt
# UNICODE_VERSION = '16.0.0'
#
# pkg:gem/reline#lib/reline/unicode/east_asian_width.rb:5
Reline::Unicode::EastAsianWidth::CHUNK_LAST = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/unicode/east_asian_width.rb:5
Reline::Unicode::EastAsianWidth::CHUNK_WIDTH = T.let(T.unsafe(nil), Array)

# pkg:gem/reline#lib/reline/unicode.rb:2
Reline::Unicode::EscapedPairs = T.let(T.unsafe(nil), Hash)

# pkg:gem/reline#lib/reline/unicode.rb:39
Reline::Unicode::NON_PRINTING_END = T.let(T.unsafe(nil), String)

# pkg:gem/reline#lib/reline/unicode.rb:38
Reline::Unicode::NON_PRINTING_START = T.let(T.unsafe(nil), String)

# pkg:gem/reline#lib/reline/unicode.rb:41
Reline::Unicode::OSC_REGEXP = T.let(T.unsafe(nil), Regexp)

# pkg:gem/reline#lib/reline/unicode.rb:42
Reline::Unicode::WIDTH_SCANNER = T.let(T.unsafe(nil), Regexp)

# pkg:gem/reline#lib/reline/version.rb:2
Reline::VERSION = T.let(T.unsafe(nil), String)
