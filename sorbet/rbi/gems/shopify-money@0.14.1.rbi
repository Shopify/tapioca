# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `shopify-money` gem.
# Please instead update this file by running `tapioca sync`.

# typed: true

ACTIVE_SUPPORT_DEFINED = T.let(T.unsafe(nil), String)

class AccountingMoneyParser < ::MoneyParser
  def parse(input, currency = T.unsafe(nil), **options); end
end

class Money
  include(::Comparable)
  extend(::Forwardable)

  def initialize(value, currency); end

  def *(numeric); end
  def +(other); end
  def -(other); end
  def -@; end
  def /(numeric); end
  def <=>(other); end
  def ==(other); end
  def abs; end
  def allocate(splits, strategy = T.unsafe(nil)); end
  def allocate_max_amounts(maximums); end
  def as_json(*args); end
  def calculate_splits(num); end
  def cents; end
  def clamp(min, max); end
  def coerce(other); end
  def currency; end
  def encode_with(coder); end
  def eql?(other); end
  def floor; end
  def fraction(rate); end
  def hash(*args, &block); end
  def init_with(coder); end
  def inspect; end
  def negative?(*args, &block); end
  def no_currency?; end
  def nonzero?(*args, &block); end
  def positive?(*args, &block); end
  def round(ndigits = T.unsafe(nil)); end
  def split(num); end
  def subunits; end
  def to_d; end
  def to_f(*args, &block); end
  def to_i(*args, &block); end
  def to_json(options = T.unsafe(nil)); end
  def to_liquid; end
  def to_money(curr = T.unsafe(nil)); end
  def to_s(style = T.unsafe(nil)); end
  def value; end
  def zero?(*args, &block); end

  private

  def arithmetic(money_or_numeric); end
  def calculated_currency(other); end

  class << self
    def active_support_deprecator; end
    def current_currency; end
    def current_currency=(currency); end
    def default_currency; end
    def default_currency=(_arg0); end
    def default_settings; end
    def deprecate(message); end
    def empty(currency = T.unsafe(nil)); end
    def from_amount(value = T.unsafe(nil), currency = T.unsafe(nil)); end
    def from_cents(cents, currency = T.unsafe(nil)); end
    def from_subunits(subunits, currency_iso); end
    def new(value = T.unsafe(nil), currency = T.unsafe(nil)); end
    def parse(*args); end
    def parser; end
    def parser=(_arg0); end
    def rational(money1, money2); end
    def with_currency(new_currency); end
    def zero(currency = T.unsafe(nil)); end
  end
end

class Money::Allocator < ::SimpleDelegator
  def initialize(money); end

  def allocate(splits, strategy = T.unsafe(nil)); end
  def allocate_max_amounts(maximums); end

  private

  def all_rational?(splits); end
  def allocation_index_for(strategy, length, idx); end
  def amounts_from_splits(allocations, splits, subunits_to_split = T.unsafe(nil)); end
  def extract_currency(money_array); end
end

class Money::Currency
  def initialize(currency_iso); end

  def ==(other); end
  def compatible?(other); end
  def decimal_mark; end
  def disambiguate_symbol; end
  def eql?(other); end
  def iso_code; end
  def iso_numeric; end
  def minor_units; end
  def name; end
  def smallest_denomination; end
  def subunit_symbol; end
  def subunit_to_unit; end
  def symbol; end
  def to_s; end

  class << self
    def currencies; end
    def find(currency_iso); end
    def find!(currency_iso); end
    def new(currency_iso); end
  end
end

module Money::Currency::Loader
  extend(::Money::Currency::Loader)

  def load_currencies; end

  private

  def parse_currency_file(filename); end
end

Money::Currency::Loader::CURRENCY_DATA_PATH = T.let(T.unsafe(nil), String)

class Money::Currency::UnknownCurrency < ::ArgumentError
end

class Money::Error < ::StandardError
end

module Money::Helpers

  private

  def string_to_decimal(num); end
  def value_to_currency(currency); end
  def value_to_decimal(num); end

  class << self
    def string_to_decimal(num); end
    def value_to_currency(currency); end
    def value_to_decimal(num); end
  end
end

Money::Helpers::DECIMAL_ZERO = T.let(T.unsafe(nil), BigDecimal)

Money::Helpers::MAX_DECIMAL = T.let(T.unsafe(nil), Integer)

Money::Helpers::NUMERIC_REGEX = T.let(T.unsafe(nil), Regexp)

class Money::IncompatibleCurrencyError < ::Money::Error
end

Money::NULL_CURRENCY = T.let(T.unsafe(nil), Money::NullCurrency)

class Money::NullCurrency
  def initialize; end

  def ==(other); end
  def compatible?(other); end
  def decimal_mark; end
  def disambiguate_symbol; end
  def eql?(other); end
  def iso_code; end
  def iso_numeric; end
  def minor_units; end
  def name; end
  def smallest_denomination; end
  def subunit_symbol; end
  def subunit_to_unit; end
  def symbol; end
  def to_s; end
end

class Money::ReverseOperationProxy
  include(::Comparable)

  def initialize(value); end

  def *(other); end
  def +(other); end
  def -(other); end
  def <=>(other); end
end

module MoneyAccessor
  mixes_in_class_methods(::MoneyAccessor::ClassMethods)

  class << self
    def included(base); end
  end
end

module MoneyAccessor::ClassMethods
  def money_accessor(*columns); end
end

module MoneyColumn
end

module MoneyColumn::ActiveRecordHooks
  mixes_in_class_methods(::MoneyColumn::ActiveRecordHooks::ClassMethods)

  def reload(*_arg0); end

  private

  def clear_money_column_cache; end
  def init_internals; end
  def initialize_dup(*_arg0); end
  def read_money_attribute(column); end
  def write_money_attribute(column, money); end

  class << self
    def included(base); end
  end
end

module MoneyColumn::ActiveRecordHooks::ClassMethods
  def money_column(*columns, currency_column: T.unsafe(nil), currency: T.unsafe(nil), currency_read_only: T.unsafe(nil), coerce_null: T.unsafe(nil)); end
  def money_column_options; end

  private

  def clear_cache_on_currency_change(currency_column); end
  def inherited(subclass); end
  def normalize_money_column_options(options); end
end

class MoneyColumn::ActiveRecordType < ::ActiveModel::Type::Decimal
  def serialize(money); end
end

class MoneyColumn::Railtie < ::Rails::Railtie
end

class MoneyParser
  def parse(input, currency = T.unsafe(nil), strict: T.unsafe(nil)); end

  private

  def extract_amount_from_string(input, currency, strict); end
  def last_digits_decimals?(digits, marks, currency); end
  def normalize_number(number, marks, currency); end

  class << self
    def parse(input, currency = T.unsafe(nil), **options); end
  end
end

MoneyParser::CHINESE_NUMERIC_REGEX = T.let(T.unsafe(nil), Regexp)

MoneyParser::COMMA_DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

MoneyParser::DOT_DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)

MoneyParser::ESCAPED_MARKS = T.let(T.unsafe(nil), String)

MoneyParser::ESCAPED_NON_COMMA_MARKS = T.let(T.unsafe(nil), String)

MoneyParser::ESCAPED_NON_DOT_MARKS = T.let(T.unsafe(nil), String)

MoneyParser::ESCAPED_NON_SPACE_MARKS = T.let(T.unsafe(nil), String)

MoneyParser::INDIAN_NUMERIC_REGEX = T.let(T.unsafe(nil), Regexp)

MoneyParser::MARKS = T.let(T.unsafe(nil), Array)

class MoneyParser::MoneyFormatError < ::ArgumentError
end

MoneyParser::NUMERIC_REGEX = T.let(T.unsafe(nil), Regexp)

class Numeric
  include(::Comparable)

  def to_money(currency = T.unsafe(nil)); end
end

Numeric::EXABYTE = T.let(T.unsafe(nil), Integer)

Numeric::GIGABYTE = T.let(T.unsafe(nil), Integer)

Numeric::KILOBYTE = T.let(T.unsafe(nil), Integer)

Numeric::MEGABYTE = T.let(T.unsafe(nil), Integer)

Numeric::PETABYTE = T.let(T.unsafe(nil), Integer)

Numeric::TERABYTE = T.let(T.unsafe(nil), Integer)

class String
  include(::Comparable)
  include(::JSON::Ext::Generator::GeneratorMethods::String)
  include(::Colorize::InstanceMethods)
  extend(::JSON::Ext::Generator::GeneratorMethods::String::Extend)
  extend(::Colorize::ClassMethods)

  def to_money(currency = T.unsafe(nil)); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)

String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
