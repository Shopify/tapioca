# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sequel` gem.
# Please instead update this file by running `tapioca generate sequel`.

# typed: true

module Sequel
  include(::Sequel::SQL::Constants)
  extend(::Sequel::SequelMethods)
  extend(::Sequel::SQL::Builders)
  extend(::Sequel::SQL::OperatorBuilders)

  class << self
    def Model(source); end
    def [](arg = T.unsafe(nil), &block); end
    def ado(*args, &block); end
    def amalgalite(*args, &block); end
    def ibmdb(*args, &block); end
    def inflections; end
    def jdbc(*args, &block); end
    def mock(*args, &block); end
    def mysql(*args, &block); end
    def mysql2(*args, &block); end
    def odbc(*args, &block); end
    def oracle(*args, &block); end
    def postgres(*args, &block); end
    def sqlanywhere(*args, &block); end
    def sqlite(*args, &block); end
    def tinytds(*args, &block); end
    def version; end
  end
end

Sequel::ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

class Sequel::ASTTransformer
  def transform(obj); end

  private

  def v(o); end
end

class Sequel::AdapterNotFound < ::Sequel::Error
end

class Sequel::BasicObject < ::BasicObject
  class << self
    def const_missing(name); end
  end
end

class Sequel::CheckConstraintViolation < ::Sequel::ConstraintViolation
end

class Sequel::ConnectionPool
  extend(::Sequel::ConnectionPool::ClassMethods)

  def initialize(db, opts = T.unsafe(nil)); end

  def after_connect; end
  def after_connect=(_arg0); end
  def connect_sqls; end
  def connect_sqls=(_arg0); end
  def db; end
  def db=(_arg0); end
  def servers; end

  private

  def disconnect_connection(conn); end
  def disconnect_error?(exception); end
  def make_new(server); end
end

module Sequel::ConnectionPool::ClassMethods
  def get_pool(db, opts = T.unsafe(nil)); end

  private

  def connection_pool_class(opts); end
end

Sequel::ConnectionPool::OPTS = T.let(T.unsafe(nil), Hash)

Sequel::ConnectionPool::POOL_CLASS_MAP = T.let(T.unsafe(nil), Hash)

class Sequel::ConstraintViolation < ::Sequel::DatabaseError
end

Sequel::DATABASES = T.let(T.unsafe(nil), Array)

Sequel::DEFAULT_INFLECTIONS_PROC = T.let(T.unsafe(nil), Proc)

class Sequel::Database
  def initialize(opts = T.unsafe(nil)); end

  def <<(sql); end
  def [](*args); end
  def adapter_scheme; end
  def add_column(table, *args); end
  def add_index(table, columns, options = T.unsafe(nil)); end
  def add_servers(servers); end
  def after_commit(opts = T.unsafe(nil), &block); end
  def after_rollback(opts = T.unsafe(nil), &block); end
  def alter_table(name, &block); end
  def alter_table_generator(&block); end
  def cache_schema; end
  def cache_schema=(_arg0); end
  def call(ps_name, hash = T.unsafe(nil), &block); end
  def cast_type_literal(type); end
  def create_join_table(hash, options = T.unsafe(nil)); end
  def create_join_table!(hash, options = T.unsafe(nil)); end
  def create_join_table?(hash, options = T.unsafe(nil)); end
  def create_or_replace_view(name, source, options = T.unsafe(nil)); end
  def create_table(name, options = T.unsafe(nil), &block); end
  def create_table!(name, options = T.unsafe(nil), &block); end
  def create_table?(name, options = T.unsafe(nil), &block); end
  def create_table_generator(&block); end
  def create_view(name, source, options = T.unsafe(nil)); end
  def database_type; end
  def dataset; end
  def dataset_class; end
  def dataset_class=(c); end
  def default_string_column_size; end
  def default_string_column_size=(_arg0); end
  def disconnect(opts = T.unsafe(nil)); end
  def disconnect_connection(conn); end
  def drop_column(table, *args); end
  def drop_index(table, columns, options = T.unsafe(nil)); end
  def drop_join_table(hash, options = T.unsafe(nil)); end
  def drop_table(*names); end
  def drop_table?(*names); end
  def drop_view(*names); end
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end
  def execute_dui(sql, opts = T.unsafe(nil), &block); end
  def execute_insert(sql, opts = T.unsafe(nil), &block); end
  def extend_datasets(mod = T.unsafe(nil), &block); end
  def extension(*exts); end
  def fetch(sql, *args, &block); end
  def freeze; end
  def from(*args, &block); end
  def from_application_timestamp(v); end
  def get(*args, &block); end
  def global_index_namespace?; end
  def in_transaction?(opts = T.unsafe(nil)); end
  def inspect; end
  def literal(v); end
  def literal_symbol(sym); end
  def literal_symbol_set(sym, lit); end
  def log_connection_info; end
  def log_connection_info=(_arg0); end
  def log_connection_yield(sql, conn, args = T.unsafe(nil)); end
  def log_exception(exception, message); end
  def log_info(message, args = T.unsafe(nil)); end
  def log_warn_duration; end
  def log_warn_duration=(_arg0); end
  def logger=(logger); end
  def loggers; end
  def loggers=(_arg0); end
  def opts; end
  def pool; end
  def prepared_statement(name); end
  def prepared_statements; end
  def quote_identifier(v); end
  def remove_servers(*servers); end
  def rename_column(table, *args); end
  def rename_table(name, new_name); end
  def rollback_checker(opts = T.unsafe(nil)); end
  def rollback_on_exit(opts = T.unsafe(nil)); end
  def run(sql, opts = T.unsafe(nil)); end
  def schema(table, opts = T.unsafe(nil)); end
  def schema_type_class(type); end
  def select(*args, &block); end
  def serial_primary_key_options; end
  def servers; end
  def set_column_default(table, *args); end
  def set_column_type(table, *args); end
  def set_prepared_statement(name, ps); end
  def sharded?; end
  def single_threaded?; end
  def sql_log_level; end
  def sql_log_level=(_arg0); end
  def supports_create_table_if_not_exists?; end
  def supports_deferrable_constraints?; end
  def supports_deferrable_foreign_key_constraints?; end
  def supports_drop_table_if_exists?; end
  def supports_foreign_key_parsing?; end
  def supports_index_parsing?; end
  def supports_partial_indexes?; end
  def supports_prepared_transactions?; end
  def supports_savepoints?; end
  def supports_savepoints_in_prepared_transactions?; end
  def supports_schema_parsing?; end
  def supports_table_listing?; end
  def supports_transaction_isolation_levels?; end
  def supports_transactional_ddl?; end
  def supports_view_listing?; end
  def supports_views_with_check_option?; end
  def supports_views_with_local_check_option?; end
  def synchronize(server = T.unsafe(nil), &block); end
  def table_exists?(name); end
  def test_connection(server = T.unsafe(nil)); end
  def timezone; end
  def timezone=(_arg0); end
  def to_application_timestamp(v); end
  def transaction(opts = T.unsafe(nil), &block); end
  def transaction_isolation_level; end
  def transaction_isolation_level=(_arg0); end
  def typecast_value(column_type, value); end
  def uri; end
  def url; end
  def valid_connection?(conn); end

  private

  def _metadata_dataset; end
  def _table_exists?(ds); end
  def _trans(conn); end
  def _transaction(conn, opts = T.unsafe(nil)); end
  def _typecast_value_string_to_decimal(*_arg0); end
  def adapter_initialize; end
  def add_savepoint_hook(conn, type, block); end
  def add_transaction(conn, opts); end
  def add_transaction_hook(conn, type, block); end
  def already_in_transaction?(conn, opts); end
  def alter_table_add_column_sql(table, op); end
  def alter_table_add_constraint_sql(table, op); end
  def alter_table_drop_column_sql(table, op); end
  def alter_table_drop_constraint_sql(table, op); end
  def alter_table_generator_class; end
  def alter_table_op_sql(table, op); end
  def alter_table_rename_column_sql(table, op); end
  def alter_table_set_column_default_sql(table, op); end
  def alter_table_set_column_null_sql(table, op); end
  def alter_table_set_column_type_sql(table, op); end
  def alter_table_sql(table, op); end
  def alter_table_sql_list(table, operations); end
  def apply_alter_table(name, ops); end
  def apply_alter_table_generator(name, generator); end
  def auto_increment_sql; end
  def begin_new_transaction(conn, opts); end
  def begin_savepoint(conn, opts); end
  def begin_savepoint_sql(depth); end
  def begin_transaction(conn, opts = T.unsafe(nil)); end
  def begin_transaction_sql; end
  def blank_object?(obj); end
  def can_add_primary_key_constraint_on_nullable_columns?; end
  def column_definition_auto_increment_sql(sql, column); end
  def column_definition_collate_sql(sql, column); end
  def column_definition_default_sql(sql, column); end
  def column_definition_null_sql(sql, column); end
  def column_definition_order; end
  def column_definition_primary_key_sql(sql, column); end
  def column_definition_references_sql(sql, column); end
  def column_definition_sql(column); end
  def column_definition_unique_sql(sql, column); end
  def column_list_sql(generator); end
  def column_references_column_constraint_sql(column); end
  def column_references_sql(column); end
  def column_references_table_constraint_sql(constraint); end
  def column_schema_default_string_type?(type); end
  def column_schema_default_to_ruby_value(default, type); end
  def column_schema_max_length(db_type); end
  def column_schema_normalize_default(default, type); end
  def column_schema_to_ruby_default(default, type); end
  def combinable_alter_table_op?(op); end
  def commit_or_rollback_transaction(exception, conn, opts); end
  def commit_savepoint_sql(depth); end
  def commit_transaction(conn, opts = T.unsafe(nil)); end
  def commit_transaction_sql; end
  def connection_execute_method; end
  def connection_info(conn); end
  def connection_pool_default_options; end
  def constraint_deferrable_sql_append(sql, defer); end
  def constraint_definition_sql(constraint); end
  def create_table_as(name, sql, options); end
  def create_table_as_sql(name, sql, options); end
  def create_table_from_generator(name, generator, options); end
  def create_table_generator_class; end
  def create_table_indexes_from_generator(name, generator, options); end
  def create_table_prefix_sql(name, options); end
  def create_table_sql(name, generator, options); end
  def create_view_prefix_sql(name, options); end
  def create_view_sql(name, source, options); end
  def create_view_sql_append_columns(sql, columns); end
  def database_error_class(exception, opts); end
  def database_error_classes; end
  def database_error_regexps; end
  def database_exception_sqlstate(exception, opts); end
  def database_specific_error_class(exception, opts); end
  def database_specific_error_class_from_sqlstate(sqlstate); end
  def dataset_class_default; end
  def default_index_name(table_name, columns); end
  def disconnect_error?(exception, opts); end
  def drop_index_sql(table, op); end
  def drop_table_sql(name, options); end
  def drop_view_sql(name, options); end
  def filter_expr(arg = T.unsafe(nil), &block); end
  def folds_unquoted_identifiers_to_uppercase?; end
  def foreign_key_name(table_name, columns); end
  def in_savepoint?(conn); end
  def index_definition_sql(table_name, index); end
  def index_sql_list(table_name, indexes); end
  def initialize_load_extensions(key); end
  def input_identifier_meth(ds = T.unsafe(nil)); end
  def join_table_name(hash, options); end
  def join_table_name_extract(entry); end
  def log_connection_execute(conn, sql); end
  def log_duration(duration, message); end
  def log_each(level, message); end
  def metadata_dataset; end
  def on_delete_clause(action); end
  def on_update_clause(action); end
  def output_identifier_meth(ds = T.unsafe(nil)); end
  def primary_key_constraint_sql_fragment(_); end
  def quote_identifiers_default; end
  def quote_schema_table(table); end
  def raise_error(exception, opts = T.unsafe(nil)); end
  def remove_cached_schema(table); end
  def remove_transaction(conn, committed); end
  def rename_table_sql(name, new_name); end
  def reset_default_dataset; end
  def rollback_on_transaction_exit?(conn, opts); end
  def rollback_savepoint_sql(depth); end
  def rollback_transaction(conn, opts = T.unsafe(nil)); end
  def rollback_transaction_sql; end
  def savepoint_hooks(conn, committed); end
  def savepoint_level(conn); end
  def schema_and_table(table_name); end
  def schema_autoincrementing_primary_key?(schema); end
  def schema_column_type(db_type); end
  def schema_post_process(cols); end
  def schema_utility_dataset; end
  def server_opts(server); end
  def set_transaction_isolation(conn, opts); end
  def set_transaction_isolation_sql(level); end
  def skip_logging?; end
  def split_qualifiers(table_name); end
  def supports_combining_alter_table_ops?; end
  def supports_create_or_replace_view?; end
  def supports_named_column_constraints?; end
  def swallow_database_error; end
  def temporary_table_sql; end
  def transaction_error(e, opts = T.unsafe(nil)); end
  def transaction_finished?(conn); end
  def transaction_hooks(conn, committed); end
  def transaction_options(conn, opts); end
  def type_literal(column); end
  def type_literal_generic(column); end
  def type_literal_generic_bigdecimal(column); end
  def type_literal_generic_bignum_symbol(column); end
  def type_literal_generic_date(column); end
  def type_literal_generic_datetime(column); end
  def type_literal_generic_falseclass(column); end
  def type_literal_generic_file(column); end
  def type_literal_generic_fixnum(column); end
  def type_literal_generic_float(column); end
  def type_literal_generic_integer(column); end
  def type_literal_generic_numeric(column); end
  def type_literal_generic_only_time(column); end
  def type_literal_generic_string(column); end
  def type_literal_generic_time(column); end
  def type_literal_generic_trueclass(column); end
  def type_literal_specific(column); end
  def typecast_value_blob(value); end
  def typecast_value_boolean(value); end
  def typecast_value_date(value); end
  def typecast_value_datetime(value); end
  def typecast_value_decimal(value); end
  def typecast_value_float(*_arg0); end
  def typecast_value_integer(value); end
  def typecast_value_string(value); end
  def typecast_value_time(value); end
  def unique_constraint_sql_fragment(_); end
  def uses_clob_for_text?; end
  def valid_connection_sql; end
  def view_with_check_option_support; end

  class << self
    def adapter_class(scheme); end
    def adapter_scheme; end
    def after_initialize(&block); end
    def connect(conn_string, opts = T.unsafe(nil)); end
    def extension(*extensions); end
    def load_adapter(scheme, opts = T.unsafe(nil)); end
    def register_extension(ext, mod = T.unsafe(nil), &block); end
    def run_after_initialize(instance); end
    def set_shared_adapter_scheme(scheme, mod); end

    private

    def set_adapter_scheme(scheme); end
    def uri_to_options(uri); end
  end
end

Sequel::Database::ADAPTERS = T.let(T.unsafe(nil), Array)

Sequel::Database::CHECK_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

Sequel::Database::COLUMN_DEFINITION_ORDER = T.let(T.unsafe(nil), Array)

Sequel::Database::COLUMN_SCHEMA_DATETIME_TYPES = T.let(T.unsafe(nil), Array)

Sequel::Database::COLUMN_SCHEMA_STRING_TYPES = T.let(T.unsafe(nil), Array)

Sequel::Database::COMBINABLE_ALTER_TABLE_OPS = T.let(T.unsafe(nil), Array)

Sequel::Database::DEFAULT_DATABASE_ERROR_REGEXPS = T.let(T.unsafe(nil), Hash)

Sequel::Database::DEFAULT_STRING_COLUMN_SIZE = T.let(T.unsafe(nil), Integer)

Sequel::Database::EXTENSIONS = T.let(T.unsafe(nil), Hash)

Sequel::Database::FOREIGN_KEY_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

Sequel::Database::NOT_NULL_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

Sequel::Database::OPTS = T.let(T.unsafe(nil), Hash)

Sequel::Database::SCHEMA_TYPE_CLASSES = T.let(T.unsafe(nil), Hash)

Sequel::Database::SERIALIZATION_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

Sequel::Database::TRANSACTION_ISOLATION_LEVELS = T.let(T.unsafe(nil), Hash)

Sequel::Database::UNIQUE_CONSTRAINT_SQLSTATES = T.let(T.unsafe(nil), Array)

class Sequel::DatabaseConnectionError < ::Sequel::DatabaseError
end

class Sequel::DatabaseDisconnectError < ::Sequel::DatabaseError
end

class Sequel::DatabaseError < ::Sequel::Error
end

class Sequel::DatabaseLockTimeout < ::Sequel::DatabaseError
end

class Sequel::Dataset
  include(::Enumerable)
  include(::Sequel::SQL::AliasMethods)
  include(::Sequel::SQL::BooleanMethods)
  include(::Sequel::SQL::CastMethods)
  include(::Sequel::SQL::ComplexExpressionMethods)
  include(::Sequel::SQL::InequalityMethods)
  include(::Sequel::SQL::NumericMethods)
  include(::Sequel::SQL::OrderMethods)
  include(::Sequel::SQL::StringMethods)

  def initialize(db); end

  def <<(arg); end
  def ==(o); end
  def [](*conditions); end
  def add_graph_aliases(graph_aliases); end
  def aliased_expression_sql_append(sql, ae); end
  def all(&block); end
  def array_sql_append(sql, a); end
  def as_hash(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def avg(arg = T.unsafe(nil), &block); end
  def bind(bind_vars = T.unsafe(nil)); end
  def boolean_constant_sql_append(sql, constant); end
  def call(type, bind_variables = T.unsafe(nil), *values, &block); end
  def case_expression_sql_append(sql, ce); end
  def cast_sql_append(sql, expr, type); end
  def clone(opts = T.unsafe(nil)); end
  def column_all_sql_append(sql, ca); end
  def columns; end
  def columns!; end
  def complex_expression_sql_append(sql, op, args); end
  def constant_sql_append(sql, constant); end
  def count(arg = T.unsafe(nil), &block); end
  def cross_join(table, opts = T.unsafe(nil)); end
  def current_datetime; end
  def db; end
  def delayed_evaluation_sql_append(sql, delay); end
  def delete(&block); end
  def delete_sql; end
  def distinct(*args, &block); end
  def dup; end
  def each; end
  def each_server; end
  def empty?; end
  def eql?(o); end
  def escape_like(string); end
  def except(dataset, opts = T.unsafe(nil)); end
  def exclude(*cond, &block); end
  def exclude_having(*cond, &block); end
  def exists; end
  def extension(*a); end
  def filter(*cond, &block); end
  def first(*args, &block); end
  def first!(*args, &block); end
  def first_source; end
  def first_source_alias; end
  def first_source_table; end
  def for_update; end
  def freeze; end
  def from(*source, &block); end
  def from_self(opts = T.unsafe(nil)); end
  def full_join(*args, &block); end
  def full_outer_join(*args, &block); end
  def function_sql_append(sql, f); end
  def get(column = T.unsafe(nil), &block); end
  def graph(dataset, join_conditions = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def grep(columns, patterns, opts = T.unsafe(nil)); end
  def group(*columns, &block); end
  def group_and_count(*columns, &block); end
  def group_append(*columns, &block); end
  def group_by(*columns, &block); end
  def group_cube; end
  def group_rollup; end
  def grouping_sets; end
  def hash; end
  def having(*cond, &block); end
  def import(columns, values, opts = T.unsafe(nil)); end
  def inner_join(*args, &block); end
  def insert(*values, &block); end
  def insert_sql(*values); end
  def inspect; end
  def intersect(dataset, opts = T.unsafe(nil)); end
  def invert; end
  def join(*args, &block); end
  def join_clause_sql_append(sql, jc); end
  def join_on_clause_sql_append(sql, jc); end
  def join_table(type, table, expr = T.unsafe(nil), options = T.unsafe(nil), &block); end
  def join_using_clause_sql_append(sql, jc); end
  def joined_dataset?; end
  def last(*args, &block); end
  def lateral; end
  def left_join(*args, &block); end
  def left_outer_join(*args, &block); end
  def limit(l, o = T.unsafe(nil)); end
  def literal(*args, &block); end
  def literal_append(sql, v); end
  def lock_style(style); end
  def map(column = T.unsafe(nil), &block); end
  def max(arg = T.unsafe(nil), &block); end
  def min(arg = T.unsafe(nil), &block); end
  def multi_insert(hashes, opts = T.unsafe(nil)); end
  def multi_insert_sql(columns, values); end
  def naked; end
  def natural_full_join(table, opts = T.unsafe(nil)); end
  def natural_join(table, opts = T.unsafe(nil)); end
  def natural_left_join(table, opts = T.unsafe(nil)); end
  def natural_right_join(table, opts = T.unsafe(nil)); end
  def negative_boolean_constant_sql_append(sql, constant); end
  def nowait; end
  def offset(o); end
  def opts; end
  def or(*cond, &block); end
  def order(*columns, &block); end
  def order_append(*columns, &block); end
  def order_by(*columns, &block); end
  def order_more(*columns, &block); end
  def order_prepend(*columns, &block); end
  def ordered_expression_sql_append(sql, oe); end
  def paged_each(opts = T.unsafe(nil)); end
  def placeholder_literal_string_sql_append(sql, pls); end
  def prepare(type, name, *values); end
  def provides_accurate_rows_matched?; end
  def qualified_identifier_sql_append(sql, table, column = T.unsafe(nil)); end
  def qualify(table = T.unsafe(nil)); end
  def quote_identifier(*args, &block); end
  def quote_identifier_append(sql, name); end
  def quote_identifiers?; end
  def quote_schema_table(*args, &block); end
  def quote_schema_table_append(sql, table); end
  def quoted_identifier_append(sql, name); end
  def recursive_cte_requires_column_aliases?; end
  def requires_placeholder_type_specifiers?; end
  def requires_sql_standard_datetimes?; end
  def returning(*values); end
  def reverse(*order, &block); end
  def reverse_order(*order, &block); end
  def right_join(*args, &block); end
  def right_outer_join(*args, &block); end
  def row_number_column; end
  def row_proc; end
  def schema_and_table(table_name, sch = T.unsafe(nil)); end
  def select(*columns, &block); end
  def select_all(*tables); end
  def select_append(*columns, &block); end
  def select_group(*columns, &block); end
  def select_hash(key_column, value_column, opts = T.unsafe(nil)); end
  def select_hash_groups(key_column, value_column, opts = T.unsafe(nil)); end
  def select_map(column = T.unsafe(nil), &block); end
  def select_more(*columns, &block); end
  def select_order_map(column = T.unsafe(nil), &block); end
  def select_sql; end
  def server(servr); end
  def server?(server); end
  def set_graph_aliases(graph_aliases); end
  def single_record; end
  def single_record!; end
  def single_value; end
  def single_value!; end
  def skip_limit_check; end
  def skip_locked; end
  def split_alias(c); end
  def split_qualifiers(table_name, *args); end
  def sql; end
  def subscript_sql_append(sql, s); end
  def sum(arg = T.unsafe(nil), &block); end
  def supports_cte?(type = T.unsafe(nil)); end
  def supports_cte_in_subqueries?; end
  def supports_derived_column_lists?; end
  def supports_distinct_on?; end
  def supports_group_cube?; end
  def supports_group_rollup?; end
  def supports_grouping_sets?; end
  def supports_insert_select?; end
  def supports_intersect_except?; end
  def supports_intersect_except_all?; end
  def supports_is_true?; end
  def supports_join_using?; end
  def supports_lateral_subqueries?; end
  def supports_limits_in_correlated_subqueries?; end
  def supports_modifying_joins?; end
  def supports_multiple_column_in?; end
  def supports_nowait?; end
  def supports_offsets_in_correlated_subqueries?; end
  def supports_ordered_distinct_on?; end
  def supports_regexp?; end
  def supports_replace?; end
  def supports_returning?(type); end
  def supports_select_all_and_column?; end
  def supports_skip_locked?; end
  def supports_timestamp_timezones?; end
  def supports_timestamp_usecs?; end
  def supports_where_true?; end
  def supports_window_clause?; end
  def supports_window_function_frame_option?(option); end
  def supports_window_functions?; end
  def to_hash(*a); end
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def truncate; end
  def truncate_sql; end
  def unfiltered; end
  def ungraphed; end
  def ungrouped; end
  def union(dataset, opts = T.unsafe(nil)); end
  def unlimited; end
  def unordered; end
  def unqualified_column_for(v); end
  def unused_table_alias(table_alias, used_aliases = T.unsafe(nil)); end
  def update(values = T.unsafe(nil), &block); end
  def update_sql(values = T.unsafe(nil)); end
  def where(*cond, &block); end
  def where_all(cond, &block); end
  def where_each(cond, &block); end
  def where_single_value(cond); end
  def window(name, opts); end
  def window_sql_append(sql, opts); end
  def with(name, dataset, opts = T.unsafe(nil)); end
  def with_extend(*mods, &block); end
  def with_quote_identifiers(v); end
  def with_recursive(name, nonrecursive, recursive, opts = T.unsafe(nil)); end
  def with_row_proc(callable); end
  def with_sql(sql, *args); end
  def with_sql_all(sql, &block); end
  def with_sql_delete(sql); end
  def with_sql_each(sql); end
  def with_sql_first(sql); end
  def with_sql_insert(sql); end
  def with_sql_single_value(sql); end
  def with_sql_update(sql); end

  protected

  def _columns; end
  def _import(columns, values, opts); end
  def _select_map_multiple(ret_cols); end
  def _select_map_single; end
  def cache; end
  def cache_get(k); end
  def cache_set(k, v); end
  def clear_columns_cache; end
  def compound_clone(type, dataset, opts); end
  def compound_from_self; end
  def options_overlap(opts); end
  def simple_select_all?; end
  def single_value_ds; end
  def to_prepared_statement(type, values = T.unsafe(nil), opts = T.unsafe(nil)); end

  private

  def _aggregate(function, arg); end
  def _all(block); end
  def _clone(*_arg0); end
  def _extension!(exts); end
  def _hash_key_symbol(s, recursing = T.unsafe(nil)); end
  def _insert_sql; end
  def _invert_filter(cond, invert); end
  def _select_hash(meth, key_column, value_column, opts = T.unsafe(nil)); end
  def _select_map(column, order, &block); end
  def _single_record_ds; end
  def _truncate_sql(table); end
  def _unqualified_column_for(v); end
  def _update_sql; end
  def _where_loader(where_args, where_block); end
  def _with_sql_dataset; end
  def add_filter(clause, cond, invert = T.unsafe(nil), combine = T.unsafe(nil), &block); end
  def aggregate_dataset; end
  def alias_alias_symbol(s); end
  def alias_symbol(sym); end
  def allow_preparing_prepared_statements?; end
  def as_sql_append(sql, aliaz, column_aliases = T.unsafe(nil)); end
  def auto_alias_expression(v); end
  def bound_variable_modules; end
  def cache_sql?; end
  def cached_dataset(key); end
  def cached_placeholder_literalizer(key); end
  def cached_where_placeholder_literalizer(where_args, where_block, key, &block); end
  def check_modification_allowed!; end
  def check_not_limited!(type); end
  def check_truncation_allowed!; end
  def column_list_append(sql, columns); end
  def columns=(v); end
  def complex_expression_arg_pairs(args); end
  def complex_expression_arg_pairs_append(sql, args, &block); end
  def complex_expression_emulate_append(sql, op, args); end
  def compound_dataset_sql_append(sql, ds); end
  def dataset_alias(number); end
  def default_import_slice; end
  def default_join_table_qualification; end
  def default_server; end
  def default_server_opts(opts); end
  def default_timestamp_format; end
  def delete_delete_sql(sql); end
  def delete_from_sql(sql); end
  def delete_order_sql(sql); end
  def delete_returning_sql(sql); end
  def delete_where_sql(sql); end
  def delete_with_sql(sql); end
  def disable_sql_caching!; end
  def empty_array_value(op, cols); end
  def empty_from_sql; end
  def emulate_function?(name); end
  def emulate_prepared_statements?; end
  def execute(sql, opts = T.unsafe(nil), &block); end
  def execute_ddl(sql, opts = T.unsafe(nil), &block); end
  def execute_dui(sql, opts = T.unsafe(nil), &block); end
  def execute_insert(sql, opts = T.unsafe(nil), &block); end
  def expression_list_append(sql, columns); end
  def filter_expr(expr = T.unsafe(nil), &block); end
  def format_timestamp(v); end
  def format_timestamp_offset(hour, minute); end
  def format_timestamp_usec(usec, ts = T.unsafe(nil)); end
  def graph_alias_columns(graph_aliases); end
  def grouping_element_list_append(sql, columns); end
  def hash_key_symbol(s); end
  def hash_key_symbols(s); end
  def hoist_cte(ds); end
  def hoist_cte?(ds); end
  def identifier_append(sql, v); end
  def identifier_list_append(sql, args); end
  def ignore_values_preceding(row); end
  def initialize_clone(c, _ = T.unsafe(nil)); end
  def initialize_copy(c, _ = T.unsafe(nil)); end
  def input_identifier(v); end
  def insert_columns_sql(sql); end
  def insert_empty_columns_values; end
  def insert_insert_sql(sql); end
  def insert_into_sql(sql); end
  def insert_returning_sql(sql); end
  def insert_supports_empty_values?; end
  def insert_values_sql(sql); end
  def insert_with_sql(sql); end
  def invert_order(order); end
  def join_type_sql(join_type); end
  def literal_array_append(sql, v); end
  def literal_big_decimal(v); end
  def literal_blob_append(sql, v); end
  def literal_dataset_append(sql, v); end
  def literal_date(v); end
  def literal_datetime(v); end
  def literal_datetime_append(sql, v); end
  def literal_expression_append(sql, v); end
  def literal_false; end
  def literal_float(v); end
  def literal_hash_append(sql, v); end
  def literal_integer(v); end
  def literal_nil; end
  def literal_other_append(sql, v); end
  def literal_sqltime(v); end
  def literal_sqltime_append(sql, v); end
  def literal_string_append(sql, v); end
  def literal_symbol_append(sql, v); end
  def literal_time(v); end
  def literal_time_append(sql, v); end
  def literal_true; end
  def multi_insert_sql_strategy; end
  def native_function_name(emulated_function); end
  def non_sql_option?(key); end
  def output_identifier(v); end
  def post_load(all_records); end
  def prepared_arg_placeholder; end
  def prepared_statement_modules; end
  def qualified_column_name(column, table); end
  def qualified_expression(e, table); end
  def qualifier_from_alias_symbol(aliaz, identifier); end
  def requires_emulating_nulls_first?; end
  def requires_like_escape?; end
  def returning_fetch_rows(sql, &block); end
  def select_columns_sql(sql); end
  def select_compounds_sql(sql); end
  def select_distinct_sql(sql); end
  def select_from_sql(sql); end
  def select_group_sql(sql); end
  def select_having_sql(sql); end
  def select_join_sql(sql); end
  def select_limit_sql(sql); end
  def select_lock_sql(sql); end
  def select_only_offset_sql(sql); end
  def select_order_sql(sql); end
  def select_select_sql(sql); end
  def select_where_sql(sql); end
  def select_window_sql(sql); end
  def select_with_sql(sql); end
  def select_with_sql_base; end
  def select_with_sql_prefix(sql, w); end
  def skip_symbol_cache?; end
  def source_list_append(sql, sources); end
  def split_symbol(sym); end
  def sql_string_origin; end
  def sqltime_precision; end
  def static_sql(sql); end
  def subselect_sql_append(sql, ds); end
  def subselect_sql_dataset(sql, ds); end
  def supports_cte_in_compounds?; end
  def supports_filtered_aggregates?; end
  def supports_quoted_function_names?; end
  def timestamp_precision; end
  def unaliased_identifier(c); end
  def update_order_sql(sql); end
  def update_returning_sql(sql); end
  def update_set_sql(sql); end
  def update_sql_values_hash(sql, values); end
  def update_table_sql(sql); end
  def update_update_sql(sql); end
  def update_where_sql(sql); end
  def update_with_sql(sql); end
  def uses_returning?(type); end
  def uses_with_rollup?; end
  def virtual_row_columns(columns, block); end
  def visible_class_name; end
  def window_frame_boundary_sql_append(sql, boundary, direction); end

  class << self
    def clause_methods(type, clauses); end
    def def_sql_method(mod, type, clauses); end
    def register_extension(ext, mod = T.unsafe(nil), &block); end

    private

    def prepared_statements_module(code, mods, meths = T.unsafe(nil), &block); end
  end
end

Sequel::Dataset::ACTION_METHODS = T.let(T.unsafe(nil), Array)

module Sequel::Dataset::ArgumentMapper
  def bind_arguments; end
  def call(bind_vars = T.unsafe(nil), &block); end
  def prepared_sql; end
  def prepared_statement_name; end

  private

  def emulate_prepared_statements?; end
end

Sequel::Dataset::BITWISE_METHOD_MAP = T.let(T.unsafe(nil), Hash)

Sequel::Dataset::COLUMNS_CLONE_OPTIONS = T.let(T.unsafe(nil), Hash)

Sequel::Dataset::COLUMN_CHANGE_OPTS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::CONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)

Sequel::Dataset::COUNT_FROM_SELF_OPTS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::COUNT_OF_ALL_AS_COUNT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

Sequel::Dataset::COUNT_SELECT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

Sequel::Dataset::DEFAULT = T.let(T.unsafe(nil), Sequel::LiteralString)

Sequel::Dataset::DEFAULT_PREPARED_STATEMENT_MODULE_METHODS = T.let(T.unsafe(nil), Array)

class Sequel::Dataset::DatasetModule < ::Module
  def distinct(name, *args, &block); end
  def exclude(name, *args, &block); end
  def exclude_having(name, *args, &block); end
  def grep(name, *args, &block); end
  def group(name, *args, &block); end
  def group_and_count(name, *args, &block); end
  def group_append(name, *args, &block); end
  def having(name, *args, &block); end
  def limit(name, *args, &block); end
  def offset(name, *args, &block); end
  def order(name, *args, &block); end
  def order_append(name, *args, &block); end
  def order_prepend(name, *args, &block); end
  def reverse(name, *args, &block); end
  def select(name, *args, &block); end
  def select_all(name, *args, &block); end
  def select_append(name, *args, &block); end
  def select_group(name, *args, &block); end
  def server(name, *args, &block); end
  def where(name, *args, &block); end

  class << self
    def def_dataset_caching_method(mod, meth); end
  end
end

Sequel::Dataset::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

Sequel::Dataset::EMPTY_SELECT = T.let(T.unsafe(nil), Sequel::SQL::AliasedExpression)

Sequel::Dataset::EXISTS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::EXTENSIONS = T.let(T.unsafe(nil), Hash)

module Sequel::Dataset::EmulatePreparedStatementMethods
  include(::Sequel::Dataset::ArgumentMapper)
  include(::Sequel::Dataset::UnnumberedArgumentMapper)

  def run(&block); end

  private

  def emulate_prepared_statements?; end
  def emulated_prepared_statement(type, name, values); end
  def prepared_arg(k); end
  def subselect_sql_dataset(sql, ds); end
end

Sequel::Dataset::IS_LITERALS = T.let(T.unsafe(nil), Hash)

Sequel::Dataset::IS_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::JOIN_METHODS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::NON_SQL_OPTIONS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::OPTS = T.let(T.unsafe(nil), Hash)

Sequel::Dataset::PREPARED_ARG_PLACEHOLDER = T.let(T.unsafe(nil), Sequel::LiteralString)

Sequel::Dataset::PREPARED_STATEMENT_MODULE_CODE = T.let(T.unsafe(nil), Hash)

class Sequel::Dataset::PlaceholderLiteralizer
  def initialize(dataset, fragments, final_sql, arity); end

  def all(*args, &block); end
  def each(*args, &block); end
  def first(*args); end
  def freeze; end
  def get(*args); end
  def sql(*args); end
  def with_dataset; end

  class << self
    def loader(dataset, &block); end
  end
end

class Sequel::Dataset::PlaceholderLiteralizer::Argument
  def initialize(recorder, pos, transformer = T.unsafe(nil)); end

  def sql_literal_append(ds, sql); end
  def transform(&block); end
end

class Sequel::Dataset::PlaceholderLiteralizer::Recorder
  def arg(v = T.unsafe(nil)); end
  def loader(dataset, &block); end
  def use(sql, arg, transformer); end

  private

  def prepared_sql_and_frags(dataset, prepared_args, &block); end
  def process(dataset); end
end

module Sequel::Dataset::PreparedStatementMethods
  def call(bind_vars = T.unsafe(nil), &block); end
  def columns; end
  def delayed_evaluation_sql_append(sql, delay); end
  def inspect; end
  def literal_symbol_append(sql, v); end
  def log_sql; end
  def orig_dataset; end
  def prepare(*_arg0); end
  def prepared_args; end
  def prepared_modify_values; end
  def prepared_sql; end
  def prepared_type; end

  protected

  def run(&block); end

  private

  def prepared_arg(k); end
  def skip_symbol_cache?; end
  def subselect_sql_append(sql, ds); end
  def subselect_sql_dataset(sql, ds); end
end

Sequel::Dataset::QUALIFY_KEYS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::QUERY_METHODS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::SIMPLE_SELECT_ALL_ALLOWED_FROM = T.let(T.unsafe(nil), Array)

Sequel::Dataset::TRUE_FREEZE = T.let(T.unsafe(nil), TrueClass)

Sequel::Dataset::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::Dataset::UNCONDITIONED_JOIN_TYPES = T.let(T.unsafe(nil), Array)

module Sequel::Dataset::UnnumberedArgumentMapper
  include(::Sequel::Dataset::ArgumentMapper)


  protected

  def map_to_prepared_args(bind_vars); end

  private

  def prepared_arg(k); end
end

Sequel::Dataset::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)

module Sequel::Deprecation
  class << self
    def backtrace_filter; end
    def backtrace_filter=(_arg0); end
    def deprecate(method, instead = T.unsafe(nil)); end
    def deprecate_constant(mod, constant); end
    def output; end
    def output=(_arg0); end
    def prefix; end
    def prefix=(_arg0); end
  end
end

class Sequel::Error < ::StandardError
  def cause; end
  def wrapped_exception; end
  def wrapped_exception=(_arg0); end
end

class Sequel::ForeignKeyConstraintViolation < ::Sequel::ConstraintViolation
end

class Sequel::HookFailed < ::Sequel::Error
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil)); end

  def model; end
end

module Sequel::Inflections

  private

  def camelize(s); end
  def constantize(s); end
  def demodulize(s); end
  def pluralize(s); end
  def singularize(s); end
  def underscore(s); end

  class << self
    def clear(scope = T.unsafe(nil)); end
    def irregular(singular, plural); end
    def plural(rule, replacement); end
    def plurals; end
    def singular(rule, replacement); end
    def singulars; end
    def uncountable(*words); end
    def uncountables; end
  end
end

class Sequel::InvalidOperation < ::Sequel::Error
end

class Sequel::InvalidValue < ::Sequel::Error
end

class Sequel::LiteralString < ::String
  include(::Sequel::SQL::OrderMethods)
  include(::Sequel::SQL::ComplexExpressionMethods)
  include(::Sequel::SQL::BooleanMethods)
  include(::Sequel::SQL::NumericMethods)
  include(::Sequel::SQL::StringMethods)
  include(::Sequel::SQL::InequalityMethods)
  include(::Sequel::SQL::AliasMethods)
  include(::Sequel::SQL::CastMethods)

  def inspect; end
  def lit(*args); end
  def to_sequel_blob; end
end

Sequel::MAJOR = T.let(T.unsafe(nil), Integer)

Sequel::MINOR = T.let(T.unsafe(nil), Integer)

class Sequel::MassAssignmentRestriction < ::Sequel::Error
end

class Sequel::Model
  include(::Sequel::Model::InstanceMethods)
  include(::Sequel::Model::Associations::InstanceMethods)
  extend(::Enumerable)
  extend(::Sequel::Inflections)
  extend(::Sequel::Model::ClassMethods)
  extend(::Sequel::Model::Associations::ClassMethods)
end

module Sequel::Model::Associations
  class << self
    def apply(model); end
  end
end

Sequel::Model::Associations::ASSOCIATION_TYPES = T.let(T.unsafe(nil), Hash)

module Sequel::Model::Associations::AssociationDatasetMethods
  def association_reflection; end
  def model_object; end

  private

  def non_sql_option?(key); end
end

class Sequel::Model::Associations::AssociationReflection < ::Hash
  include(::Sequel::Inflections)

  def _add_method; end
  def _remove_all_method; end
  def _remove_method; end
  def _setter_method; end
  def add_method; end
  def apply_dataset_changes(ds); end
  def apply_distinct_on_eager_limit_strategy(ds); end
  def apply_eager_dataset_changes(ds); end
  def apply_eager_graph_limit_strategy(strategy, ds); end
  def apply_eager_limit_strategy(ds, strategy = T.unsafe(nil), limit_and_offset = T.unsafe(nil)); end
  def apply_ruby_eager_limit_strategy(rows, limit_and_offset = T.unsafe(nil)); end
  def apply_window_function_eager_limit_strategy(ds, limit_and_offset = T.unsafe(nil)); end
  def assign_singular?; end
  def associated_class; end
  def associated_dataset; end
  def association_dataset_for(object); end
  def association_dataset_proc; end
  def association_method; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def dataset_method; end
  def dataset_need_primary_key?; end
  def delete_row_number_column(ds = T.unsafe(nil)); end
  def eager_graph_lazy_dataset?; end
  def eager_graph_limit_strategy(strategy); end
  def eager_limit_strategy; end
  def eager_load_results(eo, &block); end
  def eager_loader_key; end
  def eager_loading_use_associated_key?; end
  def filter_by_associations_add_conditions?; end
  def filter_by_associations_conditions_expression(obj); end
  def finalize; end
  def finalize_settings; end
  def handle_silent_modification_failure?; end
  def initialize_association_cache(objects); end
  def inspect; end
  def limit_and_offset; end
  def need_associated_primary_key?; end
  def placeholder_loader; end
  def predicate_key_values(object); end
  def predicate_keys; end
  def qualify(table, col); end
  def qualify_assoc(col); end
  def qualify_cur(col); end
  def reciprocal; end
  def reciprocal_array?; end
  def remove_all_method; end
  def remove_before_destroy?; end
  def remove_method; end
  def remove_should_check_existing?; end
  def returns_array?; end
  def select; end
  def set_reciprocal_to_self?; end
  def setter_method; end
  def slice_range(limit_and_offset = T.unsafe(nil)); end

  private

  def _associated_dataset; end
  def ambiguous_reciprocal_type?; end
  def apply_filter_by_associations_distinct_on_limit_strategy(ds); end
  def apply_filter_by_associations_limit_strategy(ds); end
  def apply_filter_by_associations_window_function_limit_strategy(ds); end
  def associated_eager_dataset; end
  def cached_fetch(key); end
  def cached_set(key, value); end
  def default_eager_limit_strategy; end
  def eager_loading_dataset(eo = T.unsafe(nil)); end
  def eager_loading_predicate_condition(keys); end
  def filter_by_associations_add_conditions_dataset_filter(ds); end
  def filter_by_associations_conditions_dataset; end
  def filter_by_associations_conditions_subquery_conditions(obj); end
  def filter_by_associations_limit_strategy; end
  def limit_to_single_row?; end
  def offset; end
  def placeholder_eager_loader; end
  def possible_reciprocal_types; end
  def reciprocal_association?(assoc_reflect); end
  def subqueries_per_union; end
  def transform(s, &block); end
  def true_eager_graph_limit_strategy; end
  def true_eager_limit_strategy; end
  def union_eager_loader; end
  def use_placeholder_loader?; end
end

Sequel::Model::Associations::AssociationReflection::ASSOCIATION_DATASET_PROC = T.let(T.unsafe(nil), Proc)

Sequel::Model::Associations::AssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

module Sequel::Model::Associations::ClassMethods
  def all_association_reflections; end
  def associate(type, name, opts = T.unsafe(nil), &block); end
  def association_full_join(*args, &block); end
  def association_inner_join(*args, &block); end
  def association_join(*args, &block); end
  def association_left_join(*args, &block); end
  def association_reflection(name); end
  def association_reflections; end
  def association_right_join(*args, &block); end
  def associations; end
  def autoreloading_associations; end
  def cache_associations; end
  def cache_associations=(_arg0); end
  def default_association_options; end
  def default_association_options=(_arg0); end
  def default_association_type_options; end
  def default_association_type_options=(_arg0); end
  def default_eager_limit_strategy; end
  def default_eager_limit_strategy=(_arg0); end
  def eager(*args, &block); end
  def eager_graph(*args, &block); end
  def eager_graph_with_options(*args, &block); end
  def eager_load_results(opts, eo, &block); end
  def finalize_associations; end
  def freeze; end
  def many_to_many(name, opts = T.unsafe(nil), &block); end
  def many_to_one(name, opts = T.unsafe(nil), &block); end
  def one_through_one(name, opts = T.unsafe(nil), &block); end
  def one_to_many(name, opts = T.unsafe(nil), &block); end
  def one_to_one(name, opts = T.unsafe(nil), &block); end

  private

  def _association_instance_specific_default(_); end
  def association_module(opts = T.unsafe(nil)); end
  def association_module_def(name, opts = T.unsafe(nil), &block); end
  def association_module_private_def(name, opts = T.unsafe(nil), &block); end
  def def_association_instance_methods(opts); end
  def def_association_method(opts); end
  def def_many_to_many(opts); end
  def def_many_to_one(opts); end
  def def_one_through_one(opts); end
  def def_one_to_many(opts); end
  def def_one_to_one(opts); end
  def eager_graph_dataset(opts, eager_options); end
  def inherited_instance_variables; end
  def reload_db_schema?; end
end

module Sequel::Model::Associations::DatasetMethods
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def association_full_join(*associations); end
  def association_inner_join(*associations); end
  def association_join(*associations); end
  def association_left_join(*associations); end
  def association_right_join(*associations); end
  def complex_expression_sql_append(sql, op, args); end
  def eager(*associations); end
  def eager_graph(*associations); end
  def eager_graph_with_options(associations, opts = T.unsafe(nil)); end
  def to_hash_groups(key_column, value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def ungraphed; end

  protected

  def eager_graph_association(ds, model, ta, requirements, r, *associations); end
  def eager_graph_associations(ds, model, ta, requirements, *associations); end
  def eager_graph_build_associations(hashes); end

  private

  def _association_join(type, associations); end
  def _eager_graph_build_associations(hashes, egl); end
  def add_association_filter_conditions(ref, obj, expr); end
  def association_filter_expression(op, ref, obj); end
  def association_filter_handle_inversion(op, exp, cols); end
  def association_filter_key_expression(keys, meths, obj); end
  def check_association(model, association); end
  def eager_graph_check_association(model, association); end
  def eager_graph_loader; end
  def eager_load(a, eager_assoc = T.unsafe(nil)); end
  def eager_options_for_associations(associations); end
  def many_to_many_association_filter_expression(op, ref, obj); end
  def many_to_one_association_filter_expression(op, ref, obj); end
  def non_sql_option?(key); end
  def one_through_one_association_filter_expression(op, ref, obj); end
  def one_to_many_association_filter_expression(op, ref, obj); end
  def one_to_one_association_filter_expression(op, ref, obj); end
  def post_load(all_records); end
end

class Sequel::Model::Associations::DatasetModule < ::Sequel::Model::DatasetModule
  def eager(name, *args, &block); end
end

class Sequel::Model::Associations::EagerGraphLoader
  def initialize(dataset); end

  def after_load_map; end
  def alias_map; end
  def column_maps; end
  def dependency_map; end
  def limit_map; end
  def load(hashes); end
  def master; end
  def primary_keys; end
  def reciprocal_map; end
  def records_map; end
  def reflection_map; end
  def row_procs; end
  def type_map; end

  private

  def _load(dependency_map, current, h); end
  def hfor(ta, h); end
  def hkey(h); end
  def master_hfor(h); end
  def master_pk(h); end
  def pk(ta, h); end
  def post_process(records, dependency_map); end
end

module Sequel::Model::Associations::InstanceMethods
  def associations; end
  def freeze; end

  private

  def _apply_association_options(opts, ds); end
  def _associated_dataset(opts, dynamic_opts); end
  def _associated_object_loader(opts, dynamic_opts); end
  def _dataset(opts); end
  def _join_table_dataset(opts); end
  def _load_associated_object(opts, dynamic_opts); end
  def _load_associated_object_array(opts, dynamic_opts); end
  def _load_associated_object_via_primary_key(opts); end
  def _load_associated_objects(opts, dynamic_opts = T.unsafe(nil)); end
  def _refresh_set_values(hash); end
  def _set_associated_object(opts, o); end
  def add_associated_object(opts, o, *args); end
  def add_reciprocal_object(opts, o); end
  def array_uniq!(a); end
  def change_column_value(column, value); end
  def ensure_associated_primary_key(opts, o, *args); end
  def initialize_copy(other); end
  def load_associated_objects(opts, dynamic_opts, &block); end
  def load_association_objects_options(dynamic_opts, &block); end
  def load_with_primary_key_lookup?(opts, dynamic_opts); end
  def make_add_associated_object(opts, o); end
  def remove_all_associated_objects(opts, *args); end
  def remove_associated_object(opts, o, *args); end
  def remove_check_existing_object_from_pk(opts, o, *args); end
  def remove_reciprocal_object(opts, o); end
  def run_association_callbacks(reflection, callback_type, object); end
  def set_associated_object(opts, o); end
  def set_associated_object_if_same?; end
  def set_one_through_one_associated_object(opts, o); end
  def set_one_to_one_associated_object(opts, o); end
end

class Sequel::Model::Associations::ManyToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def associated_key_alias; end
  def associated_key_array; end
  def associated_key_column; end
  def associated_key_table; end
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def default_associated_key_alias; end
  def default_eager_loader(eo); end
  def default_join_table; end
  def default_left_key; end
  def default_right_key; end
  def eager_loading_use_associated_key?; end
  def finalize_settings; end
  def join_table_alias; end
  def join_table_source; end
  def need_associated_primary_key?; end
  def predicate_key; end
  def qualified_left_key; end
  def qualified_right_key; end
  def qualified_right_primary_key; end
  def right_primary_key; end
  def right_primary_key_method; end
  def right_primary_key_methods; end
  def right_primary_keys; end
  def select; end

  private

  def _associated_dataset; end
  def default_select; end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def filter_by_associations_limit_alias_key; end
  def filter_by_associations_limit_aliases; end
  def filter_by_associations_limit_key; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
  def selection_is_qualified?(c); end
  def split_join_table_alias; end
end

Sequel::Model::Associations::ManyToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::ManyToOneAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def dataset_need_primary_key?; end
  def default_key; end
  def eager_graph_lazy_dataset?; end
  def eager_graph_limit_strategy(_); end
  def eager_limit_strategy; end
  def filter_by_associations_limit_strategy; end
  def finalize_settings; end
  def predicate_key; end
  def primary_key; end
  def primary_key_method; end
  def primary_key_methods; end
  def primary_keys; end
  def qualified_primary_key; end
  def reciprocal_array?; end
  def returns_array?; end
  def set_reciprocal_to_self?; end

  private

  def ambiguous_reciprocal_type?; end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def limit_to_single_row?; end
  def possible_reciprocal_types; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
end

Sequel::Model::Associations::ManyToOneAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::OneThroughOneAssociationReflection < ::Sequel::Model::Associations::ManyToManyAssociationReflection
  include(::Sequel::Model::Associations::SingularAssociationReflection)

  def default_right_key; end
  def reciprocal; end
end

class Sequel::Model::Associations::OneToManyAssociationReflection < ::Sequel::Model::Associations::AssociationReflection
  def apply_eager_graph_limit_strategy(strategy, ds); end
  def associated_object_keys; end
  def can_have_associated_objects?(obj); end
  def cloneable?(ref); end
  def default_key; end
  def finalize_settings; end
  def handle_silent_modification_failure?; end
  def predicate_key; end
  def primary_key; end
  def qualified_key; end
  def qualified_primary_key; end
  def reciprocal_array?; end
  def remove_before_destroy?; end
  def remove_should_check_existing?; end
  def set_reciprocal_to_self?; end

  private

  def apply_correlated_subquery_limit_strategy(ds); end
  def apply_filter_by_associations_limit_strategy(ds); end
  def filter_by_associations_conditions_associated_keys; end
  def filter_by_associations_conditions_key; end
  def filter_by_associations_limit_alias_key; end
  def filter_by_associations_limit_aliases; end
  def filter_by_associations_limit_key; end
  def predicate_key_methods; end
  def reciprocal_association?(assoc_reflect); end
  def reciprocal_type; end
  def true_eager_graph_limit_strategy; end
end

Sequel::Model::Associations::OneToManyAssociationReflection::FINALIZE_SETTINGS = T.let(T.unsafe(nil), Hash)

class Sequel::Model::Associations::OneToOneAssociationReflection < ::Sequel::Model::Associations::OneToManyAssociationReflection
  include(::Sequel::Model::Associations::SingularAssociationReflection)
end

module Sequel::Model::Associations::SingularAssociationReflection
  def assign_singular?; end
  def filter_by_associations_add_conditions?; end
  def limit_and_offset; end
  def returns_array?; end

  private

  def default_eager_limit_strategy; end
  def filter_by_associations_limit_strategy; end
  def true_eager_graph_limit_strategy; end
end

module Sequel::Model::ClassMethods
  def Model(source); end
  def [](*args); end
  def all(*args, &block); end
  def as_hash(*args, &block); end
  def avg(*args, &block); end
  def cache_anonymous_models; end
  def cache_anonymous_models=(_arg0); end
  def call(values); end
  def clear_setter_methods_cache; end
  def columns; end
  def count(*args, &block); end
  def create(values = T.unsafe(nil), &block); end
  def cross_join(*args, &block); end
  def dataset; end
  def dataset=(ds); end
  def dataset_method_modules; end
  def dataset_module(mod = T.unsafe(nil), &block); end
  def dataset_module_class; end
  def db; end
  def db=(db); end
  def db_schema; end
  def def_Model(mod); end
  def def_column_alias(meth, column); end
  def default_set_fields_options; end
  def default_set_fields_options=(_arg0); end
  def distinct(*args, &block); end
  def each(*args, &block); end
  def each_server(*args, &block); end
  def empty?(*args, &block); end
  def except(*args, &block); end
  def exclude(*args, &block); end
  def exclude_having(*args, &block); end
  def fast_instance_delete_sql; end
  def fast_pk_lookup_sql; end
  def fetch(*args, &block); end
  def fetch_rows(*args, &block); end
  def filter(*args, &block); end
  def find(*args, &block); end
  def find_or_create(cond, &block); end
  def first(*args, &block); end
  def first!(*args, &block); end
  def for_update(*args, &block); end
  def freeze; end
  def from(*args, &block); end
  def from_self(*args, &block); end
  def full_join(*args, &block); end
  def full_outer_join(*args, &block); end
  def get(*args, &block); end
  def graph(*args, &block); end
  def grep(*args, &block); end
  def group(*args, &block); end
  def group_and_count(*args, &block); end
  def group_append(*args, &block); end
  def group_by(*args, &block); end
  def has_dataset?; end
  def having(*args, &block); end
  def implicit_table_name; end
  def import(*args, &block); end
  def include(*mods); end
  def inner_join(*args, &block); end
  def insert(*args, &block); end
  def instance_dataset; end
  def intersect(*args, &block); end
  def invert(*args, &block); end
  def join(*args, &block); end
  def join_table(*args, &block); end
  def last(*args, &block); end
  def left_join(*args, &block); end
  def left_outer_join(*args, &block); end
  def limit(*args, &block); end
  def load(values); end
  def lock_style(*args, &block); end
  def map(*args, &block); end
  def max(*args, &block); end
  def min(*args, &block); end
  def multi_insert(*args, &block); end
  def naked(*args, &block); end
  def natural_full_join(*args, &block); end
  def natural_join(*args, &block); end
  def natural_left_join(*args, &block); end
  def natural_right_join(*args, &block); end
  def no_primary_key; end
  def offset(*args, &block); end
  def order(*args, &block); end
  def order_append(*args, &block); end
  def order_by(*args, &block); end
  def order_more(*args, &block); end
  def order_prepend(*args, &block); end
  def paged_each(*args, &block); end
  def plugin(plugin, *args, &block); end
  def plugins; end
  def primary_key; end
  def primary_key_hash(value); end
  def qualified_primary_key_hash(value, qualifier = T.unsafe(nil)); end
  def qualify(*args, &block); end
  def raise_on_save_failure; end
  def raise_on_save_failure=(_arg0); end
  def raise_on_typecast_failure; end
  def raise_on_typecast_failure=(_arg0); end
  def require_modification; end
  def require_modification=(_arg0); end
  def require_valid_table; end
  def require_valid_table=(_arg0); end
  def restrict_primary_key; end
  def restrict_primary_key?; end
  def reverse(*args, &block); end
  def reverse_order(*args, &block); end
  def right_join(*args, &block); end
  def right_outer_join(*args, &block); end
  def select(*args, &block); end
  def select_all(*args, &block); end
  def select_append(*args, &block); end
  def select_group(*args, &block); end
  def select_hash(*args, &block); end
  def select_hash_groups(*args, &block); end
  def select_map(*args, &block); end
  def select_more(*args, &block); end
  def select_order_map(*args, &block); end
  def server(*args, &block); end
  def set_dataset(ds, opts = T.unsafe(nil)); end
  def set_primary_key(key); end
  def setter_methods; end
  def simple_pk; end
  def simple_table; end
  def single_record(*args, &block); end
  def single_record!(*args, &block); end
  def single_value(*args, &block); end
  def single_value!(*args, &block); end
  def strict_param_setting; end
  def strict_param_setting=(_arg0); end
  def sum(*args, &block); end
  def table_name; end
  def to_hash(*args, &block); end
  def to_hash_groups(*args, &block); end
  def truncate(*args, &block); end
  def typecast_empty_string_to_nil; end
  def typecast_empty_string_to_nil=(_arg0); end
  def typecast_on_assignment; end
  def typecast_on_assignment=(_arg0); end
  def unfiltered(*args, &block); end
  def ungraphed(*args, &block); end
  def ungrouped(*args, &block); end
  def union(*args, &block); end
  def unlimited(*args, &block); end
  def unordered(*args, &block); end
  def unrestrict_primary_key; end
  def use_transactions; end
  def use_transactions=(_arg0); end
  def where(*args, &block); end
  def where_all(*args, &block); end
  def where_each(*args, &block); end
  def where_single_value(*args, &block); end
  def with(*args, &block); end
  def with_pk(pk); end
  def with_pk!(pk); end
  def with_recursive(*args, &block); end
  def with_sql(*args, &block); end

  private

  def check_non_connection_error(do_raise = T.unsafe(nil)); end
  def convert_input_dataset(ds); end
  def dataset_extend(mod, opts = T.unsafe(nil)); end
  def def_bad_column_accessor(column); end
  def def_column_accessor(*columns); end
  def def_model_dataset_method(meth); end
  def get_db_schema(reload = T.unsafe(nil)); end
  def get_setter_methods; end
  def inherited(subclass); end
  def inherited_instance_variables; end
  def late_binding_class_option(opts, default); end
  def method_added(meth); end
  def overridable_methods_module; end
  def plugin_module(plugin); end
  def primary_key_lookup(pk); end
  def reload_db_schema?; end
  def reset_fast_pk_lookup_sql; end
  def reset_instance_dataset; end
  def set_columns(new_columns); end
  def set_dataset_row_proc(ds); end
  def simple_pk=(pk); end
  def simple_table=(t); end
end

module Sequel::Model::DatasetMethods
  def [](*args); end
  def as_hash(key_column = T.unsafe(nil), value_column = T.unsafe(nil), opts = T.unsafe(nil)); end
  def destroy; end
  def last(*a, &block); end
  def model; end
  def paged_each(*a, &block); end
  def to_hash(*a); end
  def with_pk(pk); end
  def with_pk!(pk); end

  private

  def _primary_key_order; end
  def _with_pk_loader; end
  def non_sql_option?(key); end
end

class Sequel::Model::DatasetModule < ::Sequel::Dataset::DatasetModule
  def initialize(model); end

  def subset(name, *args, &block); end

  private

  def method_added(meth); end
end

class Sequel::Model::Errors < ::Hash
  def add(att, msg); end
  def count; end
  def empty?; end
  def full_messages; end
  def on(att); end
end

Sequel::Model::HOOKS = T.let(T.unsafe(nil), Array)

module Sequel::Model::InstanceMethods
  def initialize(values = T.unsafe(nil)); end

  def ==(obj); end
  def ===(obj); end
  def [](column); end
  def []=(column, value); end
  def after_create; end
  def after_destroy; end
  def after_save; end
  def after_update; end
  def after_validation; end
  def around_create; end
  def around_destroy; end
  def around_save; end
  def around_update; end
  def around_validation; end
  def autoincrementing_primary_key; end
  def before_create; end
  def before_destroy; end
  def before_save; end
  def before_update; end
  def before_validation; end
  def cancel_action(msg = T.unsafe(nil)); end
  def changed_columns; end
  def columns; end
  def db; end
  def db_schema; end
  def delete; end
  def destroy(opts = T.unsafe(nil)); end
  def each(&block); end
  def eql?(obj); end
  def errors; end
  def exists?; end
  def extend(mod); end
  def freeze; end
  def get_column_value(*_arg0); end
  def hash; end
  def id; end
  def inspect; end
  def keys; end
  def lock!(style = T.unsafe(nil)); end
  def marshallable!; end
  def model; end
  def modified!(column = T.unsafe(nil)); end
  def modified?(column = T.unsafe(nil)); end
  def new?; end
  def pk; end
  def pk_equal?(obj); end
  def pk_hash; end
  def primary_key; end
  def qualified_pk_hash(qualifier = T.unsafe(nil)); end
  def raise_on_save_failure; end
  def raise_on_save_failure=(_arg0); end
  def raise_on_typecast_failure; end
  def raise_on_typecast_failure=(_arg0); end
  def refresh; end
  def reload; end
  def require_modification; end
  def require_modification=(_arg0); end
  def save(opts = T.unsafe(nil)); end
  def save_changes(opts = T.unsafe(nil)); end
  def set(hash); end
  def set_column_value(*_arg0); end
  def set_fields(hash, fields, opts = T.unsafe(nil)); end
  def set_server(s); end
  def singleton_method_added(meth); end
  def skip_validation_on_next_save!; end
  def strict_param_setting; end
  def strict_param_setting=(_arg0); end
  def this; end
  def to_hash; end
  def typecast_empty_string_to_nil; end
  def typecast_empty_string_to_nil=(_arg0); end
  def typecast_on_assignment; end
  def typecast_on_assignment=(_arg0); end
  def update(hash); end
  def update_fields(hash, fields, opts = T.unsafe(nil)); end
  def use_transactions; end
  def use_transactions=(_arg0); end
  def valid?(opts = T.unsafe(nil)); end
  def validate; end
  def values; end

  private

  def _add_changed_column(column); end
  def _changed_columns; end
  def _clear_changed_columns(_reason); end
  def _delete; end
  def _delete_dataset; end
  def _delete_without_checking; end
  def _destroy(opts); end
  def _destroy_delete; end
  def _insert; end
  def _insert_dataset; end
  def _insert_raw(ds); end
  def _insert_select_raw(ds); end
  def _insert_values; end
  def _refresh(dataset); end
  def _refresh_get(dataset); end
  def _refresh_set_values(h); end
  def _save(opts); end
  def _save_refresh; end
  def _save_set_values(h); end
  def _save_update_all_columns_hash; end
  def _save_update_changed_colums_hash; end
  def _save_valid?(opts); end
  def _update(columns); end
  def _update_columns(columns); end
  def _update_dataset; end
  def _update_without_checking(columns); end
  def _use_insert_select?(ds); end
  def _valid?(opts); end
  def change_column_value(column, value); end
  def checked_save_failure(opts); end
  def checked_transaction(opts = T.unsafe(nil)); end
  def errors_class; end
  def hook_failed_error(msg); end
  def initialize_clone(other); end
  def initialize_copy(other); end
  def initialize_set(h); end
  def inspect_values; end
  def raise_hook_failure(type = T.unsafe(nil)); end
  def raise_on_failure?(opts); end
  def schema_type_class(column); end
  def set_restricted(hash, type); end
  def setter_methods(type); end
  def this_server; end
  def typecast_value(column, value); end
  def update_restricted(hash, type); end
  def use_server(ds); end
  def use_transaction?(opts = T.unsafe(nil)); end
  def validation_failed_error; end
end

Sequel::Model::OPTS = T.let(T.unsafe(nil), Hash)

Sequel::Model::RESTRICTED_SETTER_METHODS = T.let(T.unsafe(nil), Array)

class Sequel::NoExistingObject < ::Sequel::Error
end

class Sequel::NoMatchingRow < ::Sequel::Error
  def initialize(msg = T.unsafe(nil)); end

  def dataset; end
  def dataset=(_arg0); end
end

class Sequel::NotNullConstraintViolation < ::Sequel::ConstraintViolation
end

Sequel::OPTS = T.let(T.unsafe(nil), Hash)

module Sequel::Plugins
  class << self
    def after_set_dataset(mod, meth); end
    def def_dataset_methods(mod, meths); end
    def def_sequel_method(model, meth, expected_arity, &block); end
    def inherited_instance_variables(mod, hash); end

    private

    def _define_sequel_method_arg_numbers(callable); end
  end
end

Sequel::Plugins::SEQUEL_METHOD_NAME = T.let(T.unsafe(nil), Proc)

class Sequel::PoolTimeout < ::Sequel::Error
end

class Sequel::Qualifier < ::Sequel::ASTTransformer
  def initialize(table); end


  private

  def v(o); end
end

class Sequel::Rollback < ::Sequel::Error
end

Sequel::SHARED_ADAPTER_MAP = T.let(T.unsafe(nil), Hash)

Sequel::SPLIT_SYMBOL_CACHE = T.let(T.unsafe(nil), Hash)

module Sequel::SQL
end

module Sequel::SQL::AliasMethods
  def as(aliaz, columns = T.unsafe(nil)); end
end

class Sequel::SQL::AliasedExpression < ::Sequel::SQL::Expression
  def initialize(expression, aliaz, columns = T.unsafe(nil)); end

  def alias; end
  def columns; end
  def expression; end
  def to_s_append(ds, sql); end
end

module Sequel::SQL::BitwiseMethods
  def %(o); end
  def &(o); end
  def <<(o); end
  def >>(o); end
  def ^(o); end
  def |(o); end
  def ~; end
end

class Sequel::SQL::Blob < ::String
  include(::Sequel::SQL::AliasMethods)
  include(::Sequel::SQL::CastMethods)

  def inspect; end
  def lit(*args); end
  def to_sequel_blob; end

  class << self
    def call(*_arg0); end
  end
end

class Sequel::SQL::BooleanConstant < ::Sequel::SQL::Constant
  def to_s_append(ds, sql); end
end

class Sequel::SQL::BooleanExpression < ::Sequel::SQL::ComplexExpression
  include(::Sequel::SQL::BooleanMethods)

  def &(ce); end
  def sql_boolean; end
  def |(ce); end

  class << self
    def from_value_pairs(pairs, op = T.unsafe(nil), negate = T.unsafe(nil)); end
    def invert(ce); end

    private

    def from_value_pair(l, r); end
  end
end

module Sequel::SQL::BooleanMethods
  def &(o); end
  def |(o); end
  def ~; end
end

module Sequel::SQL::Builders
  def as(exp, aliaz, columns = T.unsafe(nil)); end
  def asc(arg, opts = T.unsafe(nil)); end
  def blob(s); end
  def case(*args); end
  def cast(arg, sql_type); end
  def cast_numeric(arg, sql_type = T.unsafe(nil)); end
  def cast_string(arg, sql_type = T.unsafe(nil)); end
  def char_length(arg); end
  def deep_qualify(qualifier, expr); end
  def delay(&block); end
  def desc(arg, opts = T.unsafe(nil)); end
  def expr(arg = T.unsafe(nil), &block); end
  def extract(datetime_part, exp); end
  def function(name, *args); end
  def identifier(name); end
  def ilike(*args); end
  def join(args, joiner = T.unsafe(nil)); end
  def like(*args); end
  def lit(s, *args); end
  def negate(arg); end
  def or(arg); end
  def qualify(qualifier, identifier); end
  def subscript(exp, *subs); end
  def trim(arg); end
  def value_list(arg); end
end

class Sequel::SQL::CaseExpression < ::Sequel::SQL::GenericExpression
  def initialize(conditions, default, expression = T.unsafe(nil)); end

  def conditions; end
  def default; end
  def expression; end
  def expression?; end
  def to_s_append(ds, sql); end
  def with_merged_expression; end
end

class Sequel::SQL::Cast < ::Sequel::SQL::GenericExpression
  def initialize(expr, type); end

  def expr; end
  def to_s_append(ds, sql); end
  def type; end
end

module Sequel::SQL::CastMethods
  def cast(sql_type); end
  def cast_numeric(sql_type = T.unsafe(nil)); end
  def cast_string(sql_type = T.unsafe(nil)); end
end

class Sequel::SQL::ColumnAll < ::Sequel::SQL::Expression
  def initialize(table); end

  def table; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::ComplexExpression < ::Sequel::SQL::Expression
  include(::Sequel::SQL::AliasMethods)
  include(::Sequel::SQL::CastMethods)
  include(::Sequel::SQL::OrderMethods)
  include(::Sequel::SQL::PatternMatchMethods)
  include(::Sequel::SQL::SubscriptMethods)

  def initialize(op, *args); end

  def args; end
  def op; end
  def sql_boolean; end
  def sql_number; end
  def sql_string; end
  def to_s_append(ds, sql); end
end

Sequel::SQL::ComplexExpression::ASSOCIATIVE_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::BITWISE_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::BOOLEAN_OPERATOR_METHODS = T.let(T.unsafe(nil), Hash)

Sequel::SQL::ComplexExpression::CONSTANT_INVERSIONS = T.let(T.unsafe(nil), Hash)

Sequel::SQL::ComplexExpression::CUSTOM_EXPRESSIONS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::INEQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::IN_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::IS_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::LIKE_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::MATHEMATICAL_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::N_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::ONE_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::OPERTATOR_INVERSIONS = T.let(T.unsafe(nil), Hash)

Sequel::SQL::ComplexExpression::REGEXP_OPERATORS = T.let(T.unsafe(nil), Array)

Sequel::SQL::ComplexExpression::TWO_ARITY_OPERATORS = T.let(T.unsafe(nil), Array)

module Sequel::SQL::ComplexExpressionMethods
  def extract(datetime_part); end
  def sql_boolean; end
  def sql_number; end
  def sql_string; end
end

class Sequel::SQL::Constant < ::Sequel::SQL::GenericExpression
  def initialize(constant); end

  def constant; end
  def to_s_append(ds, sql); end
end

module Sequel::SQL::Constants
end

Sequel::SQL::Constants::CURRENT_DATE = T.let(T.unsafe(nil), Sequel::SQL::Constant)

Sequel::SQL::Constants::CURRENT_TIME = T.let(T.unsafe(nil), Sequel::SQL::Constant)

Sequel::SQL::Constants::CURRENT_TIMESTAMP = T.let(T.unsafe(nil), Sequel::SQL::Constant)

Sequel::SQL::Constants::DEFAULT = T.let(T.unsafe(nil), Sequel::SQL::Constant)

Sequel::SQL::Constants::FALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

Sequel::SQL::Constants::NOTNULL = T.let(T.unsafe(nil), Sequel::SQL::NegativeBooleanConstant)

Sequel::SQL::Constants::NULL = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

Sequel::SQL::Constants::SQLFALSE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

Sequel::SQL::Constants::SQLTRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

Sequel::SQL::Constants::TRUE = T.let(T.unsafe(nil), Sequel::SQL::BooleanConstant)

class Sequel::SQL::DelayedEvaluation < ::Sequel::SQL::GenericExpression
  def initialize(callable); end

  def call(ds); end
  def callable; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::Expression
  def ==(other); end
  def clone; end
  def dup; end
  def eql?(other); end
  def hash; end
  def inspect; end

  class << self
    def attr_reader(*args); end
    def comparison_attrs; end
    def inherited(subclass); end

    private

    def to_s_method(meth, args = T.unsafe(nil)); end
  end
end

class Sequel::SQL::Function < ::Sequel::SQL::GenericExpression
  def initialize(name, *args); end

  def *(ce = T.unsafe(nil)); end
  def args; end
  def distinct; end
  def filter(*args, &block); end
  def lateral; end
  def name; end
  def opts; end
  def order(*args); end
  def over(window = T.unsafe(nil)); end
  def quoted; end
  def to_s_append(ds, sql); end
  def unquoted; end
  def with_ordinality; end
  def within_group(*expressions); end

  private

  def _initialize(name, args, opts); end
  def with_opts(opts); end

  class << self
    def new!(name, args, opts); end
  end
end

Sequel::SQL::Function::COMMA_ARRAY = T.let(T.unsafe(nil), Array)

Sequel::SQL::Function::DISTINCT = T.let(T.unsafe(nil), Array)

Sequel::SQL::Function::WILDCARD = T.let(T.unsafe(nil), Sequel::LiteralString)

class Sequel::SQL::GenericExpression < ::Sequel::SQL::Expression
  include(::Sequel::SQL::AliasMethods)
  include(::Sequel::SQL::BooleanMethods)
  include(::Sequel::SQL::CastMethods)
  include(::Sequel::SQL::ComplexExpressionMethods)
  include(::Sequel::SQL::InequalityMethods)
  include(::Sequel::SQL::NumericMethods)
  include(::Sequel::SQL::OrderMethods)
  include(::Sequel::SQL::PatternMatchMethods)
  include(::Sequel::SQL::StringMethods)
  include(::Sequel::SQL::SubscriptMethods)
end

class Sequel::SQL::Identifier < ::Sequel::SQL::GenericExpression
  include(::Sequel::SQL::QualifyingMethods)

  def initialize(value); end

  def function(*args); end
  def to_s_append(ds, sql); end
  def value; end
end

module Sequel::SQL::InequalityMethods
  def <(o); end
  def <=(o); end
  def >(o); end
  def >=(o); end
end

class Sequel::SQL::JoinClause < ::Sequel::SQL::Expression
  def initialize(join_type, table_expr); end

  def column_aliases; end
  def join_type; end
  def table; end
  def table_alias; end
  def table_expr; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::JoinOnClause < ::Sequel::SQL::JoinClause
  def initialize(on, *args); end

  def on; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::JoinUsingClause < ::Sequel::SQL::JoinClause
  def initialize(cols, *args); end

  def to_s_append(ds, sql); end
  def using; end
end

class Sequel::SQL::NegativeBooleanConstant < ::Sequel::SQL::Constant
  def to_s_append(ds, sql); end
end

class Sequel::SQL::NumericExpression < ::Sequel::SQL::ComplexExpression
  include(::Sequel::SQL::BitwiseMethods)
  include(::Sequel::SQL::NumericMethods)
  include(::Sequel::SQL::InequalityMethods)

  def +(ce); end
  def sql_number; end
end

module Sequel::SQL::NumericMethods
  def *(o); end
  def **(o); end
  def +(ce); end
  def -(o); end
  def /(o); end
  def coerce(other); end
end

module Sequel::SQL::OperatorBuilders
  def &(*args); end
  def *(*args); end
  def **(a, b); end
  def +(*args); end
  def -(*args); end
  def /(*args); end
  def |(*args); end
  def ~(arg); end
end

module Sequel::SQL::OrderMethods
  def asc(opts = T.unsafe(nil)); end
  def desc(opts = T.unsafe(nil)); end
end

class Sequel::SQL::OrderedExpression < ::Sequel::SQL::Expression
  def initialize(expression, descending = T.unsafe(nil), opts = T.unsafe(nil)); end

  def asc; end
  def desc; end
  def descending; end
  def expression; end
  def invert; end
  def nulls; end
  def to_s_append(ds, sql); end
end

Sequel::SQL::OrderedExpression::INVERT_NULLS = T.let(T.unsafe(nil), Hash)

module Sequel::SQL::PatternMatchMethods
  def !~(other); end
  def =~(other); end
end

class Sequel::SQL::PlaceholderLiteralString < ::Sequel::SQL::GenericExpression
  def initialize(str, args, parens = T.unsafe(nil)); end

  def args; end
  def parens; end
  def str; end
  def to_s_append(ds, sql); end
  def with_parens; end
end

class Sequel::SQL::QualifiedIdentifier < ::Sequel::SQL::GenericExpression
  include(::Sequel::SQL::QualifyingMethods)

  def initialize(table, column); end

  def column; end
  def function(*args); end
  def table; end
  def to_s_append(ds, sql); end

  private

  def convert_identifier(identifier); end
end

module Sequel::SQL::QualifyingMethods
  def *(ce = T.unsafe(nil)); end
  def [](identifier); end
  def qualify(qualifier); end
end

module Sequel::SQL::StringConcatenationMethods
  def +(ce); end
end

class Sequel::SQL::StringExpression < ::Sequel::SQL::ComplexExpression
  include(::Sequel::SQL::StringMethods)
  include(::Sequel::SQL::StringConcatenationMethods)
  include(::Sequel::SQL::InequalityMethods)

  def sql_string; end

  class << self
    def like(l, *ces); end

    private

    def like_element(re); end
  end
end

Sequel::SQL::StringExpression::LIKE_MAP = T.let(T.unsafe(nil), Hash)

module Sequel::SQL::StringMethods
  def ilike(*ces); end
  def like(*ces); end
end

class Sequel::SQL::Subscript < ::Sequel::SQL::GenericExpression
  def initialize(expression, sub); end

  def [](sub); end
  def expression; end
  def f; end
  def sub; end
  def to_s_append(ds, sql); end
  def |(sub); end
end

module Sequel::SQL::SubscriptMethods
  def sql_subscript(*sub); end
end

class Sequel::SQL::ValueList < ::Array
  def inspect; end
end

class Sequel::SQL::VirtualRow < ::Sequel::BasicObject
  include(::Sequel::SQL::OperatorBuilders)

  def initialize; end

  def <(*args); end
  def <=(*args); end
  def >(*args); end
  def >=(*args); end
end

class Sequel::SQL::Window < ::Sequel::SQL::Expression
  def initialize(opts = T.unsafe(nil)); end

  def opts; end
  def to_s_append(ds, sql); end
end

class Sequel::SQL::Wrapper < ::Sequel::SQL::GenericExpression
  def initialize(value); end

  def to_s_append(ds, sql); end
  def value; end
end

class Sequel::SQLTime < ::Time
  def inspect; end
  def to_s(*args); end

  class << self
    def create(hour, minute, second, usec = T.unsafe(nil)); end
    def date; end
    def date=(_arg0); end
    def parse(*_arg0); end
  end
end

module Sequel::Schema
end

class Sequel::Schema::AlterTableGenerator
  def initialize(db, &block); end

  def add_column(name, type, opts = T.unsafe(nil)); end
  def add_constraint(name, *args, &block); end
  def add_foreign_key(name, table, opts = T.unsafe(nil)); end
  def add_full_text_index(columns, opts = T.unsafe(nil)); end
  def add_index(columns, opts = T.unsafe(nil)); end
  def add_primary_key(name, opts = T.unsafe(nil)); end
  def add_spatial_index(columns, opts = T.unsafe(nil)); end
  def add_unique_constraint(columns, opts = T.unsafe(nil)); end
  def drop_column(name, opts = T.unsafe(nil)); end
  def drop_constraint(name, opts = T.unsafe(nil)); end
  def drop_foreign_key(name, opts = T.unsafe(nil)); end
  def drop_index(columns, options = T.unsafe(nil)); end
  def operations; end
  def rename_column(name, new_name, opts = T.unsafe(nil)); end
  def set_column_allow_null(name, allow_null = T.unsafe(nil)); end
  def set_column_default(name, default); end
  def set_column_not_null(name); end
  def set_column_type(name, type, opts = T.unsafe(nil)); end

  private

  def add_composite_foreign_key(columns, table, opts); end
  def add_composite_primary_key(columns, opts); end
  def drop_composite_foreign_key(columns, opts); end
end

class Sequel::Schema::CreateTableGenerator
  def initialize(db, &block); end

  def BigDecimal(name, opts = T.unsafe(nil)); end
  def Bignum(name, opts = T.unsafe(nil)); end
  def Date(name, opts = T.unsafe(nil)); end
  def DateTime(name, opts = T.unsafe(nil)); end
  def FalseClass(name, opts = T.unsafe(nil)); end
  def File(name, opts = T.unsafe(nil)); end
  def Fixnum(name, opts = T.unsafe(nil)); end
  def Float(name, opts = T.unsafe(nil)); end
  def Integer(name, opts = T.unsafe(nil)); end
  def Numeric(name, opts = T.unsafe(nil)); end
  def String(name, opts = T.unsafe(nil)); end
  def Time(name, opts = T.unsafe(nil)); end
  def TrueClass(name, opts = T.unsafe(nil)); end
  def check(*args, &block); end
  def column(name, type, opts = T.unsafe(nil)); end
  def columns; end
  def constraint(name, *args, &block); end
  def constraints; end
  def foreign_key(name, table = T.unsafe(nil), opts = T.unsafe(nil)); end
  def full_text_index(columns, opts = T.unsafe(nil)); end
  def has_column?(name); end
  def index(columns, opts = T.unsafe(nil)); end
  def indexes; end
  def method_missing(type, name = T.unsafe(nil), opts = T.unsafe(nil)); end
  def primary_key(name, *args); end
  def primary_key_name; end
  def spatial_index(columns, opts = T.unsafe(nil)); end
  def unique(columns, opts = T.unsafe(nil)); end

  private

  def composite_foreign_key(columns, opts); end
  def composite_primary_key(columns, *args); end
  def respond_to_missing?(meth, include_private); end

  class << self
    def add_type_method(*types); end
  end
end

Sequel::Schema::CreateTableGenerator::GENERIC_TYPES = T.let(T.unsafe(nil), Array)

module Sequel::SequelMethods
  def application_timezone; end
  def application_timezone=(tz); end
  def application_to_database_timestamp(v); end
  def condition_specifier?(obj); end
  def connect(*args, &block); end
  def convert_exception_class(exception, klass); end
  def convert_output_timestamp(v, output_timezone); end
  def convert_timestamp(v, input_timezone); end
  def convert_two_digit_years; end
  def convert_two_digit_years=(_arg0); end
  def core_extensions?; end
  def current; end
  def database_timezone; end
  def database_timezone=(tz); end
  def database_to_application_timestamp(v); end
  def datetime_class; end
  def datetime_class=(_arg0); end
  def default_timezone=(tz); end
  def elapsed_seconds_since(timer); end
  def extension(*extensions); end
  def json_parser_error_class; end
  def object_to_json(obj, *args, &block); end
  def parse_json(json); end
  def recursive_map(array, converter); end
  def require(files, subdir = T.unsafe(nil)); end
  def single_threaded; end
  def single_threaded=(_arg0); end
  def split_symbol(sym); end
  def split_symbols=(v); end
  def split_symbols?; end
  def start_timer; end
  def string_to_date(string); end
  def string_to_datetime(string); end
  def string_to_time(string); end
  def synchronize(&block); end
  def transaction(dbs, opts = T.unsafe(nil), &block); end
  def typecast_timezone; end
  def typecast_timezone=(tz); end
  def typecast_to_application_timestamp(v); end
  def virtual_row(&block); end

  private

  def adapter_method(adapter, *args, &block); end
  def convert_input_datetime_no_offset(v, input_timezone); end
  def convert_input_datetime_other(v, input_timezone); end
  def convert_input_time_other(v, input_timezone); end
  def convert_input_timestamp(v, input_timezone); end
  def convert_output_datetime_other(v, output_timezone); end
  def convert_output_time_other(v, output_timezone); end
  def convert_timezone_setter_arg(tz); end
  def def_adapter_method(*adapters); end
  def local_offset_for_datetime(dt); end
  def orig_require(_arg0); end
  def time_offset_to_datetime_offset(offset_secs); end
end

class Sequel::SerializationFailure < ::Sequel::DatabaseError
end

Sequel::TINY = T.let(T.unsafe(nil), Integer)

Sequel::Timezones = Sequel::SequelMethods

class Sequel::UndefinedAssociation < ::Sequel::Error
end

class Sequel::UniqueConstraintViolation < ::Sequel::ConstraintViolation
end

Sequel::VERSION = T.let(T.unsafe(nil), String)

Sequel::VERSION_NUMBER = T.let(T.unsafe(nil), Integer)

Sequel::VIRTUAL_ROW = T.let(T.unsafe(nil), Sequel::SQL::VirtualRow)

class Sequel::ValidationFailed < ::Sequel::Error
  def initialize(errors = T.unsafe(nil)); end

  def errors; end
  def model; end
end

Sequel::SQL::VirtualRow::Sequel::VIRTUAL_ROW = T.let(T.unsafe(nil), Sequel::SQL::VirtualRow)
