# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aasm` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module AASM
  include ::AASM::Persistence::PlainPersistence

  mixes_in_class_methods ::AASM::ClassMethods

  def aasm(name = T.unsafe(nil)); end

  private

  def aasm_failed(state_machine_name, event_name, old_state, failures = T.unsafe(nil)); end
  def aasm_fire_event(state_machine_name, event_name, options, *args, &block); end
  def aasm_fired(state_machine_name, event, old_state, new_state_name, options, *args); end
  def fire_default_callbacks(event, *processed_args); end
  def fire_exit_callbacks(old_state, *processed_args); end
  def initialize_dup(other); end
  def process_args(event, from_state, *args); end

  class << self
    def included(base); end
  end
end

class AASM::Base
  def initialize(klass, name, state_machine, options = T.unsafe(nil), &block); end

  def after_all_events(*callbacks, &block); end
  def after_all_transactions(*callbacks, &block); end
  def after_all_transitions(*callbacks, &block); end
  def attribute_name(column_name = T.unsafe(nil)); end
  def before_all_events(*callbacks, &block); end
  def before_all_transactions(*callbacks, &block); end
  def ensure_on_all_events(*callbacks, &block); end
  def error_on_all_events(*callbacks, &block); end
  def event(name, options = T.unsafe(nil), &block); end
  def events; end
  def from_states_for_state(state, options = T.unsafe(nil)); end
  def human_event_name(event); end
  def initial_state(new_initial_state = T.unsafe(nil)); end
  def klass; end
  def state(*args); end
  def state_machine; end
  def state_with_scope(*args); end
  def state_without_scope(*args); end
  def states; end
  def states_for_select; end

  private

  def configure(key, default_value); end
  def create_scope(name); end
  def create_scope?(name); end
  def create_scopes(name); end
  def default_column; end
  def interpret_state_args(args); end
  def namespace; end
  def namespace?; end
  def safely_define_method(klass, method_name, method_definition); end
  def setup_no_direct_assignment(aasm_name); end
  def setup_timestamps(aasm_name); end
  def skip_instance_level_validation(event, name, aasm_name, klass); end
end

module AASM::ClassMethods
  def aasm(*args, &block); end
  def inherited(base); end
end

class AASM::Configuration
  def column; end
  def column=(_arg0); end
  def create_scopes; end
  def create_scopes=(_arg0); end
  def enum; end
  def enum=(_arg0); end
  def logger; end
  def logger=(_arg0); end
  def namespace; end
  def namespace=(_arg0); end
  def no_direct_assignment; end
  def no_direct_assignment=(_arg0); end
  def requires_lock; end
  def requires_lock=(_arg0); end
  def requires_new_transaction; end
  def requires_new_transaction=(_arg0); end
  def skip_validation_on_save; end
  def skip_validation_on_save=(_arg0); end
  def timestamps; end
  def timestamps=(_arg0); end
  def use_transactions; end
  def use_transactions=(_arg0); end
  def whiny_persistence; end
  def whiny_persistence=(_arg0); end
  def whiny_transitions; end
  def whiny_transitions=(_arg0); end
  def with_klass; end
  def with_klass=(_arg0); end

  class << self
    def hide_warnings; end
    def hide_warnings=(_arg0); end
  end
end

module AASM::Core; end

class AASM::Core::Event
  include ::AASM::DslHelper

  def initialize(name, state_machine, options = T.unsafe(nil), &block); end

  def ==(event); end
  def default_display_name; end
  def failed_callbacks; end
  def fire(obj, options = T.unsafe(nil), to_state = T.unsafe(nil), *args); end
  def fire_callbacks(callback_name, record, *args); end
  def fire_global_callbacks(callback_name, record, *args); end
  def fire_transition_callbacks(obj, *args); end
  def may_fire?(obj, to_state = T.unsafe(nil), *args); end
  def name; end
  def options; end
  def state_machine; end
  def to_s; end
  def transitions(definitions = T.unsafe(nil), &block); end
  def transitions_from_state(state); end
  def transitions_from_state?(state); end
  def transitions_to_state(state); end
  def transitions_to_state?(state); end

  private

  def _fire(obj, options = T.unsafe(nil), to_state = T.unsafe(nil), *args); end
  def attach_event_guards(definitions); end
  def clear_failed_callbacks; end
  def initialize_copy(orig); end
  def invoke_callbacks(code, record, args); end
end

class AASM::Core::Invoker
  def initialize(subject, record, args); end

  def invoke; end
  def with_default_return_value(value); end
  def with_failures(failures); end
  def with_options(options); end

  private

  def args; end
  def class_invoker; end
  def default_return_value; end
  def failures; end
  def invoke_array; end
  def literal_invoker; end
  def options; end
  def proc_invoker; end
  def record; end
  def sub_invoke(new_subject); end
  def subject; end
end

AASM::Core::Invoker::DEFAULT_RETURN_VALUE = T.let(T.unsafe(nil), TrueClass)
module AASM::Core::Invokers; end

class AASM::Core::Invokers::BaseInvoker
  def initialize(subject, record, args); end

  def args; end
  def failures; end
  def invoke; end
  def invoke_subject; end
  def log_failure; end
  def may_invoke?; end
  def record; end
  def result; end
  def subject; end
  def with_failures(failures_buffer); end
end

class AASM::Core::Invokers::ClassInvoker < ::AASM::Core::Invokers::BaseInvoker
  def invoke_subject; end
  def log_failure; end
  def may_invoke?; end

  private

  def instance; end
  def log_method_info; end
  def log_source_location; end
  def retrieve_instance; end
  def subject_arity; end
end

class AASM::Core::Invokers::LiteralInvoker < ::AASM::Core::Invokers::BaseInvoker
  def invoke_subject; end
  def log_failure; end
  def may_invoke?; end

  private

  def exec_subject; end
  def record_error; end
  def subject_arity; end
end

class AASM::Core::Invokers::ProcInvoker < ::AASM::Core::Invokers::BaseInvoker
  def invoke_subject; end
  def log_failure; end
  def may_invoke?; end

  private

  def exec_proc(parameters_size); end
  def log_proc_info; end
  def log_source_location; end
  def parameters_to_arity; end
  def support_parameters?; end
end

class AASM::Core::State
  def initialize(name, klass, state_machine, options = T.unsafe(nil)); end

  def <=>(state); end
  def ==(state); end
  def default_display_name; end
  def display_name; end
  def fire_callbacks(action, record, *args); end
  def for_select; end
  def human_name; end
  def localized_name; end
  def name; end
  def options; end
  def state_machine; end
  def to_s; end

  private

  def _fire_callbacks(action, record, args); end
  def initialize_copy(orig); end
  def update(options = T.unsafe(nil)); end
end

class AASM::Core::Transition
  include ::AASM::DslHelper

  def initialize(event, opts, &block); end

  def ==(obj); end
  def allowed?(obj, *args); end
  def event; end
  def execute(obj, *args); end
  def failures; end
  def from; end
  def from?(value); end
  def invoke_success_callbacks(obj, *args); end
  def options; end
  def opts; end
  def to; end

  private

  def _fire_callbacks(code, record, args); end
  def initialize_copy(orig); end
  def invoke_callbacks_compatible_with_guard(code, record, args, options = T.unsafe(nil)); end
end

module AASM::DslHelper
  def add_options_from_dsl(options, valid_keys, &block); end
end

class AASM::DslHelper::Proxy
  def initialize(options, valid_keys, source); end

  def method_missing(name, *args, &block); end
  def options; end
  def options=(_arg0); end
end

class AASM::InstanceBase
  def initialize(instance, name = T.unsafe(nil)); end

  def current_event; end
  def current_event=(_arg0); end
  def current_state; end
  def current_state=(state); end
  def determine_state_name(state); end
  def enter_initial_state; end
  def events(options = T.unsafe(nil), *args); end
  def fire(event_name, *args, &block); end
  def fire!(event_name, *args, &block); end
  def from_state; end
  def from_state=(_arg0); end
  def human_state; end
  def may_fire_event?(name, *args); end
  def permitted_transitions; end
  def set_current_state_with_persistence(state); end
  def state_object_for_name(name); end
  def states(options = T.unsafe(nil), *args); end
  def to_state; end
  def to_state=(_arg0); end
end

class AASM::InvalidTransition < ::RuntimeError
  def initialize(object, event_name, state_machine_name, failures = T.unsafe(nil)); end

  def event_name; end
  def failures; end
  def object; end
  def originating_state; end
  def reasoning; end
  def state_machine_name; end
end

class AASM::Localizer
  def human_event_name(klass, event); end
  def human_state_name(klass, state); end

  private

  def ancestors_list(klass); end
  def default_display_name(object); end
  def i18n_klass(klass); end
  def i18n_scope(klass); end
  def item_for(klass, state, ancestor, options = T.unsafe(nil)); end
  def translate_queue(checklist); end
end

AASM::NO_VALUE = T.let(T.unsafe(nil), Symbol)
class AASM::NoDirectAssignmentError < ::RuntimeError; end

module AASM::Persistence
  class << self
    def load_persistence(base); end

    private

    def capitalize(string_or_symbol); end
    def constantize(string); end
    def include_persistence(base, type); end
    def require_persistence(type); end
  end
end

module AASM::Persistence::Base
  mixes_in_class_methods ::AASM::Persistence::Base::ClassMethods

  def aasm_new_record?; end
  def aasm_read_state(name = T.unsafe(nil)); end

  class << self
    def included(base); end
  end
end

module AASM::Persistence::Base::ClassMethods
  def aasm_column(attribute_name = T.unsafe(nil)); end
end

module AASM::Persistence::PlainPersistence
  def aasm_read_state(name = T.unsafe(nil)); end
  def aasm_write_state(new_state, name = T.unsafe(nil)); end
  def aasm_write_state_without_persistence(new_state, name = T.unsafe(nil)); end
end

class AASM::StateMachine
  def initialize(name); end

  def add_event(name, options, &block); end
  def add_global_callbacks(name, *callbacks, &block); end
  def add_state(state_name, klass, options); end
  def config; end
  def config=(_arg0); end
  def events; end
  def events=(_arg0); end
  def global_callbacks; end
  def global_callbacks=(_arg0); end
  def initial_state; end
  def initial_state=(_arg0); end
  def name; end
  def name=(_arg0); end
  def states; end
  def states=(_arg0); end

  private

  def initialize_copy(orig); end
  def set_initial_state(name, options); end
end

class AASM::StateMachineStore
  def initialize; end

  def [](name); end
  def clone; end
  def keys; end
  def machine(name); end
  def machine_names; end
  def register(name, machine, force = T.unsafe(nil)); end

  class << self
    def [](klass, fallback = T.unsafe(nil)); end
    def []=(klass, overwrite = T.unsafe(nil), state_machine = T.unsafe(nil)); end
    def fetch(klass, fallback = T.unsafe(nil)); end
    def register(klass, overwrite = T.unsafe(nil), state_machine = T.unsafe(nil)); end
    def stores; end
    def unregister(klass); end
  end
end

class AASM::UndefinedState < ::RuntimeError; end
class AASM::UnknownStateMachineError < ::RuntimeError; end
AASM::VERSION = T.let(T.unsafe(nil), String)
