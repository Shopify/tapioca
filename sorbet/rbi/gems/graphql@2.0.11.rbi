# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `graphql` gem.
# Please instead update this file by running `bin/tapioca gem graphql`.

# backport from ruby v2.5 to v2.2 that has no `padding` things
#
# @api private
module Base64Bp
  extend ::Base64

  private

  # @api private
  def urlsafe_decode64(str); end

  # @api private
  def urlsafe_encode64(bin, padding:); end

  class << self
    # @api private
    def urlsafe_decode64(str); end

    # @api private
    def urlsafe_encode64(bin, padding:); end
  end
end

module GraphQL
  class << self
    def default_parser; end

    # Sets the attribute default_parser
    #
    # @param value the value to set the attribute default_parser to.
    def default_parser=(_arg0); end

    # Turn a query string or schema definition into an AST
    #
    # @param graphql_string [String] a GraphQL query string or schema definition
    # @return [GraphQL::Language::Nodes::Document]
    def parse(graphql_string, tracer: T.unsafe(nil)); end

    # Read the contents of `filename` and parse them as GraphQL
    #
    # @param filename [String] Path to a `.graphql` file containing IDL or query
    # @return [GraphQL::Language::Nodes::Document]
    def parse_file(filename); end

    def parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

    # @return [Array<GraphQL::Language::Token>]
    def scan(graphql_string); end

    def scan_with_ragel(graphql_string); end
  end
end

module GraphQL::Analysis; end

# A query reducer for measuring the depth of a given query.
#
# See https://graphql-ruby.org/queries/ast_analysis.html for more examples.
#
# @example Logging the depth of a query
#   class LogQueryDepth < GraphQL::Analysis::QueryDepth
#   def result
#   log("GraphQL query depth: #{@max_depth}")
#   end
#   end
#
#   # In your Schema file:
#
#   class MySchema < GraphQL::Schema
#   query_analyzer LogQueryDepth
#   end
#
#   # When you run the query, the depth will get logged:
#
#   Schema.execute(query_str)
#   # GraphQL query depth: 8
module GraphQL::Analysis::AST
  private

  def analysis_errors(results); end

  # Analyze a multiplex, and all queries within.
  # Multiplex analyzers are ran for all queries, keeping state.
  # Query analyzers are ran per query, without carrying state between queries.
  #
  # @param multiplex [GraphQL::Execution::Multiplex]
  # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
  # @return [Array<Any>] Results from multiplex analyzers
  def analyze_multiplex(multiplex, analyzers); end

  # @param query [GraphQL::Query]
  # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
  # @return [Array<Any>] Results from those analyzers
  def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

  class << self
    def analysis_errors(results); end

    # Analyze a multiplex, and all queries within.
    # Multiplex analyzers are ran for all queries, keeping state.
    # Query analyzers are ran per query, without carrying state between queries.
    #
    # @param multiplex [GraphQL::Execution::Multiplex]
    # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
    # @return [Array<Any>] Results from multiplex analyzers
    def analyze_multiplex(multiplex, analyzers); end

    # @param query [GraphQL::Query]
    # @param analyzers [Array<GraphQL::Analysis::AST::Analyzer>]
    # @return [Array<Any>] Results from those analyzers
    def analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end
  end
end

# Query analyzer for query ASTs. Query analyzers respond to visitor style methods
# but are prefixed by `enter` and `leave`.
#
# When an analyzer is initialized with a Multiplex, you can always get the current query from
# `visitor.query` in the visit methods.
#
# @param The [GraphQL::Query, GraphQL::Execution::Multiplex] query or multiplex to analyze
class GraphQL::Analysis::AST::Analyzer
  # @return [Analyzer] a new instance of Analyzer
  def initialize(subject); end

  # Analyzer hook to decide at analysis time whether a query should
  # be analyzed or not.
  #
  # @return [Boolean] If the query should be analyzed or not
  def analyze?; end

  def on_enter_abstract_node(node, parent, visitor); end
  def on_enter_argument(node, parent, visitor); end
  def on_enter_directive(node, parent, visitor); end
  def on_enter_document(node, parent, visitor); end
  def on_enter_enum(node, parent, visitor); end
  def on_enter_field(node, parent, visitor); end
  def on_enter_fragment_spread(node, parent, visitor); end
  def on_enter_inline_fragment(node, parent, visitor); end
  def on_enter_input_object(node, parent, visitor); end
  def on_enter_list_type(node, parent, visitor); end
  def on_enter_non_null_type(node, parent, visitor); end
  def on_enter_null_value(node, parent, visitor); end
  def on_enter_operation_definition(node, parent, visitor); end
  def on_enter_type_name(node, parent, visitor); end
  def on_enter_variable_definition(node, parent, visitor); end
  def on_enter_variable_identifier(node, parent, visitor); end
  def on_leave_abstract_node(node, parent, visitor); end
  def on_leave_argument(node, parent, visitor); end
  def on_leave_directive(node, parent, visitor); end
  def on_leave_document(node, parent, visitor); end
  def on_leave_enum(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def on_leave_fragment_spread(node, parent, visitor); end
  def on_leave_inline_fragment(node, parent, visitor); end
  def on_leave_input_object(node, parent, visitor); end
  def on_leave_list_type(node, parent, visitor); end
  def on_leave_non_null_type(node, parent, visitor); end
  def on_leave_null_value(node, parent, visitor); end
  def on_leave_operation_definition(node, parent, visitor); end
  def on_leave_type_name(node, parent, visitor); end
  def on_leave_variable_definition(node, parent, visitor); end
  def on_leave_variable_identifier(node, parent, visitor); end

  # The result for this analyzer. Returning {GraphQL::AnalysisError} results
  # in a query error.
  #
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Any] The analyzer result
  def result; end

  protected

  # @return [GraphQL::Execution::Multiplex, nil] `nil` if this analyzer is visiting a query
  def multiplex; end

  # @return [GraphQL::Query, nil] `nil` if this analyzer is visiting a multiplex
  #   (When this is `nil`, use `visitor.query` inside visit methods to get the current query)
  def query; end

  # @return [GraphQL::Query, GraphQL::Execution::Multiplex] Whatever this analyzer is analyzing
  def subject; end

  class << self
    private

    def build_visitor_hooks(member_name); end
  end
end

class GraphQL::Analysis::AST::FieldUsage < ::GraphQL::Analysis::AST::Analyzer
  # @return [FieldUsage] a new instance of FieldUsage
  def initialize(query); end

  def on_leave_field(node, parent, visitor); end
  def result; end

  private

  def extract_deprecated_arguments(argument_values); end
end

# Used under the hood to implement complexity validation,
# see {Schema#max_complexity} and {Query#max_complexity}
class GraphQL::Analysis::AST::MaxQueryComplexity < ::GraphQL::Analysis::AST::QueryComplexity
  def result; end
end

class GraphQL::Analysis::AST::MaxQueryDepth < ::GraphQL::Analysis::AST::QueryDepth
  def result; end
end

class GraphQL::Analysis::AST::QueryComplexity < ::GraphQL::Analysis::AST::Analyzer
  # State for the query complexity calculation:
  # - `complexities_on_type` holds complexity scores for each type
  #
  # @return [QueryComplexity] a new instance of QueryComplexity
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end

  # Overide this method to use the complexity result
  def result; end

  private

  # @return [Boolean]
  def applies_to?(query, left_scope, right_scope); end

  # A hook which is called whenever a field's max complexity is calculated.
  # Override this method to capture individual field complexity details.
  #
  # @param scoped_type_complexity [ScopedTypeComplexity]
  # @param max_complexity [Numeric] Field's maximum complexity including child complexity
  # @param child_complexity [Numeric, nil] Field's child complexity
  def field_complexity(scoped_type_complexity, max_complexity:, child_complexity: T.unsafe(nil)); end

  # @return [Integer]
  def max_possible_complexity; end

  # (`{field_key => complexity}`)
  #
  # @param children_for_scope [Array<Hash>] An array of `scoped_children[scope]` hashes
  # @return [Integer] Complexity value for all these selections in the current scope
  def merged_max_complexity(query, children_for_scope); end

  # @param query [GraphQL::Query] Used for `query.possible_types`
  # @param scoped_children_hashes [Array<Hash>] Array of scoped children hashes
  # @return [Integer]
  def merged_max_complexity_for_scopes(query, scoped_children_hashes); end
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
  # @param parent_type [Class] The owner of `field_definition`
  # @param field_definition [GraphQL::Field, GraphQL::Schema::Field] Used for getting the `.complexity` configuration
  # @param query [GraphQL::Query] Used for `query.possible_types`
  # @param response_path [Array<String>] The path to the response key for the field
  # @return [ScopedTypeComplexity] a new instance of ScopedTypeComplexity
  def initialize(parent_type, field_definition, query, response_path); end

  # Returns the value of attribute field_definition.
  def field_definition; end

  # @return [Array<GraphQL::Language::Nodes::Field>]
  def nodes; end

  def own_complexity(child_complexity); end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute response_path.
  def response_path; end

  # This value is only calculated when asked for to avoid needless hash allocations.
  # Also, if it's never asked for, we determine that this scope complexity
  # is a scalar field ({#terminal?}).
  #
  # @return [Hash<Hash<Class => ScopedTypeComplexity>]] Hash<Hash<Class => ScopedTypeComplexity>]
  def scoped_children; end

  # Returns true if this field has no selections, ie, it's a scalar.
  # We need a quick way to check whether we should continue traversing.
  #
  # @return [Boolean]
  def terminal?; end
end

# A single proc for {#scoped_children} hashes. Use this to avoid repeated allocations,
# since the lexical binding isn't important.
GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity::HASH_CHILDREN = T.let(T.unsafe(nil), Proc)

class GraphQL::Analysis::AST::QueryDepth < ::GraphQL::Analysis::AST::Analyzer
  # @return [QueryDepth] a new instance of QueryDepth
  def initialize(query); end

  def on_enter_field(node, parent, visitor); end
  def on_leave_field(node, parent, visitor); end
  def result; end
end

# Depth first traversal through a query AST, calling AST analyzers
# along the way.
#
# The visitor is a special case of GraphQL::Language::Visitor, visiting
# only the selected operation, providing helpers for common use cases such
# as skipped fields and visiting fragment spreads.
#
# @see {GraphQL::Analysis::AST::Analyzer} AST Analyzers for queries
class GraphQL::Analysis::AST::Visitor < ::GraphQL::Language::Visitor
  # @return [Visitor] a new instance of Visitor
  def initialize(query:, analyzers:); end

  # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
  def argument_definition; end

  # @return [GraphQL::Execution::Interpreter::Arguments] Arguments for this node, merging default values, literal values and query variables
  # @see {GraphQL::Query#arguments_for}
  def arguments_for(ast_node, field_definition); end

  # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
  def directive_definition; end

  # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
  def field_definition; end

  # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
  def object_types; end

  def on_abstract_node(node, parent); end
  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  # Visitor Hooks
  def on_operation_definition(node, parent); end

  # @return [GraphQL::BaseType] The type which the current type came from
  def parent_type_definition; end

  # @return [GraphQL::Argument, nil] The previous GraphQL argument
  def previous_argument_definition; end

  # @return [GraphQL::Field, nil] The GraphQL field which returned the object that the current field belongs to
  def previous_field_definition; end

  # @return [GraphQL::Query] the query being visited
  def query; end

  # @return [Array<GraphQL::AnalysisError]] Array<GraphQL::AnalysisError]
  def rescued_errors; end

  # @return [Array<String>] The path to the response key for the current field
  def response_path; end

  # @return [Boolean] If the current node should be skipped because of a skip or include directive
  def skipping?; end

  # @return [GraphQL::BaseType] The current object type
  def type_definition; end

  def visit; end

  # @return [Boolean] If the visitor is currently inside a fragment definition
  def visiting_fragment_definition?; end

  private

  def call_analyzers(method, node, parent); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def enter_fragment_spread_inline(fragment_spread); end

  # Visit a fragment spread inline instead of visiting the definition
  # by itself.
  def leave_fragment_spread_inline(_fragment_spread); end

  # @yield [node]
  def on_fragment_with_type(node); end

  # @return [Boolean]
  def skip?(ast_node); end
end

class GraphQL::AnalysisError < ::GraphQL::ExecutionError; end

# Wrap unhandled errors with {TracedError}.
#
# {TracedError} provides a GraphQL backtrace with arguments and return values.
# The underlying error is available as {TracedError#cause}.
#
# @example toggling backtrace annotation
#   class MySchema < GraphQL::Schema
#   if Rails.env.development? || Rails.env.test?
#   use GraphQL::Backtrace
#   end
#   end
class GraphQL::Backtrace
  include ::Enumerable
  extend ::Forwardable

  # @return [Backtrace] a new instance of Backtrace
  def initialize(context, value: T.unsafe(nil)); end

  def [](*args, &block); end
  def each(*args, &block); end
  def inspect; end
  def to_a; end
  def to_s; end

  class << self
    def use(schema_defn); end
  end
end

# Used for internal bookkeeping
#
# @api private
class GraphQL::Backtrace::Frame
  # @api private
  # @return [Frame] a new instance of Frame
  def initialize(path:, query:, ast_node:, object:, field:, arguments:, parent_frame:); end

  # @api private
  def arguments; end

  # @api private
  def ast_node; end

  # @api private
  def field; end

  # @api private
  def object; end

  # @api private
  def parent_frame; end

  # @api private
  def path; end

  # @api private
  def query; end
end

module GraphQL::Backtrace::InspectResult
  private

  def inspect_result(obj); end
  def inspect_truncated(obj); end

  class << self
    def inspect_result(obj); end
    def inspect_truncated(obj); end
  end
end

# A class for turning a context into a human-readable table or array
class GraphQL::Backtrace::Table
  # @return [Table] a new instance of Table
  def initialize(context, value:); end

  # @return [Array<String>] An array of position + field name entries
  def to_backtrace; end

  # @return [String] A table layout of backtrace with metadata
  def to_table; end

  private

  # @return [Array] 5 items for a backtrace table (not `key`)
  def build_rows(context_entry, rows:, top: T.unsafe(nil)); end

  # @return [String]
  def render_table(rows); end

  def rows; end
  def value_at(runtime, path); end
end

GraphQL::Backtrace::Table::HEADERS = T.let(T.unsafe(nil), Array)
GraphQL::Backtrace::Table::MAX_COL_WIDTH = T.let(T.unsafe(nil), Integer)
GraphQL::Backtrace::Table::MIN_COL_WIDTH = T.let(T.unsafe(nil), Integer)

# When {Backtrace} is enabled, raised errors are wrapped with {TracedError}.
class GraphQL::Backtrace::TracedError < ::GraphQL::Error
  # @return [TracedError] a new instance of TracedError
  def initialize(err, current_ctx); end

  # @return [GraphQL::Query::Context] The context at the field where the error was raised
  def context; end

  # @return [Array<String>] Printable backtrace of GraphQL error context
  def graphql_backtrace; end
end

# This many lines of the original Ruby backtrace
# are included in the message
GraphQL::Backtrace::TracedError::CAUSE_BACKTRACE_PREVIEW_LENGTH = T.let(T.unsafe(nil), Integer)

GraphQL::Backtrace::TracedError::MESSAGE_TEMPLATE = T.let(T.unsafe(nil), String)

# TODO this is not fiber-friendly
module GraphQL::Backtrace::Tracer
  private

  # Implement the {GraphQL::Tracing} API.
  def trace(key, metadata); end

  class << self
    # Implement the {GraphQL::Tracing} API.
    def trace(key, metadata); end
  end
end

class GraphQL::CoercionError < ::GraphQL::Error
  # @return [CoercionError] a new instance of CoercionError
  def initialize(message, extensions: T.unsafe(nil)); end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions; end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions=(_arg0); end
end

# This plugin supports Fiber-based concurrency, along with {GraphQL::Dataloader::Source}.
#
# @example Installing Dataloader
#
#   class MySchema < GraphQL::Schema
#   use GraphQL::Dataloader
#   end
# @example Waiting for batch-loaded data in a GraphQL field
#
#   field :team, Types::Team, null: true
#
#   def team
#   dataloader.with(Sources::Record, Team).load(object.team_id)
#   end
class GraphQL::Dataloader
  # @return [Dataloader] a new instance of Dataloader
  def initialize(nonblocking: T.unsafe(nil)); end

  # @api private Nothing to see here
  def append_job(&job); end

  def join_queues(previous_queue, next_queue); end

  # @return [Boolean]
  def nonblocking?; end

  # @api private Move along, move along
  def run; end

  # Use a self-contained queue for the work in the block.
  def run_isolated; end

  # truffle-ruby wasn't doing well with the implementation below
  def with(source_class, *batch_args, **batch_kwargs); end

  # Tell the dataloader that this fiber is waiting for data.
  #
  # Dataloader will resume the fiber after the requested data has been loaded (by another Fiber).
  #
  # @return [void]
  def yield; end

  private

  # If there are pending sources, return a fiber for running them.
  # Otherwise, return `nil`.
  #
  # @return [Fiber, nil]
  def create_source_fiber; end

  def resume(fiber); end

  # Copies the thread local vars into the fiber thread local vars. Many
  # gems (such as RequestStore, MiniRacer, etc.) rely on thread local vars
  # to keep track of execution context, and without this they do not
  # behave as expected.
  #
  # @see https://github.com/rmosolgo/graphql-ruby/issues/3449
  def spawn_fiber; end

  class << self
    # Returns the value of attribute default_nonblocking.
    def default_nonblocking; end

    # Sets the attribute default_nonblocking
    #
    # @param value the value to set the attribute default_nonblocking to.
    def default_nonblocking=(_arg0); end

    def use(schema, nonblocking: T.unsafe(nil)); end

    # Call the block with a Dataloader instance,
    # then run all enqueued jobs and return the result of the block.
    def with_dataloading(&block); end
  end
end

class GraphQL::Dataloader::AsyncDataloader < ::GraphQL::Dataloader; end

# The default implementation of dataloading -- all no-ops.
#
# The Dataloader interface isn't public, but it enables
# simple internal code while adding the option to add Dataloader.
class GraphQL::Dataloader::NullDataloader < ::GraphQL::Dataloader
  def append_job; end

  # These are all no-ops because code was
  # executed sychronously.
  def run; end

  def run_isolated; end

  # @raise [GraphQL::Error]
  def yield; end
end

# @see Source#request which returns an instance of this
class GraphQL::Dataloader::Request
  # @return [Request] a new instance of Request
  def initialize(source, key); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  #
  # @return [Object] the object loaded for `key`
  def load; end
end

# @see Source#request_all which returns an instance of this.
class GraphQL::Dataloader::RequestAll < ::GraphQL::Dataloader::Request
  # @return [RequestAll] a new instance of RequestAll
  def initialize(source, keys); end

  # Call this method to cause the current Fiber to wait for the results of this request.
  #
  # @return [Array<Object>] One object for each of `keys`
  def load; end
end

class GraphQL::Dataloader::Source
  # Returns the value of attribute dataloader.
  def dataloader; end

  # Subclasses must implement this method to return a value for each of `keys`
  #
  # @param keys [Array<Object>] keys passed to {#load}, {#load_all}, {#request}, or {#request_all}
  # @return [Array<Object>] A loaded value for each of `keys`. The array must match one-for-one to the list of `keys`.
  def fetch(keys); end

  # @param key [Object] A loading key which will be passed to {#fetch} if it isn't already in the internal cache.
  # @return [Object] The result from {#fetch} for `key`. If `key` hasn't been loaded yet, the Fiber will yield until it's loaded.
  def load(key); end

  # @param keys [Array<Object>] Loading keys which will be passed to `#fetch` (or read from the internal cache).
  # @return [Object] The result from {#fetch} for `keys`. If `keys` haven't been loaded yet, the Fiber will yield until they're loaded.
  def load_all(keys); end

  # @return [Boolean] True if this source has any pending requests for data.
  def pending?; end

  # Returns the value of attribute pending_keys.
  def pending_keys; end

  # @return [Dataloader::Request] a pending request for a value from `key`. Call `.load` on that object to wait for the result.
  def request(key); end

  # @return [Dataloader::Request] a pending request for a values from `keys`. Call `.load` on that object to wait for the results.
  def request_all(keys); end

  # Called by {GraphQL::Dataloader} to resolve and pending requests to this source.
  #
  # @api private
  # @return [void]
  def run_pending_keys; end

  # Called by {Dataloader} to prepare the {Source}'s internal state
  #
  # @api private
  def setup(dataloader); end

  # Wait for a batch, if there's anything to batch.
  # Then run the batch and update the cache.
  #
  # @return [void]
  def sync; end

  private

  # Reads and returns the result for the key from the internal cache, or raises an error if the result was an error
  #
  # @api private
  # @param key [Object] key passed to {#load} or {#load_all}
  # @return [Object] The result from {#fetch} for `key`.
  def result_for(key); end

  class << self
    # These arguments are given to `dataloader.with(source_class, ...)`. The object
    # returned from this method is used to de-duplicate batch loads under the hood
    # by using it as a Hash key.
    #
    # By default, the arguments are all put in an Array. To customize how this source's
    # batches are merged, override this method to return something else.
    #
    # For example, if you pass `ActiveRecord::Relation`s to `.with(...)`, you could override
    # this method to call `.to_sql` on them, thus merging `.load(...)` calls when they apply
    # to equivalent relations.
    #
    # @param batch_args [Array<Object>]
    # @param batch_kwargs [Hash]
    # @return [Object]
    def batch_key_for(*batch_args, **batch_kwargs); end
  end
end

# This error is raised when `Types::ISO8601Date` is asked to return a value
# that cannot be parsed to a Ruby Date.
#
# @see GraphQL::Types::ISO8601Date which raises this error
class GraphQL::DateEncodingError < ::GraphQL::RuntimeTypeError
  # @return [DateEncodingError] a new instance of DateEncodingError
  def initialize(value); end

  # The value which couldn't be encoded
  def date_value; end
end

module GraphQL::Deprecation
  class << self
    def warn(message); end
  end
end

module GraphQL::Dig
  # implemented using the old activesupport #dig instead of the ruby built-in
  # so we can use some of the magic in Schema::InputObject and Interpreter::Arguments
  # to handle stringified/symbolized keys.
  #
  # @param args [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly] rgs [Array<[String, Symbol>] Retrieves the value object corresponding to the each key objects repeatedly
  # @return [Object]
  def dig(own_key, *rest_keys); end
end

class GraphQL::Error < ::StandardError; end
module GraphQL::Execution; end

# Boolean checks for how an AST node's directives should
# influence its execution
#
# @api private
module GraphQL::Execution::DirectiveChecks
  private

  # @api private
  # @return [Boolean] Should this node be included in the query?
  def include?(directive_ast_nodes, query); end

  class << self
    # @api private
    # @return [Boolean] Should this node be included in the query?
    def include?(directive_ast_nodes, query); end
  end
end

# @api private
GraphQL::Execution::DirectiveChecks::INCLUDE = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Execution::DirectiveChecks::SKIP = T.let(T.unsafe(nil), String)

class GraphQL::Execution::Errors
  class << self
    # @return [Proc, nil] The handler for `error_class`, if one was registered on this schema or inherited
    def find_handler_for(schema, error_class); end

    # Register this handler, updating the
    # internal handler index to maintain least-to-most specific.
    #
    # @param error_class [Class<Exception>]
    # @param error_handlers [Hash]
    # @param error_handler [Proc]
    # @return [void]
    def register_rescue_from(error_class, error_handlers, error_handler); end
  end
end

module GraphQL::Execution::Instrumentation
  class << self
    # This function implements the instrumentation policy:
    #
    # - Instrumenters are a stack; the first `before_query` will have the last `after_query`
    # - If a `before_` hook returned without an error, its corresponding `after_` hook will run.
    # - If the `before_` hook did _not_ run, the `after_` hook will not be called.
    #
    # When errors are raised from `after_` hooks:
    #   - Subsequent `after_` hooks _are_ called
    #   - The first raised error is captured; later errors are ignored
    #   - If an error was capture, it's re-raised after all hooks are finished
    #
    # Partial runs of instrumentation are possible:
    # - If a `before_multiplex` hook raises an error, no `before_query` hooks will run
    # - If a `before_query` hook raises an error, subsequent `before_query` hooks will not run (on any query)
    def apply_instrumenters(multiplex); end

    private

    def call_after_hooks(instrumenters, object, after_hook_name, ex); end

    # Call each before hook, and if they all succeed, yield.
    # If they don't all succeed, call after_ for each one that succeeded.
    def call_hooks(instrumenters, object, before_hook_name, after_hook_name); end

    # Call the before_ hooks of each query,
    # Then yield if no errors.
    # `call_hooks` takes care of appropriate cleanup.
    def each_query_call_hooks(instrumenters, queries, i = T.unsafe(nil)); end
  end
end

class GraphQL::Execution::Interpreter
  # Run the eager part of `query`
  #
  # @return [Interpreter::Runtime]
  def evaluate(query); end

  # Run the lazy part of `query` or `multiplex`.
  #
  # @return [void]
  def sync_lazies(query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  class << self
    def begin_multiplex(multiplex); end
    def begin_query(query, multiplex); end
    def finish_multiplex(_results, multiplex); end
    def finish_query(query, _multiplex); end
  end
end

# A container for metadata regarding arguments present in a GraphQL query.
#
# @see Interpreter::Arguments#argument_values for a hash of these objects.
class GraphQL::Execution::Interpreter::ArgumentValue
  # @return [ArgumentValue] a new instance of ArgumentValue
  def initialize(definition:, value:, default_used:); end

  # @return [Boolean] `true` if the schema-defined `default_value:` was applied in this case. (No client-provided value was present.)
  def default_used?; end

  # @return [GraphQL::Schema::Argument] The definition instance for this argument
  def definition; end

  # @return [Object] The Ruby-ready value for this Argument
  def value; end
end

# A wrapper for argument hashes in GraphQL queries.
#
# This object is immutable so that the runtime code can be sure that
# modifications don't leak from one use to another
#
# @see GraphQL::Query#arguments_for to get access to these objects.
class GraphQL::Execution::Interpreter::Arguments
  include ::GraphQL::Dig
  extend ::Forwardable

  # @param argument_values [nil, Hash{Symbol => ArgumentValue}]
  # @param keyword_arguments [nil, Hash{Symbol => Object}]
  # @return [Arguments] a new instance of Arguments
  def initialize(argument_values:, keyword_arguments: T.unsafe(nil)); end

  def [](*args, &block); end

  # @return [Hash{Symbol => ArgumentValue}]
  def argument_values; end

  def each(*args, &block); end
  def each_value(*args, &block); end

  # @return [Boolean]
  def empty?; end

  def fetch(*args, &block); end
  def inspect; end
  def key?(*args, &block); end
  def keys(*args, &block); end

  # The Ruby-style arguments hash, ready for a resolver.
  # This hash is the one used at runtime.
  #
  # @return [Hash<Symbol, Object>]
  def keyword_arguments; end

  # Create a new arguments instance which includes these extras.
  #
  # This is called by the runtime to implement field `extras: [...]`
  #
  # @api private
  # @param extra_args [Hash<Symbol => Object>]
  # @return [Interpreter::Arguments]
  def merge_extras(extra_args); end

  def size(*args, &block); end
  def to_h(*args, &block); end
  def values(*args, &block); end
end

GraphQL::Execution::Interpreter::Arguments::EMPTY = T.let(T.unsafe(nil), GraphQL::Execution::Interpreter::Arguments)
GraphQL::Execution::Interpreter::Arguments::NO_ARGS = T.let(T.unsafe(nil), Hash)

class GraphQL::Execution::Interpreter::ArgumentsCache
  # @return [ArgumentsCache] a new instance of ArgumentsCache
  def initialize(query); end

  # @yield [Interpreter::Arguments, Lazy<Interpreter::Arguments>] The finally-loaded arguments
  def dataload_for(ast_node, argument_owner, parent_object, &block); end

  def fetch(ast_node, argument_owner, parent_object); end

  class << self
    def prepare_args_hash(query, ast_arg_or_hash_or_value); end
  end
end

GraphQL::Execution::Interpreter::ArgumentsCache::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)
GraphQL::Execution::Interpreter::ArgumentsCache::NO_VALUE_GIVEN = T.let(T.unsafe(nil), Object)

class GraphQL::Execution::Interpreter::ExecutionErrors
  # @return [ExecutionErrors] a new instance of ExecutionErrors
  def initialize(ctx, ast_node, path); end

  def add(err_or_msg); end
end

class GraphQL::Execution::Interpreter::ListResultFailedError < ::GraphQL::Error
  # @return [ListResultFailedError] a new instance of ListResultFailedError
  def initialize(value:, path:, field:); end
end

# Wrapper for raw values
class GraphQL::Execution::Interpreter::RawValue
  # @return [RawValue] a new instance of RawValue
  def initialize(obj = T.unsafe(nil)); end

  def resolve; end
end

module GraphQL::Execution::Interpreter::Resolve
  class << self
    # After getting `results` back from an interpreter evaluation,
    # continue it until you get a response-ready Ruby value.
    #
    # `results` is one level of _depth_ of a query or multiplex.
    #
    # Resolve all lazy values in that depth before moving on
    # to the next level.
    #
    # It's assumed that the lazies will
    # return {Lazy} instances if there's more work to be done,
    # or return {Hash}/{Array} if the query should be continued.
    #
    # @return [void]
    def resolve(results, dataloader); end

    # Continue field results in `results` until there's nothing else to continue.
    #
    # @return [void]
    def resolve_all(results, dataloader); end
  end
end

# I think it would be even better if we could somehow make
# `continue_field` not recursive. "Trampolining" it somehow.
#
# @api private
class GraphQL::Execution::Interpreter::Runtime
  # @api private
  # @return [Runtime] a new instance of Runtime
  def initialize(query:); end

  # @api private
  # @param obj [Object] Some user-returned value that may want to be batched
  # @param path [Array<String>]
  # @param field [GraphQL::Schema::Field]
  # @param eager [Boolean] Set to `true` for mutation root fields only
  # @param trace [Boolean] If `false`, don't wrap this with field tracing
  # @return [GraphQL::Execution::Lazy, Object] If loading `object` will be deferred, it's a wrapper over it.
  def after_lazy(lazy_obj, owner:, field:, path:, owner_object:, arguments:, ast_node:, result:, result_name:, eager: T.unsafe(nil), trace: T.unsafe(nil), &block); end

  # @api private
  def arguments(graphql_object, arg_owner, ast_node); end

  # @api private
  def authorized_new(type, value, context); end

  # @api private
  def call_method_on_directives(method_name, object, directives, &block); end

  # @api private
  # @return [GraphQL::Query::Context]
  def context; end

  # The resolver for `field` returned `value`. Continue to execute the query,
  # treating `value` as `type` (probably the return type of the field).
  #
  # Use `next_selections` to resolve object fields, if there are any.
  #
  # Location information from `path` and `ast_node`.
  #
  # @api private
  # @return [Lazy, Array, Hash, Object] Lazy, Array, and Hash are all traversed to resolve lazy values later
  def continue_field(path, value, owner_type, field, current_type, ast_node, next_selections, is_non_null, owner_object, arguments, result_name, selection_result); end

  # @api private
  def continue_value(path, value, parent_type, field, is_non_null, ast_node, result_name, selection_result); end

  # @api private
  # @return [Boolean]
  def dead_result?(selection_result); end

  # @api private
  # @return [void]
  def deep_merge_selection_result(from_result, into_result); end

  # @api private
  def delete_interpreter_context(key); end

  # Check {Schema::Directive.include?} for each directive that's present
  #
  # @api private
  # @return [Boolean]
  def directives_include?(node, graphql_object, parent_type); end

  # @api private
  # @return [void]
  def evaluate_selection(path, result_name, field_ast_nodes_or_ast_node, owner_object, owner_type, is_eager_field, selections_result, parent_object); end

  # @api private
  def evaluate_selection_with_args(arguments, field_defn, next_path, ast_node, field_ast_nodes, owner_type, object, is_eager_field, result_name, selection_result, parent_object); end

  # @api private
  # @return [void]
  def evaluate_selections(path, owner_object, owner_type, is_eager_selection, gathered_selections, selections_result, target_result, parent_object); end

  # @api private
  def final_result; end

  # @api private
  def gather_selections(owner_object, owner_type, selections, selections_to_run = T.unsafe(nil), selections_by_name = T.unsafe(nil)); end

  # @api private
  def inspect; end

  # @api private
  # @return [Boolean]
  def lazy?(object); end

  # @api private
  def progress_path; end

  # @api private
  # @return [GraphQL::Query]
  def query; end

  # @api private
  def resolve_list_item(inner_value, inner_type, next_path, ast_node, field, owner_object, arguments, this_idx, response_list, next_selections, owner_type); end

  # @api private
  def resolve_type(type, value, path); end

  # @api private
  def run_directive(method_name, object, directives, idx, &block); end

  # This _begins_ the execution. Some deferred work
  # might be stored up in lazies.
  #
  # @api private
  # @return [void]
  def run_eager; end

  # @api private
  # @return [Class<GraphQL::Schema>]
  def schema; end

  # @api private
  def set_all_interpreter_context(object, field, arguments, path); end

  # Mark this node and any already-registered children as dead,
  # so that it accepts no more writes.
  #
  # @api private
  def set_graphql_dead(selection_result); end

  # Set this pair in the Query context, but also in the interpeter namespace,
  # for compatibility.
  #
  # @api private
  def set_interpreter_context(key, value); end

  # @api private
  def set_result(selection_result, result_name, value); end

  # @api private
  def tap_or_each(obj_or_array); end
end

# @api private
module GraphQL::Execution::Interpreter::Runtime::GraphQLResult
  # @api private
  def initialize(result_name, parent_result); end

  # @api private
  def graphql_dead; end

  # @api private
  def graphql_dead=(_arg0); end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  #
  # @api private
  # @return [nil, Array<String>]
  def graphql_non_null_field_names; end

  # Although these are used by only one of the Result classes,
  # it's handy to have the methods implemented on both (even though they just return `nil`)
  # because it makes it easy to check if anything is assigned.
  #
  # @api private
  # @return [nil, Array<String>]
  def graphql_non_null_field_names=(_arg0); end

  # @api private
  # @return [nil, true]
  def graphql_non_null_list_items; end

  # @api private
  # @return [nil, true]
  def graphql_non_null_list_items=(_arg0); end

  # @api private
  def graphql_parent; end

  # @api private
  # @return [Hash] Plain-Ruby result data (`@graphql_metadata` contains Result wrapper objects)
  def graphql_result_data; end

  # @api private
  # @return [Hash] Plain-Ruby result data (`@graphql_metadata` contains Result wrapper objects)
  def graphql_result_data=(_arg0); end

  # @api private
  def graphql_result_name; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLResultArray
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  # @api private
  # @return [GraphQLResultArray] a new instance of GraphQLResultArray
  def initialize(_result_name, _parent_result); end

  # @api private
  def []=(idx, value); end

  # @api private
  def graphql_skip_at(index); end

  # @api private
  def values; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLResultHash
  include ::GraphQL::Execution::Interpreter::Runtime::GraphQLResult

  # @api private
  # @return [GraphQLResultHash] a new instance of GraphQLResultHash
  def initialize(_result_name, _parent_result); end

  # @api private
  def [](k); end

  # @api private
  def []=(key, value); end

  # @api private
  def delete(key); end

  # @api private
  def each; end

  # @api private
  def graphql_merged_into; end

  # @api private
  def graphql_merged_into=(_arg0); end

  # @api private
  # @return [Boolean]
  def key?(k); end

  # @api private
  def values; end
end

# @api private
class GraphQL::Execution::Interpreter::Runtime::GraphQLSelectionSet < ::Hash
  # @api private
  def graphql_directives; end

  # @api private
  def graphql_directives=(_arg0); end
end

# @api private
GraphQL::Execution::Interpreter::Runtime::HALT = T.let(T.unsafe(nil), Object)

# @api private
GraphQL::Execution::Interpreter::Runtime::NO_ARGS = T.let(T.unsafe(nil), Hash)

# This wraps a value which is available, but not yet calculated, like a promise or future.
#
# Calling `#value` will trigger calculation & return the "lazy" value.
#
# This is an itty-bitty promise-like object, with key differences:
# - It has only two states, not-resolved and resolved
# - It has no error-catching functionality
#
# @api private
class GraphQL::Execution::Lazy
  # Create a {Lazy} which will get its inner value by calling the block
  #
  # @api private
  # @param path [Array<String, Integer>]
  # @param field [GraphQL::Schema::Field]
  # @param get_value_func [Proc] a block to get the inner value (later)
  # @return [Lazy] a new instance of Lazy
  def initialize(path: T.unsafe(nil), field: T.unsafe(nil), &get_value_func); end

  # @api private
  def field; end

  # @api private
  def path; end

  # @api private
  # @return [Lazy] A {Lazy} whose value depends on another {Lazy}, plus any transformations in `block`
  def then; end

  # @api private
  # @return [Object] The wrapped value, calling the lazy block if necessary
  def value; end

  class << self
    # @api private
    # @param lazies [Array<Object>] Maybe-lazy objects
    # @return [Lazy] A lazy which will sync all of `lazies`
    def all(lazies); end
  end
end

# {GraphQL::Schema} uses this to match returned values to lazy resolution methods.
# Methods may be registered for classes, they apply to its subclasses also.
# The result of this lookup is cached for future resolutions.
# Instances of this class are thread-safe.
#
# @api private
# @see {Schema#lazy?} looks up values from this map
class GraphQL::Execution::Lazy::LazyMethodMap
  # @api private
  # @return [LazyMethodMap] a new instance of LazyMethodMap
  def initialize(use_concurrent: T.unsafe(nil)); end

  # @api private
  def each; end

  # @api private
  # @param value [Object] an object which may have a `lazy_value_method` registered for its class or superclasses
  # @return [Symbol, nil] The `lazy_value_method` for this object, or nil
  def get(value); end

  # @api private
  # @param lazy_class [Class] A class which represents a lazy value (subclasses may also be used)
  # @param lazy_value_method [Symbol] The method to call on this class to get its value
  def set(lazy_class, lazy_value_method); end

  protected

  # @api private
  def storage; end

  private

  # @api private
  def find_superclass_method(value_class); end

  # @api private
  def initialize_copy(other); end
end

# Mock the Concurrent::Map API
#
# @api private
class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable

  # @api private
  # @return [ConcurrentishMap] a new instance of ConcurrentishMap
  def initialize; end

  # @api private
  def []=(key, value); end

  # @api private
  def compute_if_absent(key); end

  def each_pair(*args, &block); end
  def size(*args, &block); end

  protected

  # @api private
  def copy_storage; end

  private

  # @api private
  def initialize_copy(other); end
end

# This can be used for fields which _had no_ lazy results
#
# @api private
GraphQL::Execution::Lazy::NullResult = T.let(T.unsafe(nil), GraphQL::Execution::Lazy)

# Lookahead creates a uniform interface to inspect the forthcoming selections.
#
# It assumes that the AST it's working with is valid. (So, it's safe to use
# during execution, but if you're using it directly, be sure to validate first.)
#
# A field may get access to its lookahead by adding `extras: [:lookahead]`
# to its configuration.
#
# @example looking ahead in a field
#   field :articles, [Types::Article], null: false,
#   extras: [:lookahead]
#
#   # For example, imagine a faster database call
#   # may be issued when only some fields are requested.
#   #
#   # Imagine that _full_ fetch must be made to satisfy `fullContent`,
#   # we can look ahead to see if we need that field. If we do,
#   # we make the expensive database call instead of the cheap one.
#   def articles(lookahead:)
#   if lookahead.selects?(:full_content)
#   fetch_full_articles(object)
#   else
#   fetch_preview_articles(object)
#   end
#   end
class GraphQL::Execution::Lookahead
  # @param query [GraphQL::Query]
  # @param ast_nodes [Array<GraphQL::Language::Nodes::Field>, Array<GraphQL::Language::Nodes::OperationDefinition>]
  # @param field [GraphQL::Schema::Field] if `ast_nodes` are fields, this is the field definition matching those nodes
  # @param root_type [Class] if `ast_nodes` are operation definition, this is the root type for that operation
  # @return [Lookahead] a new instance of Lookahead
  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  # @return [Hash<Symbol, Object>]
  def arguments; end

  # @return [Array<GraphQL::Language::Nodes::Field>]
  def ast_nodes; end

  # @return [GraphQL::Schema::Field]
  def field; end

  def inspect; end

  # The method name of the field.
  # It returns the method_sym of the Lookahead's field.
  #
  # @example getting the name of a selection
  #   def articles(lookahead:)
  #   article.selection(:full_content).name # => :full_content
  #   # ...
  #   end
  # @return [Symbol]
  def name; end

  # @return [GraphQL::Schema::Object, GraphQL::Schema::Union, GraphQL::Schema::Interface]
  def owner_type; end

  # @return [Boolean] True if this lookahead represents a field that was requested
  def selected?; end

  # Like {#selects?}, but can be used for chaining.
  # It returns a null object (check with {#selected?})
  #
  # @return [GraphQL::Execution::Lookahead]
  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # Like {#selection}, but for all nodes.
  # It returns a list of Lookaheads for all Selections
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in each selection. This method will filter the selections
  # if any of the given `arguments:` do not match the given selection.
  #
  # @example getting the name of a selection
  #   def articles(lookahead:)
  #   next_lookaheads = lookahead.selections # => [#<GraphQL::Execution::Lookahead ...>, ...]
  #   next_lookaheads.map(&:name) #=> [:full_content, :title]
  #   end
  # @param arguments [Hash] Arguments which must match in the selection
  # @return [Array<GraphQL::Execution::Lookahead>]
  def selections(arguments: T.unsafe(nil)); end

  # True if this node has a selection on `field_name`.
  # If `field_name` is a String, it is treated as a GraphQL-style (camelized)
  # field name and used verbatim. If `field_name` is a Symbol, it is
  # treated as a Ruby-style (underscored) name and camelized before comparing.
  #
  # If `arguments:` is provided, each provided key/value will be matched
  # against the arguments in the next selection. This method will return false
  # if any of the given `arguments:` are not present and matching in the next selection.
  # (But, the next selection may contain _more_ than the given arguments.)
  #
  # @param field_name [String, Symbol]
  # @param arguments [Hash] Arguments which must match in the selection
  # @return [Boolean]
  def selects?(field_name, arguments: T.unsafe(nil)); end

  private

  # @return [Boolean]
  def arguments_match?(arguments, field_defn, field_node); end

  # If a selection on `node` matches `field_name` (which is backed by `field_defn`)
  # and matches the `arguments:` constraints, then add that node to `matches`
  def find_selected_nodes(node, field_name, field_defn, arguments:, matches:); end

  def find_selections(subselections_by_type, selections_on_type, selected_type, ast_selections, arguments); end
  def normalize_keyword(keyword); end

  # If it's a symbol, stringify and camelize it
  def normalize_name(name); end

  # @return [Boolean]
  def skipped_by_directive?(ast_selection); end
end

# A singleton, so that misses don't come with overhead.
GraphQL::Execution::Lookahead::NULL_LOOKAHEAD = T.let(T.unsafe(nil), GraphQL::Execution::Lookahead::NullLookahead)

# This is returned for {Lookahead#selection} when a non-existent field is passed
class GraphQL::Execution::Lookahead::NullLookahead < ::GraphQL::Execution::Lookahead
  # No inputs required here.
  #
  # @return [NullLookahead] a new instance of NullLookahead
  def initialize; end

  def inspect; end

  # @return [Boolean]
  def selected?; end

  def selection(*_arg0); end
  def selections(*_arg0); end

  # @return [Boolean]
  def selects?(*_arg0); end
end

# Execute multiple queries under the same multiplex "umbrella".
# They can share a batching context and reduce redundant database hits.
#
# The flow is:
#
# - Multiplex instrumentation setup
# - Query instrumentation setup
# - Analyze the multiplex + each query
# - Begin each query
# - Resolve lazy values, breadth-first across all queries
# - Finish each query (eg, get errors)
# - Query instrumentation teardown
# - Multiplex instrumentation teardown
#
# If one query raises an application error, all queries will be in undefined states.
#
# Validation errors and {GraphQL::ExecutionError}s are handled in isolation:
# one of these errors in one query will not affect the other queries.
#
# @api private
# @see {Schema#multiplex} for public API
class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable

  # @api private
  # @return [Multiplex] a new instance of Multiplex
  def initialize(schema:, queries:, context:, max_complexity:); end

  # @api private
  def context; end

  # @api private
  def dataloader; end

  # @api private
  def max_complexity; end

  # @api private
  def queries; end

  # @api private
  def schema; end

  class << self
    # @api private
    # @param query [GraphQL::Query]
    def begin_query(results, idx, query, multiplex); end

    # @api private
    # @param schema [GraphQL::Schema]
    # @param queries [Array<GraphQL::Query, Hash>]
    # @param context [Hash]
    # @param max_complexity [Integer, nil]
    # @return [Array<Hash>] One result per query
    def run_all(schema, query_options, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end

    private

    # @api private
    # @param data_result [Hash] The result for the "data" key, if any
    # @param query [GraphQL::Query] The query which was run
    # @return [Hash] final result of this query, including all values and errors
    def finish_query(data_result, query, multiplex); end
  end
end

# Used internally to signal that the query shouldn't be executed
#
# @api private
GraphQL::Execution::Multiplex::NO_OPERATION = T.let(T.unsafe(nil), Hash)

# Just a singleton for implementing {Query::Context#skip}
#
# @api private
GraphQL::Execution::SKIP = T.let(T.unsafe(nil), GraphQL::Execution::Skip)

# @api private
class GraphQL::Execution::Skip < ::GraphQL::Error; end

# If a field's resolve function returns a {ExecutionError},
# the error will be inserted into the response's `"errors"` key
# and the field will resolve to `nil`.
class GraphQL::ExecutionError < ::GraphQL::Error
  # @return [ExecutionError] a new instance of ExecutionError
  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
  def ast_node; end

  # @return [GraphQL::Language::Nodes::Field] the field where the error occurred
  def ast_node=(_arg0); end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions; end

  # under the `extensions` key.
  #
  # @return [Hash] Optional custom data for error objects which will be added
  def extensions=(_arg0); end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  #
  # @deprecated Use `extensions` instead of `options`. The GraphQL spec
  # @return [Hash] Optional data for error objects
  def options; end

  # recommends that any custom entries in an error be under the
  # `extensions` key.
  #
  # @deprecated Use `extensions` instead of `options`. The GraphQL spec
  # @return [Hash] Optional data for error objects
  def options=(_arg0); end

  # response which corresponds to this error.
  #
  # @return [String] an array describing the JSON-path into the execution
  def path; end

  # response which corresponds to this error.
  #
  # @return [String] an array describing the JSON-path into the execution
  def path=(_arg0); end

  # @return [Hash] An entry for the response's "errors" key
  def to_h; end
end

# @api private
class GraphQL::Filter
  # @api private
  # @return [Filter] a new instance of Filter
  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns true if `member, ctx` passes this filter
  #
  # @api private
  def call(member, ctx); end

  # @api private
  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

# @api private
class GraphQL::Filter::MergedExcept < ::GraphQL::Filter::MergedOnly
  # @api private
  def call(member, ctx); end
end

# @api private
class GraphQL::Filter::MergedOnly
  # @api private
  # @return [MergedOnly] a new instance of MergedOnly
  def initialize(first, second); end

  # @api private
  def call(member, ctx); end

  class << self
    # @api private
    def build(onlies); end
  end
end

# This error is raised when `Types::Int` is given an input value outside of 32-bit integer range.
#
# For really big integer values, consider `GraphQL::Types::BigInt`
#
# @see GraphQL::Types::Int which raises this error
class GraphQL::IntegerDecodingError < ::GraphQL::RuntimeTypeError
  # @return [IntegerDecodingError] a new instance of IntegerDecodingError
  def initialize(value); end

  # The value which couldn't be decoded
  def integer_value; end
end

# This error is raised when `Types::Int` is asked to return a value outside of 32-bit integer range.
#
# For values outside that range, consider:
#
# - `ID` for database primary keys or other identifiers
# - `GraphQL::Types::BigInt` for really big integer values
#
# @see GraphQL::Types::Int which raises this error
class GraphQL::IntegerEncodingError < ::GraphQL::RuntimeTypeError
  # @return [IntegerEncodingError] a new instance of IntegerEncodingError
  def initialize(value, context:); end

  # @return [GraphQL::Schema::Field] The field that returned a too-big integer
  def field; end

  # The value which couldn't be encoded
  def integer_value; end

  # @return [Array<String, Integer>] Where the field appeared in the GraphQL response
  def path; end
end

module GraphQL::Introspection
  class << self
    def query(include_deprecated_args: T.unsafe(nil), include_schema_description: T.unsafe(nil), include_is_repeatable: T.unsafe(nil), include_specified_by_url: T.unsafe(nil)); end
  end
end

class GraphQL::Introspection::BaseObject < ::GraphQL::Schema::Object
  class << self
    def field(*args, **kwargs, &block); end
  end
end

class GraphQL::Introspection::DirectiveLocationEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::DirectiveType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
end

class GraphQL::Introspection::DynamicFields < ::GraphQL::Introspection::BaseObject
  def __typename; end
end

class GraphQL::Introspection::EntryPoints < ::GraphQL::Introspection::BaseObject
  def __schema; end
  def __type(name:); end
end

class GraphQL::Introspection::EnumValueType < ::GraphQL::Introspection::BaseObject
  def is_deprecated; end
  def name; end
end

class GraphQL::Introspection::FieldType < ::GraphQL::Introspection::BaseObject
  def args(include_deprecated:); end
  def is_deprecated; end
end

# This query is used by graphql-client so don't add the includeDeprecated
# argument for inputFields since the server may not support it. Two stage
# introspection queries will be required to handle this in clients.
GraphQL::Introspection::INTROSPECTION_QUERY = T.let(T.unsafe(nil), String)

class GraphQL::Introspection::InputValueType < ::GraphQL::Introspection::BaseObject
  def default_value; end
  def is_deprecated; end

  private

  # Recursively serialize, taking care not to add quotes to enum values
  def serialize_default_value(value, type); end
end

class GraphQL::Introspection::SchemaType < ::GraphQL::Introspection::BaseObject
  def directives; end
  def mutation_type; end
  def query_type; end
  def schema_description; end
  def subscription_type; end
  def types; end

  private

  def permitted_root_type(op_type); end
end

class GraphQL::Introspection::TypeKindEnum < ::GraphQL::Schema::Enum; end
class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError < ::GraphQL::Schema::Enum::UnresolvedValueError; end

class GraphQL::Introspection::TypeType < ::GraphQL::Introspection::BaseObject
  def enum_values(include_deprecated:); end
  def fields(include_deprecated:); end
  def input_fields(include_deprecated:); end
  def interfaces; end
  def kind; end
  def of_type; end
  def possible_types; end
  def specified_by_url; end
end

class GraphQL::InvalidNameError < ::GraphQL::ExecutionError
  # @return [InvalidNameError] a new instance of InvalidNameError
  def initialize(name, valid_regex); end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute valid_regex.
  def valid_regex; end
end

# Raised automatically when a field's resolve function returns `nil`
# for a non-null field.
class GraphQL::InvalidNullError < ::GraphQL::RuntimeTypeError
  # @return [InvalidNullError] a new instance of InvalidNullError
  def initialize(parent_type, field, value); end

  # @return [GraphQL::Field] The field which failed to return a value
  def field; end

  # @deprecated always false
  # @return [Boolean]
  def parent_error?; end

  # @return [GraphQL::BaseType] The owner of {#field}
  def parent_type; end

  # @return [Hash] An entry for the response's "errors" key
  def to_h; end

  # @return [nil, GraphQL::ExecutionError] The invalid value for this field
  def value; end

  class << self
    def inspect; end

    # Returns the value of attribute parent_class.
    def parent_class; end

    # Sets the attribute parent_class
    #
    # @param value the value to set the attribute parent_class to.
    def parent_class=(_arg0); end

    def subclass_for(parent_class); end
  end
end

# This error is raised when GraphQL-Ruby encounters a situation
# that it *thought* would never happen. Please report this bug!
class GraphQL::InvariantError < ::GraphQL::Error
  # @return [InvariantError] a new instance of InvariantError
  def initialize(message); end
end

module GraphQL::Language
  class << self
    # @api private
    def serialize(value); end
  end
end

module GraphQL::Language::BlockString
  class << self
    def break_line(line, length); end
    def print(str, indent: T.unsafe(nil)); end

    # Remove leading and trailing whitespace from a block string.
    # See "Block Strings" in https://github.com/facebook/graphql/blob/master/spec/Section%202%20--%20Language.md
    def trim_whitespace(str); end
  end
end

class GraphQL::Language::Cache
  # @return [Cache] a new instance of Cache
  def initialize(path); end

  def fetch(filename); end
end

GraphQL::Language::Cache::DIGEST = T.let(T.unsafe(nil), Digest::SHA256)

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice

  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor < ::GraphQL::Language::Visitor
  # @return [DependencyVisitor] a new instance of DependencyVisitor
  def initialize(doc, definitions, names); end

  def on_fragment_spread(node, parent); end

  class << self
    def find_definition_dependencies(definitions, name, names); end
  end
end

# {GraphQL::Language::DocumentFromSchemaDefinition} is used to convert a {GraphQL::Schema} object
# To a {GraphQL::Language::Document} AST node.
#
# @api private
# @param context [Hash]
# @param only [<#call(member, ctx)>]
# @param except [<#call(member, ctx)>]
# @param include_introspection_types [Boolean] Whether or not to include introspection types in the AST
# @param include_built_in_scalars [Boolean] Whether or not to include built in scalars in the AST
# @param include_built_in_directives [Boolean] Whether or not to include built in directives in the AST
class GraphQL::Language::DocumentFromSchemaDefinition
  # @api private
  # @return [DocumentFromSchemaDefinition] a new instance of DocumentFromSchemaDefinition
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end

  # @api private
  def build_argument_node(argument); end

  # @api private
  def build_argument_nodes(arguments); end

  # @api private
  def build_default_value(default_value, type); end

  # @api private
  def build_definition_nodes; end

  # @api private
  def build_directive_location_node(location); end

  # @api private
  def build_directive_location_nodes(locations); end

  # @api private
  def build_directive_node(directive); end

  # @api private
  def build_directive_nodes(directives); end

  # @api private
  def build_enum_type_node(enum_type); end

  # @api private
  def build_enum_value_node(enum_value); end

  # @api private
  def build_field_node(field); end

  # @api private
  def build_field_nodes(fields); end

  # @api private
  def build_input_object_node(input_object); end

  # @api private
  def build_interface_type_node(interface_type); end

  # @api private
  def build_object_type_node(object_type); end

  # @api private
  def build_scalar_type_node(scalar_type); end

  # @api private
  def build_schema_node; end

  # @api private
  def build_type_definition_node(type); end

  # @api private
  def build_type_definition_nodes(types); end

  # @api private
  def build_type_name_node(type); end

  # @api private
  def build_union_type_node(union_type); end

  # @api private
  def document; end

  private

  # @api private
  def always_include_schema; end

  # @api private
  def ast_directives(member); end

  # @api private
  def definition_directives(member); end

  # @api private
  def directives(member); end

  # @api private
  def include_built_in_directives; end

  # @api private
  def include_built_in_scalars; end

  # @api private
  def include_introspection_types; end

  # @api private
  # @return [Boolean]
  def include_schema_node?; end

  # @api private
  def schema; end

  # @api private
  # @return [Boolean]
  def schema_respects_root_name_conventions?(schema); end

  # @api private
  def warden; end
end

# Exposes {.generate}, which turns AST nodes back into query strings.
module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation

  # Turn an AST node back into a string.
  #
  # @example Turning a document into a query
  #   document = GraphQL.parse(query_string)
  #   GraphQL::Language::Generation.generate(document)
  #   # => "{ ... }"
  # @param node [GraphQL::Language::Nodes::AbstractNode] an AST node to recursively stringify
  # @param indent [String] Whitespace to add to each printed node
  # @param printer [GraphQL::Language::Printer] An optional custom printer for printing AST nodes. Defaults to GraphQL::Language::Printer
  # @return [String] Valid GraphQL for `node`
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Lexer
  class << self
    def emit(token_name, ts, te, meta, token_value = T.unsafe(nil)); end
    def emit_string(ts, te, meta, block:); end

    # Returns the value of attribute graphql_lexer_en_main.
    def graphql_lexer_en_main; end

    # Sets the attribute graphql_lexer_en_main
    #
    # @param value the value to set the attribute graphql_lexer_en_main to.
    def graphql_lexer_en_main=(_arg0); end

    # Returns the value of attribute graphql_lexer_en_str.
    def graphql_lexer_en_str; end

    # Sets the attribute graphql_lexer_en_str
    #
    # @param value the value to set the attribute graphql_lexer_en_str to.
    def graphql_lexer_en_str=(_arg0); end

    # Returns the value of attribute graphql_lexer_error.
    def graphql_lexer_error; end

    # Sets the attribute graphql_lexer_error
    #
    # @param value the value to set the attribute graphql_lexer_error to.
    def graphql_lexer_error=(_arg0); end

    # Returns the value of attribute graphql_lexer_first_final.
    def graphql_lexer_first_final; end

    # Sets the attribute graphql_lexer_first_final
    #
    # @param value the value to set the attribute graphql_lexer_first_final to.
    def graphql_lexer_first_final=(_arg0); end

    # Returns the value of attribute graphql_lexer_start.
    def graphql_lexer_start; end

    # Sets the attribute graphql_lexer_start
    #
    # @param value the value to set the attribute graphql_lexer_start to.
    def graphql_lexer_start=(_arg0); end

    def record_comment(ts, te, meta); end

    # Replace any escaped unicode or whitespace with the _actual_ characters
    # To avoid allocating more strings, this modifies the string passed into it
    def replace_escaped_characters_in_place(raw_string); end

    def run_lexer(query_string); end
    def tokenize(query_string); end

    private

    # Returns the value of attribute _graphql_lexer_char_class.
    def _graphql_lexer_char_class; end

    # Sets the attribute _graphql_lexer_char_class
    #
    # @param value the value to set the attribute _graphql_lexer_char_class to.
    def _graphql_lexer_char_class=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_actions.
    def _graphql_lexer_cond_actions; end

    # Sets the attribute _graphql_lexer_cond_actions
    #
    # @param value the value to set the attribute _graphql_lexer_cond_actions to.
    def _graphql_lexer_cond_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_cond_targs.
    def _graphql_lexer_cond_targs; end

    # Sets the attribute _graphql_lexer_cond_targs
    #
    # @param value the value to set the attribute _graphql_lexer_cond_targs to.
    def _graphql_lexer_cond_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_eof_trans.
    def _graphql_lexer_eof_trans; end

    # Sets the attribute _graphql_lexer_eof_trans
    #
    # @param value the value to set the attribute _graphql_lexer_eof_trans to.
    def _graphql_lexer_eof_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_from_state_actions.
    def _graphql_lexer_from_state_actions; end

    # Sets the attribute _graphql_lexer_from_state_actions
    #
    # @param value the value to set the attribute _graphql_lexer_from_state_actions to.
    def _graphql_lexer_from_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_defaults.
    def _graphql_lexer_index_defaults; end

    # Sets the attribute _graphql_lexer_index_defaults
    #
    # @param value the value to set the attribute _graphql_lexer_index_defaults to.
    def _graphql_lexer_index_defaults=(_arg0); end

    # Returns the value of attribute _graphql_lexer_index_offsets.
    def _graphql_lexer_index_offsets; end

    # Sets the attribute _graphql_lexer_index_offsets
    #
    # @param value the value to set the attribute _graphql_lexer_index_offsets to.
    def _graphql_lexer_index_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_indicies.
    def _graphql_lexer_indicies; end

    # Sets the attribute _graphql_lexer_indicies
    #
    # @param value the value to set the attribute _graphql_lexer_indicies to.
    def _graphql_lexer_indicies=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_offsets.
    def _graphql_lexer_nfa_offsets; end

    # Sets the attribute _graphql_lexer_nfa_offsets
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_offsets to.
    def _graphql_lexer_nfa_offsets=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_pop_trans.
    def _graphql_lexer_nfa_pop_trans; end

    # Sets the attribute _graphql_lexer_nfa_pop_trans
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_pop_trans to.
    def _graphql_lexer_nfa_pop_trans=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_push_actions.
    def _graphql_lexer_nfa_push_actions; end

    # Sets the attribute _graphql_lexer_nfa_push_actions
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_push_actions to.
    def _graphql_lexer_nfa_push_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_nfa_targs.
    def _graphql_lexer_nfa_targs; end

    # Sets the attribute _graphql_lexer_nfa_targs
    #
    # @param value the value to set the attribute _graphql_lexer_nfa_targs to.
    def _graphql_lexer_nfa_targs=(_arg0); end

    # Returns the value of attribute _graphql_lexer_to_state_actions.
    def _graphql_lexer_to_state_actions; end

    # Sets the attribute _graphql_lexer_to_state_actions
    #
    # @param value the value to set the attribute _graphql_lexer_to_state_actions to.
    def _graphql_lexer_to_state_actions=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_cond_spaces.
    def _graphql_lexer_trans_cond_spaces; end

    # Sets the attribute _graphql_lexer_trans_cond_spaces
    #
    # @param value the value to set the attribute _graphql_lexer_trans_cond_spaces to.
    def _graphql_lexer_trans_cond_spaces=(_arg0); end

    # Returns the value of attribute _graphql_lexer_trans_keys.
    def _graphql_lexer_trans_keys; end

    # Sets the attribute _graphql_lexer_trans_keys
    #
    # @param value the value to set the attribute _graphql_lexer_trans_keys to.
    def _graphql_lexer_trans_keys=(_arg0); end
  end
end

GraphQL::Language::Lexer::ESCAPES = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::ESCAPES_REPLACE = T.let(T.unsafe(nil), Hash)
GraphQL::Language::Lexer::PACK_DIRECTIVE = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::UTF_8 = T.let(T.unsafe(nil), Regexp)
GraphQL::Language::Lexer::UTF_8_ENCODING = T.let(T.unsafe(nil), String)
GraphQL::Language::Lexer::VALID_STRING = T.let(T.unsafe(nil), Regexp)
module GraphQL::Language::Nodes; end

# {AbstractNode} is the base class for all nodes in a GraphQL AST.
#
# It provides some APIs for working with ASTs:
# - `children` returns all AST nodes attached to this one. Used for tree traversal.
# - `scalars` returns all scalar (Ruby) values attached to this one. Used for comparing nodes.
# - `to_query_string` turns an AST node into a GraphQL string
class GraphQL::Language::Nodes::AbstractNode
  # Initialize a node by extracting its position,
  # then calling the class's `initialize_node` method.
  #
  # @param options [Hash] Initial attributes for this node
  # @return [AbstractNode] a new instance of AbstractNode
  def initialize(options = T.unsafe(nil)); end

  # Value equality
  #
  # @return [Boolean] True if `self` is equivalent to `other`
  def ==(other); end

  # @return [Array<GraphQL::Language::Nodes::AbstractNode>] all nodes in the tree below this one
  def children; end

  def children_method_name; end

  # Returns the value of attribute col.
  def col; end

  # TODO DRY with `replace_child`
  def delete_child(previous_child); end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute line.
  def line; end

  # This creates a copy of `self`, with `new_options` applied.
  #
  # @param new_options [Hash]
  # @return [AbstractNode] a shallow copy of `self`
  def merge(new_options); end

  def position; end

  # Copy `self`, but modify the copy so that `previous_child` is replaced by `new_child`
  def replace_child(previous_child, new_child); end

  # @return [Array<Integer, Float, String, Boolean, Array>] Scalar values attached to this node
  def scalars; end

  def to_query_string(printer: T.unsafe(nil)); end

  protected

  def merge!(new_options); end

  private

  # This might be unnecessary, but its easiest to add it here.
  def initialize_copy(other); end

  class << self
    # Add a default `#visit_method` and `#children_method_name` using the class name
    def inherited(child_class); end

    private

    # Name accessors which return lists of nodes,
    # along with the kind of node they return, if possible.
    # - Add a reader for these children
    # - Add a persistent update method to add a child
    # - Generate a `#children` method
    def children_methods(children_of_type); end

    def generate_initialize_node; end

    # These methods return a plain Ruby value, not another node
    # - Add reader methods
    # - Add a `#scalars` method
    def scalar_methods(*method_names); end
  end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def initialize(options = T.unsafe(nil)); end

  # This AST node's {#line} returns the first line, which may be the description.
  #
  # @return [Integer] The first line of the definition (not the description)
  def definition_line; end
end

GraphQL::Language::Nodes::AbstractNode::NO_CHILDREN = T.let(T.unsafe(nil), Array)

# A key-value pair for a field's inputs
class GraphQL::Language::Nodes::Argument < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  # @return [String] the key for this argument
  def name; end

  def scalars; end

  # @return [String, Float, Integer, Boolean, Array, InputObject] The value passed for this key
  def value; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::Directive < ::GraphQL::Language::Nodes::AbstractNode
  def arguments; end
  def children; end
  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def initialize_node(name: T.unsafe(nil), repeatable: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def locations; end
  def merge_argument(node_opts); end
  def merge_location(node_opts); end
  def name; end
  def repeatable; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::DirectiveLocation < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# This is the AST root for normal queries
#
# @example Deriving a document by parsing a string
#   document = GraphQL.parse(query_string)
# @example Creating a string from a document
#   document.to_query_string
#   # { ... }
# @example Creating a custom string from a document
#   class VariableScrubber < GraphQL::Language::Printer
#   def print_argument(arg)
#   "#{arg.name}: <HIDDEN>"
#   end
#   end
#
#   document.to_query_string(printer: VariableScrubber.new)
class GraphQL::Language::Nodes::Document < ::GraphQL::Language::Nodes::AbstractNode
  def children; end

  # @return [Array<OperationDefinition, FragmentDefinition>] top-level GraphQL units: operations or fragments
  def definitions; end

  def initialize_node(definitions: T.unsafe(nil)); end
  def slice_definition(name); end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An enum value. The string is available as {#name}.
class GraphQL::Language::Nodes::Enum < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_value(node_opts); end
  def name; end
  def scalars; end
  def values; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::EnumValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A single selection in a GraphQL query.
class GraphQL::Language::Nodes::Field < ::GraphQL::Language::Nodes::AbstractNode
  def alias; end
  def arguments; end
  def children; end
  def directives; end
  def initialize_node(attributes); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def name; end
  def scalars; end

  # @return [Array<Nodes::Field>] Selections on this object (or empty array if this is a scalar field)
  def selections; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

GraphQL::Language::Nodes::Field::NONE = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Nodes::FieldDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def arguments; end
  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end

  # this is so that `children_method_name` of `InputValueDefinition` works properly
  # with `#replace_child`
  def fields; end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end
  def merge(new_options); end
  def merge_argument(node_opts); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A reusable fragment, defined at document-level.
class GraphQL::Language::Nodes::FragmentDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end

  # @return [String] the identifier for this fragment, which may be applied with `...#{name}`
  def name; end

  def scalars; end
  def selections; end

  # @return [String] the type condition for this fragment (name of type which it may apply to)
  def type; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Application of a named fragment in a selection
class GraphQL::Language::Nodes::FragmentSpread < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An unnamed fragment, defined directly in the query with `... {  }`
class GraphQL::Language::Nodes::InlineFragment < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def scalars; end
  def selections; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A collection of key-value inputs which may be a field argument
class GraphQL::Language::Nodes::InputObject < ::GraphQL::Language::Nodes::AbstractNode
  # @return [Array<Nodes::Argument>] A list of key-value pairs inside this input object
  def arguments; end

  def children; end
  def initialize_node(arguments: T.unsafe(nil)); end
  def merge_argument(node_opts); end

  # @return [Hash<String, Any>] Recursively turn this input object into a Ruby Hash
  def to_h(options = T.unsafe(nil)); end

  def visit_method; end

  private

  def serialize_value_for_hash(value); end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InputValueDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def default_value; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def type; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def merge_interface(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A list type definition, denoted with `[...]` (used for variable type definitions)
class GraphQL::Language::Nodes::ListType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for nodes whose only value is a name (no child nodes or other scalars)
class GraphQL::Language::Nodes::NameOnlyNode < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(name: T.unsafe(nil)); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A non-null type definition, denoted with `...!` (used for variable type definitions)
class GraphQL::Language::Nodes::NonNullType < ::GraphQL::Language::Nodes::WrapperType
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A null value literal.
class GraphQL::Language::Nodes::NullValue < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ObjectTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def fields; end
  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end
  def interfaces; end
  def merge_directive(node_opts); end
  def merge_field(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A query, mutation or subscription.
# May be anonymous or named.
# May be explicitly typed (eg `mutation { ... }`) or implicitly a query (eg `{ ... }`).
class GraphQL::Language::Nodes::OperationDefinition < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def merge_selection(node_opts); end
  def merge_variable(node_opts); end
  def name; end

  # @return [String, nil] The root type for this operation, or `nil` for implicit `"query"`
  def operation_type; end

  def scalars; end

  # @return [Array<Field>] Root-level fields on this operation
  def selections; end

  # @return [Array<VariableDefinition>] Variable $definitions for this operation
  def variables; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::ScalarTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::SchemaExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def mutation; end
  def query; end
  def scalars; end
  def subscription; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# A type name, used for variable definitions
class GraphQL::Language::Nodes::TypeName < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeDefinition < ::GraphQL::Language::Nodes::AbstractNode
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode

  def children; end

  # Returns the value of attribute description.
  def description; end

  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Nodes::UnionTypeExtension < ::GraphQL::Language::Nodes::AbstractNode
  def children; end
  def directives; end
  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end
  def merge_directive(node_opts); end
  def name; end
  def scalars; end

  # Returns the value of attribute types.
  def types; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# An operation-level query variable
class GraphQL::Language::Nodes::VariableDefinition < ::GraphQL::Language::Nodes::AbstractNode
  # @return [String, Integer, Float, Boolean, Array, NullValue] A Ruby value to use if no other value is provided
  def default_value; end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end
  def name; end
  def scalars; end

  # @return [TypeName, NonNullType, ListType] The expected type of this value
  def type; end

  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Usage of a variable in a query. Name does _not_ include `$`.
class GraphQL::Language::Nodes::VariableIdentifier < ::GraphQL::Language::Nodes::NameOnlyNode
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

# Base class for non-null type names and list type names
class GraphQL::Language::Nodes::WrapperType < ::GraphQL::Language::Nodes::AbstractNode
  def initialize_node(of_type: T.unsafe(nil)); end
  def of_type; end
  def scalars; end
  def visit_method; end

  class << self
    def children_method_name; end
    def children_method_name=(_arg0); end
  end
end

class GraphQL::Language::Parser < ::Racc::Parser
  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def _reduce_10(val, _values, result); end
  def _reduce_100(val, _values, result); end
  def _reduce_102(val, _values, result); end
  def _reduce_103(val, _values, result); end
  def _reduce_104(val, _values, result); end
  def _reduce_105(val, _values, result); end
  def _reduce_106(val, _values, result); end
  def _reduce_107(val, _values, result); end
  def _reduce_108(val, _values, result); end
  def _reduce_109(val, _values, result); end
  def _reduce_11(val, _values, result); end
  def _reduce_114(val, _values, result); end
  def _reduce_116(val, _values, result); end
  def _reduce_117(val, _values, result); end
  def _reduce_12(val, _values, result); end
  def _reduce_126(val, _values, result); end
  def _reduce_127(val, _values, result); end
  def _reduce_134(val, _values, result); end
  def _reduce_135(val, _values, result); end
  def _reduce_136(val, _values, result); end
  def _reduce_137(val, _values, result); end
  def _reduce_138(val, _values, result); end
  def _reduce_139(val, _values, result); end
  def _reduce_140(val, _values, result); end
  def _reduce_141(val, _values, result); end
  def _reduce_142(val, _values, result); end
  def _reduce_143(val, _values, result); end
  def _reduce_144(val, _values, result); end
  def _reduce_145(val, _values, result); end
  def _reduce_146(val, _values, result); end
  def _reduce_147(val, _values, result); end
  def _reduce_151(val, _values, result); end
  def _reduce_152(val, _values, result); end
  def _reduce_153(val, _values, result); end
  def _reduce_155(val, _values, result); end
  def _reduce_156(val, _values, result); end
  def _reduce_157(val, _values, result); end
  def _reduce_158(val, _values, result); end
  def _reduce_159(val, _values, result); end
  def _reduce_16(val, _values, result); end
  def _reduce_160(val, _values, result); end
  def _reduce_161(val, _values, result); end
  def _reduce_162(val, _values, result); end
  def _reduce_163(val, _values, result); end
  def _reduce_164(val, _values, result); end
  def _reduce_165(val, _values, result); end
  def _reduce_166(val, _values, result); end
  def _reduce_167(val, _values, result); end
  def _reduce_168(val, _values, result); end
  def _reduce_169(val, _values, result); end
  def _reduce_170(val, _values, result); end
  def _reduce_171(val, _values, result); end
  def _reduce_172(val, _values, result); end
  def _reduce_173(val, _values, result); end
  def _reduce_174(val, _values, result); end
  def _reduce_175(val, _values, result); end
  def _reduce_176(val, _values, result); end
  def _reduce_177(val, _values, result); end
  def _reduce_178(val, _values, result); end
  def _reduce_179(val, _values, result); end
  def _reduce_18(val, _values, result); end
  def _reduce_182(val, _values, result); end
  def _reduce_183(val, _values, result); end
  def _reduce_19(val, _values, result); end
  def _reduce_2(val, _values, result); end
  def _reduce_20(val, _values, result); end
  def _reduce_21(val, _values, result); end
  def _reduce_22(val, _values, result); end
  def _reduce_23(val, _values, result); end
  def _reduce_24(val, _values, result); end
  def _reduce_25(val, _values, result); end
  def _reduce_26(val, _values, result); end
  def _reduce_27(val, _values, result); end
  def _reduce_28(val, _values, result); end
  def _reduce_29(val, _values, result); end
  def _reduce_3(val, _values, result); end
  def _reduce_30(val, _values, result); end
  def _reduce_31(val, _values, result); end
  def _reduce_32(val, _values, result); end
  def _reduce_33(val, _values, result); end
  def _reduce_37(val, _values, result); end
  def _reduce_38(val, _values, result); end
  def _reduce_4(val, _values, result); end
  def _reduce_63(val, _values, result); end
  def _reduce_64(val, _values, result); end
  def _reduce_65(val, _values, result); end
  def _reduce_66(val, _values, result); end
  def _reduce_67(val, _values, result); end
  def _reduce_68(val, _values, result); end
  def _reduce_69(val, _values, result); end
  def _reduce_70(val, _values, result); end
  def _reduce_71(val, _values, result); end
  def _reduce_72(val, _values, result); end
  def _reduce_73(val, _values, result); end
  def _reduce_74(val, _values, result); end
  def _reduce_75(val, _values, result); end
  def _reduce_83(val, _values, result); end
  def _reduce_84(val, _values, result); end
  def _reduce_85(val, _values, result); end
  def _reduce_86(val, _values, result); end
  def _reduce_87(val, _values, result); end
  def _reduce_88(val, _values, result); end
  def _reduce_89(val, _values, result); end
  def _reduce_90(val, _values, result); end
  def _reduce_91(val, _values, result); end
  def _reduce_92(val, _values, result); end
  def _reduce_93(val, _values, result); end
  def _reduce_94(val, _values, result); end
  def _reduce_95(val, _values, result); end
  def _reduce_96(val, _values, result); end
  def _reduce_97(val, _values, result); end
  def _reduce_98(val, _values, result); end
  def _reduce_99(val, _values, result); end
  def _reduce_none(val, _values, result); end
  def parse_document; end

  private

  def get_description(token); end
  def make_node(node_name, assigns); end
  def next_token; end
  def on_error(parser_token_id, lexer_token, vstack); end

  class << self
    def cache; end
    def cache=(_arg0); end
    def parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
    def parse_file(filename, tracer: T.unsafe(nil)); end
  end
end

GraphQL::Language::Parser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_arg = T.let(T.unsafe(nil), Array)
GraphQL::Language::Parser::Racc_token_to_s_table = T.let(T.unsafe(nil), Array)

class GraphQL::Language::Printer
  # Turn an arbitrary AST node back into a string.
  #
  # @example Turning a document into a query string
  #   document = GraphQL.parse(query_string)
  #   GraphQL::Language::Printer.new.print(document)
  #   # => "{ ... }"
  # @example Building a custom printer
  #
  #   class MyPrinter < GraphQL::Language::Printer
  #   def print_argument(arg)
  #   "#{arg.name}: <HIDDEN>"
  #   end
  #   end
  #
  #   MyPrinter.new.print(document)
  #   # => "mutation { pay(creditCard: <HIDDEN>) { success } }"
  # @param indent [String] Whitespace to add to the printed node
  # @return [String] Valid GraphQL for `node`
  def print(node, indent: T.unsafe(nil)); end

  protected

  def print_argument(argument); end
  def print_arguments(arguments, indent: T.unsafe(nil)); end
  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end
  def print_directive(directive); end
  def print_directive_definition(directive); end
  def print_directives(directives); end
  def print_document(document); end
  def print_enum(enum); end
  def print_enum_type_definition(enum_type); end
  def print_enum_value_definition(enum_value); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_field_definition(field); end
  def print_field_definitions(fields); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end
  def print_implements(type); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_input_object(input_object); end
  def print_input_object_type_definition(input_object_type); end
  def print_input_value_definition(input_value); end
  def print_interface_type_definition(interface_type); end
  def print_list_type(list_type); end
  def print_node(node, indent: T.unsafe(nil)); end
  def print_non_null_type(non_null_type); end
  def print_null_value; end
  def print_object_type_definition(object_type); end
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end
  def print_scalar_type_definition(scalar_type); end
  def print_schema_definition(schema); end
  def print_selections(selections, indent: T.unsafe(nil)); end
  def print_type_name(type_name); end
  def print_union_type_definition(union_type); end
  def print_variable_definition(variable_definition); end
  def print_variable_identifier(variable_identifier); end

  private

  # Returns the value of attribute node.
  def node; end
end

# A custom printer used to print sanitized queries. It inlines provided variables
# within the query for facilitate logging and analysis of queries.
#
# The printer returns `nil` if the query is invalid.
#
# Since the GraphQL Ruby AST for a GraphQL query doesnt contain any reference
# on the type of fields or arguments, we have to track the current object, field
# and input type while printing the query.
#
# @example Printing a scrubbed string
#   printer = QueryPrinter.new(query)
#   puts printer.sanitized_query_string
# @see {Query#sanitized_query_string}
class GraphQL::Language::SanitizedPrinter < ::GraphQL::Language::Printer
  # @return [SanitizedPrinter] a new instance of SanitizedPrinter
  def initialize(query, inline_variables: T.unsafe(nil)); end

  # @return [Boolean]
  def coerce_argument_value_to_list?(type, value); end

  def print_argument(argument); end
  def print_directive(directive); end
  def print_field(field, indent: T.unsafe(nil)); end
  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end
  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end
  def print_node(node, indent: T.unsafe(nil)); end

  # Print the operation definition but do not include the variable
  # definitions since we will inline them within the query
  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_variable_identifier(variable_id); end

  # Indicates whether or not to redact non-null values for the given argument. Defaults to redacting all strings
  # arguments but this can be customized by subclasses.
  #
  # @return [Boolean]
  def redact_argument_value?(argument, value); end

  # Returns the value to use for redacted versions of the given argument. Defaults to the
  # string "<REDACTED>".
  def redacted_argument_value(argument); end

  # @return [String, nil] A scrubbed query string, if the query was valid.
  def sanitized_query_string; end

  private

  # Returns the value of attribute query.
  def query; end

  def value_to_ast(value, type); end
end

GraphQL::Language::SanitizedPrinter::REDACTED = T.let(T.unsafe(nil), String)

# Emitted by the lexer and passed to the parser.
# Contains type, value and position data.
class GraphQL::Language::Token
  # @return [Token] a new instance of Token
  def initialize(name, value, line, col, prev_token); end

  # Returns the value of attribute col.
  def col; end

  def inspect; end

  # Returns the value of attribute line.
  def line; end

  def line_and_column; end

  # @return [Symbol] The kind of token this is
  def name; end

  # Returns the value of attribute prev_token.
  def prev_token; end

  def to_f; end
  def to_i; end

  # @return [String] The text of this token
  def to_s; end

  # @return [String] The text of this token
  def value; end
end

# Depth-first traversal through the tree, calling hooks at each stop.
#
# @example Create a visitor counting certain field names
#   class NameCounter < GraphQL::Language::Visitor
#   def initialize(document, field_name)
#   super(document)
#   @field_name = field_name
#   @count = 0
#   end
#
#   attr_reader :count
#
#   def on_field(node, parent)
#   # if this field matches our search, increment the counter
#   if node.name == @field_name
#   @count += 1
#   end
#   # Continue visiting subfields:
#   super
#   end
#   end
#
#   # Initialize a visitor
#   visitor = NameCounter.new(document, "name")
#   # Run it
#   visitor.visit
#   # Check the result
#   visitor.count
#   # => 3
class GraphQL::Language::Visitor
  # @return [Visitor] a new instance of Visitor
  def initialize(document); end

  # Get a {NodeVisitor} for `node_class`
  #
  # @deprecated see `on_` methods, like {#on_field}
  # @example Run a hook whenever you enter a new Field
  #   visitor[GraphQL::Language::Nodes::Field] << ->(node, parent) { p "Here's a field" }
  # @param node_class [Class] The node class that you want to listen to
  # @return [NodeVisitor]
  def [](node_class); end

  # The default implementation for visiting an AST node.
  # It doesn't _do_ anything, but it continues to visiting the node's children.
  # To customize this hook, override one of its make_visit_methodes (or the base method?)
  # in your subclasses.
  #
  # For compatibility, it calls hook procs, too.
  #
  # @param node [GraphQL::Language::Nodes::AbstractNode] the node being visited
  # @param parent [GraphQL::Language::Nodes::AbstractNode, nil] the previously-visited node, or `nil` if this is the root node.
  # @return [Array, nil] If there were modifications, it returns an array of new nodes, otherwise, it returns `nil`.
  def on_abstract_node(node, parent); end

  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_directive_definition(node, parent); end
  def on_directive_location(node, parent); end
  def on_document(node, parent); end
  def on_enum(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_list_type(node, parent); end
  def on_non_null_type(node, parent); end
  def on_null_value(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_type_name(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
  def on_variable_definition(node, parent); end
  def on_variable_identifier(node, parent); end

  # @return [GraphQL::Language::Nodes::Document] The document with any modifications applied
  def result; end

  # Visit `document` and all children, applying hooks as you go
  #
  # @return [void]
  def visit; end

  # Call the user-defined handler for `node`.
  def visit_node(node, parent); end

  private

  def begin_visit(node, parent); end

  # Should global `leave` visitors come first or last?
  def end_visit(node, parent); end

  # Run the hooks for `node`, and if the hooks return a copy of `node`,
  # copy `parent` so that it contains the copy of that node as a child,
  # then return the copies
  # If a non-array value is returned, consuming functions should ignore
  # said value
  def on_node_with_modifications(node, parent); end

  class << self
    # If one of the visitors returns SKIP, stop visiting this node
    def apply_hooks(hooks, node, parent); end

    # We don't use `alias` here because it breaks `super`
    def make_visit_method(node_method); end
  end
end

# When this is returned from a visitor method,
# Then the `node` passed into the method is removed from `parent`'s children.
GraphQL::Language::Visitor::DELETE_NODE = T.let(T.unsafe(nil), GraphQL::Language::Visitor::DeleteNode)

class GraphQL::Language::Visitor::DeleteNode; end

# Collect `enter` and `leave` hooks for classes in {GraphQL::Language::Nodes}
#
# Access {NodeVisitor}s via {GraphQL::Language::Visitor#[]}
class GraphQL::Language::Visitor::NodeVisitor
  # @return [NodeVisitor] a new instance of NodeVisitor
  def initialize; end

  # Shorthand to add a hook to the {#enter} array
  #
  # @param hook [Proc] A hook to add
  def <<(hook); end

  # @return [Array<Proc>] Hooks to call when entering a node of this type
  def enter; end

  # @return [Array<Proc>] Hooks to call when leaving a node of this type
  def leave; end
end

# If any hook returns this value, the {Visitor} stops visiting this
# node right away
#
# @deprecated Use `super` to continue the visit; or don't call it to halt.
GraphQL::Language::Visitor::SKIP = T.let(T.unsafe(nil), Symbol)

# Raised when a argument is configured with `loads:` and the client provides an `ID`,
# but no object is loaded for that ID.
#
# @see GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader#load_application_object_failed, A hook which you can override in resolvers, mutations and input objects.
class GraphQL::LoadApplicationObjectFailedError < ::GraphQL::ExecutionError
  # @return [LoadApplicationObjectFailedError] a new instance of LoadApplicationObjectFailedError
  def initialize(argument:, id:, object:); end

  # @return [GraphQL::Schema::Argument] the argument definition for the argument that was looked up
  def argument; end

  # @return [String] The ID provided by the client
  def id; end

  # @return [Object] The value found with this ID
  def object; end
end

class GraphQL::NameValidator
  class << self
    # @raise [GraphQL::InvalidNameError]
    def validate!(name); end
  end
end

GraphQL::NameValidator::VALID_NAME_REGEX = T.let(T.unsafe(nil), Regexp)
module GraphQL::Pagination; end

# Customizes `RelationConnection` to work with `ActiveRecord::Relation`s.
class GraphQL::Pagination::ActiveRecordRelationConnection < ::GraphQL::Pagination::RelationConnection
  private

  # @return [Boolean]
  def already_loaded?(relation); end

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_larger_than(relation, initial_offset, size); end
  def relation_limit(relation); end
  def relation_offset(relation); end
  def set_limit(nodes, limit); end
  def set_offset(nodes, offset); end
end

class GraphQL::Pagination::ArrayConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  def index_from_cursor(cursor); end

  # Populate all the pagination info _once_,
  # It doesn't do anything on subsequent calls.
  def load_nodes; end
end

# A Connection wraps a list of items and provides cursor-based pagination over it.
#
# Connections were introduced by Facebook's `Relay` front-end framework, but
# proved to be generally useful for GraphQL APIs. When in doubt, use connections
# to serve lists (like Arrays, ActiveRecord::Relations) via GraphQL.
#
# Unlike the previous connection implementation, these default to bidirectional pagination.
#
# Pagination arguments and context may be provided at initialization or assigned later (see {Schema::Field::ConnectionExtension}).
class GraphQL::Pagination::Connection
  # @param items [Object] some unpaginated collection item, like an `Array` or `ActiveRecord::Relation`
  # @param context [Query::Context]
  # @param parent [Object] The object this collection belongs to
  # @param first [Integer, nil] The limit parameter from the client, if it provided one
  # @param after [String, nil] A cursor for pagination, if the client provided one
  # @param last [Integer, nil] Limit parameter from the client, if provided
  # @param before [String, nil] A cursor for pagination, if the client provided one.
  # @param arguments [Hash] The arguments to the field that returned the collection wrapped by this connection
  # @param max_page_size [Integer, nil] A configured value to cap the result size. Applied as `first` if neither first or last are given and no `default_page_size` is set.
  # @param default_page_size [Integer, nil] A configured value to determine the result size when neither first or last are given.
  # @return [Connection] a new instance of Connection
  def initialize(items, parent: T.unsafe(nil), field: T.unsafe(nil), context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), default_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil), edge_class: T.unsafe(nil), arguments: T.unsafe(nil)); end

  # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
  def after; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def after_value=(_arg0); end

  # @return [Hash<Symbol => Object>] The field arguments from the field that returned this connection
  def arguments; end

  # @return [Hash<Symbol => Object>] The field arguments from the field that returned this connection
  def arguments=(_arg0); end

  # @return [String, nil] the client-provided cursor. `""` is treated as `nil`.
  def before; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def before_value=(_arg0); end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [GraphQL::Query::Context]
  def context=(_arg0); end

  # Return a cursor for this item.
  #
  # @param item [Object] one of the passed in {items}, taken from {nodes}
  # @raise [PaginationImplementationMissingError]
  # @return [String]
  def cursor_for(item); end

  def default_page_size; end
  def default_page_size=(new_value); end

  # @return [Class] A wrapper class for edges of this connection
  def edge_class; end

  # @return [Class] A wrapper class for edges of this connection
  def edge_class=(_arg0); end

  # A dynamic alias for compatibility with {Relay::BaseConnection}.
  #
  # @deprecated use {#nodes} instead
  def edge_nodes; end

  # @return [Array<Edge>] {nodes}, but wrapped with Edge instances
  def edges; end

  # @return [String] The cursor of the last item in {nodes}
  def end_cursor; end

  # @return [GraphQL::Schema::Field] The field this connection was returned by
  def field; end

  # @return [GraphQL::Schema::Field] The field this connection was returned by
  def field=(_arg0); end

  # @return [Integer, nil] A clamped `first` value.
  #   (The underlying instance variable doesn't have limits on it.)
  #   If neither `first` nor `last` is given, but `default_page_size` is
  #   present, default_page_size is used for first. If `default_page_size`
  #   is greater than `max_page_size``, it'll be clamped down to
  #   `max_page_size`. If `default_page_size` is nil, use `max_page_size`.
  def first; end

  # Sets the attribute first
  #
  # @param value the value to set the attribute first to.
  def first=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def first_value=(_arg0); end

  # @return [Boolean]
  def has_default_page_size_override?; end

  # @return [Boolean]
  def has_max_page_size_override?; end

  # @raise [PaginationImplementationMissingError]
  # @return [Boolean] True if there are more items after this page
  def has_next_page; end

  # @raise [PaginationImplementationMissingError]
  # @return [Boolean] True if there were items before these items
  def has_previous_page; end

  # @return [Object] A list object, from the application. This is the unpaginated value passed into the connection.
  def items; end

  # @return [Integer, nil] A clamped `last` value. (The underlying instance variable doesn't have limits on it)
  def last; end

  # Sets the attribute last
  #
  # @param value the value to set the attribute last to.
  def last=(_arg0); end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value; end

  # Raw access to client-provided values. (`max_page_size` not applied to first or last.)
  def last_value=(_arg0); end

  def max_page_size; end
  def max_page_size=(new_value); end

  # @raise [PaginationImplementationMissingError]
  # @return [Array<Object>] A slice of {items}, constrained by {@first_value}/{@after_value}/{@last_value}/{@before_value}
  def nodes; end

  # The connection object itself implements `PageInfo` fields
  def page_info; end

  # @return [Object] the object this collection belongs to
  def parent; end

  # @return [Object] the object this collection belongs to
  def parent=(_arg0); end

  # This is called by `Relay::RangeAdd` -- it can be overridden
  # when `item` needs some modifications based on this connection's state.
  #
  # @param item [Object] An item newly added to `items`
  # @return [Edge]
  def range_add_edge(item); end

  # @return [String] The cursor of the first item in {nodes}
  def start_cursor; end

  private

  def decode(cursor); end
  def encode(cursor); end

  # @param argument [nil, Integer] `first` or `last`, as provided by the client
  # @param max_page_size [nil, Integer]
  # @return [nil, Integer] `nil` if the input was `nil`, otherwise a value between `0` and `max_page_size`
  def limit_pagination_argument(argument, max_page_size); end
end

# A wrapper around paginated items. It includes a {cursor} for pagination
# and could be extended with custom relationship-level data.
class GraphQL::Pagination::Connection::Edge
  # @return [Edge] a new instance of Edge
  def initialize(node, connection); end

  def cursor; end

  # Returns the value of attribute node.
  def node; end

  def parent; end
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError < ::GraphQL::Error; end

# A schema-level connection wrapper manager.
#
# Attach as a plugin.
#
# @example Adding a custom wrapper
#   class MySchema < GraphQL::Schema
#   connections.add(MyApp::SearchResults, MyApp::SearchResultsConnection)
#   end
# @example Removing default connection support for arrays (they can still be manually wrapped)
#   class MySchema < GraphQL::Schema
#   connections.delete(Array)
#   end
# @see {Schema.connections}
class GraphQL::Pagination::Connections
  # @return [Connections] a new instance of Connections
  def initialize(schema:); end

  def add(nodes_class, implementation); end
  def all_wrappers; end
  def delete(nodes_class); end

  # use an override if there is one
  #
  # @api private
  def edge_class_for_field(field); end

  # Used by the runtime to wrap values in connection wrappers.
  #
  # @api Private
  def wrap(field, parent, items, arguments, context); end

  def wrapper_for(items, wrappers: T.unsafe(nil)); end

  protected

  # Returns the value of attribute wrappers.
  def wrappers; end

  private

  def add_default; end
end

class GraphQL::Pagination::Connections::ImplementationMissingError < ::GraphQL::Error; end

class GraphQL::Pagination::MongoidRelationConnection < ::GraphQL::Pagination::RelationConnection
  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

# A generic class for working with database query objects.
class GraphQL::Pagination::RelationConnection < ::GraphQL::Pagination::Connection
  def cursor_for(item); end
  def has_next_page; end
  def has_previous_page; end
  def nodes; end

  private

  # @return [Integer, nil]
  def after_offset; end

  # @return [Integer, nil]
  def before_offset; end

  def calculate_sliced_nodes_parameters; end

  # Apply `first` and `last` to `sliced_nodes`,
  # returning a new relation
  def limited_nodes; end

  # Load nodes after applying first/last/before/after,
  # returns an array of nodes
  def load_nodes; end

  # @param relation [Object] A database query object
  # @return [Object] A modified query object which will return no records
  def null_relation(relation); end

  # @return [Integer]
  def offset_from_cursor(cursor); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The number of items in this relation (hopefully determined without loading all records into memory!)
  def relation_count(relation); end

  # @param relation [Object] A database query object
  # @param _initial_offset [Integer] The number of items already excluded from the relation
  # @param size [Integer] The value against which we check the relation size
  # @return [Boolean] True if the number of items in this relation is larger than `size`
  def relation_larger_than(relation, _initial_offset, size); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The limit value, or nil if there isn't one
  def relation_limit(relation); end

  # @param relation [Object] A database query object
  # @return [Integer, nil] The offset value, or nil if there isn't one
  def relation_offset(relation); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_limit(relation, limit_value); end

  # Abstract this operation so we can always ignore inputs less than zero.
  # (Sequel doesn't like it, understandably.)
  def set_offset(relation, offset_value); end

  # Apply `before` and `after` to the underlying `items`,
  # returning a new relation.
  def sliced_nodes; end
end

# Customizes `RelationConnection` to work with `Sequel::Dataset`s.
class GraphQL::Pagination::SequelDatasetConnection < ::GraphQL::Pagination::RelationConnection
  private

  def null_relation(relation); end
  def relation_count(relation); end
  def relation_limit(relation); end
  def relation_offset(relation); end
end

class GraphQL::ParseError < ::GraphQL::Error
  # @return [ParseError] a new instance of ParseError
  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  # Returns the value of attribute col.
  def col; end

  # Returns the value of attribute line.
  def line; end

  # Returns the value of attribute query.
  def query; end

  def to_h; end
end

# A combination of query string and {Schema} instance which can be reduced to a {#result}.
class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  extend ::Forwardable

  # Prepare query `query_string` on `schema`
  #
  # @param schema [GraphQL::Schema]
  # @param query_string [String]
  # @param context [#[]] an arbitrary hash of values which you can access in {GraphQL::Field#resolve}
  # @param variables [Hash] values for `$variables` in the query
  # @param operation_name [String] if the query string contains many operations, this is the one which should be executed
  # @param root_value [Object] the object used to resolve fields on the root type
  # @param max_depth [Numeric] the maximum number of nested selections allowed for this query (falls back to schema-level value)
  # @param max_complexity [Numeric] the maximum field complexity for this query (falls back to schema-level value)
  # @param except [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns truthy
  # @param only [<#call(schema_member, context)>] If provided, objects will be hidden from the schema when `.call(schema_member, context)` returns false
  # @return [Query] a new instance of Query
  def initialize(schema, query_string = T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil), warden: T.unsafe(nil)); end

  # Returns the value of attribute analysis_errors.
  def analysis_errors; end

  # Sets the attribute analysis_errors
  #
  # @param value the value to set the attribute analysis_errors to.
  def analysis_errors=(_arg0); end

  def analyzers(*args, &block); end
  def arguments_cache; end

  # Node-level cache for calculating arguments. Used during execution and query analysis.
  #
  # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
  # @param definition [GraphQL::Schema::Field]
  # @param parent_object [GraphQL::Schema::Object]
  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end

  def ast_analyzers(*args, &block); end

  # Returns the value of attribute context.
  def context; end

  # @return [GraphQL::Language::Nodes::Document]
  def document; end

  # @return [Boolean]
  def executed?; end

  # This contains a few components:
  #
  # - The selected operation name (or `anonymous`)
  # - The fingerprint of the query string
  # - The number of given variables (for readability)
  # - The fingerprint of the given variables
  #
  # This fingerprint can be used to track runs of the same operation-variables combination over time.
  #
  # @return [String] An opaque hash identifying this operation-variables combination
  # @see operation_fingerprint
  # @see variables_fingerprint
  def fingerprint; end

  def fragments; end
  def get_field(*args, &block); end
  def get_type(*args, &block); end

  # @api private
  def handle_or_reraise(err); end

  def inspect; end

  # @return [Boolean]
  def interpreter?; end

  # A lookahead for the root selections of this query
  #
  # @return [GraphQL::Execution::Lookahead]
  def lookahead; end

  def max_complexity(*args, &block); end
  def max_depth(*args, &block); end

  # @return [void]
  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  # Returns the value of attribute multiplex.
  def multiplex; end

  # Sets the attribute multiplex
  #
  # @param value the value to set the attribute multiplex to.
  def multiplex=(_arg0); end

  # @return [Boolean]
  def mutation?; end

  # @return [String] An opaque hash for identifying this query's given query string and selected operation
  def operation_fingerprint; end

  # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
  def operation_name; end

  # @return [nil, String] The operation name provided by client or the one inferred from the document. Used to determine which operation to run.
  def operation_name=(_arg0); end

  def operations; end
  def possible_types(*args, &block); end

  # Returns the value of attribute provided_variables.
  def provided_variables; end

  # @return [Boolean]
  def query?; end

  # If a document was provided to `GraphQL::Schema#execute` instead of the raw query string, we will need to get it from the document
  def query_string; end

  # Sets the attribute query_string
  #
  # @param value the value to set the attribute query_string to.
  def query_string=(_arg0); end

  # @param abstract_type [GraphQL::UnionType, GraphQL::InterfaceType]
  # @param value [Object] Any runtime value
  # @return [GraphQL::ObjectType, nil] The runtime type of `value` from {Schema#resolve_type}
  # @see {#possible_types} to apply filtering from `only` / `except`
  def resolve_type(abstract_type, value = T.unsafe(nil)); end

  # Get the result for this query, executing it once
  #
  # @return [Hash] A GraphQL response, with `"data"` and/or `"errors"` keys
  def result; end

  # @api private
  def result_values; end

  # @api private
  def result_values=(result_hash); end

  def root_type_for_operation(*args, &block); end

  # The value for root types
  def root_value; end

  # The value for root types
  def root_value=(_arg0); end

  # A version of the given query string, with:
  # - Variables inlined to the query
  # - Strings replaced with `<REDACTED>`
  #
  # @return [String, nil] Returns nil if the query is invalid.
  def sanitized_query_string(inline_variables: T.unsafe(nil)); end

  # Returns the value of attribute schema.
  def schema; end

  # This is the operation to run for this query.
  # If more than one operation is present, it must be named at runtime.
  #
  # @return [GraphQL::Language::Nodes::OperationDefinition, nil]
  def selected_operation; end

  # @return [String, nil] The name of the operation to run (may be inferred)
  def selected_operation_name; end

  def static_errors; end

  # @return [Boolean]
  def subscription?; end

  # @return [String, nil] the triggered event, if this query is a subscription update
  def subscription_topic; end

  # @return [Boolean]
  def subscription_update?; end

  # Returns the value of attribute tracers.
  def tracers; end

  # @return [Boolean]
  def valid?; end

  # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
  def validate; end

  # @return [Boolean] if false, static validation is skipped (execution behavior for invalid queries is undefined)
  def validate=(_arg0); end

  def validation_errors(*args, &block); end
  def validation_pipeline; end

  # Determine the values for variables of this query, using default values
  # if a value isn't provided at runtime.
  #
  # If some variable is invalid, errors are added to {#validation_errors}.
  #
  # @return [GraphQL::Query::Variables] Variables to apply to this query
  def variables; end

  # @return [String] An opaque hash for identifying this query's given a variable values (not including defaults)
  def variables_fingerprint; end

  def warden; end

  private

  def find_operation(operations, operation_name); end
  def prepare_ast; end

  # Since the query string is processed at the last possible moment,
  # any internal values which depend on it should be accessed within this wrapper.
  def with_prepared_ast; end
end

# Expose some query-specific info to field resolve functions.
# It delegates `[]` to the hash that's passed to `GraphQL::Query#initialize`.
class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  extend ::Forwardable

  # Make a new context which delegates key lookup to `values`
  #
  # @param query [GraphQL::Query] the query who owns this context
  # @param values [Hash] A hash of arbitrary values which will be accessible at query-time
  # @return [Context] a new instance of Context
  def initialize(query:, values:, object:, schema: T.unsafe(nil)); end

  # Lookup `key` from the hash passed to {Schema#execute} as `context:`
  def [](key); end

  # Reassign `key` to the hash passed to {Schema#execute} as `context:`
  def []=(key, value); end

  def dataloader; end
  def delete(key); end
  def dig(key, *other_keys); end

  # @return [Array<GraphQL::ExecutionError>] errors returned during execution
  def errors; end

  def fetch(key, default = T.unsafe(nil)); end
  def inspect; end

  # @api private
  def interpreter=(_arg0); end

  def interpreter?(*args, &block); end

  # @return [Boolean]
  def key?(key); end

  # Get an isolated hash for `ns`. Doesn't affect user-provided storage.
  #
  # @param ns [Object] a usage-specific namespace identifier
  # @return [Hash] namespaced storage
  def namespace(ns); end

  # @return [Boolean] true if this namespace was accessed before
  def namespace?(ns); end

  # @return [Array<String, Integer>] The current position in the result
  def path; end

  # @return [GraphQL::Query] The query whose context this is
  def query; end

  # @return [Hash] A hash that will be added verbatim to the result hash, as `"extensions" => { ... }`
  def response_extensions; end

  # @return [GraphQL::Schema]
  def schema; end

  # @api private
  def scoped_context; end

  def scoped_merge!(hash); end
  def scoped_set!(key, value); end
  def to_h; end
  def to_hash; end
  def trace(*args, &block); end

  # @api private
  def value=(_arg0); end

  # @return [GraphQL::Schema::Warden]
  def warden; end

  # @api private
  def warden=(_arg0); end
end

class GraphQL::Query::Context::ExecutionErrors
  # @return [ExecutionErrors] a new instance of ExecutionErrors
  def initialize(ctx); end

  def >>(err_or_msg); end
  def add(err_or_msg); end
  def push(err_or_msg); end
end

class GraphQL::Query::Context::ScopedContext
  # @return [ScopedContext] a new instance of ScopedContext
  def initialize(query_context); end

  def [](key); end
  def current_path; end
  def dig(key, *other_keys); end

  # @return [Boolean]
  def key?(key); end

  def merge!(hash); end
  def merged_context; end

  private

  # Start at the current location,
  # but look up the tree for previously-assigned scoped values
  def each_present_path_ctx; end
end

module GraphQL::Query::Context::SharedMethods
  # Add error at query-level.
  #
  # @param error [GraphQL::ExecutionError] an execution error
  # @return [void]
  def add_error(error); end

  # @example Print the GraphQL backtrace during field resolution
  #   puts ctx.backtrace
  # @return [GraphQL::Backtrace] The backtrace for this point in query execution
  def backtrace; end

  def execution_errors; end

  # Return this value to tell the runtime
  # to exclude this field from the response altogether
  def skip; end
end

GraphQL::Query::Context::UNSPECIFIED_FETCH_DEFAULT = T.let(T.unsafe(nil), Object)

# @api private
# @see Query#query_fingerprint
# @see Query#variables_fingerprint
# @see Query#fingerprint
module GraphQL::Query::Fingerprint
  class << self
    # Make an obfuscated hash of the given string (either a query string or variables JSON)
    #
    # @api private
    # @param string [String]
    # @return [String] A normalized, opaque hash
    def generate(input_str); end
  end
end

class GraphQL::Query::InputValidationResult
  # @return [InputValidationResult] a new instance of InputValidationResult
  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def add_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  def merge_result!(path, inner_result); end

  # Returns the value of attribute problems.
  def problems; end

  # Sets the attribute problems
  #
  # @param value the value to set the attribute problems to.
  def problems=(_arg0); end

  # @return [Boolean]
  def valid?; end

  class << self
    def from_problem(explanation, path = T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end
  end
end

GraphQL::Query::InputValidationResult::VALID = T.let(T.unsafe(nil), GraphQL::Query::InputValidationResult)

# This object can be `ctx` in places where there is no query
class GraphQL::Query::NullContext
  # @return [NullContext] a new instance of NullContext
  def initialize; end

  def [](key); end

  # Returns the value of attribute dataloader.
  def dataloader; end

  # @return [Boolean]
  def interpreter?; end

  # Returns the value of attribute query.
  def query; end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    def [](key); end
    def dataloader(*args, &block); end
    def instance; end
    def interpreter?(*args, &block); end
    def query(*args, &block); end
    def schema(*args, &block); end
    def warden(*args, &block); end
  end
end

class GraphQL::Query::NullContext::NullQuery; end
class GraphQL::Query::NullContext::NullSchema < ::GraphQL::Schema; end

class GraphQL::Query::NullContext::NullWarden < ::GraphQL::Schema::Warden
  # @return [Boolean]
  def visible_argument?(arg, ctx); end

  # @return [Boolean]
  def visible_enum_value?(ev, ctx); end

  # @return [Boolean]
  def visible_field?(field, ctx); end

  # @return [Boolean]
  def visible_type?(type, ctx); end

  # @return [Boolean]
  def visible_type_membership?(tm, ctx); end
end

class GraphQL::Query::OperationNameMissingError < ::GraphQL::ExecutionError
  # @return [OperationNameMissingError] a new instance of OperationNameMissingError
  def initialize(name); end
end

# A result from {Schema#execute}.
# It provides the requested data and
# access to the {Query} and {Query::Context}.
class GraphQL::Query::Result
  extend ::Forwardable

  # @return [Result] a new instance of Result
  def initialize(query:, values:); end

  # A result is equal to another object when:
  #
  # - The other object is a Hash whose value matches `result.to_h`
  # - The other object is a Result whose value matches `result.to_h`
  #
  # (The query is ignored for comparing result equality.)
  #
  # @return [Boolean]
  def ==(other); end

  def [](*args, &block); end
  def as_json(*args, &block); end
  def context(*args, &block); end
  def inspect; end
  def keys(*args, &block); end

  # Delegate any hash-like method to the underlying hash.
  def method_missing(method_name, *args, &block); end

  def mutation?(*args, &block); end

  # @return [GraphQL::Query] The query that was executed
  def query; end

  def query?(*args, &block); end
  def subscription?(*args, &block); end

  # @return [Hash] The resulting hash of "data" and/or "errors"
  def to_h; end

  def to_json(*args, &block); end
  def values(*args, &block); end

  private

  # @return [Boolean]
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
end

# Contain the validation pipeline and expose the results.
#
# 0. Checks in {Query#initialize}:
#   - Rescue a ParseError, halt if there is one
#   - Check for selected operation, halt if not found
# 1. Validate the AST, halt if errors
# 2. Validate the variables, halt if errors
# 3. Run query analyzers, halt if errors
#
# {#valid?} is false if any of the above checks halted the pipeline.
#
# @api private
class GraphQL::Query::ValidationPipeline
  # @api private
  # @return [ValidationPipeline] a new instance of ValidationPipeline
  def initialize(query:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  # @api private
  def analyzers; end

  # @api private
  def max_complexity; end

  # @api private
  def max_depth; end

  # @api private
  # @return [Boolean] does this query have errors that should prevent it from running?
  def valid?; end

  # @api private
  # @return [Array<GraphQL::StaticValidation::Error, GraphQL::Query::VariableValidationError>] Static validation errors for the query string
  def validation_errors; end

  private

  # If there are max_* values, add them,
  # otherwise reuse the schema's list of analyzers.
  #
  # @api private
  def build_analyzers(schema, max_depth, max_complexity); end

  # If the pipeline wasn't run yet, run it.
  # If it was already run, do nothing.
  #
  # @api private
  def ensure_has_validated; end
end

class GraphQL::Query::VariableValidationError < ::GraphQL::ExecutionError
  # @return [VariableValidationError] a new instance of VariableValidationError
  def initialize(variable_ast, type, value, validation_result); end

  def to_h; end

  # Returns the value of attribute validation_result.
  def validation_result; end

  # Sets the attribute validation_result
  #
  # @param value the value to set the attribute validation_result to.
  def validation_result=(_arg0); end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end

  private

  def problem_fields; end
end

# Read-only access to query variables, applying default values if needed.
class GraphQL::Query::Variables
  extend ::Forwardable

  # @return [Variables] a new instance of Variables
  def initialize(ctx, ast_variables, provided_variables); end

  def [](*args, &block); end

  # Returns the value of attribute context.
  def context; end

  # @return [Array<GraphQL::Query::VariableValidationError>] Any errors encountered when parsing the provided variables and literal values
  def errors; end

  def fetch(*args, &block); end
  def key?(*args, &block); end
  def length(*args, &block); end
  def to_h(*args, &block); end

  private

  def deep_stringify(val); end
end

class GraphQL::Railtie < ::Rails::Railtie; end
module GraphQL::Relay; end

# This provides some isolation from `GraphQL::Relay` internals.
#
# Given a list of items and a new item, it will provide a connection and an edge.
#
# The connection doesn't receive outside arguments, so the list of items
# should be ordered and paginated before providing it here.
#
# @example Adding a comment to list of comments
#   post = Post.find(args[:post_id])
#   comments = post.comments
#   new_comment = comments.build(body: args[:body])
#   new_comment.save!
#
#   range_add = GraphQL::Relay::RangeAdd.new(
#   parent: post,
#   collection: comments,
#   item: new_comment,
#   context: context,
#   )
#
#   response = {
#   post: post,
#   comments_connection: range_add.connection,
#   new_comment_edge: range_add.edge,
#   }
class GraphQL::Relay::RangeAdd
  # @param collection [Object] The list of items to wrap in a connection
  # @param item [Object] The newly-added item (will be wrapped in `edge_class`)
  # @param context [GraphQL::Query::Context] The surrounding `ctx`, will be passed to the connection
  # @param parent [Object] The owner of `collection`, will be passed to the connection if provided
  # @param edge_class [Class] The class to wrap `item` with (defaults to the connection's edge class)
  # @return [RangeAdd] a new instance of RangeAdd
  def initialize(collection:, item:, context:, parent: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  # Returns the value of attribute connection.
  def connection; end

  # Returns the value of attribute edge.
  def edge; end

  # Returns the value of attribute parent.
  def parent; end
end

class GraphQL::RequiredImplementationMissingError < ::GraphQL::Error; end

# forwards-compat for argument handling
module GraphQL::Ruby2Keywords; end

class GraphQL::RuntimeTypeError < ::GraphQL::Error; end

# A GraphQL schema which may be queried with {GraphQL::Query}.
#
# The {Schema} contains:
#
#  - types for exposing your application
#  - query analyzers for assessing incoming queries (including max depth & max complexity restrictions)
#  - execution strategies for running incoming queries
#
# Schemas start with root types, {Schema#query}, {Schema#mutation} and {Schema#subscription}.
# The schema will traverse the tree of fields & types, using those as starting points.
# Any undiscoverable types may be provided with the `types` configuration.
#
# Schemas can restrict large incoming queries with `max_depth` and `max_complexity` configurations.
# (These configurations can be overridden by specific calls to {Schema#execute})
#
# Schemas can specify how queries should be executed against them.
# `query_execution_strategy`, `mutation_execution_strategy` and `subscription_execution_strategy`
# each apply to corresponding root types.
#  #
#
# @example defining a schema
#   class MySchema < GraphQL::Schema
#   query QueryType
#   # If types are only connected by way of interfaces, they must be added here
#   orphan_types ImageType, AudioType
#   end
class GraphQL::Schema
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  class << self
    # @return [Boolean]
    def accessible?(member, ctx); end

    # @api private
    def add_subscription_extension_if_necessary; end

    # Return a lazy if any of `maybe_lazies` are lazy,
    # otherwise, call the block eagerly and return the result.
    #
    # @api private
    # @param maybe_lazies [Array]
    def after_any_lazies(maybe_lazies); end

    # Call the given block at the right time, either:
    # - Right away, if `value` is not registered with `lazy_resolve`
    # - After resolving `value`, if it's registered with `lazy_resolve` (eg, `Promise`)
    #
    # @api private
    def after_lazy(value, &block); end

    def analysis_engine; end

    # Sets the attribute analysis_engine
    #
    # @param value the value to set the attribute analysis_engine to.
    def analysis_engine=(_arg0); end

    # Return the Hash response of {Introspection::INTROSPECTION_QUERY}.
    #
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [Hash] GraphQL result
    def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    # @return [GraphQL::Pagination::Connections] if installed
    def connections; end

    # @api private
    def connections=(_arg0); end

    def context_class(new_context_class = T.unsafe(nil)); end
    def cursor_encoder(new_encoder = T.unsafe(nil)); end

    # @api private
    # @see GraphQL::Dataloader
    def dataloader_class; end

    # Sets the attribute dataloader_class
    #
    # @param value the value to set the attribute dataloader_class to.
    def dataloader_class=(_arg0); end

    def default_analysis_engine; end
    def default_directives; end
    def default_execution_strategy; end
    def default_filter; end
    def default_mask(new_mask = T.unsafe(nil)); end
    def default_max_page_size(new_default_max_page_size = T.unsafe(nil)); end
    def default_page_size(new_default_page_size = T.unsafe(nil)); end
    def deprecated_graphql_definition; end

    # @return [String, nil]
    def description(new_description = T.unsafe(nil)); end

    # Attach a single directive to this schema
    #
    # @param new_directive [Class]
    # @return void
    def directive(new_directive); end

    # Add several directives at once
    #
    # @param new_directives [Class]
    def directives(*new_directives); end

    def disable_introspection_entry_points; end

    # @return [Boolean]
    def disable_introspection_entry_points?; end

    def disable_schema_introspection_entry_point; end

    # @return [Boolean]
    def disable_schema_introspection_entry_point?; end

    def disable_type_introspection_entry_point; end

    # @return [Boolean]
    def disable_type_introspection_entry_point?; end

    def error_bubbling(new_error_bubbling = T.unsafe(nil)); end

    # Sets the attribute error_bubbling
    #
    # @param value the value to set the attribute error_bubbling to.
    def error_bubbling=(_arg0); end

    def error_handlers; end

    # Execute a query on itself.
    #
    # @return [Hash] query result, ready to be serialized as JSON
    # @see {Query#initialize} for arguments.
    def execute(query_str = T.unsafe(nil), **kwargs); end

    def find(path); end

    # Create schema from an IDL schema or file containing an IDL definition.
    #
    # @param definition_or_path [String] A schema definition string, or a path to a file containing the definition
    # @param default_resolve [<#call(type, field, obj, args, ctx)>] A callable for handling field resolution
    # @param parser [Object] An object for handling definition string parsing (must respond to `parse`)
    # @param using [Hash] Plugins to attach to the created schema with `use(key, value)`
    # @return [Class] the schema described by `document`
    def from_definition(definition_or_path, default_resolve: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end

    # Create schema with the result of an introspection query.
    #
    # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
    # @return [Class<GraphQL::Schema>] the schema described by `input`
    def from_introspection(introspection_result); end

    def get_field(type_or_name, field_name, context = T.unsafe(nil)); end
    def get_fields(type, context = T.unsafe(nil)); end

    # @param type_name [String]
    # @return [Module, nil] A type, or nil if there's no type called `type_name`
    def get_type(type_name, context = T.unsafe(nil)); end

    # @api private
    def handle_or_reraise(context, err); end

    # @raise [GraphQL::RequiredImplementationMissingError]
    def id_from_object(object, type, ctx); end

    # This hook is called when a client tries to access one or more
    # fields that fail the `accessible?` check.
    #
    # By default, an error is added to the response. Override this hook to
    # track metrics or return a different error to the client.
    #
    # @param error [InaccessibleFieldsError] The analysis error for this check
    # @return [AnalysisError, nil] Return an error to skip the query
    def inaccessible_fields(error); end

    def inherited(child_class); end
    def instrument(instrument_step, instrumenter, options = T.unsafe(nil)); end
    def instrumenters; end

    # Sets the attribute interpreter
    #
    # @param value the value to set the attribute interpreter to.
    def interpreter=(_arg0); end

    # @return [Boolean]
    def interpreter?; end

    def introspection(new_introspection_namespace = T.unsafe(nil)); end
    def introspection_system; end

    # @return [Boolean] True if this object should be lazily resolved
    def lazy?(obj); end

    # @return [Symbol, nil] The method name to lazily resolve `obj`, or nil if `obj`'s class wasn't registered with {#lazy_resolve}.
    def lazy_method_name(obj); end

    def lazy_resolve(lazy_class, value_method); end
    def max_complexity(max_complexity = T.unsafe(nil)); end

    # Sets the attribute max_complexity
    #
    # @param value the value to set the attribute max_complexity to.
    def max_complexity=(_arg0); end

    def max_depth(new_max_depth = T.unsafe(nil)); end

    # Sets the attribute max_depth
    #
    # @param value the value to set the attribute max_depth to.
    def max_depth=(_arg0); end

    # Execute several queries on itself, concurrently.
    #
    # @example Run several queries at once
    #   context = { ... }
    #   queries = [
    #   { query: params[:query_1], variables: params[:variables_1], context: context },
    #   { query: params[:query_2], variables: params[:variables_2], context: context },
    #   ]
    #   results = MySchema.multiplex(queries)
    #   render json: {
    #   result_1: results[0],
    #   result_2: results[1],
    #   }
    # @param queries [Array<Hash>] Keyword arguments for each query
    # @param context [Hash] Multiplex-level context
    # @return [Array<Hash>] One result for each query in the input
    # @see {Query#initialize} for query keyword arguments
    # @see {Execution::Multiplex#run_all} for multiplex keyword arguments
    def multiplex(queries, **kwargs); end

    def multiplex_analyzer(new_analyzer); end
    def multiplex_analyzers; end
    def mutation(new_mutation_object = T.unsafe(nil)); end
    def mutation_execution_strategy(new_mutation_execution_strategy = T.unsafe(nil)); end

    # @return [Boolean]
    def new_connections?; end

    # @raise [GraphQL::RequiredImplementationMissingError]
    def object_from_id(node_id, ctx); end

    def orphan_types(*new_orphan_types); end

    # A function to call when {#execute} receives an invalid query string
    #
    # The default is to add the error to `context.errors`
    #
    # @param err [GraphQL::ParseError] The error encountered during parsing
    # @param ctx [GraphQL::Query::Context] The context for the query where the error occurred
    # @return void
    def parse_error(parse_err, ctx); end

    def plugins; end

    # @param type [Module] The type definition whose possible types you want to see
    # @return [Hash<String, Module>] All possible types, if no `type` is given.
    # @return [Array<Module>] Possible types for `type`, if it's given.
    def possible_types(type = T.unsafe(nil), context = T.unsafe(nil)); end

    def query(new_query_object = T.unsafe(nil)); end
    def query_analyzer(new_analyzer); end
    def query_analyzers; end
    def query_execution_strategy(new_query_execution_strategy = T.unsafe(nil)); end
    def query_stack_error(query, err); end
    def references_to(to_type = T.unsafe(nil), from: T.unsafe(nil)); end
    def rescue_from(*err_classes, &handler_block); end
    def resolve_type(type, obj, ctx); end

    # @return [GraphQL::ObjectType, nil]
    # @see [GraphQL::Schema::Warden] Restricted access to root types
    def root_type_for_operation(operation); end

    def root_types; end
    def sanitized_printer(new_sanitized_printer = T.unsafe(nil)); end
    def static_validator; end
    def subscription(new_subscription_object = T.unsafe(nil)); end
    def subscription_execution_strategy(new_subscription_execution_strategy = T.unsafe(nil)); end

    # @return [GraphQL::Subscriptions]
    def subscriptions(inherited: T.unsafe(nil)); end

    def subscriptions=(new_implementation); end

    # Override this method to handle lazy objects in a custom way.
    #
    # @api private
    # @param value [Object] an instance of a class registered with {.lazy_resolve}
    # @return [Object] A GraphQL-ready (non-lazy) object
    def sync_lazy(value); end

    # Return the GraphQL IDL for the schema
    #
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    # @return [String]
    def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

    # Return the GraphQL::Language::Document IDL AST for the schema
    #
    # @return [GraphQL::Language::Document]
    def to_document; end

    # Returns the JSON response of {Introspection::INTROSPECTION_QUERY}.
    #
    # @return [String]
    # @see {#as_json}
    def to_json(**args); end

    def tracer(new_tracer); end
    def tracers; end
    def type_error(type_error, ctx); end
    def type_from_ast(ast_node, context: T.unsafe(nil)); end

    # Build a map of `{ name => type }` and return it
    #
    # @return [Hash<String => Class>] A dictionary of type classes by their GraphQL name
    # @see get_type Which is more efficient for finding _one type_ by name, because it doesn't merge hashes.
    def types(context = T.unsafe(nil)); end

    # This hook is called when a field fails an `authorized?` check.
    #
    # By default, this hook implements the same behavior as unauthorized_object.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized field . If an error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedFieldError]
    # @return [Field] The returned field will be put in the GraphQL response
    def unauthorized_field(unauthorized_error); end

    # This hook is called when an object fails an `authorized?` check.
    # You might report to your bug tracker here, so you can correct
    # the field resolvers not to return unauthorized objects.
    #
    # By default, this hook just replaces the unauthorized object with `nil`.
    #
    # Whatever value is returned from this method will be used instead of the
    # unauthorized object (accessible as `unauthorized_error.object`). If an
    # error is raised, then `nil` will be used.
    #
    # If you want to add an error to the `"errors"` key, raise a {GraphQL::ExecutionError}
    # in this hook.
    #
    # @param unauthorized_error [GraphQL::UnauthorizedError]
    # @return [Object] The returned object will be put in the GraphQL response
    def unauthorized_object(unauthorized_error); end

    def union_memberships(type = T.unsafe(nil)); end
    def use(plugin, **kwargs); end

    # @return [Boolean]
    def using_ast_analysis?; end

    # Validate a query string according to this schema.
    #
    # @param string_or_document [String, GraphQL::Language::Nodes::Document]
    # @return [Array<GraphQL::StaticValidation::Error >]
    def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end

    def validate_max_errors(new_validate_max_errors = T.unsafe(nil)); end

    # Sets the attribute validate_max_errors
    #
    # @param value the value to set the attribute validate_max_errors to.
    def validate_max_errors=(_arg0); end

    def validate_timeout(new_validate_timeout = T.unsafe(nil)); end

    # Sets the attribute validate_timeout
    #
    # @param value the value to set the attribute validate_timeout to.
    def validate_timeout=(_arg0); end

    # @return [Boolean]
    def visible?(member, ctx); end

    private

    # @param t [Module, Array<Module>]
    # @return [void]
    def add_type_and_traverse(t, root:); end

    def lazy_methods; end
    def non_introspection_types; end
    def own_directives; end
    def own_instrumenters; end
    def own_multiplex_analyzers; end
    def own_orphan_types; end
    def own_plugins; end
    def own_possible_types; end
    def own_query_analyzers; end
    def own_tracers; end
    def own_types; end
    def own_union_memberships; end
  end
end

class GraphQL::Schema::Addition
  # @return [Addition] a new instance of Addition
  def initialize(schema:, own_types:, new_types:); end

  # Returns the value of attribute arguments_with_default_values.
  def arguments_with_default_values; end

  # Returns the value of attribute directives.
  def directives; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # Returns the value of attribute references.
  def references; end

  # Returns the value of attribute types.
  def types; end

  # Returns the value of attribute union_memberships.
  def union_memberships; end

  private

  def add_directives_from(owner); end
  def add_type(type, owner:, late_types:, path:); end
  def add_type_and_traverse(new_types); end

  # Lookup using `own_types` here because it's ok to override
  # inherited types by name
  def get_local_type(name); end

  def get_type(name); end
  def references_to(thing, from:); end
  def update_type_owner(owner, type); end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators

  # @param arg_name [Symbol]
  # @param type_expr
  # @param desc [String]
  # @param required [Boolean, :nullable] if true, this argument is non-null; if false, this argument is nullable. If `:nullable`, then the argument must be provided, though it may be `null`.
  # @param description [String]
  # @param default_value [Object]
  # @param as [Symbol] Override the keyword name when passed to a method
  # @param prepare [Symbol] A method to call to transform this argument's valuebefore sending it to field resolution
  # @param camelize [Boolean] if true, the name will be camelized when building the schema
  # @param from_resolver [Boolean] if true, a Resolver class defined this argument
  # @param directives [Hash{Class => Hash}]
  # @param deprecation_reason [String]
  # @param validates [Hash, nil] Options for building validators, if any should be applied
  # @param replace_null_with_default [Boolean] if `true`, incoming values of `null` will be replaced with the configured `default_value`
  # @return [Argument] a new instance of Argument
  def initialize(arg_name = T.unsafe(nil), type_expr = T.unsafe(nil), desc = T.unsafe(nil), owner:, required: T.unsafe(nil), type: T.unsafe(nil), name: T.unsafe(nil), loads: T.unsafe(nil), description: T.unsafe(nil), ast_node: T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), from_resolver: T.unsafe(nil), camelize: T.unsafe(nil), prepare: T.unsafe(nil), validates: T.unsafe(nil), directives: T.unsafe(nil), deprecation_reason: T.unsafe(nil), replace_null_with_default: T.unsafe(nil), &definition_block); end

  # @return [Boolean]
  def accessible?(context); end

  # @return [Boolean]
  def authorized?(obj, value, ctx); end

  # @return [Boolean]
  def authorized_as_type?(obj, value, ctx, as_type:); end

  # @api private
  def coerce_into_values(parent_object, values, context, argument_values); end

  # @return [Object] the value used when the client doesn't provide a value for this argument
  def default_value; end

  # @return [Boolean] True if this argument has a default value
  def default_value?; end

  # @return [String] Deprecation reason for this argument
  def deprecation_reason(text = T.unsafe(nil)); end

  def deprecation_reason=(new_reason); end

  # @return [String] Documentation for this argument
  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # @return [Boolean] true if a resolver defined this argument
  def from_resolver?; end

  # @return [String] the GraphQL name for this argument, camelized unless `camelize: false` is provided
  def graphql_name; end

  def inspect; end

  # @return [Symbol] This argument's name in Ruby keyword arguments
  def keyword; end

  def load_and_authorize_value(load_method_owner, coerced_value, context); end

  # @return [Class, Module, nil] If this argument should load an application object, this is the type of object to load
  def loads; end

  # @return [String] the GraphQL name for this argument, camelized unless `camelize: false` is provided
  def name; end

  # @return [GraphQL::Schema::Field, Class] The field or input object this argument belongs to
  def owner; end

  # @return [Symbol] A method to call to transform this value before sending it to field resolution method
  def prepare; end

  # Apply the {prepare} configuration to `value`, using methods from `obj`.
  # Used by the runtime.
  #
  # @api private
  def prepare_value(obj, value, context: T.unsafe(nil)); end

  # @return [Boolean]
  def replace_null_with_default?; end

  # @return [Boolean]
  def statically_coercible?; end

  def type; end
  def type=(new_type); end

  # @api private
  def validate_default_value; end

  # @return [Boolean]
  def visible?(context); end

  private

  def validate_deprecated_or_optional(null:, deprecation_reason:); end
  def validate_input_type(input_type); end
end

class GraphQL::Schema::Argument::InvalidDefaultValueError < ::GraphQL::Error
  # @return [InvalidDefaultValueError] a new instance of InvalidDefaultValueError
  def initialize(argument); end
end

GraphQL::Schema::Argument::NO_DEFAULT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::BUILT_IN_TYPES = T.let(T.unsafe(nil), Hash)

# @api private
module GraphQL::Schema::Base64Encoder
  class << self
    # @api private
    def decode(encoded_text, nonce: T.unsafe(nil)); end

    # @api private
    def encode(unencoded_text, nonce: T.unsafe(nil)); end
  end
end

module GraphQL::Schema::BuildFromDefinition
  class << self
    # @see {Schema.from_definition}
    def from_definition(definition_string, parser: T.unsafe(nil), **kwargs); end

    def from_definition_path(definition_path, parser: T.unsafe(nil), **kwargs); end
    def from_document(document, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil)); end
  end
end

# @api private
module GraphQL::Schema::BuildFromDefinition::Builder
  extend ::GraphQL::Schema::BuildFromDefinition::Builder

  # @api private
  def args_to_kwargs(arg_owner, node); end

  # @api private
  # @raise [InvalidDocumentError]
  def build(document, default_resolve:, relay:, using: T.unsafe(nil)); end

  # @api private
  def build_arguments(type_class, arguments, type_resolver); end

  # @api private
  def build_default_value(default_value); end

  # @api private
  def build_definition_from_node(definition, type_resolver, default_resolve); end

  # @api private
  def build_deprecation_reason(directives); end

  # @api private
  def build_directive(directive_definition, type_resolver); end

  # @api private
  def build_directives(definition, ast_node, type_resolver); end

  # @api private
  def build_enum_type(enum_type_definition, type_resolver); end

  # @api private
  def build_fields(owner, field_definitions, type_resolver, default_resolve:); end

  # @api private
  def build_input_object_type(input_object_type_definition, type_resolver); end

  # @api private
  def build_interface_type(interface_type_definition, type_resolver); end

  # @api private
  def build_object_type(object_type_definition, type_resolver); end

  # @api private
  def build_resolve_type(lookup_hash, directives, missing_type_handler); end

  # @api private
  def build_scalar_type(scalar_type_definition, type_resolver, default_resolve:); end

  # @api private
  def build_scalar_type_coerce_method(scalar_class, method_name, default_definition_resolve); end

  # @api private
  def build_union_type(union_type_definition, type_resolver); end

  # @api private
  def prepare_directives(ast_node, type_resolver); end

  # Modify `types`, replacing any late-bound references to built-in types
  # with their actual definitions.
  #
  # (Schema definitions are allowed to reference those built-ins without redefining them.)
  #
  # @api private
  # @return void
  def replace_late_bound_types_with_built_in(types); end

  # @api private
  def resolve_type_name(type); end
end

# @api private
GraphQL::Schema::BuildFromDefinition::Builder::NO_DEFAULT_VALUE = T.let(T.unsafe(nil), Hash)

# @api private
GraphQL::Schema::BuildFromDefinition::Builder::NullResolveType = T.let(T.unsafe(nil), Proc)

# Wrap a user-provided hash of resolution behavior for easy access at runtime.
#
# Coerce scalar values by:
# - Checking for a function in the map like `{ Date: { coerce_input: ->(val, ctx) { ... }, coerce_result: ->(val, ctx) { ... } } }`
# - Falling back to a passthrough
#
# Interface/union resolution can be provided as a `resolve_type:` key.
#
# @api private
class GraphQL::Schema::BuildFromDefinition::ResolveMap
  # @api private
  # @return [ResolveMap] a new instance of ResolveMap
  def initialize(user_resolve_hash); end

  # @api private
  def call(type, field, obj, args, ctx); end

  # @api private
  def coerce_input(type, value, ctx); end

  # @api private
  def coerce_result(type, value, ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  # @return [DefaultResolve] a new instance of DefaultResolve
  def initialize(field_map, field_name); end

  # Make some runtime checks about
  # how `obj` implements the `field_name`.
  #
  # Create a new resolve function according to that implementation, then:
  #   - update `field_map` with this implementation
  #   - call the implementation now (to satisfy this field execution)
  #
  # If `obj` doesn't implement `field_name`, raise an error.
  def call(obj, args, ctx); end
end

# @api private
module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  class << self
    # @api private
    def call(val, _ctx); end
  end
end

# Subclasses of this can influence how {GraphQL::Execution::Interpreter} runs queries.
#
# - {.include?}: if it returns `false`, the field or fragment will be skipped altogether, as if it were absent
# - {.resolve}: Wraps field resolution (so it should call `yield` to continue)
class GraphQL::Schema::Directive < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor

  # @return [Directive] a new instance of Directive
  def initialize(owner, **arguments); end

  # @return [GraphQL::Interpreter::Arguments]
  def arguments; end

  def graphql_name; end

  # @return [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class, Module]
  def owner; end

  private

  def assert_has_location(location); end
  def assert_valid_owner; end

  class << self
    def default_directive(new_default_directive = T.unsafe(nil)); end

    # @return [Boolean]
    def default_directive?; end

    # Return a name based on the class name,
    # but downcase the first letter.
    def default_graphql_name; end

    # If false, this part of the query won't be evaluated
    #
    # @return [Boolean]
    def include?(_object, arguments, context); end

    def locations(*new_locations); end

    # @return [Boolean]
    def on_field?; end

    # @return [Boolean]
    def on_fragment?; end

    # @return [Boolean]
    def on_operation?; end

    def path; end
    def repeatable(new_value); end

    # @return [Boolean]
    def repeatable?; end

    # Continuing is passed as a block; `yield` to continue
    def resolve(object, arguments, context); end

    # Continuing is passed as a block, yield to continue.
    def resolve_each(object, arguments, context); end

    # Determines whether {Execution::Lookahead} considers the field to be selected
    #
    # @return [Boolean]
    def static_include?(_arguments, _context); end
  end
end

GraphQL::Schema::Directive::ARGUMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::DEFAULT_DEPRECATION_REASON = T.let(T.unsafe(nil), String)

class GraphQL::Schema::Directive::Deprecated < ::GraphQL::Schema::Directive
  class << self
    def load_reason(value, _context = T.unsafe(nil)); end
  end
end

GraphQL::Schema::Directive::ENUM = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::ENUM_VALUE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::FRAGMENT_SPREAD = T.let(T.unsafe(nil), Symbol)

# An example directive to show how you might interact with the runtime.
#
# This directive might be used along with a server-side feature flag system like Flipper.
#
# With that system, you could use this directive to exclude parts of a query
# if the current viewer doesn't have certain flags enabled.
# (So, this flag would be for internal clients, like your iOS app, not third-party API clients.)
#
# To use it, you have to implement `.enabled?`, for example:
#
# @example Implementing the Feature directive
#   # app/graphql/directives/feature.rb
#   class Directives::Feature < GraphQL::Schema::Directive::Feature
#   def self.enabled?(flag_name, _obj, context)
#   # Translate some GraphQL data for Ruby:
#   flag_key = flag_name.underscore
#   current_user = context[:viewer]
#   # Check the feature flag however your app does it:
#   MyFeatureFlags.enabled?(current_user, flag_key)
#   end
#   end
# @example Flagging a part of the query
#   viewer {
#   # This field only runs if `.enabled?("recommendationEngine", obj, context)`
#   # returns true. Otherwise, it's treated as if it didn't exist.
#   recommendations @feature(flag: "recommendationEngine") {
#   name
#   rating
#   }
#   }
class GraphQL::Schema::Directive::Feature < ::GraphQL::Schema::Directive
  class << self
    # Override this method in your app's subclass of this directive.
    #
    # @param flag_name [String] The client-provided string of a feature to check
    # @param object [GraphQL::Schema::Objct] The currently-evaluated GraphQL object instance
    # @param context [GraphQL::Query::Context]
    # @raise [GraphQL::RequiredImplementationMissingError]
    # @return [Boolean] If truthy, execution will continue
    def enabled?(flag_name, object, context); end

    # Implement the Directive API
    #
    # @return [Boolean]
    def include?(object, arguments, context); end

    def load_flag(value, _context = T.unsafe(nil)); end
  end
end

# This is _similar_ to {Directive::Feature}, except it's prescribed by the server, not the client.
#
# In this case, the server hides types and fields _entirely_, unless the current context has certain `:flags` present.
class GraphQL::Schema::Directive::Flagged < ::GraphQL::Schema::Directive
  # @return [Flagged] a new instance of Flagged
  def initialize(target, **options); end

  class << self
    def load_by(value, _context = T.unsafe(nil)); end
  end
end

module GraphQL::Schema::Directive::Flagged::VisibleByFlag
  # @return [Boolean]
  def visible?(context); end

  class << self
    # @private
    def included(schema_class); end
  end
end

GraphQL::Schema::Directive::INLINE_FRAGMENT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_FIELD_DEFINITION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INPUT_OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::INTERFACE = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Include < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end

    # @return [Boolean]
    def static_include?(args, ctx); end
  end
end

GraphQL::Schema::Directive::LOCATIONS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::LOCATION_DESCRIPTIONS = T.let(T.unsafe(nil), Hash)
GraphQL::Schema::Directive::MUTATION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::OBJECT = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::QUERY = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCALAR = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SCHEMA = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::SUBSCRIPTION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::Directive::Skip < ::GraphQL::Schema::Directive
  class << self
    def load_if(value, _context = T.unsafe(nil)); end

    # @return [Boolean]
    def static_include?(args, ctx); end
  end
end

# An example directive to show how you might interact with the runtime.
#
# This directive takes the return value of the tagged part of the query,
# and if the named transform is whitelisted and applies to the return value,
# it's applied by calling a method with that name.
#
# @example Installing the directive
#   class MySchema < GraphQL::Schema
#   directive(GraphQL::Schema::Directive::Transform)
#   end
# @example Transforming strings
#   viewer {
#   username @transform(by: "upcase")
#   }
class GraphQL::Schema::Directive::Transform < ::GraphQL::Schema::Directive
  class << self
    def load_by(value, _context = T.unsafe(nil)); end

    # Implement the Directive API
    def resolve(object, arguments, context); end
  end
end

GraphQL::Schema::Directive::Transform::TRANSFORMS = T.let(T.unsafe(nil), Array)
GraphQL::Schema::Directive::UNION = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Directive::VARIABLE_DEFINITION = T.let(T.unsafe(nil), Symbol)

class GraphQL::Schema::DuplicateNamesError < ::GraphQL::Error
  # @return [DuplicateNamesError] a new instance of DuplicateNamesError
  def initialize(duplicated_name:, duplicated_definition_1:, duplicated_definition_2:); end

  # Returns the value of attribute duplicated_name.
  def duplicated_name; end
end

class GraphQL::Schema::Enum < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::ValidatesInput

  class << self
    # @return [Array<Schema::EnumValue>] An unfiltered list of all definitions
    def all_enum_value_definitions; end

    def coerce_input(value_name, ctx); end
    def coerce_result(value, ctx); end

    # @return [Class] for handling `value(...)` inputs and building `GraphQL::Enum::EnumValue`s out of them
    def enum_value_class(new_enum_value_class = T.unsafe(nil)); end

    # @return [Array<GraphQL::Schema::EnumValue>] Possible values of this enum
    def enum_values(context = T.unsafe(nil)); end

    # @private
    def inherited(child_class); end

    def kind; end
    def validate_non_null_input(value_name, ctx); end

    # Define a value for this enum
    #
    # @param graphql_name [String, Symbol] the GraphQL value for this, usually `SCREAMING_CASE`
    # @param description [String] , the GraphQL description for this value, present in documentation
    # @param value [Object] , the translated Ruby value for this object (defaults to `graphql_name`)
    # @param deprecation_reason [String] if this object is deprecated, include a message here
    # @return [void]
    # @see {Schema::EnumValue} which handles these inputs by default
    def value(*args, **kwargs, &block); end

    # @return [Hash<String => GraphQL::Schema::EnumValue>] Possible values of this enum, keyed by name.
    def values(context = T.unsafe(nil)); end

    private

    def own_values; end
  end
end

class GraphQL::Schema::Enum::UnresolvedValueError < ::GraphQL::Error
  # @return [UnresolvedValueError] a new instance of UnresolvedValueError
  def initialize(value:, enum:, context:); end
end

# A possible value for an {Enum}.
#
# You can extend this class to customize enum values in your schema.
#
# @example custom enum value class
#   # define a custom class:
#   class CustomEnumValue < GraphQL::Schema::EnumValue
#   def initialize(*args)
#   # arguments to `value(...)` in Enum classes are passed here
#   super
#   end
#   end
#
#   class BaseEnum < GraphQL::Schema::Enum
#   # use it for these enums:
#   enum_value_class CustomEnumValue
#   end
class GraphQL::Schema::EnumValue < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason

  # @return [EnumValue] a new instance of EnumValue
  def initialize(graphql_name, desc = T.unsafe(nil), owner:, ast_node: T.unsafe(nil), directives: T.unsafe(nil), description: T.unsafe(nil), value: T.unsafe(nil), deprecation_reason: T.unsafe(nil), &block); end

  # @return [Boolean]
  def accessible?(_ctx); end

  # @return [Boolean]
  def authorized?(_ctx); end

  def description(new_desc = T.unsafe(nil)); end

  # Returns the value of attribute graphql_name.
  def graphql_name; end

  def inspect; end

  # @return [Class] The enum type that owns this value
  def owner; end

  def value(new_val = T.unsafe(nil)); end

  # @return [Boolean]
  def visible?(_ctx); end
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasDeprecationReason
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @param name [Symbol] The underscore-cased version of this field name (will be camelized for the GraphQL API)
  # @param type [Class, GraphQL::BaseType, Array] The return type of this field
  # @param owner [Class] The type that this field belongs to
  # @param null [Boolean] (defaults to `true`) `true` if this field may return `null`, `false` if it is never `null`
  # @param description [String] Field description
  # @param deprecation_reason [String] If present, the field is marked "deprecated" with this message
  # @param method [Symbol] The method to call on the underlying object to resolve this field (defaults to `name`)
  # @param hash_key [String, Symbol] The hash key to lookup on the underlying object (if its a Hash) to resolve this field (defaults to `name` or `name.to_s`)
  # @param dig [Array<String, Symbol>] The nested hash keys to lookup on the underlying hash to resolve this field using dig
  # @param resolver_method [Symbol] The method on the type to call to resolve this field (defaults to `name`)
  # @param connection [Boolean] `true` if this field should get automagic connection behavior; default is to infer by `*Connection` in the return type name
  # @param connection_extension [Class] The extension to add, to implement connections. If `nil`, no extension is added.
  # @param max_page_size [Integer, nil] For connections, the maximum number of items to return from this field, or `nil` to allow unlimited results.
  # @param default_page_size [Integer, nil] For connections, the default number of items to return from this field, or `nil` to return unlimited results.
  # @param introspection [Boolean] If true, this field will be marked as `#introspection?` and the name may begin with `__`
  # @param resolver_class [Class] (Private) A {Schema::Resolver} which this field was derived from. Use `resolver:` to create a field with a resolver.
  # @param arguments [{String=>GraphQL::Schema::Argument, Hash}] Arguments for this field (may be added in the block, also)
  # @param camelize [Boolean] If true, the field name will be camelized when building the schema
  # @param complexity [Numeric] When provided, set the complexity for this field
  # @param scope [Boolean] If true, the return type's `.scope_items` method will be called on the return value
  # @param subscription_scope [Symbol, String] A key in `context` which will be used to scope subscription payloads
  # @param extensions [Array<Class, Hash<Class => Object>>] Named extensions to apply to this field (see also {#extension})
  # @param directives [Hash{Class => Hash}] Directives to apply to this field
  # @param trace [Boolean] If true, a {GraphQL::Tracing} tracer will measure this scalar field
  # @param broadcastable [Boolean] Whether or not this field can be distributed in subscription broadcasts
  # @param ast_node [Language::Nodes::FieldDefinition, nil] If this schema was parsed from definition, this AST node defined the field
  # @param method_conflict_warning [Boolean] If false, skip the warning if this field's method conflicts with a built-in method
  # @param validates [Array<Hash>] Configurations for validating this field
  # @return [Field] a new instance of Field
  def initialize(type: T.unsafe(nil), name: T.unsafe(nil), owner: T.unsafe(nil), null: T.unsafe(nil), description: T.unsafe(nil), deprecation_reason: T.unsafe(nil), method: T.unsafe(nil), hash_key: T.unsafe(nil), dig: T.unsafe(nil), resolver_method: T.unsafe(nil), connection: T.unsafe(nil), max_page_size: T.unsafe(nil), default_page_size: T.unsafe(nil), scope: T.unsafe(nil), introspection: T.unsafe(nil), camelize: T.unsafe(nil), trace: T.unsafe(nil), complexity: T.unsafe(nil), ast_node: T.unsafe(nil), extras: T.unsafe(nil), extensions: T.unsafe(nil), connection_extension: T.unsafe(nil), resolver_class: T.unsafe(nil), subscription_scope: T.unsafe(nil), relay_node_field: T.unsafe(nil), relay_nodes_field: T.unsafe(nil), method_conflict_warning: T.unsafe(nil), broadcastable: T.unsafe(nil), arguments: T.unsafe(nil), directives: T.unsafe(nil), validates: T.unsafe(nil), fallback_value: T.unsafe(nil), &definition_block); end

  # @return [Boolean]
  def accessible?(context); end

  # @return [Boolean]
  def authorized?(object, args, context); end

  # If true, subscription updates with this field can be shared between viewers
  #
  # @return [Boolean, nil]
  # @see GraphQL::Subscriptions::BroadcastAnalyzer
  def broadcastable?; end

  def calculate_complexity(query:, nodes:, child_complexity:); end
  def complexity(new_complexity = T.unsafe(nil)); end

  # Can be set with `connection: true|false` or inferred from a type name ending in `*Connection`
  #
  # @return [Boolean] if true, this field will be wrapped with Relay connection behavior
  def connection?; end

  # @return [Integer, nil] Applied to connections if {#has_default_page_size?}
  def default_page_size; end

  # @param text [String]
  # @return [String]
  def description(text = T.unsafe(nil)); end

  # Sets the attribute description
  #
  # @param value the value to set the attribute description to.
  def description=(_arg0); end

  # Returns the value of attribute dig_keys.
  def dig_keys; end

  # Add `extension` to this field, initialized with `options` if provided.
  #
  # @example adding an extension
  #   extension(MyExtensionClass)
  # @example adding an extension with options
  #   extension(MyExtensionClass, filter: true)
  # @param extension_class [Class] subclass of {Schema::FieldExtension}
  # @param options [Hash] if provided, given as `options:` when initializing `extension`.
  # @return [void]
  def extension(extension_class, options = T.unsafe(nil)); end

  # Read extension instances from this field,
  # or add new classes/options to be initialized on this field.
  # Extensions are executed in the order they are added.
  #
  # @example adding an extension
  #   extensions([MyExtensionClass])
  # @example adding multiple extensions
  #   extensions([MyExtensionClass, AnotherExtensionClass])
  # @example adding an extension with options
  #   extensions([MyExtensionClass, { AnotherExtensionClass => { filter: true } }])
  # @param extensions [Array<Class, Hash<Class => Hash>>] Add extensions to this field. For hash elements, only the first key/value is used.
  # @return [Array<GraphQL::Schema::FieldExtension>] extensions to apply to this field
  def extensions(new_extensions = T.unsafe(nil)); end

  # Read extras (as symbols) from this field,
  # or add new extras to be opted into by this field's resolver.
  #
  # @param new_extras [Array<Symbol>] Add extras to this field
  # @return [Array<Symbol>]
  def extras(new_extras = T.unsafe(nil)); end

  # @param ctx [GraphQL::Query::Context]
  def fetch_extra(extra_name, ctx); end

  # @return [String] the GraphQL name for this field, camelized unless `camelize: false` is provided
  def graphql_name; end

  # @return [Boolean] True if this field's {#default_page_size} should override the schema default.
  def has_default_page_size?; end

  # @return [Boolean] True if this field's {#max_page_size} should override the schema default.
  def has_max_page_size?; end

  # Returns the value of attribute hash_key.
  def hash_key; end

  def inspect; end

  # @return [Boolean] Is this field a predefined introspection field?
  def introspection?; end

  # @return [Integer, nil] Applied to connections if {#has_max_page_size?}
  def max_page_size; end

  # @return [Boolean] Should we warn if this field's name conflicts with a built-in method?
  def method_conflict_warning?; end

  # @return [String] Method or hash key on the underlying object to look up
  def method_str; end

  # @return [Symbol] Method or hash key on the underlying object to look up
  def method_sym; end

  # @return [Class, nil] The {Schema::Resolver} this field was derived from, if there is one
  def mutation; end

  # @return [String] the GraphQL name for this field, camelized unless `camelize: false` is provided
  def name; end

  # @return [Symbol] the original name of the field, passed in by the user
  def original_name; end

  # @return [Class] The thing this field was defined on (type, mutation, resolver)
  def owner; end

  # @return [Class] The thing this field was defined on (type, mutation, resolver)
  def owner=(_arg0); end

  # @return [Class] The GraphQL type this field belongs to. (For fields defined on mutations, it's the payload type)
  def owner_type; end

  # @return Boolean
  def relay_node_field; end

  # @return Boolean
  def relay_nodes_field; end

  # This method is called by the interpreter for each field.
  # You can extend it in your base field classes.
  #
  # @param object [GraphQL::Schema::Object] An instance of some type class, wrapping an application object
  # @param args [Hash] A symbol-keyed hash of Ruby keyword arguments. (Empty if no args)
  # @param ctx [GraphQL::Query::Context]
  def resolve(object, args, query_ctx); end

  # @return [Class, nil] The {Schema::Resolver} this field was derived from, if there is one
  def resolver; end

  # @return [Symbol] The method on the type to look up
  def resolver_method; end

  # @return [Boolean] if true, the return type's `.scope_items` method will be applied to this field's return value
  def scoped?; end

  # @return [String, nil]
  def subscription_scope; end

  # Sets the attribute subscription_scope
  #
  # @param value the value to set the attribute subscription_scope to.
  def subscription_scope=(_arg0); end

  # @return [Boolean] Apply tracing to this field? (Default: skip scalars, this is the override value)
  def trace; end

  def type; end

  # Sets the attribute type
  #
  # @param value the value to set the attribute type to.
  def type=(_arg0); end

  # @return [Boolean]
  def visible?(context); end

  private

  def assert_satisfactory_implementation(receiver, method_name, ruby_kwargs); end
  def run_extensions_before_resolve(obj, args, ctx, extended, idx: T.unsafe(nil)); end

  # Wrap execution with hooks.
  # Written iteratively to avoid big stack traces.
  #
  # @return [Object] Whatever the
  def with_extensions(obj, args, ctx); end

  class << self
    # This extension is applied to fields when {#connection?} is true.
    #
    # You can override it in your base field definition.
    #
    # @example Configuring a custom extension
    #   class Types::BaseField < GraphQL::Schema::Field
    #   connection_extension(MyCustomExtension)
    #   end
    # @return [Class] A {FieldExtension} subclass for implementing pagination behavior.
    def connection_extension(new_extension_class = T.unsafe(nil)); end

    # Create a field instance from a list of arguments, keyword arguments, and a block.
    #
    # This method implements prioritization between the `resolver` or `mutation` defaults
    # and the local overrides via other keywords.
    #
    # It also normalizes positional arguments into keywords for {Schema::Field#initialize}.
    #
    # @param resolver [Class] A {GraphQL::Schema::Resolver} class to use for field configuration
    # @param mutation [Class] A {GraphQL::Schema::Mutation} class to use for field configuration
    # @param subscription [Class] A {GraphQL::Schema::Subscription} class to use for field configuration
    # @return [GraphQL::Schema:Field] an instance of `self
    # @see {.initialize} for other options
    def from_options(name = T.unsafe(nil), type = T.unsafe(nil), desc = T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
  end
end

class GraphQL::Schema::Field::ConnectionExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
  def apply; end

  # Remove pagination args before passing it to a user method
  #
  # @yield [object, next_args, arguments]
  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::Field::FieldImplementationFailed < ::GraphQL::Error; end
class GraphQL::Schema::Field::MissingReturnTypeError < ::GraphQL::Error; end

class GraphQL::Schema::Field::ScopeExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end
end

# Extend this class to make field-level customizations to resolve behavior.
#
# When a extension is added to a field with `extension(MyExtension)`, a `MyExtension` instance
# is created, and its hooks are applied whenever that field is called.
#
# The instance is frozen so that instance variables aren't modified during query execution,
# which could cause all kinds of issues due to race conditions.
class GraphQL::Schema::FieldExtension
  # Called when the extension is mounted with `extension(name, options)`.
  # The instance will be frozen to avoid improper use of state during execution.
  #
  # @param field [GraphQL::Schema::Field] The field where this extension was mounted
  # @param options [Object] The second argument to `extension`, or `{}` if nothing was passed.
  # @return [FieldExtension] a new instance of FieldExtension
  def initialize(field:, options:); end

  # @return [Array<Symbol>, nil] `default_argument`s added, if any were added (otherwise, `nil`)
  def added_default_arguments; end

  # @api private
  def added_extras; end

  # Called after the field's definition block has been executed.
  # (Any arguments from the block are present on `field`)
  #
  # @return [void]
  def after_define; end

  # @api private
  def after_define_apply; end

  # Called after {#field} was resolved, and after any lazy values (like `Promise`s) were synced,
  # but before the value was added to the GraphQL response.
  #
  # Whatever this hook returns will be used as the return value.
  #
  # @param object [Object] The object the field is being resolved on
  # @param arguments [Hash] Ruby keyword arguments for resolving this field
  # @param context [Query::Context] the context for this query
  # @param value [Object] Whatever the field previously returned
  # @param memo [Object] The third value yielded by {#resolve}, or `nil` if there wasn't one
  # @return [Object] The return value for this field.
  def after_resolve(object:, arguments:, context:, value:, memo:); end

  # Called when this extension is attached to a field.
  # The field definition may be extended during this method.
  #
  # @return [void]
  def apply; end

  # @return [GraphQL::Schema::Field]
  def field; end

  # @return [Object]
  def options; end

  # Called before resolving {#field}. It should either:
  #
  # - `yield` values to continue execution; OR
  # - return something else to shortcut field execution.
  #
  # Whatever this method returns will be used for execution.
  #
  # @param object [Object] The object the field is being resolved on
  # @param arguments [Hash] Ruby keyword arguments for resolving this field
  # @param context [Query::Context] the context for this query
  # @return [Object] The return value for this field.
  # @yieldparam object [Object] The object to continue resolving the field on
  # @yieldparam arguments [Hash] The keyword arguments to continue resolving with
  # @yieldparam memo [Object] Any extension-specific value which will be passed to {#after_resolve} later
  def resolve(object:, arguments:, context:); end

  class << self
    # @see Argument#initialize
    # @see HasArguments#argument
    def default_argument(*argument_args, **argument_kwargs); end

    # @return [Array(Array, Hash), nil] A list of default argument configs, or `nil` if there aren't any
    def default_argument_configurations; end

    # If configured, these `extras` will be added to the field if they aren't already present,
    # but removed by from `arguments` before the field's `resolve` is called.
    # (The extras _will_ be present for other extensions, though.)
    #
    # @param new_extras [Array<Symbol>] If provided, assign extras used by this extension
    # @return [Array<Symbol>] any extras assigned to this extension
    def extras(new_extras = T.unsafe(nil)); end
  end
end

GraphQL::Schema::FieldExtension::NO_EXTRAS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  private

  def find_inherited_value(method_name, default_value = T.unsafe(nil)); end

  class << self
    # @private
    def extended(child_cls); end

    # @private
    def included(child_cls); end
  end
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects; end
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
GraphQL::Schema::FindInheritedValue::EmptyObjects::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Find schema members using string paths
#
# @example Finding object types
#   MySchema.find("SomeObjectType")
# @example Finding fields
#   MySchema.find("SomeObjectType.myField")
# @example Finding arguments
#   MySchema.find("SomeObjectType.myField.anArgument")
# @example Finding directives
#   MySchema.find("@include")
class GraphQL::Schema::Finder
  # @return [Finder] a new instance of Finder
  def initialize(schema); end

  def find(path); end

  private

  def find_in_directive(directive, path:); end
  def find_in_enum_type(enum_type, path:); end
  def find_in_field(field, path:); end
  def find_in_fields_type(type, kind:, path:); end
  def find_in_input_object(input_object, path:); end
  def find_in_type(type, path:); end

  # Returns the value of attribute schema.
  def schema; end
end

class GraphQL::Schema::Finder::MemberNotFoundError < ::ArgumentError; end

class GraphQL::Schema::InputObject < ::GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::HasValidators

  # @return [InputObject] a new instance of InputObject
  def initialize(arguments, ruby_kwargs:, context:, defaults_used:); end

  # Lookup a key on this object, it accepts new-style underscored symbols
  # Or old-style camelized identifiers.
  #
  # @param key [Symbol, String]
  def [](key); end

  def any?(*args, &block); end

  # @return [GraphQL::Execution::Interpereter::Arguments] The underlying arguments instance
  def arguments; end

  # @return [GraphQL::Query::Context] The context for this query
  def context; end

  def each(*args, &block); end
  def empty?(*args, &block); end

  # @return [Boolean]
  def key?(key); end

  def keys(*args, &block); end
  def map(*args, &block); end
  def prepare; end
  def to_h; end
  def to_hash; end

  # A copy of the Ruby-style hash
  def to_kwargs; end

  def unwrap_value(value); end
  def values(*args, &block); end

  private

  def overwrite_argument(key, value); end

  class << self
    def argument(*args, **kwargs, &block); end

    # @return [Boolean]
    def authorized?(obj, value, ctx); end

    def coerce_input(value, ctx); end

    # It's funny to think of a _result_ of an input object.
    # This is used for rendering the default value in introspection responses.
    def coerce_result(value, ctx); end

    def kind; end
    def validate_non_null_input(input, ctx); end
  end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Interface::DefinitionMethods

  def unwrap; end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasUnresolvedTypeError
  include ::GraphQL::Schema::Member::HasDirectives
  include ::GraphQL::Schema::Member::HasInterfaces

  # The interface is accessible if any of its possible types are accessible
  #
  # @return [Boolean]
  def accessible?(context); end

  # Methods defined in this block will be:
  # - Added as class methods to this interface
  # - Added as class methods to all child interfaces
  def definition_methods(&block); end

  # Here's the tricky part. Make sure behavior keeps making its way down the inheritance chain.
  def included(child_class); end

  def kind; end
  def orphan_types(*types); end
  def type_membership_class(membership_class = T.unsafe(nil)); end

  # @return [Boolean]
  # @see {Schema::Warden} hides interfaces without visible implementations
  def visible?(context); end
end

class GraphQL::Schema::IntrospectionSystem
  # @return [IntrospectionSystem] a new instance of IntrospectionSystem
  def initialize(schema); end

  def dynamic_field(name:); end
  def dynamic_fields; end
  def entry_point(name:); end
  def entry_points; end

  # Returns the value of attribute possible_types.
  def possible_types; end

  # The introspection system is prepared with a bunch of LateBoundTypes.
  # Replace those with the objects that they refer to, since LateBoundTypes
  # aren't handled at runtime.
  #
  # @api private
  # @return void
  def resolve_late_bindings; end

  # Returns the value of attribute types.
  def types; end

  private

  # This is probably not 100% robust -- but it has to be good enough to avoid modifying the built-in introspection types
  def dup_type_class(type_class); end

  def get_fields_from_class(class_sym:); end
  def load_constant(class_name); end
  def resolve_late_binding(late_bound_type); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  # @return [PerFieldProxyResolve] a new instance of PerFieldProxyResolve
  def initialize(object_class:, inner_resolve:); end

  def call(obj, args, ctx); end
end

# Error that is raised when [#Schema#from_definition] is passed an invalid schema definition string.
class GraphQL::Schema::InvalidDocumentError < ::GraphQL::Error; end

class GraphQL::Schema::InvalidTypeError < ::GraphQL::Error; end

# A stand-in for a type which will be resolved in a given schema, by name.
# TODO: support argument types too, make this a public API somehow
#
# @api Private
class GraphQL::Schema::LateBoundType
  # @api Private
  # @return [LateBoundType] a new instance of LateBoundType
  def initialize(local_name); end

  # @api Private
  def graphql_name; end

  # @api Private
  def inspect; end

  # @api Private
  def name; end

  # @api Private
  def to_list_type; end

  # @api Private
  def to_non_null_type; end

  # @api Private
  def to_s; end

  # @api Private
  def unwrap; end
end

# Represents a list type in the schema.
# Wraps a {Schema::Member} as a list type.
#
# @see {Schema::Member::TypeSystemHelpers#to_list_type}
class GraphQL::Schema::List < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # Also for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  # @return [GraphQL::TypeKinds::LIST]
  def kind; end

  # @return [true]
  def list?; end

  def to_type_signature; end
  def validate_non_null_input(value, ctx); end

  private

  def ensure_array(value); end
end

# You can use the result of {GraphQL::Introspection::INTROSPECTION_QUERY}
# to make a schema. This schema is missing some important details like
# `resolve` functions, but it does include the full type system,
# so you can use it to validate queries.
#
# @see GraphQL::Schema.from_introspection for a public API
module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader

  # Create schema with the result of an introspection query.
  #
  # @param introspection_result [Hash] A response from {GraphQL::Introspection::INTROSPECTION_QUERY}
  # @return [Class] the schema described by `input`
  def load(introspection_result); end

  class << self
    def build_arguments(arg_owner, args, type_resolver); end
    def build_fields(type_defn, fields, type_resolver); end

    private

    def define_directive(directive, type_resolver); end
    def define_type(type, type_resolver); end
    def extract_default_value(default_value_str, input_value_ast); end
    def resolve_type(types, type); end
  end
end

GraphQL::Schema::Loader::NullScalarCoerce = T.let(T.unsafe(nil), Proc)

# The base class for things that make up the schema,
# eg objects, enums, scalars.
#
# @api private
class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasDirectives
end

# DSL methods shared by lots of things in the GraphQL Schema.
#
# @api private
# @see Classes that extend this, eg {GraphQL::Schema::Object}
module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @api private
  # @return [Boolean]
  def accessible?(context); end

  # @api private
  # @return [Boolean]
  def authorized?(object, context); end

  # Creates the default name for a schema member.
  # The default name is the Ruby constant name,
  # without any namespaces and with any `-Type` suffix removed
  #
  # @api private
  def default_graphql_name; end

  # Call this method to provide a new description; OR
  # call it without an argument to get the description
  #
  # @api private
  # @param new_description [String]
  # @return [String]
  def description(new_description = T.unsafe(nil)); end

  # Call this with a new name to override the default name for this schema member; OR
  # call it without an argument to get the name of this schema member
  #
  # The default name is implemented in default_graphql_name
  #
  # @api private
  # @param new_name [String]
  # @return [String]
  def graphql_name(new_name = T.unsafe(nil)); end

  # @api private
  # @return [Boolean] If true, this object is part of the introspection system
  def introspection(new_introspection = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def introspection?; end

  # The mutation this type was derived from, if it was derived from a mutation
  #
  # @api private
  # @return [Class]
  def mutation(mutation_class = T.unsafe(nil)); end

  # Just a convenience method to point out that people should use graphql_name instead
  #
  # @api private
  def name(new_name = T.unsafe(nil)); end

  # @api private
  def overridden_graphql_name; end

  # @api private
  def unwrap; end

  # @api private
  # @return [Boolean]
  def visible?(context); end
end

# This pushes some configurations _down_ the inheritance tree,
# in order to prevent repetitive lookups at runtime.
#
# @api private
module GraphQL::Schema::Member::BaseDSLMethods::ConfigurationExtension
  # @api private
  def inherited(child_class); end
end

# @api private
module GraphQL::Schema::Member::BuildType
  private

  # @api private
  def camelize(string); end

  # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
  #
  # @api private
  def constantize(string); end

  # @api private
  # @param type_expr [String, Class, GraphQL::BaseType]
  # @return [GraphQL::BaseType]
  def parse_type(type_expr, null:); end

  # @api private
  def to_type_name(something); end

  # @api private
  def underscore(string); end

  class << self
    # @api private
    def camelize(string); end

    # Resolves constant from string (based on Rails `ActiveSupport::Inflector.constantize`)
    #
    # @api private
    def constantize(string); end

    # @api private
    # @param type_expr [String, Class, GraphQL::BaseType]
    # @return [GraphQL::BaseType]
    def parse_type(type_expr, null:); end

    # @api private
    def to_type_name(something); end

    # @api private
    def underscore(string); end
  end
end

# @api private
GraphQL::Schema::Member::BuildType::LIST_TYPE_ERROR = T.let(T.unsafe(nil), String)

# These constants are interpreted as GraphQL types when defining fields or arguments
#
# @api private
# @example
#   field :is_draft, Boolean, null: false
#   field :id, ID, null: false
#   field :score, Int, null: false
module GraphQL::Schema::Member::GraphQLTypeNames; end

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::Boolean = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::ID = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Schema::Member::GraphQLTypeNames::Int = T.let(T.unsafe(nil), String)

module GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader

  mixes_in_class_methods ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor

  # Register this argument with the class.
  #
  # @param arg_defn [GraphQL::Schema::Argument]
  # @return [GraphQL::Schema::Argument]
  def add_argument(arg_defn); end

  def all_argument_definitions; end

  # @return [GraphQL::Schema::Argument] An instance of {argument_class}, created from `*args`
  # @see {GraphQL::Schema::Argument#initialize} for parameters
  def argument(*args, **kwargs, &block); end

  # @param new_arg_class [Class] A class to use for building argument definitions
  def argument_class(new_arg_class = T.unsafe(nil)); end

  # @return [Hash<String => GraphQL::Schema::Argument] Arguments defined on this thing, keyed by name. Includes inherited definitions] Hash<String => GraphQL::Schema::Argument] Arguments defined on this thing, keyed by name. Includes inherited definitions
  def arguments(context = T.unsafe(nil)); end

  # @return [Boolean]
  def arguments_statically_coercible?; end

  # If given a block, it will eventually yield the loaded args to the block.
  #
  # If no block is given, it will immediately dataload (but might return a Lazy).
  #
  # @api private
  # @param values [Hash<String, Object>]
  # @param context [GraphQL::Query::Context]
  # @return [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
  # @yield [Interpreter::Arguments, Execution::Lazy<Interpeter::Arguments>]
  def coerce_arguments(parent_object, values, context, &block); end

  # @return [GraphQL::Schema::Argument, nil] Argument defined on this thing, fetched by name.
  def get_argument(argument_name, context = T.unsafe(nil)); end

  def own_arguments; end
  def remove_argument(arg_defn); end

  # Usually, this is validated statically by RequiredArgumentsArePresent,
  # but not for directives.
  # TODO apply static validations on schema definitions?
  def validate_directive_argument(arg_defn, value); end

  class << self
    # @private
    def extended(cls); end

    # @private
    def included(cls); end
  end
end

module GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  def argument_class(new_arg_class = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def authorize_application_object(argument, id, context, loaded_application_object); end
  def load_and_authorize_application_object(argument, id, context); end
  def load_application_object(argument, id, context); end
  def load_application_object_failed(err); end

  # Look up the corresponding object for a provided ID.
  # By default, it uses Relay-style {Schema.object_from_id},
  # override this to find objects another way.
  #
  # @param type [Class, Module] A GraphQL type definition
  # @param id [String] A client-provided to look up
  # @param context [GraphQL::Query::Context] the current context
  def object_from_id(type, id, context); end
end

GraphQL::Schema::Member::HasArguments::NO_ARGUMENTS = T.let(T.unsafe(nil), Hash)

module GraphQL::Schema::Member::HasAstNode
  # If this schema was parsed from a `.graphql` file (or other SDL),
  # this is the AST node that defined this part of the schema.
  def ast_node(new_ast_node = T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasDeprecationReason
  # @return [String, nil] Explains why this member was deprecated (if present, this will be marked deprecated in introspection)
  def deprecation_reason; end

  # Set the deprecation reason for this member, or remove it by assigning `nil`
  #
  # @param text [String, nil]
  def deprecation_reason=(text); end
end

module GraphQL::Schema::Member::HasDirectives
  # Create an instance of `dir_class` for `self`, using `options`.
  #
  # It removes a previously-attached instance of `dir_class`, if there is one.
  #
  # @return [void]
  def directive(dir_class, **options); end

  def directives; end

  # Remove an attached instance of `dir_class`, if there is one
  #
  # @param dir_class [Class<GraphQL::Schema::Directive>]
  # @return [viod]
  def remove_directive(dir_class); end

  protected

  def own_directives; end

  private

  # Modify `target` by adding items from `dirs` such that:
  # - Any name conflict is overriden by the incoming member of `dirs`
  # - Any other member of `dirs` is appended
  #
  # @param target [Array<GraphQL::Schema::Directive>]
  # @param dirs [Array<GraphQL::Schema::Directive>]
  # @return [void]
  def merge_directives(target, dirs); end
end

GraphQL::Schema::Member::HasDirectives::NO_DIRECTIVES = T.let(T.unsafe(nil), Array)

# Shared code for Objects, Interfaces, Mutations, Subscriptions
module GraphQL::Schema::Member::HasFields
  # Register this field with the class, overriding a previous one if needed.
  #
  # @param field_defn [GraphQL::Schema::Field]
  # @return [void]
  def add_field(field_defn, method_conflict_warning: T.unsafe(nil)); end

  def all_field_definitions; end

  # Add a field to this object or interface with the given definition
  #
  # @return [GraphQL::Schema::Field]
  # @see {GraphQL::Schema::Field#initialize} for method signature
  def field(*args, **kwargs, &block); end

  # @return [Class] The class to initialize when adding fields to this kind of schema member
  def field_class(new_field_class = T.unsafe(nil)); end

  # @return [Hash<String => GraphQL::Schema::Field>] Fields on this object, keyed by name, including inherited fields
  def fields(context = T.unsafe(nil)); end

  def get_field(field_name, context = T.unsafe(nil)); end
  def global_id_field(field_name, **kwargs); end

  # @return [Hash<String => GraphQL::Schema::Field, Array<GraphQL::Schema::Field>>] Fields defined on this class _specifically_, not parent classes
  def own_fields; end

  private

  # @param [GraphQL::Schema::Field]
  # @return [String] A warning to give when this field definition might conflict with a built-in method
  def conflict_field_name_warning(field_defn); end

  # If `type` is an interface, and `self` has a type membership for `type`, then make sure it's visible.
  #
  # @return [Boolean]
  def visible_interface_implementation?(type, context, warden); end
end

# A list of field names that we should advise users to pick a different
# resolve method name.
#
# @api private
GraphQL::Schema::Member::HasFields::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)

# A list of GraphQL-Ruby keywords.
#
# @api private
GraphQL::Schema::Member::HasFields::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

# A list of Ruby keywords.
#
# @api private
GraphQL::Schema::Member::HasFields::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

module GraphQL::Schema::Member::HasInterfaces
  def implements(*new_interfaces, **options); end
  def interface_type_memberships; end

  # param context [Query::Context] If omitted, skip filtering.
  def interfaces(context = T.unsafe(nil)); end

  def own_interface_type_memberships; end
end

module GraphQL::Schema::Member::HasPath
  # @return [String] A description of this member's place in the GraphQL schema
  def path; end
end

# Set up a type-specific error to make debugging & bug tracker integration better
module GraphQL::Schema::Member::HasUnresolvedTypeError
  private

  def add_unresolved_type_error(child_class); end
end

module GraphQL::Schema::Member::HasValidators
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # Build {GraphQL::Schema::Validator}s based on the given configuration
  # and use them for this schema member
  #
  # @param validation_config [Hash{Symbol => Hash}]
  # @return [void]
  def validates(validation_config); end

  # @return [Array<GraphQL::Schema::Validator>]
  def validators; end
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type; end
  def connection_type_class(new_connection_type_class = T.unsafe(nil)); end
  def edge_type; end
  def edge_type_class(new_edge_type_class = T.unsafe(nil)); end

  protected

  def configured_connection_type_class; end
  def configured_edge_type_class; end
end

module GraphQL::Schema::Member::Scoped
  # This is called when a field has `scope: true`.
  # The field's return type class receives this call.
  #
  # By default, it's a no-op. Override it to scope your objects.
  #
  # @param items [Object] Some list-like object (eg, Array, ActiveRecord::Relation)
  # @param context [GraphQL::Query::Context]
  # @return [Object] Another list-like object, scoped to the current context
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [GraphQL::TypeKinds::TypeKind]
  def kind; end

  # @return [Boolean] true if this is a list type. A non-nullable list is considered a list.
  def list?; end

  # @return [Boolean] true if this is a non-nullable type. A nullable list of non-nullables is considered nullable.
  def non_null?; end

  # @return [Schema::List] Make a list-type representation of this type
  def to_list_type; end

  # @return [Schema::NonNull] Make a non-null-type representation of this type
  def to_non_null_type; end

  def to_type_signature; end
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end
  def coerce_isolated_result(v); end

  # @return [Boolean]
  def valid_input?(val, ctx); end

  # @return [Boolean]
  def valid_isolated_input?(v); end

  def validate_input(val, ctx); end
end

# This base class accepts configuration for a mutation root field,
# then it can be hooked up to your mutation root object type.
#
# If you want to customize how this class generates types, in your base class,
# override the various `generate_*` methods.
#
# @example Creating a comment
#   # Define the mutation:
#   class Mutations::CreateComment < GraphQL::Schema::Mutation
#   argument :body, String, required: true
#   argument :post_id, ID, required: true
#
#   field :comment, Types::Comment, null: true
#   field :errors, [String], null: false
#
#   def resolve(body:, post_id:)
#   post = Post.find(post_id)
#   comment = post.comments.build(body: body, author: context[:current_user])
#   if comment.save
#   # Successful creation, return the created object with no errors
#   {
#   comment: comment,
#   errors: [],
#   }
#   else
#   # Failed save, return the errors to the client
#   {
#   comment: nil,
#   errors: comment.errors.full_messages
#   }
#   end
#   end
#   end
#
#   # Hook it up to your mutation:
#   class Types::Mutation < GraphQL::Schema::Object
#   field :create_comment, mutation: Mutations::CreateComment
#   end
#
#   # Call it from GraphQL:
#   result = MySchema.execute <<-GRAPHQL
#   mutation {
#   createComment(postId: "1", body: "Nice Post!") {
#   errors
#   comment {
#   body
#   author {
#   login
#   }
#   }
#   }
#   }
#   GRAPHQL
# @see {GraphQL::Schema::RelayClassicMutation} for an extension of this class with some conventions built-in.
class GraphQL::Schema::Mutation < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Resolver::HasPayloadType

  class << self
    # @return [Boolean]
    def visible?(context); end

    private

    def conflict_field_name_warning(field_defn); end

    # Override this to attach self as `mutation`
    def generate_payload_type; end
  end
end

# Represents a non null type in the schema.
# Wraps a {Schema::Member} when it is required.
#
# @see {Schema::Member::TypeSystemHelpers#to_non_null_type}
class GraphQL::Schema::NonNull < ::GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::ValidatesInput

  def coerce_input(value, ctx); end
  def coerce_result(value, ctx); end

  # This is for implementing introspection
  def description; end

  # This is for introspection, where it's expected the name will be `null`
  def graphql_name; end

  def inspect; end

  # @return [GraphQL::TypeKinds::NON_NULL]
  def kind; end

  # @return [Boolean] True if this type wraps a list type
  def list?; end

  # @return [true]
  def non_null?; end

  def to_type_signature; end
  def validate_input(value, ctx); end
end

# @api private
module GraphQL::Schema::NullMask
  class << self
    # @api private
    def call(member, ctx); end
  end
end

class GraphQL::Schema::Object < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasInterfaces

  # @return [Object] a new instance of Object
  def initialize(object, context); end

  # @return [GraphQL::Query::Context] the context instance for this query
  def context; end

  # @return [GraphQL::Dataloader]
  def dataloader; end

  # @return [Object] the application object this type is wrapping
  def object; end

  # Call this in a field method to return a value that should be returned to the client
  # without any further handling by GraphQL.
  def raw_value(obj); end

  class << self
    # Make a new instance of this type _if_ the auth check passes,
    # otherwise, raise an error.
    #
    # Probably only the framework should call this method.
    #
    # This might return a {GraphQL::Execution::Lazy} if the user-provided `.authorized?`
    # hook returns some lazy value (like a Promise).
    #
    # The reason that the auth check is in this wrapper method instead of {.new} is because
    # of how it might return a Promise. It would be weird if `.new` returned a promise;
    # It would be a headache to try to maintain Promise-y state inside a {Schema::Object}
    # instance. So, hopefully this wrapper method will do the job.
    #
    # @param object [Object] The thing wrapped by this object
    # @param context [GraphQL::Query::Context]
    # @raise [GraphQL::UnauthorizedError] if the user-provided hook returns `false`
    # @return [GraphQL::Schema::Object, GraphQL::Execution::Lazy]
    def authorized_new(object, context); end

    # Set up a type-specific invalid null error to use when this object's non-null fields wrongly return `nil`.
    # It should help with debugging and bug tracker integrations.
    def const_missing(name); end

    def kind; end
  end
end

# Used to convert your {GraphQL::Schema} to a GraphQL schema string
#
# @example print your schema to standard output (via helper)
#   puts GraphQL::Schema::Printer.print_schema(MySchema)
# @example print your schema to standard output
#   puts GraphQL::Schema::Printer.new(MySchema).print_schema
# @example print a single type to standard output
#   class Types::Query < GraphQL::Schema::Object
#   description "The query root of this schema"
#
#   field :post, Types::Post, null: true
#   end
#
#   class Types::Post < GraphQL::Schema::Object
#   description "A blog post"
#
#   field :id, ID, null: false
#   field :title, String, null: false
#   field :body, String, null: false
#   end
#
#   class MySchema < GraphQL::Schema
#   query(Types::Query)
#   end
#
#   printer = GraphQL::Schema::Printer.new(MySchema)
#   puts printer.print_type(Types::Post)
class GraphQL::Schema::Printer < ::GraphQL::Language::Printer
  # @param schema [GraphQL::Schema]
  # @param context [Hash]
  # @param only [<#call(member, ctx)>]
  # @param except [<#call(member, ctx)>]
  # @param introspection [Boolean] Should include the introspection types in the string?
  # @return [Printer] a new instance of Printer
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), introspection: T.unsafe(nil)); end

  # Return a GraphQL schema string for the defined types in the schema
  def print_schema; end

  def print_type(type); end

  # Returns the value of attribute schema.
  def schema; end

  # Returns the value of attribute warden.
  def warden; end

  class << self
    # Return the GraphQL schema string for the introspection type system
    def print_introspection_schema; end

    # Return a GraphQL schema string for the defined types in the schema
    #
    # @param schema [GraphQL::Schema]
    # @param context [Hash]
    # @param only [<#call(member, ctx)>]
    # @param except [<#call(member, ctx)>]
    def print_schema(schema, **args); end
  end
end

class GraphQL::Schema::Printer::IntrospectionPrinter < ::GraphQL::Language::Printer
  def print_schema_definition(schema); end
end

# Mutations that extend this base class get some conventions added for free:
#
# - An argument called `clientMutationId` is _always_ added, but it's not passed
#   to the resolve method. The value is re-inserted to the response. (It's for
#   client libraries to manage optimistic updates.)
# - The returned object type always has a field called `clientMutationId` to support that.
# - The mutation accepts one argument called `input`, `argument`s defined in the mutation
#   class are added to that input object, which is generated by the mutation.
#
# These conventions were first specified by Relay Classic, but they come in handy:
#
# - `clientMutationId` supports optimistic updates and cache rollbacks on the client
# - using a single `input:` argument makes it easy to post whole JSON objects to the mutation
#   using one GraphQL variable (`$input`) instead of making a separate variable for each argument.
#
# @see {GraphQL::Schema::Mutation} for an example, it's basically the same.
class GraphQL::Schema::RelayClassicMutation < ::GraphQL::Schema::Mutation
  # Override {GraphQL::Schema::Resolver#resolve_with_support} to
  # delete `client_mutation_id` from the kwargs.
  def resolve_with_support(**inputs); end

  private

  def authorize_arguments(args, values); end

  class << self
    def all_field_argument_definitions; end

    # Also apply this argument to the input type:
    def argument(*args, own_argument: T.unsafe(nil), **kwargs, &block); end

    def dummy; end
    def field_arguments(context = T.unsafe(nil)); end
    def get_field_argument(name, context = T.unsafe(nil)); end

    # The base class for generated input object types
    #
    # @param new_class [Class] The base class to use for generating input object definitions
    # @return [Class] The base class for this mutation's generated input object (default is {GraphQL::Schema::InputObject})
    def input_object_class(new_class = T.unsafe(nil)); end

    # @param new_input_type [Class, nil] If provided, it configures this mutation to accept `new_input_type` instead of generating an input type
    # @return [Class] The generated {Schema::InputObject} class for this mutation's `input`
    def input_type(new_input_type = T.unsafe(nil)); end

    def own_field_arguments; end

    private

    # Generate the input type for the `input:` argument
    # To customize how input objects are generated, override this method
    #
    # @return [Class] a subclass of {.input_object_class}
    def generate_input_type; end
  end
end

# A class-based container for field configuration and resolution logic. It supports:
#
# - Arguments, via `.argument(...)` helper, which will be applied to the field.
# - Return type, via `.type(..., null: ...)`, which will be applied to the field.
# - Description, via `.description(...)`, which will be applied to the field
# - Resolution, via `#resolve(**args)` method, which will be called to resolve the field.
# - `#object` and `#context` accessors for use during `#resolve`.
#
# Resolvers can be attached with the `resolver:` option in a `field(...)` call.
#
# A resolver's configuration may be overridden with other keywords in the `field(...)` call.
#
# @see {GraphQL::Schema::Mutation} for a concrete subclass of `Resolver`.
# @see {GraphQL::Function} `Resolver` is a replacement for `GraphQL::Function`
class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentClassAccessor
  extend ::GraphQL::Schema::Member::HasValidators
  extend ::GraphQL::Schema::Member::HasPath

  # @param object [Object] The application object that this field is being resolved on
  # @param context [GraphQL::Query::Context]
  # @param field [GraphQL::Schema::Field]
  # @return [Resolver] a new instance of Resolver
  def initialize(object:, context:, field:); end

  def arguments; end

  # Called after arguments are loaded, but before resolving.
  #
  # Override it to check everything before calling the mutation.
  #
  # @param inputs [Hash] The input arguments
  # @raise [GraphQL::ExecutionError] To add an error to the response
  # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
  # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
  def authorized?(**inputs); end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [GraphQL::Dataloader]
  def dataloader; end

  # @return [GraphQL::Schema::Field]
  def field; end

  # @return [Object] The application object this field is being resolved on
  def object; end

  # Called before arguments are prepared.
  # Implement this hook to make checks before doing any work.
  #
  # If it returns a lazy object (like a promise), it will be synced by GraphQL
  # (but the resulting value won't be used).
  #
  # @param args [Hash] The input arguments, if there are any
  # @raise [GraphQL::ExecutionError] To add an error to the response
  # @raise [GraphQL::UnauthorizedError] To signal an authorization failure
  # @return [Boolean, early_return_data] If `false`, execution will stop (and `early_return_data` will be returned instead, if present.)
  def ready?(**args); end

  # Do the work. Everything happens here.
  #
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Object] An object corresponding to the return type
  def resolve(**args); end

  # This method is _actually_ called by the runtime,
  # it does some preparation and then eventually calls
  # the user-defined `#resolve` method.
  #
  # @api private
  def resolve_with_support(**args); end

  # Called when an object loaded by `loads:` fails the `.authorized?` check for its resolved GraphQL object type.
  #
  # By default, the error is re-raised and passed along to {{Schema.unauthorized_object}}.
  #
  # Any value returned here will be used _instead of_ of the loaded object.
  #
  # @param err [GraphQL::UnauthorizedError]
  def unauthorized_object(err); end

  private

  def authorize_arguments(args, inputs); end
  def get_argument(name, context = T.unsafe(nil)); end
  def load_arguments(args); end

  class << self
    def all_field_argument_definitions; end

    # Add an argument to this field's signature, but
    # also add some preparation hook methods which will be used for this argument
    #
    # @see {GraphQL::Schema::Argument#initialize} for the signature
    def argument(*args, **kwargs, &block); end

    def broadcastable(new_broadcastable); end

    # @return [Boolean, nil]
    def broadcastable?; end

    # Specifies the complexity of the field. Defaults to `1`
    #
    # @return [Integer, Proc]
    def complexity(new_complexity = T.unsafe(nil)); end

    # Get or set the `default_page_size:` which will be configured for fields using this resolver
    # (`nil` means "unlimited default page size".)
    #
    # @param default_page_size [Integer, nil] Set a new value
    # @return [Integer, nil] The `default_page_size` assigned to fields that use this resolver
    def default_page_size(new_default_page_size = T.unsafe(nil)); end

    # Registers new extension
    #
    # @param extension [Class] Extension class
    # @param options [Hash] Optional extension options
    def extension(extension, **options); end

    # @api private
    def extensions; end

    # Additional info injected into {#resolve}
    #
    # @see {GraphQL::Schema::Field#extras}
    def extras(new_extras = T.unsafe(nil)); end

    def field_arguments(context = T.unsafe(nil)); end
    def get_field_argument(name, context = T.unsafe(nil)); end

    # @return [Boolean] `true` if this resolver or a superclass has an assigned `default_page_size`
    def has_default_page_size?; end

    # @return [Boolean] `true` if this resolver or a superclass has an assigned `max_page_size`
    def has_max_page_size?; end

    # Get or set the `max_page_size:` which will be configured for fields using this resolver
    # (`nil` means "unlimited max page size".)
    #
    # @param max_page_size [Integer, nil] Set a new value
    # @return [Integer, nil] The `max_page_size` assigned to fields that use this resolver
    def max_page_size(new_max_page_size = T.unsafe(nil)); end

    # If `true` (default), then the return type for this resolver will be nullable.
    # If `false`, then the return type is non-null.
    #
    # @param allow_null [Boolean] Whether or not the response can be null
    # @see #type which sets the return type of this field and accepts a `null:` option
    def null(allow_null = T.unsafe(nil)); end

    # Default `:resolve` set below.
    #
    # @return [Symbol] The method to call on instances of this object to resolve the field
    def resolve_method(new_method = T.unsafe(nil)); end

    def resolver_method(new_method_name = T.unsafe(nil)); end

    # Call this method to get the return type of the field,
    # or use it as a configuration method to assign a return type
    # instead of generating one.
    # TODO unify with {#null}
    #
    # @param new_type [Class, Array<Class>, nil] If a type definition class is provided, it will be used as the return type of the field
    # @param null [true, false] Whether or not the field may return `nil`
    # @return [Class] The type which this field returns.
    def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end

    # A non-normalized type configuration, without `null` applied
    def type_expr; end

    private

    def own_extensions; end
  end
end

# Adds `field(...)` helper to resolvers so that they can
# generate payload types.
#
# Or, an already-defined one can be attached with `payload_type(...)`.
module GraphQL::Schema::Resolver::HasPayloadType
  def field(*args, **kwargs, &block); end
  def field_class(new_class = T.unsafe(nil)); end

  # An object class to use for deriving return types
  #
  # @param new_class [Class, nil] Defaults to {GraphQL::Schema::Object}
  # @return [Class]
  def object_class(new_class = T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  #
  # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
  # @return [Class] The object type which this mutation returns.
  def payload_type(new_payload_type = T.unsafe(nil)); end

  def type(new_type = T.unsafe(nil), null: T.unsafe(nil)); end

  # Call this method to get the derived return type of the mutation,
  # or use it as a configuration method to assign a return type
  # instead of generating one.
  #
  # @param new_payload_type [Class, nil] If a type definition class is provided, it will be used as the return type of the mutation field
  # @return [Class] The object type which this mutation returns.
  def type_expr(new_payload_type = T.unsafe(nil)); end

  private

  # Build a subclass of {.object_class} based on `self`.
  # This value will be cached as `{.payload_type}`.
  # Override this hook to customize return type generation.
  def generate_payload_type; end
end

GraphQL::Schema::Resolver::HasPayloadType::NO_INTERFACES = T.let(T.unsafe(nil), Array)

class GraphQL::Schema::Scalar < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::ValidatesInput

  class << self
    def coerce_input(val, ctx); end
    def coerce_result(val, ctx); end
    def default_scalar(is_default = T.unsafe(nil)); end

    # @return [Boolean]
    def default_scalar?; end

    def kind; end
    def specified_by_url(new_url = T.unsafe(nil)); end
    def validate_non_null_input(value, ctx); end
  end
end

# This class can be extended to create fields on your subscription root.
#
# It provides hooks for the different parts of the subscription lifecycle:
#
# - `#authorized?`: called before initial subscription and subsequent updates
# - `#subscribe`: called for the initial subscription
# - `#update`: called for subsequent update
#
# Also, `#unsubscribe` terminates the subscription.
class GraphQL::Schema::Subscription < ::GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields

  # @return [Subscription] a new instance of Subscription
  def initialize(object:, context:, field:); end

  # If an argument is flagged with `loads:` and no object is found for it,
  # remove this subscription (assuming that the object was deleted in the meantime,
  # or that it became inaccessible).
  def load_application_object_failed(err); end

  # Implement the {Resolve} API
  def resolve(**args); end

  # Wrap the user-defined `#subscribe` hook
  def resolve_subscribe(**args); end

  # Wrap the user-provided `#update` hook
  def resolve_update(**args); end

  def resolve_with_support(**args); end

  # The default implementation returns nothing on subscribe.
  # Override it to return an object or
  # `:no_response` to (explicitly) return nothing.
  def subscribe(args = T.unsafe(nil)); end

  # Call this to halt execution and remove this subscription from the system
  def unsubscribe; end

  # The default implementation returns the root object.
  # Override it to return {NO_UPDATE} if you want to
  # skip updates sometimes. Or override it to return a different object.
  def update(args = T.unsafe(nil)); end

  class << self
    # Call this method to provide a new subscription_scope; OR
    # call it without an argument to get the subscription_scope
    #
    # @param new_scope [Symbol]
    # @param optional [Boolean] If true, then don't require `scope:` to be provided to updates to this subscription.
    # @return [Symbol]
    def subscription_scope(new_scope = T.unsafe(nil), optional: T.unsafe(nil)); end

    # @return [Boolean]
    def subscription_scope_optional?; end

    # This is called during initial subscription to get a "name" for this subscription.
    # Later, when `.trigger` is called, this will be called again to build another "name".
    # Any subscribers with matching topic will begin the update flow.
    #
    # The default implementation creates a string using the field name, subscription scope, and argument keys and values.
    # In that implementation, only `.trigger` calls with _exact matches_ result in updates to subscribers.
    #
    # To implement a filtered stream-type subscription flow, override this method to return a string with field name and subscription scope.
    # Then, implement {#update} to compare its arguments to the current `object` and return {NO_UPDATE} when an
    # update should be filtered out.
    #
    # @param arguments [Hash<String => Object>] The arguments for this topic, in GraphQL-style (camelized strings)
    # @param field [GraphQL::Schema::Field]
    # @param scope [Object, nil] A value corresponding to `.trigger(... scope:)` (for updates) or the `subscription_scope` found in `context` (for initial subscriptions).
    # @return [String] An identifier corresponding to a stream of updates
    # @see {#update} for how to skip updates when an event comes with a matching topic.
    def topic_for(arguments:, field:, scope:); end
  end
end

GraphQL::Schema::Subscription::NO_UPDATE = T.let(T.unsafe(nil), Symbol)
GraphQL::Schema::Subscription::READING_SCOPE = T.let(T.unsafe(nil), Object)

# This plugin will stop resolving new fields after `max_seconds` have elapsed.
# After the time has passed, any remaining fields will be `nil`, with errors added
# to the `errors` key. Any already-resolved fields will be in the `data` key, so
# you'll get a partial response.
#
# You can subclass `GraphQL::Schema::Timeout` and override `max_seconds` and/or `handle_timeout`
# to provide custom logic when a timeout error occurs.
#
# Note that this will stop a query _in between_ field resolutions, but
# it doesn't interrupt long-running `resolve` functions. Be sure to use
# timeout options for external connections. For more info, see
# www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/
#
# @example Stop resolving fields after 2 seconds
#   class MySchema < GraphQL::Schema
#   use GraphQL::Schema::Timeout, max_seconds: 2
#   end
# @example Notifying Bugsnag and logging a timeout
#   class MyTimeout < GraphQL::Schema::Timeout
#   def handle_timeout(error, query)
#   Rails.logger.warn("GraphQL Timeout: #{error.message}: #{query.query_string}")
#   Bugsnag.notify(error, {query_string: query.query_string})
#   end
#   end
#
#   class MySchema < GraphQL::Schema
#   use MyTimeout, max_seconds: 2
#   end
class GraphQL::Schema::Timeout
  # @param max_seconds [Numeric] how many seconds the query should be allowed to resolve new fields
  # @return [Timeout] a new instance of Timeout
  def initialize(max_seconds:); end

  # Invoked when a query times out.
  #
  # @param error [GraphQL::Schema::Timeout::TimeoutError]
  # @param query [GraphQL::Error]
  def handle_timeout(error, query); end

  # Called at the start of each query.
  # The default implementation returns the `max_seconds:` value from installing this plugin.
  #
  # @param query [GraphQL::Query] The query that's about to run
  # @return [Integer, false] The number of seconds after which to interrupt query execution and call {#handle_error}, or `false` to bypass the timeout.
  def max_seconds(query); end

  def trace(key, data); end

  class << self
    def use(schema, **options); end
  end
end

# This error is raised when a query exceeds `max_seconds`.
# Since it's a child of {GraphQL::ExecutionError},
# its message will be added to the response's `errors` key.
#
# To raise an error that will stop query resolution, use a custom block
# to take this error and raise a new one which _doesn't_ descend from {GraphQL::ExecutionError},
# such as `RuntimeError`.
class GraphQL::Schema::Timeout::TimeoutError < ::GraphQL::ExecutionError
  # @return [TimeoutError] a new instance of TimeoutError
  def initialize(parent_type, field); end
end

# @api private
module GraphQL::Schema::TypeExpression
  class << self
    # Fetch a type from a type map by its AST specification.
    # Return `nil` if not found.
    #
    # @api private
    # @param type_owner [#get_type] A thing for looking up types by name
    # @param ast_node [GraphQL::Language::Nodes::AbstractNode]
    # @return [Class, GraphQL::Schema::NonNull, GraphQL::Schema:List]
    def build_type(type_owner, ast_node); end

    private

    # @api private
    def wrap_type(type, wrapper_method); end
  end
end

# This class joins an object type to an abstract type (interface or union) of which
# it is a member.
class GraphQL::Schema::TypeMembership
  # Called when an object is hooked up to an abstract type, such as {Schema::Union.possible_types}
  # or {Schema::Object.implements} (for interfaces).
  #
  # @param abstract_type [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
  # @param object_type [Class<GraphQL::Schema::Object>]
  # @param options [Hash] Any options passed to `.possible_types` or `.implements`
  # @return [TypeMembership] a new instance of TypeMembership
  def initialize(abstract_type, object_type, **options); end

  # @return [Class<GraphQL::Schema::Union>, Module<GraphQL::Schema::Interface>]
  def abstract_type; end

  def graphql_name; end
  def inspect; end

  # @return [Class<GraphQL::Schema::Object>]
  def object_type; end

  # @return [Class<GraphQL::Schema::Object>]
  def object_type=(_arg0); end

  def path; end
  def type_class; end

  # @return [Boolean] if false, {#object_type} will be treated as _not_ a member of {#abstract_type}
  def visible?(ctx); end
end

class GraphQL::Schema::Union < ::GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError

  class << self
    def all_possible_types; end

    # Update a type membership whose `.object_type` is a string or late-bound type
    # so that the type membership's `.object_type` is the given `object_type`.
    # (This is used for updating the union after the schema as lazily loaded the union member.)
    #
    # @api private
    def assign_type_membership_object_type(object_type); end

    # @private
    def inherited(child_class); end

    def kind; end
    def possible_types(*types, context: T.unsafe(nil), **options); end
    def type_membership_class(membership_class = T.unsafe(nil)); end
    def type_memberships; end

    private

    def assert_valid_union_member(type_defn); end
  end
end

module GraphQL::Schema::UniqueWithinType
  private

  # @param node_id [String] A unique ID generated by {.encode}
  # @return [Array<(String, String)>] The type name & value passed to {.encode}
  def decode(node_id, separator: T.unsafe(nil)); end

  # @param type_name [String]
  # @param object_value [Any]
  # @return [String] a unique, opaque ID generated as a function of the two inputs
  def encode(type_name, object_value, separator: T.unsafe(nil)); end

  class << self
    # @param node_id [String] A unique ID generated by {.encode}
    # @return [Array<(String, String)>] The type name & value passed to {.encode}
    def decode(node_id, separator: T.unsafe(nil)); end

    # Returns the value of attribute default_id_separator.
    def default_id_separator; end

    # Sets the attribute default_id_separator
    #
    # @param value the value to set the attribute default_id_separator to.
    def default_id_separator=(_arg0); end

    # @param type_name [String]
    # @param object_value [Any]
    # @return [String] a unique, opaque ID generated as a function of the two inputs
    def encode(type_name, object_value, separator: T.unsafe(nil)); end
  end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError < ::GraphQL::Error
  # @return [UnresolvedLateBoundTypeError] a new instance of UnresolvedLateBoundTypeError
  def initialize(type:); end

  # Returns the value of attribute type.
  def type; end
end

class GraphQL::Schema::Validator
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects

  # @param validated [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>] The argument or argument owner this validator is attached to
  # @param allow_blank [Boolean] if `true`, then objects that respond to `.blank?` and return true for `.blank?` will skip this validation
  # @param allow_null [Boolean] if `true`, then incoming `null`s will skip this validation
  # @return [Validator] a new instance of Validator
  def initialize(validated:, allow_blank: T.unsafe(nil), allow_null: T.unsafe(nil)); end

  # This is like `String#%`, but it supports the case that only some of `string`'s
  # values are present in `substitutions`
  def partial_format(string, substitutions); end

  # @return [Boolean] `true` if `value` is `nil` and this validator has `allow_null: true` or if value is `.blank?` and this validator has `allow_blank: true`
  def permitted_empty_value?(value); end

  # @param object [Object] The application object that this argument's field is being resolved for
  # @param context [GraphQL::Query::Context]
  # @param value [Object] The client-provided value for this argument (after parsing and coercing by the input type)
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [nil, Array<String>, String] Error message or messages to add
  def validate(object, context, value); end

  # The thing being validated
  #
  # @return [GraphQL::Schema::Argument, GraphQL::Schema::Field, GraphQL::Schema::Resolver, Class<GraphQL::Schema::InputObject>]
  def validated; end

  class << self
    # Returns the value of attribute all_validators.
    def all_validators; end

    # Sets the attribute all_validators
    #
    # @param value the value to set the attribute all_validators to.
    def all_validators=(_arg0); end

    # @param schema_member [GraphQL::Schema::Field, GraphQL::Schema::Argument, Class<GraphQL::Schema::InputObject>]
    # @param validates_hash [Hash{Symbol => Hash}, Hash{Class => Hash} nil] A configuration passed as `validates:`
    # @return [Array<Validator>]
    def from_config(schema_member, validates_hash); end

    # Add `validator_class` to be initialized when `validates:` is given `name`.
    # (It's initialized with whatever options are given by the key `name`).
    #
    # @param name [Symbol]
    # @param validator_class [Class]
    # @return [void]
    def install(name, validator_class); end

    # Remove whatever validator class is {.install}ed at `name`, if there is one
    #
    # @param name [Symbol]
    # @return [void]
    def uninstall(name); end

    # @param validators [Array<Validator>]
    # @param object [Object]
    # @param context [Query::Context]
    # @param value [Object]
    # @return [void]
    def validate!(validators, object, context, value, as: T.unsafe(nil)); end
  end
end

# Use this to specifically reject values that respond to `.blank?` and respond truthy for that method.
#
# @example Require a non-empty string for an argument
#   argument :name, String, required: true, validate: { allow_blank: false }
class GraphQL::Schema::Validator::AllowBlankValidator < ::GraphQL::Schema::Validator
  # @return [AllowBlankValidator] a new instance of AllowBlankValidator
  def initialize(allow_blank_positional, allow_blank: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to specifically reject or permit `nil` values (given as `null` from GraphQL).
#
# @example require a non-null value for an argument if it is provided
#   argument :name, String, required: false, validates: { allow_null: false }
class GraphQL::Schema::Validator::AllowNullValidator < ::GraphQL::Schema::Validator
  # @return [AllowNullValidator] a new instance of AllowNullValidator
  def initialize(allow_null_positional, allow_null: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

GraphQL::Schema::Validator::AllowNullValidator::MESSAGE = T.let(T.unsafe(nil), String)

# Use this to specifically reject values from an argument.
#
# @example disallow certain values
#
#   argument :favorite_non_prime, Integer, required: true,
#   validates: { exclusion: { in: [2, 3, 5, 7, ... ]} }
class GraphQL::Schema::Validator::ExclusionValidator < ::GraphQL::Schema::Validator
  # @param message [String]
  # @param in [Array] The values to reject
  # @return [ExclusionValidator] a new instance of ExclusionValidator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert that string values match (or don't match) the given RegExp.
#
# @example requiring input to match a pattern
#
#   argument :handle, String, required: true,
#   validates: { format: { with: /\A[a-z0-9_]+\Z/ } }
# @example reject inputs that match a pattern
#
#   argument :word_that_doesnt_begin_with_a_vowel, String, required: true,
#   validates: { format: { without: /\A[aeiou]/ } }
#
#   # It's pretty hard to come up with a legitimate use case for `without:`
class GraphQL::Schema::Validator::FormatValidator < ::GraphQL::Schema::Validator
  # @param with [RegExp, nil]
  # @param without [Regexp, nil]
  # @param message [String]
  # @return [FormatValidator] a new instance of FormatValidator
  def initialize(with: T.unsafe(nil), without: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# You can use this to allow certain values for an argument.
#
# Usually, a {GraphQL::Schema::Enum} is better for this, because it's self-documenting.
#
# @example only allow certain values for an argument
#
#   argument :favorite_prime, Integer, required: true,
#   validates: { inclusion: { in: [2, 3, 5, 7, 11, ... ] } }
class GraphQL::Schema::Validator::InclusionValidator < ::GraphQL::Schema::Validator
  # @param message [String]
  # @param in [Array] The values to allow
  # @return [InclusionValidator] a new instance of InclusionValidator
  def initialize(in:, message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to enforce a `.length` restriction on incoming values. It works for both Strings and Lists.
#
# @example Allow no more than 10 IDs
#
#   argument :ids, [ID], required: true, validates: { length: { maximum: 10 } }
# @example Require three selections
#
#   argument :ice_cream_preferences, [ICE_CREAM_FLAVOR], required: true, validates: { length: { is: 3 } }
class GraphQL::Schema::Validator::LengthValidator < ::GraphQL::Schema::Validator
  # @param maximum [Integer]
  # @param too_long [String] Used when `maximum` is exceeded or value is greater than `within`
  # @param minimum [Integer]
  # @param too_short [String] Used with value is less than `minimum` or less than `within`
  # @param is [Integer] Exact length requirement
  # @param wrong_length [String] Used when value doesn't match `is`
  # @param within [Range] An allowed range (becomes `minimum:` and `maximum:` under the hood)
  # @param message [String]
  # @return [LengthValidator] a new instance of LengthValidator
  def initialize(maximum: T.unsafe(nil), too_long: T.unsafe(nil), minimum: T.unsafe(nil), too_short: T.unsafe(nil), is: T.unsafe(nil), within: T.unsafe(nil), wrong_length: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

# Use this to assert numerical comparisons hold true for inputs.
#
# @example Require a number between 0 and 1
#
#   argument :batting_average, Float, required: true, validates: { numericality: { within: 0..1 } }
# @example Require the number 42
#
#   argument :the_answer, Integer, required: true, validates: { numericality: { equal_to: 42 } }
# @example Require a real number
#
#   argument :items_count, Integer, required: true, validates: { numericality: { greater_than_or_equal_to: 0 } }
class GraphQL::Schema::Validator::NumericalityValidator < ::GraphQL::Schema::Validator
  # @param greater_than [Integer]
  # @param greater_than_or_equal_to [Integer]
  # @param less_than [Integer]
  # @param less_than_or_equal_to [Integer]
  # @param equal_to [Integer]
  # @param other_than [Integer]
  # @param odd [Boolean]
  # @param even [Boolean]
  # @param within [Range]
  # @param message [String] used for all validation failures
  # @return [NumericalityValidator] a new instance of NumericalityValidator
  def initialize(greater_than: T.unsafe(nil), greater_than_or_equal_to: T.unsafe(nil), less_than: T.unsafe(nil), less_than_or_equal_to: T.unsafe(nil), equal_to: T.unsafe(nil), other_than: T.unsafe(nil), odd: T.unsafe(nil), even: T.unsafe(nil), within: T.unsafe(nil), message: T.unsafe(nil), null_message: T.unsafe(nil), **default_options); end

  def validate(object, context, value); end
end

# Use this validator to require _one_ of the named arguments to be present.
# Or, use Arrays of symbols to name a valid _set_ of arguments.
#
# (This is for specifying mutually exclusive sets of arguments.)
#
# @example Require exactly one of these arguments
#
#   field :update_amount, IngredientAmount, null: false do
#   argument :ingredient_id, ID, required: true
#   argument :cups, Integer, required: false
#   argument :tablespoons, Integer, required: false
#   argument :teaspoons, Integer, required: false
#   validates required: { one_of: [:cups, :tablespoons, :teaspoons] }
#   end
# @example Require one of these _sets_ of arguments
#
#   field :find_object, Node, null: true do
#   argument :node_id, ID, required: false
#   argument :object_type, String, required: false
#   argument :object_id, Integer, required: false
#   # either a global `node_id` or an `object_type`/`object_id` pair is required:
#   validates required: { one_of: [:node_id, [:object_type, :object_id]] }
#   end
# @example require _some_ value for an argument, even if it's null
#   field :update_settings, AccountSettings do
#   # `required: :nullable` means this argument must be given, but may be `null`
#   argument :age, Integer, required: :nullable
#   end
class GraphQL::Schema::Validator::RequiredValidator < ::GraphQL::Schema::Validator
  # @param one_of [Symbol, Array<Symbol>] An argument, or a list of arguments, that represents a valid set of inputs for this field
  # @param message [String]
  # @return [RequiredValidator] a new instance of RequiredValidator
  def initialize(one_of: T.unsafe(nil), argument: T.unsafe(nil), message: T.unsafe(nil), **default_options); end

  def validate(_object, _context, value); end
end

class GraphQL::Schema::Validator::ValidationFailedError < ::GraphQL::ExecutionError
  # @return [ValidationFailedError] a new instance of ValidationFailedError
  def initialize(errors:); end

  # Returns the value of attribute errors.
  def errors; end
end

# Restrict access to a {GraphQL::Schema} with a user-defined filter.
#
# When validating and executing a query, all access to schema members
# should go through a warden. If you access the schema directly,
# you may show a client something that it shouldn't be allowed to see.
#
# @api private
# @example Hiding private fields
#   private_members = -> (member, ctx) { member.metadata[:private] }
#   result = Schema.execute(query_string, except: private_members)
# @example Custom filter implementation
#   # It must respond to `#call(member)`.
#   class MissingRequiredFlags
#   def initialize(user)
#   @user = user
#   end
#
#   # Return `false` if any required flags are missing
#   def call(member, ctx)
#   member.metadata[:required_flags].any? do |flag|
#   !@user.has_flag?(flag)
#   end
#   end
#   end
#
#   # Then, use the custom filter in query:
#   missing_required_flags = MissingRequiredFlags.new(current_user)
#
#   # This query can only access members which match the user's flags
#   result = Schema.execute(query_string, except: missing_required_flags)
class GraphQL::Schema::Warden
  # @api private
  # @param filter [<#call(member)>] Objects are hidden when `.call(member, ctx)` returns true
  # @param context [GraphQL::Query::Context]
  # @param schema [GraphQL::Schema]
  # @return [Warden] a new instance of Warden
  def initialize(filter, context:, schema:); end

  # @api private
  # @param argument_owner [GraphQL::Field, GraphQL::InputObjectType]
  # @return [Array<GraphQL::Argument>] Visible arguments on `argument_owner`
  def arguments(argument_owner); end

  # @api private
  def directives; end

  # @api private
  # @return [Array<GraphQL::EnumType::EnumValue>] Visible members of `enum_defn`
  def enum_values(enum_defn); end

  # @api private
  # @param type_defn [GraphQL::ObjectType, GraphQL::InterfaceType]
  # @return [Array<GraphQL::Field>] Fields on `type_defn`
  def fields(type_defn); end

  # @api private
  # @return [GraphQL::Argument, nil] The argument named `argument_name` on `parent_type`, if it exists and is visible
  def get_argument(parent_type, argument_name); end

  # @api private
  # @return [GraphQL::Field, nil] The field named `field_name` on `parent_type`, if it exists
  def get_field(parent_type, field_name); end

  # @api private
  # @return [GraphQL::BaseType, nil] The type named `type_name`, if it exists (else `nil`)
  def get_type(type_name); end

  # @api private
  # @return [Array<GraphQL::InterfaceType>] Visible interfaces implemented by `obj_type`
  def interfaces(obj_type); end

  # @api private
  # @return [Array<GraphQL::BaseType>] The types which may be member of `type_defn`
  def possible_types(type_defn); end

  # @api private
  # @return [Boolean] Boolean True if the type is visible and reachable in the schema
  def reachable_type?(type_name); end

  # @api private
  # @return [Array<GraphQL::BaseType>] Visible and reachable types in the schema
  def reachable_types; end

  # @api private
  def root_type_for_operation(op_name); end

  # @api private
  # @return [Hash<String, GraphQL::BaseType>] Visible types in the schema
  def types; end

  # @api private
  # @return [Boolean]
  def visible_argument?(arg_defn, _ctx = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_enum_value?(enum_value, _ctx = T.unsafe(nil)); end

  # @api private
  # @param owner [Class, Module] If provided, confirm that field has the given owner.
  # @return [Boolean]
  def visible_field?(field_defn, _ctx = T.unsafe(nil), owner = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_type?(type_defn, _ctx = T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  def visible_type_membership?(type_membership, _ctx = T.unsafe(nil)); end

  private

  # If this field was inherited from an interface, and the field on that interface is _hidden_,
  # then treat this inherited field as hidden.
  # (If it _wasn't_ inherited, then don't hide it for this reason.)
  #
  # @api private
  # @return [Boolean]
  def field_on_visible_interface?(field_defn, type_defn); end

  # @api private
  # @return [Boolean]
  def orphan_type?(type_defn); end

  # @api private
  def reachable_type_set; end

  # @api private
  def read_through; end

  # @api private
  # @return [Boolean]
  def referenced?(type_defn); end

  # @api private
  # @return [Boolean]
  def root_type?(type_defn); end

  # We need this to tell whether a field was inherited by an interface
  # even when that interface is hidden from `#interfaces`
  #
  # @api private
  def unfiltered_interfaces(type_defn); end

  # @api private
  def union_memberships(obj_type); end

  # @api private
  # @return [Boolean]
  def visible?(member); end

  # @api private
  # @return [Boolean]
  def visible_abstract_type?(type_defn); end

  # @api private
  # @return [Boolean]
  def visible_and_reachable_type?(type_defn); end

  # @api private
  # @return [Boolean]
  def visible_possible_types?(type_defn); end

  class << self
    # @api private
    def from_context(context); end

    # @api private
    # @param visibility_method [Symbol] a Warden method to call for this entry
    # @param entry [Object, Array<Object>] One or more definitions for a given name in a GraphQL Schema
    # @param context [GraphQL::Query::Context]
    # @param warden [Warden]
    # @return [Object] `entry` or one of `entry`'s items if exactly one of them is visible for this context
    # @return [nil] If neither `entry` nor any of `entry`'s items are visible for this context
    def visible_entry?(visibility_method, entry, context, warden = T.unsafe(nil)); end
  end
end

# @api private
GraphQL::Schema::Warden::NO_REFERENCES = T.let(T.unsafe(nil), Array)

# This is used when a caller provides a Hash for context.
# We want to call the schema's hooks, but we don't have a full-blown warden.
# The `context` arguments to these methods exist purely to simplify the code that
# calls methods on this object, so it will have everything it needs.
#
# @api private
class GraphQL::Schema::Warden::PassThruWarden
  class << self
    # @api private
    # @return [Boolean]
    def visible_argument?(arg, ctx); end

    # @api private
    # @return [Boolean]
    def visible_enum_value?(ev, ctx); end

    # @api private
    # @return [Boolean]
    def visible_field?(field, ctx); end

    # @api private
    # @return [Boolean]
    def visible_type?(type, ctx); end

    # @api private
    # @return [Boolean]
    def visible_type_membership?(tm, ctx); end
  end
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::TypeSystemHelpers

  # @return [Wrapper] a new instance of Wrapper
  def initialize(of_type); end

  def ==(other); end

  # @return [Class, Module] The inner type of this wrapping type, the type of which one or more objects may be present.
  def of_type; end

  def unwrap; end
end

module GraphQL::StaticValidation; end

# Default rules for {GraphQL::StaticValidation::Validator}
#
# Order is important here. Some validators return {GraphQL::Language::Visitor::SKIP}
# which stops the visit on that node. That way it doesn't try to find fields on types that
# don't exist, etc.
GraphQL::StaticValidation::ALL_RULES = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentLiteralsAreCompatibleError] a new instance of ArgumentLiteralsAreCompatibleError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument_name: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil), argument: T.unsafe(nil), value: T.unsafe(nil)); end

  # Returns the value of attribute argument.
  def argument; end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute value.
  def value; end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_directive(node, parent); end
  def on_field(node, parent); end
  def validate_arguments(node); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentNamesAreUniqueError] a new instance of ArgumentNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end

  private

  def node_type(parent); end
  def parent_definition(parent); end

  # TODO smell: these methods are added to all visitors, since they're included in a module.
  def parent_name(parent, type_defn); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError < ::GraphQL::StaticValidation::Error
  # @return [ArgumentsAreDefinedError] a new instance of ArgumentsAreDefinedError
  def initialize(message, name:, type:, argument_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute parent.
  def parent; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

class GraphQL::StaticValidation::BaseVisitor < ::GraphQL::Language::Visitor
  # @return [BaseVisitor] a new instance of BaseVisitor
  def initialize(document, context); end

  # Returns the value of attribute context.
  def context; end

  # @return [Array<GraphQL::ObjectType>] Types whose scope we've entered
  def object_types; end

  # @return [Array<String>] The nesting of the current position in the AST
  def path; end

  private

  def add_error(error, path: T.unsafe(nil)); end

  class << self
    # Build a class to visit the AST and perform validation,
    # or use a pre-built class if rules is `ALL_RULES` or empty.
    #
    # @param rules [Array<Module, Class>]
    # @return [Class] A class for validating `rules` during visitation
    def including_rules(rules); end
  end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  # @return [GraphQL::Argument, nil] The most-recently-entered GraphQL::Argument, if currently inside one
  def argument_definition; end

  # @return [GraphQL::Directive, nil] The most-recently-entered GraphQL::Directive, if currently inside one
  def directive_definition; end

  # @return [GraphQL::Field, nil] The most-recently-entered GraphQL::Field, if currently inside one
  def field_definition; end

  def on_argument(node, parent); end
  def on_directive(node, parent); end
  def on_field(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object(node, parent); end
  def on_operation_definition(node, parent); end

  # @return [GraphQL::BaseType] The type which the current type came from
  def parent_type_definition; end

  # @return [GraphQL::BaseType] The current object type
  def type_definition; end

  private

  # @yield [node]
  def on_fragment_with_type(node); end

  def push_type(t); end
end

# Track fragment dependencies for operations
# and expose the fragment definitions which
# are used by a given operation
module GraphQL::StaticValidation::DefinitionDependencies
  def initialize(*_arg0); end

  # Returns the value of attribute dependencies.
  def dependencies; end

  # A map of operation definitions to an array of that operation's dependencies
  #
  # @return [DependencyMap]
  def dependency_map(&block); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_operation_definition(node, prev_node); end

  private

  # Return a hash of { node => [node, node ... ]} pairs
  # Keys are top-level definitions
  # Values are arrays of flattened dependencies
  def resolve_dependencies; end
end

# Map definition AST nodes to the definition AST nodes they depend on.
# Expose circular dependencies.
class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  # @return [DependencyMap] a new instance of DependencyMap
  def initialize; end

  # @return [Array<GraphQL::Language::Nodes::AbstractNode>] dependencies for `definition_node`
  def [](definition_node); end

  # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
  def cyclical_definitions; end

  # @return [Hash<Node, Array<GraphQL::Language::Nodes::FragmentSpread>>]
  def unmet_dependencies; end

  # @return [Array<GraphQL::Language::Nodes::FragmentDefinition>]
  def unused_dependencies; end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable

  # @return [NodeWithPath] a new instance of NodeWithPath
  def initialize(node, path); end

  def eql?(*args, &block); end
  def hash(*args, &block); end
  def name(*args, &block); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute path.
  def path; end
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_arg0); end

  def on_directive(node, parent); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError < ::GraphQL::StaticValidation::Error
  # @return [DirectivesAreDefinedError] a new instance of DirectivesAreDefinedError
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language

  def on_directive(node, parent); end

  private

  def assert_includes_location(directive_defn, directive_ast, required_location); end
  def validate_location(ast_directive, ast_parent, directives); end
end

GraphQL::StaticValidation::DirectivesAreInValidLocations::LOCATION_MESSAGE_NAMES = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATIONS = T.let(T.unsafe(nil), Hash)
GraphQL::StaticValidation::DirectivesAreInValidLocations::SIMPLE_LOCATION_NODES = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError < ::GraphQL::StaticValidation::Error
  # @return [DirectivesAreInValidLocationsError] a new instance of DirectivesAreInValidLocationsError
  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute target_name.
  def target_name; end

  # A hash representation of this Message
  def to_h; end
end

# Generates GraphQL-compliant validation message.
class GraphQL::StaticValidation::Error
  # @return [Error] a new instance of Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute message.
  def message; end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # A hash representation of this Message
  def to_h; end

  private

  def locations; end

  # Returns the value of attribute nodes.
  def nodes; end
end

# Convenience for validators
module GraphQL::StaticValidation::Error::ErrorHelper
  # Error `error_message` is located at `node`
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError < ::GraphQL::StaticValidation::Error
  # @return [FieldsAreDefinedOnTypeError] a new instance of FieldsAreDefinedOnTypeError
  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute field_name.
  def field_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

# Scalars _can't_ have selections
# Objects _must_ have selections
module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def on_field(node, parent); end
  def on_operation_definition(node, _parent); end

  private

  def validate_field_selections(ast_node, resolved_type); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError < ::GraphQL::StaticValidation::Error
  # @return [FieldsHaveAppropriateSelectionsError] a new instance of FieldsHaveAppropriateSelectionsError
  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute node_name.
  def node_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_arg0); end

  def on_field(node, _parent); end
  def on_operation_definition(node, _parent); end

  private

  def arg_conflicts; end
  def compared_fragments_key(frag1, frag2, exclusive); end
  def conflicts_within_selection_set(node, parent_type); end
  def field_conflicts; end
  def fields_and_fragments_from_selection(node, owner_type:, parents:); end
  def find_conflict(response_key, field1, field2, mutually_exclusive: T.unsafe(nil)); end
  def find_conflicts_between(response_keys, response_keys2, mutually_exclusive:); end
  def find_conflicts_between_fields_and_fragment(fragment_spread, fields, mutually_exclusive:); end
  def find_conflicts_between_fragments(fragment_spread1, fragment_spread2, mutually_exclusive:); end
  def find_conflicts_between_sub_selection_sets(field1, field2, mutually_exclusive:); end
  def find_conflicts_within(response_keys); end
  def find_fields_and_fragments(selections, owner_type:, parents:, fields:, fragment_spreads:); end

  # Given two list of parents, find out if they are mutually exclusive
  # In this context, `parents` represends the "self scope" of the field,
  # what types may be found at this point in the query.
  #
  # @return [Boolean]
  def mutually_exclusive?(parents1, parents2); end

  # @return [Boolean]
  def same_arguments?(field1, field2); end

  def serialize_arg(arg_value); end
  def serialize_field_args(field); end
  def setting_errors; end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field < ::Struct
  # Returns the value of attribute definition
  #
  # @return [Object] the current value of definition
  def definition; end

  # Sets the attribute definition
  #
  # @param value [Object] the value to set the attribute definition to.
  # @return [Object] the newly set value
  def definition=(_); end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  # Returns the value of attribute owner_type
  #
  # @return [Object] the current value of owner_type
  def owner_type; end

  # Sets the attribute owner_type
  #
  # @param value [Object] the value to set the attribute owner_type to.
  # @return [Object] the newly set value
  def owner_type=(_); end

  # Returns the value of attribute parents
  #
  # @return [Object] the current value of parents
  def parents; end

  # Sets the attribute parents
  #
  # @param value [Object] the value to set the attribute parents to.
  # @return [Object] the newly set value
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute parents
  #
  # @return [Object] the current value of parents
  def parents; end

  # Sets the attribute parents
  #
  # @param value [Object] the value to set the attribute parents to.
  # @return [Object] the newly set value
  def parents=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Validates that a selection set is valid if all fields (including spreading any
# fragments) either correspond to distinct response names or can be merged
# without ambiguity.
#
# Original Algorithm: https://github.com/graphql/graphql-js/blob/master/src/validation/rules/OverlappingFieldsCanBeMerged.js
GraphQL::StaticValidation::FieldsWillMerge::NO_ARGS = T.let(T.unsafe(nil), Hash)

GraphQL::StaticValidation::FieldsWillMerge::NO_SELECTIONS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::FieldsWillMergeError < ::GraphQL::StaticValidation::Error
  # @return [FieldsWillMergeError] a new instance of FieldsWillMergeError
  def initialize(kind:, field_name:); end

  def add_conflict(node, conflict_str); end
  def code; end
  def conflicts; end

  # Returns the value of attribute field_name.
  def field_name; end

  # Returns the value of attribute kind.
  def kind; end

  def message; end
  def path; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_arg0); end

  def on_document(_n, _p); end
  def on_fragment_definition(node, parent); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [FragmentNamesAreUniqueError] a new instance of FragmentNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_fragment_in_scope(parent_type, child_type, node, context, path); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  # @return [FragmentSpread] a new instance of FragmentSpread
  def initialize(node:, parent_type:, path:); end

  # Returns the value of attribute node.
  def node; end

  # Returns the value of attribute parent_type.
  def parent_type; end

  # Returns the value of attribute path.
  def path; end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError < ::GraphQL::StaticValidation::Error
  # @return [FragmentSpreadsArePossibleError] a new instance of FragmentSpreadsArePossibleError
  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # Returns the value of attribute parent_name.
  def parent_name; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end
  def on_inline_fragment(node, _parent); end

  private

  def validate_type_exists(fragment_node); end
end

class GraphQL::StaticValidation::FragmentTypesExistError < ::GraphQL::StaticValidation::Error
  # @return [FragmentTypesExistError] a new instance of FragmentTypesExistError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreFiniteError] a new instance of FragmentsAreFiniteError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreNamedError] a new instance of FragmentsAreNamedError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end
  def on_inline_fragment(node, parent); end

  private

  def validate_type_is_composite(node); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreOnCompositeTypesError] a new instance of FragmentsAreOnCompositeTypesError
  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError < ::GraphQL::StaticValidation::Error
  # @return [FragmentsAreUsedError] a new instance of FragmentsAreUsedError
  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute fragment_name.
  def fragment_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::InputObjectNamesAreUnique
  def on_input_object(node, parent); end

  private

  def validate_input_fields(node); end
end

class GraphQL::StaticValidation::InputObjectNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [InputObjectNamesAreUniqueError] a new instance of InputObjectNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

class GraphQL::StaticValidation::InterpreterVisitor < ::GraphQL::StaticValidation::BaseVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::InputObjectNamesAreUnique
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::QueryRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

# Test whether `ast_value` is a valid input for `type`
class GraphQL::StaticValidation::LiteralValidator
  # @return [LiteralValidator] a new instance of LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end

  private

  # The GraphQL grammar supports variables embedded within scalars but graphql.js
  # doesn't support it so we won't either for simplicity
  #
  # @return [Boolean]
  def constant_scalar?(ast_value); end

  def ensure_array(value); end

  # When `error_bubbling` is false, we want to bail on the first failure that we find.
  # Use `throw` to escape the current call stack, returning the invalid response.
  def maybe_raise_if_invalid(ast_value); end

  def merge_results(results_list); end
  def present_input_field_values_are_valid(type, ast_node); end
  def recursively_validate(ast_value, type); end
  def required_input_fields_are_present(type, ast_node); end
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::MutationRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [MutationRootExistsError] a new instance of MutationRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper

  def initialize(*_arg0); end

  def on_directive_definition(node, parent); end
  def on_document(node, parent); end
  def on_enum_type_definition(node, parent); end
  def on_enum_type_extension(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_object_type_extension(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_interface_type_extension(node, parent); end
  def on_invalid_node(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_object_type_extension(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_scalar_type_extension(node, parent); end
  def on_schema_definition(node, parent); end
  def on_schema_extension(node, parent); end
  def on_union_type_definition(node, parent); end
  def on_union_type_extension(node, parent); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError < ::GraphQL::StaticValidation::Error
  # @return [NoDefinitionsArePresentError] a new instance of NoDefinitionsArePresentError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError < ::GraphQL::StaticValidation::Error
  # @return [OperationNamesAreValidError] a new instance of OperationNamesAreValidError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute operation_name.
  def operation_name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::QueryRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::QueryRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [QueryRootExistsError] a new instance of QueryRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end
  def on_field(node, _parent); end

  private

  def assert_required_args(ast_node, defn); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError < ::GraphQL::StaticValidation::Error
  # @return [RequiredArgumentsArePresentError] a new instance of RequiredArgumentsArePresentError
  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute arguments.
  def arguments; end

  # Returns the value of attribute class_name.
  def class_name; end

  def code; end

  # Returns the value of attribute name.
  def name; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end

  private

  def get_parent_type(context, parent); end
  def validate_input_object(ast_node, context, parent); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError < ::GraphQL::StaticValidation::Error
  # @return [RequiredInputObjectAttributesArePresentError] a new instance of RequiredInputObjectAttributesArePresentError
  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  # Returns the value of attribute argument_type.
  def argument_type; end

  def code; end

  # Returns the value of attribute input_object_type.
  def input_object_type; end

  # A hash representation of this Message
  def to_h; end
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError < ::GraphQL::StaticValidation::Error
  # @return [SubscriptionRootExistsError] a new instance of SubscriptionRootExistsError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# - Ride along with `GraphQL::Language::Visitor`
# - Track type info, expose it to validators
class GraphQL::StaticValidation::TypeStack
  # @param schema [GraphQL::Schema] the schema whose types to use when climbing this document
  # @param visitor [GraphQL::Language::Visitor] a visitor to follow & watch the types
  # @return [TypeStack] a new instance of TypeStack
  def initialize(schema, visitor); end

  # @return [Array<GraphQL::Node::Argument>] arguments which have been entered
  def argument_definitions; end

  # Directives are pushed on, then popped off while traversing the tree
  #
  # @return [Array<GraphQL::Node::Directive>] directives which have been entered
  def directive_definitions; end

  # When it enters a field, it's pushed on this stack (useful for nested fields, args).
  # When it exits, it's popped off.
  #
  # @return [Array<GraphQL::Field>] fields which have been entered
  def field_definitions; end

  # When it enters an object (starting with query or mutation root), it's pushed on this stack.
  # When it exits, it's popped off.
  #
  # @return [Array<GraphQL::ObjectType, GraphQL::Union, GraphQL::Interface>]
  def object_types; end

  # @return [Array<String>] fields which have been entered (by their AST name)
  def path; end

  # @return [GraphQL::Schema] the schema whose types are present in this document
  def schema; end
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  private

  def pop(stack, node); end

  # Push `argument_defn` onto the stack.
  # It's possible that `argument_defn` will be nil.
  # Push it anyways so `pop` has something to pop.
  def push(stack, node); end

  class << self
    def pop(stack, node); end

    # Push `argument_defn` onto the stack.
    # It's possible that `argument_defn` will be nil.
    # Push it anyways so `pop` has something to pop.
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  # @return [EnterWithStrategy] a new instance of EnterWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end
  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy

  private

  def push_path_member(stack, node); end

  class << self
    def push_path_member(stack, node); end
  end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  # @return [LeaveWithStrategy] a new instance of LeaveWithStrategy
  def initialize(stack, strategy); end

  def call(node, parent); end
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  private

  def pop(stack, node); end
  def push(stack, node); end

  class << self
    def pop(stack, node); end
    def push(stack, node); end
  end
end

GraphQL::StaticValidation::TypeStack::PUSH_STRATEGIES = T.let(T.unsafe(nil), Hash)

# These are jumping-off points for infering types down the tree
GraphQL::StaticValidation::TypeStack::TYPE_INFERRENCE_ROOTS = T.let(T.unsafe(nil), Array)

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end
  def on_enum_value_definition(node, parent); end
  def on_field(node, parent); end
  def on_field_definition(node, parent); end
  def on_fragment_definition(node, parent); end
  def on_fragment_spread(node, parent); end
  def on_inline_fragment(node, parent); end
  def on_input_object_type_definition(node, parent); end
  def on_input_value_definition(node, parent); end
  def on_interface_type_definition(node, parent); end
  def on_object_type_definition(node, parent); end
  def on_operation_definition(node, parent); end
  def on_scalar_type_definition(node, parent); end
  def on_union_type_definition(node, parent); end

  private

  def validate_directive_location(node); end
end

GraphQL::StaticValidation::UniqueDirectivesPerLocation::DIRECTIVE_NODE_HOOKS = T.let(T.unsafe(nil), Array)

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError < ::GraphQL::StaticValidation::Error
  # @return [UniqueDirectivesPerLocationError] a new instance of UniqueDirectivesPerLocationError
  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # Returns the value of attribute directive_name.
  def directive_name; end

  # A hash representation of this Message
  def to_h; end
end

# The validation context gets passed to each validator.
#
# It exposes a {GraphQL::Language::Visitor} where validators may add hooks. ({Language::Visitor#visit} is called in {Validator#validate})
#
# It provides access to the schema & fragments which validators may read from.
#
# It holds a list of errors which each validator may add to.
#
# It also provides limited access to the {TypeStack} instance,
# which tracks state as you climb in and out of different fields.
class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable

  # @return [ValidationContext] a new instance of ValidationContext
  def initialize(query, visitor_class, max_errors); end

  def argument_definition(*args, &block); end
  def dependencies(*args, &block); end
  def directive_definition(*args, &block); end
  def document(*args, &block); end

  # Returns the value of attribute errors.
  def errors; end

  def field_definition(*args, &block); end
  def fragments(*args, &block); end

  # Returns the value of attribute max_errors.
  def max_errors; end

  def object_types(*args, &block); end
  def on_dependency_resolve(&handler); end

  # Returns the value of attribute on_dependency_resolve_handlers.
  def on_dependency_resolve_handlers; end

  def operations(*args, &block); end
  def parent_type_definition(*args, &block); end
  def path(*args, &block); end

  # Returns the value of attribute query.
  def query; end

  def schema(*args, &block); end
  def schema_directives; end

  # @return [Boolean]
  def too_many_errors?; end

  def type_definition(*args, &block); end
  def validate_literal(ast_value, type); end

  # Returns the value of attribute visitor.
  def visitor; end

  def warden(*args, &block); end
end

class GraphQL::StaticValidation::ValidationTimeoutError < ::GraphQL::StaticValidation::Error
  # @return [ValidationTimeoutError] a new instance of ValidationTimeoutError
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end
end

# Initialized with a {GraphQL::Schema}, then it can validate {GraphQL::Language::Nodes::Documents}s based on that schema.
#
# By default, it's used by {GraphQL::Query}
#
# @example Validate a query
#   validator = GraphQL::StaticValidation::Validator.new(schema: MySchema)
#   query = GraphQL::Query.new(MySchema, query_string)
#   errors = validator.validate(query)[:errors]
class GraphQL::StaticValidation::Validator
  # @param schema [GraphQL::Schema]
  # @param rules [Array<#validate(context)>] a list of rules to use when validating
  # @return [Validator] a new instance of Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  # Invoked when static validation times out.
  #
  # @param query [GraphQL::Query]
  # @param context [GraphQL::StaticValidation::ValidationContext]
  def handle_timeout(query, context); end

  # Validate `query` against the schema. Returns an array of message hashes.
  #
  # @param query [GraphQL::Query]
  # @param validate [Boolean]
  # @param timeout [Float] Number of seconds to wait before aborting validation. Any positive number may be used, including Floats to specify fractional seconds.
  # @param max_errors [Integer] Maximum number of errors before aborting validation. Any positive number will limit the number of errors. Defaults to nil for no limit.
  # @return [Array<Hash>]
  def validate(query, validate: T.unsafe(nil), timeout: T.unsafe(nil), max_errors: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError < ::GraphQL::StaticValidation::Error
  # @return [VariableDefaultValuesAreCorrectlyTypedError] a new instance of VariableDefaultValuesAreCorrectlyTypedError
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError < ::GraphQL::StaticValidation::Error
  # @return [VariableNamesAreUniqueError] a new instance of VariableNamesAreUniqueError
  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_arg0); end

  def on_argument(node, parent); end
  def on_operation_definition(node, parent); end

  private

  def create_error(error_message, var_type, ast_var, arg_defn, arg_node); end

  # @return [Integer] Returns the max depth of `array`, or `0` if it isn't an array at all
  def depth_of_array(array); end

  def list_dimension(type); end
  def non_null_levels_match(arg_type, var_type); end
  def validate_usage(argument_owner, arg_node, ast_var); end
  def wrap_var_type_with_depth_of_arg(var_type, arg_node); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError < ::GraphQL::StaticValidation::Error
  # @return [VariableUsagesAreAllowedError] a new instance of VariableUsagesAreAllowedError
  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  # Returns the value of attribute argument_name.
  def argument_name; end

  def code; end

  # Returns the value of attribute error_message.
  def error_message; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end

  private

  def get_type_name(ast_type); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError < ::GraphQL::StaticValidation::Error
  # @return [VariablesAreInputTypesError] a new instance of VariablesAreInputTypesError
  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute type_name.
  def type_name; end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

# The problem is
#   - Variable $usage must be determined at the OperationDefinition level
#   - You can't tell how fragments use variables until you visit FragmentDefinitions (which may be at the end of the document)
#
#  So, this validator includes some crazy logic to follow fragment spreads recursively, while avoiding infinite loops.
#
# `graphql-js` solves this problem by:
#   - re-visiting the AST for each validator
#   - allowing validators to say `followSpreads: true`
module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_arg0); end

  def on_document(node, parent); end
  def on_fragment_definition(node, parent); end

  # For FragmentSpreads:
  #  - find the context on the stack
  #  - mark the context as containing this spread
  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, parent); end

  # For VariableIdentifiers:
  #  - mark the variable as used
  #  - assign its AST node
  def on_variable_identifier(node, parent); end

  private

  # Determine all the error messages,
  # Then push messages into the validation context
  def create_errors(node_variables); end

  # Follow spreads in `node`, looking them up from `spreads_for_context` and finding their match in `fragment_definitions`.
  # Use those fragments to update {VariableUsage}s in `parent_variables`.
  # Avoid infinite loops by skipping anything in `visited_fragments`.
  def follow_spreads(node, parent_variables, spreads_for_context, fragment_definitions, visited_fragments); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  # Returns the value of attribute ast_node.
  def ast_node; end

  # Sets the attribute ast_node
  #
  # @param value the value to set the attribute ast_node to.
  def ast_node=(_arg0); end

  # @return [Boolean]
  def declared?; end

  # Returns the value of attribute declared_by.
  def declared_by; end

  # Sets the attribute declared_by
  #
  # @param value the value to set the attribute declared_by to.
  def declared_by=(_arg0); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # @return [Boolean]
  def used?; end

  # Returns the value of attribute used_by.
  def used_by; end

  # Sets the attribute used_by
  #
  # @param value the value to set the attribute used_by to.
  def used_by=(_arg0); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError < ::GraphQL::StaticValidation::Error
  # @return [VariablesAreUsedAndDefinedError] a new instance of VariablesAreUsedAndDefinedError
  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def code; end

  # A hash representation of this Message
  def to_h; end

  # Returns the value of attribute variable_name.
  def variable_name; end

  # Returns the value of attribute violation.
  def violation; end
end

GraphQL::StaticValidation::VariablesAreUsedAndDefinedError::VIOLATIONS = T.let(T.unsafe(nil), Hash)

class GraphQL::StringEncodingError < ::GraphQL::RuntimeTypeError
  # @return [StringEncodingError] a new instance of StringEncodingError
  def initialize(str, context:); end

  # Returns the value of attribute field.
  def field; end

  # Returns the value of attribute path.
  def path; end

  # Returns the value of attribute string.
  def string; end
end

class GraphQL::Subscriptions
  # @param schema [Class] the GraphQL schema this manager belongs to
  # @param validate_update [Boolean] If false, then validation is skipped when executing updates
  # @return [Subscriptions] a new instance of Subscriptions
  def initialize(schema:, validate_update: T.unsafe(nil), broadcast: T.unsafe(nil), default_broadcastable: T.unsafe(nil), **rest); end

  # @return [Boolean] if true, then a query like this one would be broadcasted
  def broadcastable?(query_str, **query_options); end

  # @return [String] A new unique identifier for a subscription
  def build_id; end

  # @return [Boolean] Used when fields don't have `broadcastable:` explicitly set
  def default_broadcastable; end

  # A subscription was terminated server-side.
  # Clean up the database.
  #
  # @param subscription_id [String]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return void.
  def delete_subscription(subscription_id); end

  # A subscription query was re-evaluated, returning `result`.
  # The result should be send to `subscription_id`.
  #
  # @param subscription_id [String]
  # @param result [Hash]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def deliver(subscription_id, result); end

  # Run the update query for this subscription and deliver it
  #
  # @return [void]
  # @see {#execute_update}
  # @see {#deliver}
  def execute(subscription_id, event, object); end

  # Event `event` occurred on `object`,
  # Update all subscribers.
  #
  # @param event [Subscriptions::Event]
  # @param object [Object]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def execute_all(event, object); end

  # `event` was triggered on `object`, and `subscription_id` was subscribed,
  # so it should be updated.
  #
  # Load `subscription_id`'s GraphQL data, re-evaluate the query and return the result.
  #
  # @param subscription_id [String]
  # @param event [GraphQL::Subscriptions::Event] The event which was triggered
  # @param object [Object] The value for the subscription field
  # @return [GraphQL::Query::Result]
  def execute_update(subscription_id, event, object); end

  # Convert a user-provided event name or argument
  # to the equivalent in GraphQL.
  #
  # By default, it converts the identifier to camelcase.
  # Override this in a subclass to change the transformation.
  #
  # @param event_or_arg_name [String, Symbol]
  # @return [String]
  def normalize_name(event_or_arg_name); end

  # The system wants to send an update to this subscription.
  # Read its data and return it.
  #
  # @param subscription_id [String]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [Hash] Containing required keys
  def read_subscription(subscription_id); end

  # Fetch subscriptions matching this field + arguments pair
  # And pass them off to the queue.
  #
  # @param event_name [String]
  # @param args [Hash<String, Symbol => Object]] rgs [Hash<String, Symbol => Object]
  # @param object [Object]
  # @param scope [Symbol, String]
  # @param context [Hash]
  # @return [void]
  def trigger(event_name, args, object, scope: T.unsafe(nil), context: T.unsafe(nil)); end

  # Define this method to customize whether to validate
  # this subscription when executing an update.
  #
  # @return [Boolean] defaults to `true`, or false if `validate: false` is provided.
  def validate_update?(query:, context:, root_value:, subscription_topic:, operation_name:, variables:); end

  # `query` was executed and found subscriptions to `events`.
  # Update the database to reflect this new state.
  #
  # @param query [GraphQL::Query]
  # @param events [Array<GraphQL::Subscriptions::Event>]
  # @raise [GraphQL::RequiredImplementationMissingError]
  # @return [void]
  def write_subscription(query, events); end

  private

  # Recursively normalize `args` as belonging to `arg_owner`:
  # - convert symbols to strings,
  # - if needed, camelize the string (using {#normalize_name})
  #
  # @param arg_owner [GraphQL::Field, GraphQL::BaseType]
  # @param args [Hash, Array, Any] some GraphQL input value to coerce as `arg_owner`
  # @return [Any] normalized arguments value
  def normalize_arguments(event_name, arg_owner, args, context); end

  class << self
    # @see {Subscriptions#initialize} for options, concrete implementations may add options.
    def use(defn, options = T.unsafe(nil)); end
  end
end

# A subscriptions implementation that sends data
# as ActionCable broadcastings.
#
# Some things to keep in mind:
#
# - No queueing system; ActiveJob should be added
# - Take care to reload context when re-delivering the subscription. (see {Query#subscription_update?})
# - Avoid the async ActionCable adapter and use the redis or PostgreSQL adapters instead. Otherwise calling #trigger won't work from background jobs or the Rails console.
#
# @example Adding ActionCableSubscriptions to your schema
#   class MySchema < GraphQL::Schema
#   # ...
#   use GraphQL::Subscriptions::ActionCableSubscriptions
#   end
# @example Implementing a channel for GraphQL Subscriptions
#   class GraphqlChannel < ApplicationCable::Channel
#   def subscribed
#   @subscription_ids = []
#   end
#
#   def execute(data)
#   query = data["query"]
#   variables = ensure_hash(data["variables"])
#   operation_name = data["operationName"]
#   context = {
#   # Re-implement whatever context methods you need
#   # in this channel or ApplicationCable::Channel
#   # current_user: current_user,
#   # Make sure the channel is in the context
#   channel: self,
#   }
#
#   result = MySchema.execute(
#   query: query,
#   context: context,
#   variables: variables,
#   operation_name: operation_name
#   )
#
#   payload = {
#   result: result.to_h,
#   more: result.subscription?,
#   }
#
#   # Track the subscription here so we can remove it
#   # on unsubscribe.
#   if result.context[:subscription_id]
#   @subscription_ids << result.context[:subscription_id]
#   end
#
#   transmit(payload)
#   end
#
#   def unsubscribed
#   @subscription_ids.each { |sid|
#   MySchema.subscriptions.delete_subscription(sid)
#   }
#   end
#
#   private
#
#   def ensure_hash(ambiguous_param)
#   case ambiguous_param
#   when String
#   if ambiguous_param.present?
#   ensure_hash(JSON.parse(ambiguous_param))
#   else
#   {}
#   end
#   when Hash, ActionController::Parameters
#   ambiguous_param
#   when nil
#   {}
#   else
#   raise ArgumentError, "Unexpected parameter: #{ambiguous_param}"
#   end
#   end
#   end
class GraphQL::Subscriptions::ActionCableSubscriptions < ::GraphQL::Subscriptions
  # @param serializer [<#dump(obj), #load(string)] Used for serializing messages before handing them to `.broadcast(msg)`] erializer [<#dump(obj), #load(string)] Used for serializing messages before handing them to `.broadcast(msg)`
  # @param namespace [string] Used to namespace events and subscriptions (default: '')
  # @return [ActionCableSubscriptions] a new instance of ActionCableSubscriptions
  def initialize(serializer: T.unsafe(nil), namespace: T.unsafe(nil), action_cable: T.unsafe(nil), action_cable_coder: T.unsafe(nil), **rest); end

  # The channel was closed, forget about it.
  def delete_subscription(subscription_id); end

  # This subscription was re-evaluated.
  # Send it to the specific stream where this client was waiting.
  def deliver(subscription_id, result); end

  # An event was triggered; Push the data over ActionCable.
  # Subscribers will re-evaluate locally.
  def execute_all(event, object); end

  # This is called to turn an ActionCable-broadcasted string (JSON)
  # into a query-ready application object.
  #
  # @param message [String] n ActionCable-broadcasted string (JSON)
  # @param context [GraphQL::Query::Context] the context of the first event for a given subscription fingerprint
  def load_action_cable_message(message, context); end

  # Return the query from "storage" (in memory)
  def read_subscription(subscription_id); end

  # Every subscribing channel is listening here, but only one of them takes any action.
  # This is so we can reuse payloads when possible, and make one payload to send to
  # all subscribers.
  #
  # But the problem is, any channel could close at any time, so each channel has to
  # be ready to take over the primary position.
  #
  # To make sure there's always one-and-only-one channel building payloads,
  # let the listener belonging to the first event on the list be
  # the one to build and publish payloads.
  def setup_stream(channel, initial_event); end

  # A query was run where these events were subscribed to.
  # Store them in memory in _this_ ActionCable frontend.
  # It will receive notifications when events come in
  # and re-evaluate the query locally.
  def write_subscription(query, events); end

  private

  def stream_event_name(event); end
  def stream_subscription_name(subscription_id); end
end

GraphQL::Subscriptions::ActionCableSubscriptions::EVENT_PREFIX = T.let(T.unsafe(nil), String)
GraphQL::Subscriptions::ActionCableSubscriptions::SUBSCRIPTION_PREFIX = T.let(T.unsafe(nil), String)

# Detect whether the current operation:
# - Is a subscription operation
# - Is completely broadcastable
#
# Assign the result to `context.namespace(:subscriptions)[:subscription_broadcastable]`
#
# @api private
# @see Subscriptions#broadcastable? for a public API
class GraphQL::Subscriptions::BroadcastAnalyzer < ::GraphQL::Analysis::AST::Analyzer
  # @api private
  # @return [BroadcastAnalyzer] a new instance of BroadcastAnalyzer
  def initialize(subject); end

  # Only analyze subscription operations
  #
  # @api private
  # @return [Boolean]
  def analyze?; end

  # @api private
  def on_enter_field(node, parent, visitor); end

  # Assign the result to context.
  # (This method is allowed to return an error, but we don't need to)
  #
  # @api private
  # @return [void]
  def result; end

  private

  # Modify `@subscription_broadcastable` based on `field_defn`'s configuration (and/or the default value)
  #
  # @api private
  def apply_broadcastable(field_defn); end
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension < ::GraphQL::Schema::FieldExtension
  def after_resolve(value:, context:, object:, arguments:, **rest); end
  def resolve(context:, object:, arguments:); end

  private

  def arguments_without_field_extras(arguments:); end
end

# This thing can be:
# - Subscribed to by `subscription { ... }`
# - Triggered by `MySchema.subscriber.trigger(name, arguments, obj)`
class GraphQL::Subscriptions::Event
  # @return [Event] a new instance of Event
  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  # @return [GraphQL::Execution::Interpreter::Arguments]
  def arguments; end

  # @return [GraphQL::Query::Context]
  def context; end

  # @return [String] a logical identifier for this event. (Stable when the query is broadcastable.)
  def fingerprint; end

  # @return [String] Corresponds to the Subscription root field name
  def name; end

  # @return [String] An opaque string which identifies this event, derived from `name` and `arguments`
  def topic; end

  class << self
    # @return [String] an identifier for this unit of subscription
    def serialize(_name, arguments, field, scope:, context: T.unsafe(nil)); end

    private

    # @raise [ArgumentError]
    def deep_sort_array_hashes(array_to_inspect); end

    # This method does not support cyclic references in the Hash,
    # nor does it support Hashes whose keys are not sortable
    # with respect to their peers ( cases where a <=> b might throw an error )
    #
    # @raise [ArgumentError]
    def deep_sort_hash_keys(hash_to_sort); end

    def get_arg_definition(arg_owner, arg_name, context); end
    def stringify_args(arg_owner, args, context); end
  end
end

# Wrap the root fields of the subscription type with special logic for:
# - Registering the subscription during the first execution
# - Evaluating the triggered portion(s) of the subscription during later execution
class GraphQL::Subscriptions::Instrumentation
  # @return [Instrumentation] a new instance of Instrumentation
  def initialize(schema:); end

  # After checking the root fields, pass the gathered events to the store
  def after_query(query); end

  # If needed, prepare to gather events which this query subscribes to
  def before_query(query); end
end

# Raised when either:
# - the triggered `event_name` doesn't match a field in the schema; or
# - one or more arguments don't match the field arguments
class GraphQL::Subscriptions::InvalidTriggerError < ::GraphQL::Error; end

# Serialization helpers for passing subscription data around.
#
# @api private
module GraphQL::Subscriptions::Serialize
  private

  # @api private
  # @param obj [Object] Some subscription-related data to dump
  # @return [String] The stringified object
  def dump(obj); end

  # This is for turning objects into subscription scopes.
  # It's a one-way transformation, can't reload this :'(
  #
  # @api private
  # @param obj [Object]
  # @return [String]
  def dump_recursive(obj); end

  # @api private
  # @param str [String] A serialized object from {.dump}
  # @return [Object] An object equivalent to the one passed to {.dump}
  def load(str); end

  class << self
    # @api private
    # @param obj [Object] Some subscription-related data to dump
    # @return [String] The stringified object
    def dump(obj); end

    # This is for turning objects into subscription scopes.
    # It's a one-way transformation, can't reload this :'(
    #
    # @api private
    # @param obj [Object]
    # @return [String]
    def dump_recursive(obj); end

    # @api private
    # @param str [String] A serialized object from {.dump}
    # @return [Object] An object equivalent to the one passed to {.dump}
    def load(str); end

    private

    # @api private
    # @param obj [Object] Some subscription-related data to dump
    # @return [Object] The object that converted Global::Identification
    def dump_value(obj); end

    # @api private
    # @param value [Object] A parsed JSON object
    # @return [Object] An object that load Global::Identification recursive
    def load_value(value); end
  end
end

# @api private
GraphQL::Subscriptions::Serialize::GLOBALID_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::OPEN_STRUCT_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::SYMBOL_KEY = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::SYMBOL_KEYS_KEY = T.let(T.unsafe(nil), String)

# eg '2020-01-01 23:59:59.123456789+05:00'
#
# @api private
GraphQL::Subscriptions::Serialize::TIMESTAMP_FORMAT = T.let(T.unsafe(nil), String)

# @api private
GraphQL::Subscriptions::Serialize::TIMESTAMP_KEY = T.let(T.unsafe(nil), String)

# Raised when either:
# - An initial subscription didn't have a value for `context[subscription_scope]`
# - Or, an update didn't pass `.trigger(..., scope:)`
# When raised, the initial subscription or update fails completely.
class GraphQL::Subscriptions::SubscriptionScopeMissingError < ::GraphQL::Error; end

# Library entry point for performance metric reporting.
#
# Events:
#
# Key | Metadata
# ----|---------
# lex | `{ query_string: String }`
# parse | `{ query_string: String }`
# validate | `{ query: GraphQL::Query, validate: Boolean }`
# analyze_multiplex |  `{ multiplex: GraphQL::Execution::Multiplex }`
# analyze_query | `{ query: GraphQL::Query }`
# execute_multiplex | `{ multiplex: GraphQL::Execution::Multiplex }`
# execute_query | `{ query: GraphQL::Query }`
# execute_query_lazy | `{ query: GraphQL::Query?, multiplex: GraphQL::Execution::Multiplex? }`
# execute_field | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# execute_field_lazy | `{ owner: Class, field: GraphQL::Schema::Field, query: GraphQL::Query, path: Array<String, Integer>, ast_node: GraphQL::Language::Nodes::Field}`
# authorized | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# authorized_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
# resolve_type_lazy | `{ context: GraphQL::Query::Context, type: Class, object: Object, path: Array<String, Integer> }`
#
# Note that `execute_field` and `execute_field_lazy` receive different data in different settings:
#
# - When using {GraphQL::Execution::Interpreter}, they receive `{field:, path:, query:}`
# - Otherwise, they receive `{context: ...}`
#
# @example Sending custom events
#   query.trace("my_custom_event", { ... }) do
#   # do stuff ...
#   end
# @example Adding a tracer to a schema
#   class MySchema < GraphQL::Schema
#   tracer MyTracer # <= responds to .trace(key, data, &block)
#   end
# @example Adding a tracer to a single query
#   MySchema.execute(query_str, context: { backtrace: true })
module GraphQL::Tracing; end

# This implementation forwards events to ActiveSupport::Notifications
# with a `graphql` suffix.
#
# @see KEYS for event names
module GraphQL::Tracing::ActiveSupportNotificationsTracing
  class << self
    def trace(key, metadata, &blk); end
  end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::ActiveSupportNotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::ActiveSupportNotificationsTracing::NOTIFICATIONS_ENGINE = T.let(T.unsafe(nil), GraphQL::Tracing::NotificationsTracing)

# This class uses the AppopticsAPM SDK from the appoptics_apm gem to create
# traces for GraphQL.
#
# There are 4 configurations available. They can be set in the
# appoptics_apm config file or in code. Please see:
# {https://docs.appoptics.com/kb/apm_tracing/ruby/configure}
#
#     AppOpticsAPM::Config[:graphql][:enabled] = true|false
#     AppOpticsAPM::Config[:graphql][:transaction_name]  = true|false
#     AppOpticsAPM::Config[:graphql][:sanitize_query] = true|false
#     AppOpticsAPM::Config[:graphql][:remove_comments] = true|false
class GraphQL::Tracing::AppOpticsTracing < ::GraphQL::Tracing::PlatformTracing
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, _key, data); end

  private

  def gql_config; end
  def graphql_context(context, layer); end
  def graphql_multiplex(data); end
  def graphql_query(query); end
  def graphql_query_string(query_string); end
  def metadata(data, layer); end
  def multiplex_transaction_name(names); end
  def remove_comments(query); end
  def sanitize(query); end
  def span_name(key); end
  def transaction_name(query); end

  class << self
    # During auto-instrumentation this version of AppOpticsTracing is compared
    # with the version provided in the appoptics_apm gem, so that the newer
    # version of the class can be used
    def version; end
  end
end

# These GraphQL events will show up as 'graphql.execute' spans
GraphQL::Tracing::AppOpticsTracing::EXEC_KEYS = T.let(T.unsafe(nil), Array)

# These GraphQL events will show up as 'graphql.prep' spans
GraphQL::Tracing::AppOpticsTracing::PREP_KEYS = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::AppsignalTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_action_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_appsignal_action_name]`.
  # @return [AppsignalTracing] a new instance of AppsignalTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::DataDogTracing < ::GraphQL::Tracing::PlatformTracing
  # @return [Boolean]
  def analytics_available?; end

  # @return [Boolean]
  def analytics_enabled?; end

  def analytics_sample_rate; end
  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end

  # Implement this method in a subclass to apply custom tags to datadog spans
  #
  # @param key [String] The event being traced
  # @param data [Hash] The runtime data for this event (@see GraphQL::Tracing for keys for each event)
  # @param span [Datadog::Tracing::SpanOperation] The datadog span for this event
  def prepare_span(key, data, span); end

  def service_name; end
  def tracer; end
end

class GraphQL::Tracing::NewRelicTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_new_relic_transaction_name]`.
  # @return [NewRelicTracing] a new instance of NewRelicTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# This implementation forwards events to a notification handler (i.e.
# ActiveSupport::Notifications or Dry::Monitor::Notifications)
# with a `graphql` suffix.
#
# @see KEYS for event names
class GraphQL::Tracing::NotificationsTracing
  # Initialize a new NotificationsTracing instance
  #
  # @param notifications_engine [Object] The notifications engine to use
  # @return [NotificationsTracing] a new instance of NotificationsTracing
  def initialize(notifications_engine); end

  # Sends a GraphQL tracing event to the notification handler
  #
  # . notifications_engine = Dry::Monitor::Notifications.new(:graphql)
  # . tracer = GraphQL::Tracing::NotificationsTracing.new(notifications_engine)
  # . tracer.trace("lex") { ... }
  #
  # @param key [string] The key for the event
  # @param metadata [Hash] The metadata for the event
  # @yield The block to execute for the event
  def trace(key, metadata, &blk); end
end

# A cache of frequently-used keys to avoid needless string allocations
GraphQL::Tracing::NotificationsTracing::KEYS = T.let(T.unsafe(nil), Hash)

GraphQL::Tracing::NotificationsTracing::MAX_KEYS_SIZE = T.let(T.unsafe(nil), Integer)

module GraphQL::Tracing::NullTracer
  private

  def trace(k, v); end

  class << self
    def trace(k, v); end
  end
end

# Each platform provides:
# - `.platform_keys`
# - `#platform_trace`
# - `#platform_field_key(type, field)`
#
# @api private
class GraphQL::Tracing::PlatformTracing
  # @api private
  # @return [PlatformTracing] a new instance of PlatformTracing
  def initialize(options = T.unsafe(nil)); end

  # @api private
  def trace(key, data); end

  private

  # Different kind of schema objects have different kinds of keys:
  #
  # - Object types: `.authorized`
  # - Union/Interface types: `.resolve_type`
  # - Fields: execution
  #
  # So, they can all share one cache.
  #
  # If the key isn't present, the given block is called and the result is cached for `key`.
  #
  # @api private
  # @param ctx [GraphQL::Query::Context]
  # @param key [Class, GraphQL::Field] A part of the schema
  # @param trace_phase [Symbol] The stage of execution being traced (used by OpenTelementry tracing)
  # @return [String]
  def cached_platform_key(ctx, key, trace_phase); end

  # @api private
  def fallback_transaction_name(context); end

  # @api private
  def options; end

  # Get the transaction name based on the operation type and name if possible, or fall back to a user provided
  # one. Useful for anonymous queries.
  #
  # @api private
  def transaction_name(query); end

  class << self
    # @api private
    # @private
    def inherited(child_class); end

    # @api private
    def platform_keys; end

    # @api private
    def platform_keys=(_arg0); end

    # @api private
    def use(schema_defn, options = T.unsafe(nil)); end
  end
end

class GraphQL::Tracing::PrometheusTracing < ::GraphQL::Tracing::PlatformTracing
  # @return [PrometheusTracing] a new instance of PrometheusTracing
  def initialize(opts = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data, &block); end

  private

  def instrument_execution(platform_key, key, data, &block); end
  def observe(platform_key, key, duration); end
end

GraphQL::Tracing::PrometheusTracing::DEFAULT_COLLECTOR_TYPE = T.let(T.unsafe(nil), String)
GraphQL::Tracing::PrometheusTracing::DEFAULT_WHITELIST = T.let(T.unsafe(nil), Array)

class GraphQL::Tracing::ScoutTracing < ::GraphQL::Tracing::PlatformTracing
  # @param set_transaction_name [Boolean] If true, the GraphQL operation name will be used as the transaction name.
  #   This is not advised if you run more than one query per HTTP request, for example, with `graphql-client` or multiplexing.
  #   It can also be specified per-query with `context[:set_scout_transaction_name]`.
  # @return [ScoutTracing] a new instance of ScoutTracing
  def initialize(options = T.unsafe(nil)); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

GraphQL::Tracing::ScoutTracing::INSTRUMENT_OPTS = T.let(T.unsafe(nil), Hash)

class GraphQL::Tracing::StatsdTracing < ::GraphQL::Tracing::PlatformTracing
  # @param statsd [Object] A statsd client
  # @return [StatsdTracing] a new instance of StatsdTracing
  def initialize(statsd:, **rest); end

  def platform_authorized_key(type); end
  def platform_field_key(type, field); end
  def platform_resolve_type_key(type); end
  def platform_trace(platform_key, key, data); end
end

# Objects may include traceable to gain a `.trace(...)` method.
# The object must have a `@tracers` ivar of type `Array<<#trace(k, d, &b)>>`.
#
# @api private
module GraphQL::Tracing::Traceable
  # @api private
  # @param key [String] The name of the event in GraphQL internals
  # @param metadata [Hash] Event-related metadata (can be anything)
  # @return [Object] Must return the value of the block
  def trace(key, metadata, &block); end

  private

  # If there's a tracer at `idx`, call it and then increment `idx`.
  # Otherwise, yield.
  #
  # @api private
  # @param idx [Integer] Which tracer to call
  # @param key [String] The current event name
  # @param metadata [Object] The current event object
  # @return Whatever the block returns
  def call_tracers(idx, key, metadata, &block); end
end

# Type kinds are the basic categories which a type may belong to (`Object`, `Scalar`, `Union`...)
module GraphQL::TypeKinds; end

GraphQL::TypeKinds::ENUM = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INPUT_OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::INTERFACE = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::LIST = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::NON_NULL = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::OBJECT = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::SCALAR = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
GraphQL::TypeKinds::TYPE_KINDS = T.let(T.unsafe(nil), Array)

# These objects are singletons, eg `GraphQL::TypeKinds::UNION`, `GraphQL::TypeKinds::SCALAR`.
class GraphQL::TypeKinds::TypeKind
  # @return [TypeKind] a new instance of TypeKind
  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  # Is this TypeKind abstract?
  #
  # @return [Boolean]
  def abstract?; end

  # Is this TypeKind composed of many values?
  #
  # @return [Boolean]
  def composite?; end

  # Returns the value of attribute description.
  def description; end

  # @return [Boolean]
  def enum?; end

  # Does this TypeKind have queryable fields?
  #
  # @return [Boolean]
  def fields?; end

  # Is this TypeKind a valid query input?
  #
  # @return [Boolean]
  def input?; end

  # @return [Boolean]
  def input_object?; end

  # @return [Boolean]
  def interface?; end

  # @return [Boolean]
  def list?; end

  # Returns the value of attribute name.
  def name; end

  # @return [Boolean]
  def non_null?; end

  # @return [Boolean]
  def object?; end

  # Does this TypeKind have multiple possible implementors?
  #
  # @deprecated Use `abstract?` instead of `resolves?`.
  # @return [Boolean]
  def resolves?; end

  # @return [Boolean]
  def scalar?; end

  def to_s; end

  # @return [Boolean]
  def union?; end

  # Does this TypeKind modify another type?
  #
  # @return [Boolean]
  def wraps?; end
end

GraphQL::TypeKinds::UNION = T.let(T.unsafe(nil), GraphQL::TypeKinds::TypeKind)
module GraphQL::Types; end

class GraphQL::Types::BigInt < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
    def parse_int(value); end
  end
end

class GraphQL::Types::Boolean < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::Float < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

class GraphQL::Types::ID < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Date`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
#     field :published_at, GraphQL::Types::ISO8601Date, null: false
#
#     argument :deliver_at, GraphQL::Types::ISO8601Date, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own Date type.
class GraphQL::Types::ISO8601Date < ::GraphQL::Schema::Scalar
  class << self
    # @param str_value [String, Date, DateTime, Time]
    # @return [Date, nil]
    def coerce_input(value, ctx); end

    # @param value [Date, Time, DateTime, String]
    # @return [String]
    def coerce_result(value, _ctx); end
  end
end

# This scalar takes `Time`s and transmits them as strings,
# using ISO 8601 format.
#
# Use it for fields or arguments as follows:
#
#     field :created_at, GraphQL::Types::ISO8601DateTime, null: false
#
#     argument :deliver_at, GraphQL::Types::ISO8601DateTime, null: false
#
# Alternatively, use this built-in scalar as inspiration for your
# own DateTime type.
class GraphQL::Types::ISO8601DateTime < ::GraphQL::Schema::Scalar
  class << self
    # @param str_value [String]
    # @return [Time]
    def coerce_input(str_value, _ctx); end

    # @param value [Time, Date, DateTime, String]
    # @return [String]
    def coerce_result(value, _ctx); end

    # @return [Integer]
    def time_precision; end

    # @param value [Integer]
    def time_precision=(value); end
  end
end

# It's not compatible with Rails' default,
# i.e. ActiveSupport::JSON::Encoder.time_precision (3 by default)
GraphQL::Types::ISO8601DateTime::DEFAULT_TIME_PRECISION = T.let(T.unsafe(nil), Integer)

# @see {Types::BigInt} for handling integers outside 32-bit range.
class GraphQL::Types::Int < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, ctx); end
    def coerce_result(value, ctx); end
  end
end

GraphQL::Types::Int::MAX = T.let(T.unsafe(nil), Integer)
GraphQL::Types::Int::MIN = T.let(T.unsafe(nil), Integer)

# An untyped JSON scalar that maps to Ruby hashes, arrays, strings, integers, floats, booleans and nils.
# This should be used judiciously because it subverts the GraphQL type system.
#
# Use it for fields or arguments as follows:
#
#     field :template_parameters, GraphQL::Types::JSON, null: false
#
#     argument :template_parameters, GraphQL::Types::JSON, null: false
class GraphQL::Types::JSON < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _context); end
    def coerce_result(value, _context); end
  end
end

# This module contains some types and fields that could support Relay conventions in GraphQL.
#
# You can use these classes out of the box if you want, but if you want to use your _own_
# GraphQL extensions along with the features in this code, you could also
# open up the source files and copy the relevant methods and configuration into
# your own classes.
#
# For example, the provided object types extend {Types::Relay::BaseObject},
# but you might want to:
#
# 1. Migrate the extensions from {Types::Relay::BaseObject} into _your app's_ base object
# 2. Copy {Relay::BaseConnection}, {Relay::BaseEdge}, etc into _your app_, and
#   change them to extend _your_ base object.
#
# Similarly, `BaseField`'s extensions could be migrated to your app
# and `Node` could be implemented to mix in your base interface module.
module GraphQL::Types::Relay; end

# Use this to implement Relay connections, or take it as inspiration
# for Relay classes in your own app.
#
# You may wish to copy this code into your own base class,
# so you can extend your own `BaseObject` instead of `GraphQL::Schema::Object`.
#
# @example Implementation a connection and edge
#   class BaseObject < GraphQL::Schema::Object; end
#
#   # Given some object in your app ...
#   class Types::Post < BaseObject
#   end
#
#   # Make a couple of base classes:
#   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge; end
#   class Types::BaseConnection < GraphQL::Types::Relay::BaseConnection; end
#
#   # Then extend them for the object in your app
#   class Types::PostEdge < Types::BaseEdge
#   node_type Types::Post
#   end
#
#   class Types::PostConnection < Types::BaseConnection
#   edge_type Types::PostEdge,
#   edges_nullable: true,
#   edge_nullable: true,
#   node_nullable: true,
#   nodes_field: true
#
#   # Alternatively, you can call the class methods followed by your edge type
#   # edges_nullable true
#   # edge_nullable true
#   # nodes_nullable true
#   # has_nodes_field true
#   # edge_type Types::PostEdge
#   end
# @see Relay::BaseEdge for edge types
class GraphQL::Types::Relay::BaseConnection < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::ConnectionBehaviors
  extend ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

# A class-based definition for Relay edges.
#
# Use this as a parent class in your app, or use it as inspiration for your
# own base `Edge` class.
#
# For example, you may want to extend your own `BaseObject` instead of the
# built-in `GraphQL::Schema::Object`.
#
# @example Making a UserEdge type
#   # Make a base class for your app
#   class Types::BaseEdge < GraphQL::Types::Relay::BaseEdge
#   end
#
#   # Then extend your own base class
#   class Types::UserEdge < Types::BaseEdge
#   node_type(Types::User)
#   end
# @see {Relay::BaseConnection} for connection types
class GraphQL::Types::Relay::BaseEdge < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::EdgeBehaviors
  extend ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
end

module GraphQL::Types::Relay::ConnectionBehaviors
  extend ::Forwardable

  mixes_in_class_methods ::GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  def cursor_from_node(*args, &block); end
  def parent(*args, &block); end

  class << self
    def add_page_info_field(obj_type); end

    # @private
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::ConnectionBehaviors::ClassMethods
  # @return [Boolean]
  def accessible?(ctx); end

  # @return [Boolean]
  def authorized?(obj, ctx); end

  # @return [Class]
  def edge_class; end

  # Set the default `edge_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edge_nullable(false)` in your base class to make non-null `edge` fields.
  def edge_nullable(new_value = T.unsafe(nil)); end

  # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
  #
  # This method will use the inputs to create:
  # - `edges` field
  # - `nodes` field
  # - description
  #
  # It's called when you subclass this base connection, trying to use the
  # class name to set defaults. You can call it again in the class definition
  # to override the default (or provide a value, if the default lookup failed).
  #
  # @param field_options [Hash] Any extra keyword arguments to pass to the `field :edges, ...` and `field :nodes, ...` configurations
  def edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil), node_nullable: T.unsafe(nil), edges_nullable: T.unsafe(nil), edge_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Set the default `edges_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `edges_nullable(false)` in your base class to make non-null `edges` fields.
  def edges_nullable(new_value = T.unsafe(nil)); end

  # Set the default `nodes_field` for this class and its child classes. (Defaults to `true`.)
  # Use `nodes_field(false)` in your base class to prevent adding of a nodes field.
  def has_nodes_field(new_value = T.unsafe(nil)); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` and `nodes` fields.
  def node_nullable(new_value = T.unsafe(nil)); end

  # @return [Class]
  def node_type; end

  # Add the shortcut `nodes` field to this connection and its subclasses
  def nodes_field(node_nullable: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # Filter this list according to the way its node type would scope them
  def scope_items(items, context); end

  # @return [Boolean]
  def visible?(ctx); end

  private

  def define_nodes_field(nullable, field_options: T.unsafe(nil)); end
end

module GraphQL::Types::Relay::DefaultRelay
  def default_relay(new_value); end

  # @return [Boolean]
  def default_relay?; end

  class << self
    # @private
    def extended(child_class); end
  end
end

module GraphQL::Types::Relay::EdgeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::EdgeBehaviors::ClassMethods

  class << self
    # @private
    def included(child_class); end
  end
end

module GraphQL::Types::Relay::EdgeBehaviors::ClassMethods
  # @return [Boolean]
  def accessible?(ctx); end

  # @return [Boolean]
  def authorized?(obj, ctx); end

  # Set the default `node_nullable` for this class and its child classes. (Defaults to `true`.)
  # Use `node_nullable(false)` in your base class to make non-null `node` field.
  def node_nullable(new_value = T.unsafe(nil)); end

  # Get or set the Object type that this edge wraps.
  #
  # @param node_type [Class] A `Schema::Object` subclass
  # @param null [Boolean]
  # @param field_options [Hash] Any extra arguments to pass to the `field :node` configuration
  def node_type(node_type = T.unsafe(nil), null: T.unsafe(nil), field_options: T.unsafe(nil)); end

  # @return [Boolean]
  def visible?(ctx); end
end

# Include this module to your root Query type to get a Relay-compliant `node(id: ID!): Node` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodeField
  class << self
    def field_block; end
    def field_options; end

    # @private
    def included(child_class); end
  end
end

# Include this module to your root Query type to get a Relay-style `nodes(id: ID!): [Node]` field that uses the schema's `object_from_id` hook.
module GraphQL::Types::Relay::HasNodesField
  class << self
    def field_block; end
    def field_options; end

    # @private
    def included(child_class); end
  end
end

# This can be used for Relay's `Node` interface,
# or you can take it as inspiration for your own implementation
# of the `Node` interface.
module GraphQL::Types::Relay::Node
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Types::Relay::NodeBehaviors
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::HasDirectives
  extend ::GraphQL::Schema::Member::HasInterfaces
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
  extend ::GraphQL::Types::Relay::DefaultRelay
end

module GraphQL::Types::Relay::Node::DefinitionMethods; end
class GraphQL::Types::Relay::Node::UnresolvedTypeError < ::GraphQL::UnresolvedTypeError; end

module GraphQL::Types::Relay::NodeBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  def default_global_id; end

  class << self
    # @private
    def included(child_module); end
  end
end

# The return type of a connection's `pageInfo` field
class GraphQL::Types::Relay::PageInfo < ::GraphQL::Schema::Object
  include ::GraphQL::Types::Relay::PageInfoBehaviors
  extend ::GraphQL::Types::Relay::DefaultRelay
end

module GraphQL::Types::Relay::PageInfoBehaviors
  mixes_in_class_methods ::GraphQL::Types::Relay::DefaultRelay

  class << self
    # @private
    def included(child_class); end
  end
end

class GraphQL::Types::String < ::GraphQL::Schema::Scalar
  class << self
    def coerce_input(value, _ctx); end
    def coerce_result(value, ctx); end
  end
end

# When an `authorized?` hook returns false, this error is used to communicate the failure.
# It's passed to {Schema.unauthorized_object}.
#
# Alternatively, custom code in `authorized?` may raise this error. It will be routed the same way.
class GraphQL::UnauthorizedError < ::GraphQL::Error
  # @return [UnauthorizedError] a new instance of UnauthorizedError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  # @return [GraphQL::Query::Context] the context for the current query
  def context; end

  # @return [GraphQL::Query::Context] the context for the current query
  def context=(_arg0); end

  # @return [Object] the application object that failed the authorization check
  def object; end

  # @return [Class] the GraphQL object type whose `.authorized?` method was called (and returned false)
  def type; end
end

class GraphQL::UnauthorizedFieldError < ::GraphQL::UnauthorizedError
  # @return [UnauthorizedFieldError] a new instance of UnauthorizedFieldError
  def initialize(message = T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end

  # @return [Field] the field that failed the authorization check
  def field; end

  # @return [Field] the field that failed the authorization check
  def field=(_arg0); end
end

# Error raised when the value provided for a field
# can't be resolved to one of the possible types for the field.
class GraphQL::UnresolvedTypeError < ::GraphQL::RuntimeTypeError
  # @return [UnresolvedTypeError] a new instance of UnresolvedTypeError
  def initialize(value, field, parent_type, resolved_type, possible_types); end

  # @return [GraphQL::Field] The field whose value couldn't be resolved (`field.type` is type which couldn't be resolved)
  def field; end

  # @return [GraphQL::BaseType] The owner of `field`
  def parent_type; end

  # @return [Array<GraphQL::BaseType>] The allowed options for resolving `value` to `field.type`
  def possible_types; end

  # @return [Object] The return of {Schema#resolve_type} for `value`
  def resolved_type; end

  # @return [Object] The runtime value which couldn't be successfully resolved with `resolve_type`
  def value; end
end

GraphQL::VERSION = T.let(T.unsafe(nil), String)
