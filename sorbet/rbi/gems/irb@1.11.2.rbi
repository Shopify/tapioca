# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `irb` gem.
# Please instead update this file by running `bin/tapioca gem irb`.

# source://irb//lib/irb.rb#1458
class Binding
  # Opens an IRB session where +binding.irb+ is called which allows for
  # interactive debugging. You can call any methods or variables available in
  # the current scope, and mutate state if you need to.
  #
  #
  # Given a Ruby file called +potato.rb+ containing the following code:
  #
  #     class Potato
  #       def initialize
  #         @cooked = false
  #         binding.irb
  #         puts "Cooked potato: #{@cooked}"
  #       end
  #     end
  #
  #     Potato.new
  #
  # Running <code>ruby potato.rb</code> will open an IRB session where
  # +binding.irb+ is called, and you will see the following:
  #
  #     $ ruby potato.rb
  #
  #     From: potato.rb @ line 4 :
  #
  #         1: class Potato
  #         2:   def initialize
  #         3:     @cooked = false
  #      => 4:     binding.irb
  #         5:     puts "Cooked potato: #{@cooked}"
  #         6:   end
  #         7: end
  #         8:
  #         9: Potato.new
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0>
  #
  # You can type any valid Ruby code and it will be evaluated in the current
  # context. This allows you to debug without having to run your code repeatedly:
  #
  #     irb(#<Potato:0x00007feea1916670>):001:0> @cooked
  #     => false
  #     irb(#<Potato:0x00007feea1916670>):002:0> self.class
  #     => Potato
  #     irb(#<Potato:0x00007feea1916670>):003:0> caller.first
  #     => ".../2.5.1/lib/ruby/2.5.0/irb/workspace.rb:85:in `eval'"
  #     irb(#<Potato:0x00007feea1916670>):004:0> @cooked = true
  #     => true
  #
  # You can exit the IRB session with the +exit+ command. Note that exiting will
  # resume execution where +binding.irb+ had paused it, as you can see from the
  # output printed to standard output in this example:
  #
  #     irb(#<Potato:0x00007feea1916670>):005:0> exit
  #     Cooked potato: true
  #
  # See IRB for more information.
  #
  # source://irb//lib/irb.rb#1515
  def irb(show_code: T.unsafe(nil)); end
end

# == \IRB
#
# \Module \IRB ("Interactive Ruby") provides a shell-like interface
# that supports user interaction with the Ruby interpreter.
#
# It operates as a <i>read-eval-print loop</i>
# ({REPL}[https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop])
# that:
#
# - <b>_Reads_</b> each character as you type.
#   You can modify the \IRB context to change the way input works.
#   See {Input}[rdoc-ref:IRB@Input].
# - <b>_Evaluates_</b> the code each time it has read a syntactically complete passage.
# - <b>_Prints_</b> after evaluating.
#   You can modify the \IRB context to change the way output works.
#   See {Output}[rdoc-ref:IRB@Output].
#
# Example:
#
#   $ irb
#   irb(main):001> File.basename(Dir.pwd)
#   => "irb"
#   irb(main):002> Dir.entries('.').size
#   => 25
#   irb(main):003* Dir.entries('.').select do |entry|
#   irb(main):004*   entry.start_with?('R')
#   irb(main):005> end
#   => ["README.md", "Rakefile"]
#
# The typed input may also include
# {\IRB-specific commands}[rdoc-ref:IRB@IRB-Specific+Commands].
#
# As seen above, you can start \IRB by using the shell command +irb+.
#
# You can stop an \IRB session by typing command +exit+:
#
#   irb(main):006> exit
#   $
#
# At that point, \IRB calls any hooks found in array <tt>IRB.conf[:AT_EXIT]</tt>,
# then exits.
#
# == Startup
#
# At startup, \IRB:
#
# 1. Interprets (as Ruby code) the content of the
#    {configuration file}[rdoc-ref:IRB@Configuration+File] (if given).
# 1. Constructs the initial session context
#    from {hash IRB.conf}[rdoc-ref:IRB@Hash+IRB.conf] and from default values;
#    the hash content may have been affected
#    by {command-line options}[rdoc-ref:IB@Command-Line+Options],
#    and by direct assignments in the configuration file.
# 1. Assigns the context to variable +conf+.
# 1. Assigns command-line arguments to variable <tt>ARGV</tt>.
# 1. Prints the {prompt}[rdoc-ref:IRB@Prompt+and+Return+Formats].
# 1. Puts the content of the
#    {initialization script}[rdoc-ref:IRB@Initialization+Script]
#    onto the \IRB shell, just as if it were user-typed commands.
#
# === The Command Line
#
# On the command line, all options precede all arguments;
# the first item that is not recognized as an option is treated as an argument,
# as are all items that follow.
#
# ==== Command-Line Options
#
# Many command-line options affect entries in hash <tt>IRB.conf</tt>,
# which in turn affect the initial configuration of the \IRB session.
#
# Details of the options are described in the relevant subsections below.
#
# A cursory list of the \IRB command-line options
# may be seen in the {help message}[https://raw.githubusercontent.com/ruby/irb/master/lib/irb/lc/help-message],
# which is also displayed if you use command-line option <tt>--help</tt>.
#
# If you are interested in a specific option, consult the
# {index}[rdoc-ref:doc/irb/indexes.md@Index+of+Command-Line+Options].
#
# ==== Command-Line Arguments
#
# Command-line arguments are passed to \IRB in array +ARGV+:
#
#   $ irb --noscript Foo Bar Baz
#   irb(main):001> ARGV
#   => ["Foo", "Bar", "Baz"]
#   irb(main):002> exit
#   $
#
# Command-line option <tt>--</tt> causes everything that follows
# to be treated as arguments, even those that look like options:
#
#   $ irb --noscript -- --noscript -- Foo Bar Baz
#   irb(main):001> ARGV
#   => ["--noscript", "--", "Foo", "Bar", "Baz"]
#   irb(main):002> exit
#   $
#
# === Configuration File
#
# You can initialize \IRB via a <i>configuration file</i>.
#
# If command-line option <tt>-f</tt> is given,
# no configuration file is looked for.
#
# Otherwise, \IRB reads and interprets a configuration file
# if one is available.
#
# The configuration file can contain any Ruby code, and can usefully include
# user code that:
#
# - Can then be debugged in \IRB.
# - Configures \IRB itself.
# - Requires or loads files.
#
# The path to the configuration file is the first found among:
#
# - The value of variable <tt>$IRBRC</tt>, if defined.
# - The value of variable <tt>$XDG_CONFIG_HOME/irb/irbrc</tt>, if defined.
# - File <tt>$HOME/.irbrc</tt>, if it exists.
# - File <tt>$HOME/.config/irb/irbrc</tt>, if it exists.
# - File +.config/irb/irbrc+ in the current directory, if it exists.
# - File +.irbrc+ in the current directory, if it exists.
# - File +irb.rc+ in the current directory, if it exists.
# - File +_irbrc+ in the current directory, if it exists.
# - File <tt>$irbrc</tt> in the current directory, if it exists.
#
# If the search fails, there is no configuration file.
#
# If the search succeeds, the configuration file is read as Ruby code,
# and so can contain any Ruby programming you like.
#
# \Method <tt>conf.rc?</tt> returns +true+ if a configuration file was read,
# +false+ otherwise.
# \Hash entry <tt>IRB.conf[:RC]</tt> also contains that value.
#
# === \Hash <tt>IRB.conf</tt>
#
# The initial entries in hash <tt>IRB.conf</tt> are determined by:
#
# - Default values.
# - Command-line options, which may override defaults.
# - Direct assignments in the configuration file.
#
# You can see the hash by typing <tt>IRB.conf</tt>.
#
# Details of the entries' meanings are described in the relevant subsections below.
#
# If you are interested in a specific entry, consult the
# {index}[rdoc-ref:doc/irb/indexes.md@Index+of+IRB.conf+Entries].
#
# === Notes on Initialization Precedence
#
# - Any conflict between an entry in hash <tt>IRB.conf</tt> and a command-line option
#   is resolved in favor of the hash entry.
# - \Hash <tt>IRB.conf</tt> affects the context only once,
#   when the configuration file is interpreted;
#   any subsequent changes to it do not affect the context
#   and are therefore essentially meaningless.
#
# === Initialization Script
#
# By default, the first command-line argument (after any options)
# is the path to a Ruby initialization script.
#
# \IRB reads the initialization script and puts its content onto the \IRB shell,
# just as if it were user-typed commands.
#
# Command-line option <tt>--noscript</tt> causes the first command-line argument
# to be treated as an ordinary argument (instead of an initialization script);
# <tt>--script</tt> is the default.
#
# == Input
#
# This section describes the features that allow you to change
# the way \IRB input works;
# see also {Input and Output}[rdoc-ref:IRB@Input+and+Output].
#
# === Input Command History
#
# By default, \IRB stores a history of up to 1000 input commands in a
# file named <tt>.irb_history</tt>. The history file will be in the same directory
# as the {configuration file}[rdoc-ref:IRB@Configuration+File] if one is found, or
# in <tt>~/</tt> otherwise.
#
# A new \IRB session creates the history file if it does not exist,
# and appends to the file if it does exist.
#
# You can change the filepath by adding to your configuration file:
# <tt>IRB.conf[:HISTORY_FILE] = _filepath_</tt>,
# where _filepath_ is a string filepath.
#
# During the session, method <tt>conf.history_file</tt> returns the filepath,
# and method <tt>conf.history_file = <i>new_filepath</i></tt>
# copies the history to the file at <i>new_filepath</i>,
# which becomes the history file for the session.
#
# You can change the number of commands saved by adding to your configuration file:
# <tt>IRB.conf[:SAVE_HISTORY] = _n_</tt>,
# where _n_ is one of:
#
# - Positive integer: the number of commands to be saved,
# - Zero: all commands are to be saved.
# - +nil+: no commands are to be saved,.
#
# During the session, you can use
# methods <tt>conf.save_history</tt> or <tt>conf.save_history=</tt>
# to retrieve or change the count.
#
# === Command Aliases
#
# By default, \IRB defines several command aliases:
#
#   irb(main):001> conf.command_aliases
#   => {:"$"=>:show_source, :"@"=>:whereami}
#
# You can change the initial aliases in the configuration file with:
#
#   IRB.conf[:COMMAND_ALIASES] = {foo: :show_source, bar: :whereami}
#
# You can replace the current aliases at any time
# with configuration method <tt>conf.command_aliases=</tt>;
# Because <tt>conf.command_aliases</tt> is a hash,
# you can modify it.
#
# === End-of-File
#
# By default, <tt>IRB.conf[:IGNORE_EOF]</tt> is +false+,
# which means that typing the end-of-file character <tt>Ctrl-D</tt>
# causes the session to exit.
#
# You can reverse that behavior by adding <tt>IRB.conf[:IGNORE_EOF] = true</tt>
# to the configuration file.
#
# During the session, method <tt>conf.ignore_eof?</tt> returns the setting,
# and method <tt>conf.ignore_eof = _boolean_</tt> sets it.
#
# === SIGINT
#
# By default, <tt>IRB.conf[:IGNORE_SIGINT]</tt> is +true+,
# which means that typing the interrupt character <tt>Ctrl-C</tt>
# causes the session to exit.
#
# You can reverse that behavior by adding <tt>IRB.conf[:IGNORE_SIGING] = false</tt>
# to the configuration file.
#
# During the session, method <tt>conf.ignore_siging?</tt> returns the setting,
# and method <tt>conf.ignore_sigint = _boolean_</tt> sets it.
#
# === Automatic Completion
#
# By default, \IRB enables
# {automatic completion}[https://en.wikipedia.org/wiki/Autocomplete#In_command-line_interpreters]:
#
# You can disable it by either of these:
#
# - Adding <tt>IRB.conf[:USE_AUTOCOMPLETE] = false</tt> to the configuration file.
# - Giving command-line option <tt>--noautocomplete</tt>
#   (<tt>--autocomplete</tt> is the default).
#
# \Method <tt>conf.use_autocomplete?</tt> returns +true+
# if automatic completion is enabled, +false+ otherwise.
#
# The setting may not be changed during the session.
#
# === Automatic Indentation
#
# By default, \IRB automatically indents lines of code to show structure
# (e.g., it indent the contents of a block).
#
# The current setting is returned
# by the configuration method <tt>conf.auto_indent_mode</tt>.
#
# The default initial setting is +true+:
#
#   irb(main):001> conf.auto_indent_mode
#   => true
#   irb(main):002* Dir.entries('.').select do |entry|
#   irb(main):003*   entry.start_with?('R')
#   irb(main):004> end
#   => ["README.md", "Rakefile"]
#
# You can change the initial setting in the
# configuration file with:
#
#   IRB.conf[:AUTO_INDENT] = false
#
# Note that the _current_ setting <i>may not</i> be changed in the \IRB session.
#
# === Input \Method
#
# The \IRB input method determines how command input is to be read;
# by default, the input method for a session is IRB::RelineInputMethod.
#
# You can set the input method by:
#
# - Adding to the configuration file:
#
#   - <tt>IRB.conf[:USE_SINGLELINE] = true</tt>
#     or <tt>IRB.conf[:USE_MULTILINE]= false</tt>
#     sets the input method to IRB::ReadlineInputMethod.
#   - <tt>IRB.conf[:USE_SINGLELINE] = false</tt>
#     or <tt>IRB.conf[:USE_MULTILINE] = true</tt>
#     sets the input method to IRB::RelineInputMethod.
#
# - Giving command-line options:
#
#   - <tt>--singleline</tt>
#     or <tt>--nomultiline</tt>
#     sets the input method to IRB::ReadlineInputMethod.
#   - <tt>--nosingleline</tt>
#     or <tt>--multiline/tt>
#     sets the input method to IRB::RelineInputMethod.
#
# \Method <tt>conf.use_multiline?</tt>
# and its synonym <tt>conf.use_reline</tt> return:
#
# - +true+ if option <tt>--multiline</tt> was given.
# - +false+ if option <tt>--nomultiline</tt> was given.
# - +nil+ if neither was given.
#
# \Method <tt>conf.use_singleline?</tt>
# and its synonym <tt>conf.use_readline</tt> return:
#
# - +true+ if option <tt>--singleline</tt> was given.
# - +false+ if option <tt>--nosingleline</tt> was given.
# - +nil+ if neither was given.
#
# == Output
#
# This section describes the features that allow you to change
# the way \IRB output works;
# see also {Input and Output}[rdoc-ref:IRB@Input+and+Output].
#
# === Return-Value Printing (Echoing)
#
# By default, \IRB prints (echoes) the values returned by all input commands.
#
# You can change the initial behavior and suppress all echoing by:
#
# - Adding to the configuration file: <tt>IRB.conf[:ECHO] = false</tt>.
#   (The default value for this entry is +nil+, which means the same as +true+.)
# - Giving command-line option <tt>--noecho</tt>.
#   (The default is <tt>--echo</tt>.)
#
# During the session, you can change the current setting
# with configuration method <tt>conf.echo=</tt> (set to +true+ or +false+).
#
# As stated above, by default \IRB prints the values returned by all input commands;
# but \IRB offers special treatment for values returned by assignment statements,
# which may be:
#
# - Printed with truncation (to fit on a single line of output),
#   which is the default;
#   an ellipsis (<tt>...</tt> is suffixed, to indicate the truncation):
#
#     irb(main):001> x = 'abc' * 100
# => "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
#
# - Printed in full (regardless of the length).
# - Suppressed (not printed at all)
#
# You can change the initial behavior by:
#
# - Adding to the configuration file: <tt>IRB.conf[:ECHO_ON_ASSIGNMENT] = false</tt>.
#   (The default value for this entry is +niL+, which means the same as +:truncate+.)
# - Giving command-line option <tt>--noecho-on-assignment</tt>
#   or <tt>--echo-on-assignment</tt>.
#   (The default is <tt>--truncate-echo-on-assignment</tt>.)
#
# During the session, you can change the current setting
# with configuration method <tt>conf.echo_on_assignment=</tt>
# (set to +true+, +false+, or +:truncate+).
#
# By default, \IRB formats returned values by calling method +inspect+.
#
# You can change the initial behavior by:
#
# - Adding to the configuration file: <tt>IRB.conf[:INSPECT_MODE] = false</tt>.
#   (The default value for this entry is +true+.)
# - Giving command-line option <tt>--noinspect</tt>.
#   (The default is <tt>--inspect</tt>.)
#
# During the session, you can change the setting using method <tt>conf.inspect_mode=</tt>.
#
# === Multiline Output
#
# By default, \IRB prefixes a newline to a multiline response.
#
# You can change the initial default value by adding to the configuration file:
#
#   IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT] = false
#
# During a session, you can retrieve or set the value using
# methods <tt>conf.newline_before_multiline_output?</tt>
# and <tt>conf.newline_before_multiline_output=</tt>.
#
# Examples:
#
#   irb(main):001> conf.inspect_mode = false
#   => false
#   irb(main):002> "foo\nbar"
#   =>
#   foo
#   bar
#   irb(main):003> conf.newline_before_multiline_output = false
#   => false
#   irb(main):004> "foo\nbar"
#   => foo
#   bar
#
# === Evaluation History
#
# By default, \IRB saves no history of evaluations (returned values),
# and the related methods <tt>conf.eval_history</tt>, <tt>_</tt>,
# and <tt>__</tt> are undefined.
#
# You can turn on that history, and set the maximum number of evaluations to be stored:
#
# - In the configuration file: add <tt>IRB.conf[:EVAL_HISTORY] = _n_</tt>.
#   (Examples below assume that we've added <tt>IRB.conf[:EVAL_HISTORY] = 5</tt>.)
# - In the session (at any time): <tt>conf.eval_history = _n_</tt>.
#
# If +n+ is zero, all evaluation history is stored.
#
# Doing either of the above:
#
# - Sets the maximum size of the evaluation history;
#   defines method <tt>conf.eval_history</tt>,
#   which returns the maximum size +n+ of the evaluation history:
#
#     irb(main):001> conf.eval_history = 5
#     => 5
#     irb(main):002> conf.eval_history
#     => 5
#
# - Defines variable <tt>_</tt>, which contains the most recent evaluation,
#   or +nil+ if none; same as method <tt>conf.last_value</tt>:
#
#     irb(main):003> _
#     => 5
#     irb(main):004> :foo
#     => :foo
#     irb(main):005> :bar
#     => :bar
#     irb(main):006> _
#     => :bar
#     irb(main):007> _
#     => :bar
#
# - Defines variable <tt>__</tt>:
#
#   - <tt>__</tt> unadorned: contains all evaluation history:
#
#       irb(main):008> :foo
#       => :foo
#       irb(main):009> :bar
#       => :bar
#       irb(main):010> :baz
#       => :baz
#       irb(main):011> :bat
#       => :bat
#       irb(main):012> :bam
#       => :bam
#       irb(main):013> __
#       =>
#       9 :bar
#       10 :baz
#       11 :bat
#       12 :bam
#       irb(main):014> __
#       =>
#       10 :baz
#       11 :bat
#       12 :bam
#       13 ...self-history...
#
#     Note that when the evaluation is multiline, it is displayed differently.
#
#   - <tt>__[</tt>_m_<tt>]</tt>:
#
#     - Positive _m_:  contains the evaluation for the given line number,
#       or +nil+ if that line number is not in the evaluation history:
#
#         irb(main):015> __[12]
#         => :bam
#         irb(main):016> __[1]
#         => nil
#
#     - Negative _m_: contains the +mth+-from-end evaluation,
#       or +nil+ if that evaluation is not in the evaluation history:
#
#         irb(main):017> __[-3]
#         => :bam
#         irb(main):018> __[-13]
#         => nil
#
#     - Zero _m_: contains +nil+:
#
#         irb(main):019> __[0]
#         => nil
#
# === Prompt and Return Formats
#
# By default, \IRB uses the prompt and return value formats
# defined in its +:DEFAULT+ prompt mode.
#
# ==== The Default Prompt and Return Format
#
# The default prompt and return values look like this:
#
#   irb(main):001> 1 + 1
#   => 2
#   irb(main):002> 2 + 2
#   => 4
#
# The prompt includes:
#
# - The name of the running program (<tt>irb</tt>);
#   see {IRB Name}[rdoc-ref:IRB@IRB+Name].
# - The name of the current session (<tt>main</tt>);
#   See {IRB Sessions}[rdoc-ref:IRB@IRB+Sessions].
# - A 3-digit line number (1-based).
#
# The default prompt actually defines three formats:
#
# - One for most situations (as above):
#
#     irb(main):003> Dir
#     => Dir
#
# - One for when the typed command is a statement continuation (adds trailing asterisk):
#
#     irb(main):004* Dir.
#
# - One for when the typed command is a string continuation (adds trailing single-quote):
#
#     irb(main):005' Dir.entries('.
#
# You can see the prompt change as you type the characters in the following:
#
#     irb(main):001* Dir.entries('.').select do |entry|
#     irb(main):002*   entry.start_with?('R')
#     irb(main):003> end
#     => ["README.md", "Rakefile"]
#
# ==== Pre-Defined Prompts
#
# \IRB has several pre-defined prompts, stored in hash <tt>IRB.conf[:PROMPT]</tt>:
#
#   irb(main):001> IRB.conf[:PROMPT].keys
#   => [:NULL, :DEFAULT, :CLASSIC, :SIMPLE, :INF_RUBY, :XMP]
#
# To see the full data for these, type <tt>IRB.conf[:PROMPT]</tt>.
#
# Most of these prompt definitions include specifiers that represent
# values like the \IRB name, session name, and line number;
# see {Prompt Specifiers}[rdoc-ref:IRB@Prompt+Specifiers].
#
# You can change the initial prompt and return format by:
#
# - Adding to the configuration file: <tt>IRB.conf[:PROMPT] = _mode_</tt>
#   where _mode_ is the symbol name of a prompt mode.
# - Giving a command-line option:
#
#   - <tt>--prompt _mode_</tt>: sets the prompt mode to _mode_.
#     where _mode_ is the symbol name of a prompt mode.
#   - <tt>--simple-prompt</tt> or <tt>--sample-book-mode</tt>:
#     sets the prompt mode to +:SIMPLE+.
#   - <tt>--inf-ruby-mode</tt>: sets the prompt mode to +:INF_RUBY+
#     and suppresses both <tt>--multiline</tt> and <tt>--singleline</tt>.
#   - <tt>--noprompt</tt>: suppresses prompting; does not affect echoing.
#
# You can retrieve or set the current prompt mode with methods
#
# <tt>conf.prompt_mode</tt> and <tt>conf.prompt_mode=</tt>.
#
# If you're interested in prompts and return formats other than the defaults,
# you might experiment by trying some of the others.
#
# ==== Custom Prompts
#
# You can also define custom prompts and return formats,
# which may be done either in an \IRB session or in the configuration file.
#
# A prompt in \IRB actually defines three prompts, as seen above.
# For simple custom data, we'll make all three the same:
#
#   irb(main):001* IRB.conf[:PROMPT][:MY_PROMPT] = {
#   irb(main):002*   PROMPT_I: ': ',
#   irb(main):003*   PROMPT_C: ': ',
#   irb(main):004*   PROMPT_S: ': ',
#   irb(main):005*   RETURN: '=> '
#   irb(main):006> }
#   => {:PROMPT_I=>": ", :PROMPT_C=>": ", :PROMPT_S=>": ", :RETURN=>"=> "}
#
# If you define the custom prompt in the configuration file,
# you can also make it the current prompt by adding:
#
#   IRB.conf[:PROMPT_MODE] = :MY_PROMPT
#
# Regardless of where it's defined, you can make it the current prompt in a session:
#
#   conf.prompt_mode = :MY_PROMPT
#
# You can view or modify the current prompt data with various configuration methods:
#
# - <tt>conf.prompt_mode</tt>, <tt>conf.prompt_mode=</tt>.
# - <tt>conf.prompt_c</tt>, <tt>conf.c=</tt>.
# - <tt>conf.prompt_i</tt>, <tt>conf.i=</tt>.
# - <tt>conf.prompt_s</tt>, <tt>conf.s=</tt>.
# - <tt>conf.return_format</tt>, <tt>return_format=</tt>.
#
# ==== Prompt Specifiers
#
# A prompt's definition can include specifiers for which certain values are substituted:
#
# - <tt>%N</tt>: the name of the running program.
# - <tt>%m</tt>: the value of <tt>self.to_s</tt>.
# - <tt>%M</tt>: the value of <tt>self.inspect</tt>.
# - <tt>%l</tt>: an indication of the type of string;
#   one of <tt>"</tt>, <tt>'</tt>, <tt>/</tt>, <tt>]</tt>.
# - <tt><i>NN</i>i</tt>: Indentation level.
# - <tt><i>NN</i>n</tt>: Line number.
# - <tt>%%</tt>: Literal <tt>%</tt>.
#
# === Verbosity
#
# By default, \IRB verbosity is disabled, which means that output is smaller
# rather than larger.
#
# You can enable verbosity by:
#
# - Adding to the configuration file: <tt>IRB.conf[:VERBOSE] = true</tt>
#   (the default is +nil+).
# - Giving command-line options <tt>--verbose</tt>
#   (the default is <tt>--noverbose</tt>).
#
# During a session, you can retrieve or set verbosity with methods
# <tt>conf.verbose</tt> and <tt>conf.verbose=</tt>.
#
# === Help
#
# Command-line option <tt>--version</tt> causes \IRB to print its help text
# and exit.
#
# === Version
#
# Command-line option <tt>--version</tt> causes \IRB to print its version text
# and exit.
#
# == Input and Output
#
# === \Color Highlighting
#
# By default, \IRB color highlighting is enabled, and is used for both:
#
# - Input: As you type, \IRB reads the typed characters and highlights
#   elements that it recognizes;
#   it also highlights errors such as mismatched parentheses.
# - Output: \IRB highlights syntactical elements.
#
# You can disable color highlighting by:
#
# - Adding to the configuration file: <tt>IRB.conf[:USE_COLORIZE] = false</tt>
#   (the default value is +true+).
# - Giving command-line option <tt>--nocolorize</tt>
#
# == Debugging
#
# Command-line option <tt>-d</tt> sets variables <tt>$VERBOSE</tt>
# and <tt>$DEBUG</tt> to +true+;
# these have no effect on \IRB output.
#
# === Warnings
#
# Command-line option <tt>-w</tt> suppresses warnings.
#
# Command-line option <tt>-W[_level_]<tt>
# sets warning level; 0=silence, 1=medium, 2=verbose.
#
# == Other Features
#
# === Load Modules
#
# You can specify the names of modules that are to be required at startup.
#
# \Array <tt>conf.load_modules</tt> determines the modules (if any)
# that are to be required during session startup.
# The array is used only during session startup,
# so the initial value is the only one that counts.
#
# The default initial value is <tt>[]</tt> (load no modules):
#
#   irb(main):001> conf.load_modules
#   => []
#
# You can set the default initial value via:
#
# - Command-line option <tt>-r</tt>
#
#     $ irb -r csv -r json
#    irb(main):001> conf.load_modules
#    => ["csv", "json"]
#
# - \Hash entry <tt>IRB.conf[:LOAD_MODULES] = _array_</tt>:
#
#     IRB.conf[:LOAD_MODULES] = %w[csv, json]
#
# Note that the configuration file entry overrides the command-line options.
#
# === RI Documentation Directories
#
# You can specify the paths to RI documentation directories
# that are to be loaded (in addition to the default directories) at startup;
# see details about RI by typing <tt>ri --help</tt>.
#
# \Array <tt>conf.extra_doc_dirs</tt> determines the directories (if any)
# that are to be loaded during session startup.
# The array is used only during session startup,
# so the initial value is the only one that counts.
#
# The default initial value is <tt>[]</tt> (load no extra documentation):
#
#   irb(main):001> conf.extra_doc_dirs
#   => []
#
# You can set the default initial value via:
#
# - Command-line option <tt>--extra_doc_dir</tt>
#
#     $ irb --extra-doc-dir your_doc_dir --extra-doc-dir my_doc_dir
#     irb(main):001> conf.extra_doc_dirs
#     => ["your_doc_dir", "my_doc_dir"]
#
# - \Hash entry <tt>IRB.conf[:EXTRA_DOC_DIRS] = _array_</tt>:
#
#     IRB.conf[:EXTRA_DOC_DIRS] = %w[your_doc_dir my_doc_dir]
#
# Note that the configuration file entry overrides the command-line options.
#
# === \IRB Name
#
# You can specify a name for \IRB.
#
# The default initial value is <tt>'irb'</tt>:
#
#   irb(main):001> conf.irb_name
#   => "irb"
#
# You can set the default initial value
# via hash entry <tt>IRB.conf[:IRB_NAME] = _string_</tt>:
#
#   IRB.conf[:IRB_NAME] = 'foo'
#
# === Application Name
#
# You can specify an application name for the \IRB session.
#
# The default initial value is <tt>'irb'</tt>:
#
#   irb(main):001> conf.ap_name
#   => "irb"
#
# You can set the default initial value
# via hash entry <tt>IRB.conf[:AP_NAME] = _string_</tt>:
#
#   IRB.conf[:AP_NAME] = 'my_ap_name'
#
# === Configuration Monitor
#
# You can monitor changes to the configuration by assigning a proc
# to <tt>IRB.conf[:IRB_RC]</tt> in the configuration file:
#
#   IRB.conf[:IRB_RC] = proc {|conf| puts conf.class }
#
# Each time the configuration is changed,
# that proc is called with argument +conf+:
#
# === Encodings
#
# Command-line option <tt>-E _ex_[:_in_]</tt>
# sets initial external (ex) and internal (in) encodings.
#
# Command-line option <tt>-U</tt> sets both to UTF-8.
#
# === Commands
#
# Please use the `show_cmds` command to see the list of available commands.
#
# === IRB Sessions
#
# IRB has a special feature, that allows you to manage many sessions at once.
#
# You can create new sessions with Irb.irb, and get a list of current sessions
# with the +jobs+ command in the prompt.
#
# ==== Configuration
#
# The command line options, or IRB.conf, specify the default behavior of
# Irb.irb.
#
# On the other hand, each conf in IRB@Command-Line+Options is used to
# individually configure IRB.irb.
#
# If a proc is set for <code>IRB.conf[:IRB_RC]</code>, its will be invoked after execution
# of that proc with the context of the current session as its argument. Each
# session can be configured using this mechanism.
#
# ==== Session variables
#
# There are a few variables in every Irb session that can come in handy:
#
# <code>_</code>::
#   The value command executed, as a local variable
# <code>__</code>::
#   The history of evaluated commands. Available only if
#   <code>IRB.conf[:EVAL_HISTORY]</code> is not +nil+ (which is the default).
#   See also IRB::Context#eval_history= and IRB::History.
# <code>__[line_no]</code>::
#   Returns the evaluation value at the given line number, +line_no+.
#   If +line_no+ is a negative, the return value +line_no+ many lines before
#   the most recent return value.
#
# == Restrictions
#
# Ruby code typed into \IRB behaves the same as Ruby code in a file, except that:
#
# - Because \IRB evaluates input immediately after it is syntactically complete,
#   some results may be slightly different.
# - Forking may not be well behaved.
#
# source://irb//lib/irb/init.rb#7
module IRB
  class << self
    # The current IRB::Context of the session, see IRB.conf
    #
    #   irb
    #   irb(main):001:0> IRB.CurrentContext.irb_name = "foo"
    #   foo(main):002:0> IRB.conf[:MAIN_CONTEXT].irb_name #=> "foo"
    #
    # source://irb//lib/irb.rb#868
    def CurrentContext; end

    # Convenience method to create a new Inspector, using the given +inspect+
    # proc, and optional +init+ proc and passes them to Inspector.new
    #
    #     irb(main):001:0> ins = IRB::Inspector(proc{ |v| "omg! #{v}" })
    #     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
    #     irb(main):001:0> "what?" #=> omg! what?
    #
    # source://irb//lib/irb/inspector.rb#17
    def Inspector(inspect, init = T.unsafe(nil)); end

    # Displays current configuration.
    #
    # Modifying the configuration is achieved by sending a message to IRB.conf.
    #
    # See IRB@Configuration for more information.
    #
    # source://irb//lib/irb/init.rb#15
    def conf; end

    # source://irb//lib/irb/init.rb#64
    def init_config(ap_path); end

    # source://irb//lib/irb/init.rb#245
    def init_error; end

    # @return [Boolean]
    #
    # source://irb//lib/irb/init.rb#45
    def initialized?; end

    # Aborts then interrupts irb.
    #
    # Will raise an Abort exception, or the given +exception+.
    #
    # source://irb//lib/irb.rb#895
    def irb_abort(irb, exception = T.unsafe(nil)); end

    # Quits irb
    #
    # source://irb//lib/irb.rb#888
    def irb_exit(*_arg0); end

    # loading modules
    #
    # source://irb//lib/irb/init.rb#451
    def load_modules; end

    # option analyzing
    #
    # source://irb//lib/irb/init.rb#250
    def parse_opts(argv: T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#410
    def rc_file(ext = T.unsafe(nil)); end

    # enumerate possible rc-file base name generators
    #
    # @yield [proc{|rc| current_dir+"/.irb#{rc}"}]
    #
    # source://irb//lib/irb/init.rb#429
    def rc_file_generators; end

    # Run the config file
    #
    # source://irb//lib/irb/init.rb#396
    def run_config; end

    # source://irb//lib/irb/init.rb#198
    def set_measure_callback(type = T.unsafe(nil), arg = T.unsafe(nil), &block); end

    # initialize config
    #
    # source://irb//lib/irb/init.rb#50
    def setup(ap_path, argv: T.unsafe(nil)); end

    # Initializes IRB and creates a new Irb.irb object at the +TOPLEVEL_BINDING+
    #
    # source://irb//lib/irb.rb#873
    def start(ap_path = T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#235
    def unset_measure_callback(type = T.unsafe(nil)); end

    # Returns the current version of IRB, including release version and last
    # updated date.
    #
    # source://irb//lib/irb/init.rb#41
    def version; end

    private

    # source://irb//lib/irb/easter-egg.rb#109
    def easter_egg(type = T.unsafe(nil)); end

    # source://irb//lib/irb/easter-egg.rb#101
    def easter_egg_logo(type); end

    # source://irb//lib/irb/init.rb#463
    def set_encoding(extern, intern = T.unsafe(nil), override: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/completion.rb#11
class IRB::BaseCompletor
  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/completion.rb#36
  def completion_candidates(preposing, target, postposing, bind:); end

  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/completion.rb#40
  def doc_namespace(preposing, matched, postposing, bind:); end

  # source://irb//lib/irb/completion.rb#70
  def retrieve_files_to_require_from_load_path; end

  # source://irb//lib/irb/completion.rb#89
  def retrieve_files_to_require_relative_from_current_dir; end

  # source://irb//lib/irb/completion.rb#59
  def retrieve_gem_and_system_load_path; end
end

# source://irb//lib/irb/completion.rb#44
IRB::BaseCompletor::GEM_PATHS = T.let(T.unsafe(nil), Array)

# Set of reserved words used by Ruby, you should not use these for
# constants or variables
#
# source://irb//lib/irb/completion.rb#15
IRB::BaseCompletor::ReservedWords = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/color.rb#7
module IRB::Color
  class << self
    # source://irb//lib/irb/color.rb#114
    def clear(colorable: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#81
    def colorable?; end

    # source://irb//lib/irb/color.rb#119
    def colorize(text, seq, colorable: T.unsafe(nil)); end

    # If `complete` is false (code is incomplete), this does not warn compile_error.
    # This option is needed to avoid warning a user when the compile_error is happening
    # because the input is not wrong but just incomplete.
    #
    # source://irb//lib/irb/color.rb#128
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#93
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    # source://irb//lib/irb/color.rb#213
    def dispatch_seq(token, expr, str, in_symbol:); end

    # source://irb//lib/irb/color.rb#177
    def scan(code, allow_last_error:); end

    # source://irb//lib/irb/color.rb#169
    def without_circular_ref(obj, seen:, &block); end
  end
end

# A constant of all-bit 1 to match any Ripper's state in #dispatch_seq
#
# source://irb//lib/irb/color.rb#28
IRB::Color::ALL = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#12
IRB::Color::BLACK = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#16
IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#9
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#8
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#18
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#77
IRB::Color::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/color.rb#14
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#17
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#13
IRB::Color::RED = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#11
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)

# A class to manage a state to know whether the current token is for Symbol or not.
#
# source://irb//lib/irb/color.rb#229
class IRB::Color::SymbolState
  # @return [SymbolState] a new instance of SymbolState
  #
  # source://irb//lib/irb/color.rb#230
  def initialize; end

  # Return true if the token is a part of Symbol.
  #
  # source://irb//lib/irb/color.rb#236
  def scan_token(token); end
end

# source://irb//lib/irb/color.rb#21
IRB::Color::TOKEN_KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#34
IRB::Color::TOKEN_SEQ_EXPRS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#10
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#19
IRB::Color::WHITE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#15
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/context.rb#15
class IRB::Context
  # Creates a new IRB context.
  #
  # The optional +input_method+ argument:
  #
  # +nil+::     uses stdin or Reline or Readline
  # +String+::  uses a File
  # +other+::   uses this as InputMethod
  #
  # @return [Context] a new instance of Context
  #
  # source://irb//lib/irb/context.rb#23
  def initialize(irb, workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#241
  def ap_name; end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#241
  def ap_name=(_arg0); end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#311
  def auto_indent_mode; end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#311
  def auto_indent_mode=(_arg0); end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # source://irb//lib/irb/context.rb#402
  def back_trace_limit; end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # source://irb//lib/irb/context.rb#402
  def back_trace_limit=(_arg0); end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#405
  def command_aliases; end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#405
  def command_aliases=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#342
  def echo; end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#342
  def echo=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#342
  def echo?; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#377
  def echo_on_assignment; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#377
  def echo_on_assignment=(_arg0); end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#377
  def echo_on_assignment?; end

  # Sets command result history limit. Default value is set from
  # <code>IRB.conf[:EVAL_HISTORY]</code>.
  #
  # +no+ is an Integer or +nil+.
  #
  # Returns +no+ of history items if greater than 0.
  #
  # If +no+ is 0, the number of history items is unlimited.
  #
  # If +no+ is +nil+, execution result history isn't used (default).
  #
  # EvalHistory values are available via <code>__</code> variable, see
  # IRB::EvalHistory.
  #
  # source://irb//lib/irb/extend-command.rb#340
  def eval_history=(*opts, &b); end

  # source://irb//lib/irb/context.rb#550
  def evaluate(line, line_no); end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#331
  def extra_doc_dirs; end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#331
  def extra_doc_dirs=(_arg0); end

  # Whether #io uses a File for the +input_method+ passed when creating the
  # current context, see ::new
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#492
  def file_input?; end

  # A copy of the default <code>IRB.conf[:HISTORY_FILE]</code>
  #
  # source://irb//lib/irb/context.rb#211
  def history_file; end

  # Set <code>IRB.conf[:HISTORY_FILE]</code> to the given +hist+.
  #
  # source://irb//lib/irb/context.rb#216
  def history_file=(hist); end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#328
  def ignore_eof; end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#328
  def ignore_eof=(_arg0); end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#328
  def ignore_eof?; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#324
  def ignore_sigint; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#324
  def ignore_sigint=(_arg0); end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#324
  def ignore_sigint?; end

  # source://irb//lib/irb/context.rb#586
  def inspect; end

  # Whether #inspect_mode is set or not, see #inspect_mode= for more detail.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#486
  def inspect?; end

  # source://irb//lib/irb/context.rb#577
  def inspect_last_value; end

  # A copy of the default <code>IRB.conf[:INSPECT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#266
  def inspect_mode; end

  # Specifies the inspect mode with +opt+:
  #
  # +true+::  display +inspect+
  # +false+:: display +to_s+
  # +nil+::   inspect mode in non-math mode,
  #           non-inspect mode in math mode
  #
  # See IRB::Inspector for more information.
  #
  # Can also be set using the +--inspect+ and +--noinspect+ command line
  # options.
  #
  # source://irb//lib/irb/context.rb#507
  def inspect_mode=(opt); end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#236
  def io; end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#236
  def io=(_arg0); end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#239
  def irb; end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#239
  def irb=(_arg0); end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#248
  def irb_name; end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#248
  def irb_name=(_arg0); end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#251
  def irb_path; end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#251
  def irb_path=(_arg0); end

  # The return value of the last statement evaluated.
  #
  # source://irb//lib/irb/context.rb#458
  def last_value; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#245
  def load_modules; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#245
  def load_modules=(_arg0); end

  # source://irb//lib/irb/context.rb#608
  def local_variables; end

  # The top-level workspace, see WorkSpace#main
  #
  # source://irb//lib/irb/context.rb#221
  def main; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#391
  def newline_before_multiline_output; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#391
  def newline_before_multiline_output=(_arg0); end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#391
  def newline_before_multiline_output?; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#281
  def prompt_c; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#281
  def prompt_c=(_arg0); end

  # Standard IRB prompt.
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#273
  def prompt_i; end

  # Standard IRB prompt.
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#273
  def prompt_i=(_arg0); end

  # A copy of the default <code>IRB.conf[:PROMPT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#269
  def prompt_mode; end

  # Sets the +mode+ of the prompt in this context.
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#470
  def prompt_mode=(mode); end

  # TODO: Remove this when developing v2.0
  #
  # source://irb//lib/irb/context.rb#284
  def prompt_n; end

  # TODO: Remove this when developing v2.0
  #
  # source://irb//lib/irb/context.rb#290
  def prompt_n=(_); end

  # IRB prompt for continuated strings.
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#277
  def prompt_s; end

  # IRB prompt for continuated strings.
  #
  # See {Custom Prompts}[rdoc-ref:IRB@Custom+Prompts] for more information.
  #
  # source://irb//lib/irb/context.rb#277
  def prompt_s=(_arg0); end

  # Whether #verbose? is +true+, and +input_method+ is either
  # StdioInputMethod or RelineInputMethod or ReadlineInputMethod, see #io
  # for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#451
  def prompting?; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#243
  def rc; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#243
  def rc=(_arg0); end

  # A copy of the default <code>IRB.conf[:RC]</code>
  # Alias for #rc
  #
  # source://irb//lib/irb/context.rb#243
  def rc?; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#314
  def return_format; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#314
  def return_format=(_arg0); end

  # source://irb//lib/irb/context.rb#206
  def save_history; end

  # source://irb//lib/irb/context.rb#202
  def save_history=(val); end

  # Sets the return value from the last statement evaluated in this context
  # to #last_value.
  #
  # source://irb//lib/irb/context.rb#462
  def set_last_value(value); end

  # Return true if it's aliased from the argument and it's not an identifier.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#613
  def symbol_alias?(command); end

  # The current thread in this context.
  #
  # source://irb//lib/irb/context.rb#230
  def thread; end

  # source://irb//lib/irb/context.rb#586
  def to_s; end

  # Return true if the command supports transforming args
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#619
  def transform_args?(command); end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  #
  # source://irb//lib/irb/context.rb#264
  def use_autocomplete; end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  # Alias for #use_autocomplete
  #
  # source://irb//lib/irb/context.rb#264
  def use_autocomplete?; end

  # Sets <code>IRB.conf[:USE_LOADER]</code>
  #
  # See #use_loader for more information.
  #
  # source://irb//lib/irb/extend-command.rb#340
  def use_loader=(*opts, &b); end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  #
  # source://irb//lib/irb/context.rb#256
  def use_multiline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # Alias for #use_multiline
  #
  # source://irb//lib/irb/context.rb#256
  def use_multiline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#260
  def use_readline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#260
  def use_readline?; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#256
  def use_reline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#256
  def use_reline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  #
  # source://irb//lib/irb/context.rb#260
  def use_singleline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # Alias for #use_singleline
  #
  # source://irb//lib/irb/context.rb#260
  def use_singleline?; end

  # source://irb//lib/irb/context.rb#164
  def use_tracer=(val); end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#395
  def verbose; end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#395
  def verbose=(_arg0); end

  # Returns whether messages are displayed or not.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#432
  def verbose?; end

  # Returns the value of attribute with_debugger.
  #
  # source://irb//lib/irb/context.rb#407
  def with_debugger; end

  # Sets the attribute with_debugger
  #
  # @param value the value to set the attribute with_debugger to.
  #
  # source://irb//lib/irb/context.rb#407
  def with_debugger=(_arg0); end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#228
  def workspace; end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#228
  def workspace=(_arg0); end

  # The toplevel workspace, see #home_workspace
  #
  # source://irb//lib/irb/context.rb#226
  def workspace_home; end

  private

  # source://irb//lib/irb/context.rb#169
  def build_completor; end

  # source://irb//lib/irb/context.rb#184
  def build_type_completor; end
end

# source://irb//lib/irb/context.rb#583
IRB::Context::IDNAME_IVARS = T.let(T.unsafe(nil), Array)

# because all input will eventually be evaluated as Ruby code,
# command names that conflict with Ruby keywords need special workaround
# we can remove them once we implemented a better command system for IRB
#
# source://irb//lib/irb/context.rb#156
IRB::Context::KEYWORD_ALIASES = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/context.rb#581
IRB::Context::NOPRINTING_IVARS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/context.rb#582
IRB::Context::NO_INSPECTING_IVARS = T.let(T.unsafe(nil), Array)

# Extends methods for the Context module
#
# source://irb//lib/irb/extend-command.rb#315
module IRB::ContextExtender
  class << self
    # Evaluate the given +command+ from the given +load_file+ on the Context
    # module.
    #
    # Will also define any given +aliases+ for the method.
    #
    # source://irb//lib/irb/extend-command.rb#338
    def def_extend_command(cmd_name, load_file, *aliases); end

    # Installs the default context extensions as irb commands:
    #
    # Context#eval_history=::   +irb/ext/history.rb+
    # Context#use_tracer=::     +irb/ext/tracer.rb+
    # Context#use_loader=::     +irb/ext/use-loader.rb+
    #
    # source://irb//lib/irb/extend-command.rb#328
    def install_extend_commands; end
  end
end

# source://irb//lib/irb/debug.rb#4
module IRB::Debug
  class << self
    # source://irb//lib/irb/debug.rb#8
    def insert_debug_break(pre_cmds: T.unsafe(nil), do_cmds: T.unsafe(nil)); end

    # source://irb//lib/irb/debug.rb#25
    def setup(irb); end

    private

    # source://irb//lib/irb/debug.rb#83
    def configure_irb_for_debugger(irb); end

    # This is used when debug.gem is not written in Gemfile. Even if it's not
    # installed by `bundle install`, debug.gem is installed by default because
    # it's a bundled gem. This method tries to activate and load that.
    #
    # source://irb//lib/irb/debug.rb#100
    def load_bundled_debug_gem; end
  end
end

# source://irb//lib/irb/debug.rb#5
IRB::Debug::IRB_DIR = T.let(T.unsafe(nil), String)

# Installs the default irb extensions command bundle.
#
# source://irb//lib/irb/extend-command.rb#9
module IRB::ExtendCommandBundle
  # Installs alias methods for the default irb commands, see
  # ::install_extend_commands.
  #
  # source://irb//lib/irb/extend-command.rb#276
  def install_alias_method(to, from, override = T.unsafe(nil)); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_backtrace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_break(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_catch(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_change_workspace(*opts, **kwargs, &b); end

  # Displays current configuration.
  #
  # Modifying the configuration is achieved by sending a message to IRB.conf.
  #
  # source://irb//lib/irb/extend-command.rb#22
  def irb_context; end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_continue(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_current_working_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_debug(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_debug_info(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_delete(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_edit(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_exit(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_fg(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_finish(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_help(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_history(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_info(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_jobs(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_kill(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
  #
  # source://irb//lib/irb/extend-command.rb#263
  def irb_load(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_ls(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_measure(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_next(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_pop_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_push_workspace(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#require
  #
  # source://irb//lib/irb/extend-command.rb#263
  def irb_require(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_cmds(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_doc(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_show_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_step(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_whereami(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#263
  def irb_workspaces(*opts, **kwargs, &b); end

  class << self
    # source://irb//lib/irb/extend-command.rb#200
    def all_commands_info; end

    # Evaluate the given +cmd_name+ on the given +cmd_class+ Class.
    #
    # Will also define any given +aliases+ for the method.
    #
    # The optional +load_file+ parameter will be required within the method
    # definition.
    #
    # source://irb//lib/irb/extend-command.rb#253
    def def_extend_command(cmd_name, cmd_class, load_file, *aliases); end

    # Installs alias methods for the default irb commands on the given object
    # using #install_alias_method.
    #
    # source://irb//lib/irb/extend-command.rb#302
    def extend_object(obj); end

    # Installs the default irb commands.
    #
    # source://irb//lib/irb/extend-command.rb#241
    def install_extend_commands; end

    # source://irb//lib/irb/extend-command.rb#296
    def irb_original_method_name(method_name); end

    # Convert a command name to its implementation class if such command exists
    #
    # source://irb//lib/irb/extend-command.rb#227
    def load_command(command); end
  end
end

# source://irb//lib/irb/extend-command.rb#10
IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

# Use a File for IO with irb, see InputMethod
#
# source://irb//lib/irb/input-method.rb#115
class IRB::FileInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [FileInputMethod] a new instance of FileInputMethod
  #
  # source://irb//lib/irb/input-method.rb#128
  def initialize(file); end

  # source://irb//lib/irb/input-method.rb#159
  def close; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#150
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#137
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#144
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#155
  def inspect; end

  class << self
    # source://irb//lib/irb/input-method.rb#117
    def open(file, &block); end
  end
end

# source://irb//lib/irb/history.rb#4
module IRB::HistorySavingAbility
  # source://irb//lib/irb/history.rb#13
  def load_history; end

  # source://irb//lib/irb/history.rb#9
  def reset_history_counter; end

  # source://irb//lib/irb/history.rb#37
  def save_history; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/history.rb#5
  def support_history_saving?; end
end

# source://irb//lib/irb/init.rb#409
IRB::IRBRC_EXT = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/completion.rb#451
module IRB::InputCompletor
  class << self
    # source://irb//lib/irb/completion.rb#457
    def retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

    private

    # source://irb//lib/irb/completion.rb#453
    def regexp_completor; end
  end
end

# source://irb//lib/irb/completion.rb#461
IRB::InputCompletor::CompletionProc = T.let(T.unsafe(nil), Proc)

# source://irb//lib/irb/input-method.rb#13
class IRB::InputMethod
  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#22
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#48
  def inspect; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#17
  def prompt; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#17
  def prompt=(_arg0); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#39
  def readable_after_eof?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#43
  def support_history_saving?; end

  # source://irb//lib/irb/input-method.rb#27
  def winsize; end
end

# source://irb//lib/irb/input-method.rb#14
IRB::InputMethod::BASIC_WORD_BREAK_CHARACTERS = T.let(T.unsafe(nil), String)

# An irb inspector
#
# In order to create your own custom inspector there are two things you
# should be aware of:
#
# Inspector uses #inspect_value, or +inspect_proc+, for output of return values.
#
# This also allows for an optional #init+, or +init_proc+, which is called
# when the inspector is activated.
#
# Knowing this, you can create a rudimentary inspector as follows:
#
#     irb(main):001:0> ins = IRB::Inspector.new(proc{ |v| "omg! #{v}" })
#     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
#     irb(main):001:0> "what?" #=> omg! what?
#
# source://irb//lib/irb/inspector.rb#37
class IRB::Inspector
  # Creates a new inspector object, using the given +inspect_proc+ when
  # output return values in irb.
  #
  # @return [Inspector] a new instance of Inspector
  #
  # source://irb//lib/irb/inspector.rb#83
  def initialize(inspect_proc, init_proc = T.unsafe(nil)); end

  # Proc to call when the inspector is activated, good for requiring
  # dependent libraries.
  #
  # source://irb//lib/irb/inspector.rb#90
  def init; end

  # Proc to call when the input is evaluated and output in irb.
  #
  # source://irb//lib/irb/inspector.rb#95
  def inspect_value(v); end

  class << self
    # Example
    #
    #     Inspector.def_inspector(key, init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector([key1,..], init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector(key, inspector)
    #     Inspector.def_inspector([key1,...], inspector)
    #
    # source://irb//lib/irb/inspector.rb#58
    def def_inspector(key, arg = T.unsafe(nil), &block); end

    # Determines the inspector to use where +inspector+ is one of the keys passed
    # during inspector definition.
    #
    # source://irb//lib/irb/inspector.rb#48
    def keys_with_inspector(inspector); end
  end
end

# source://irb//lib/irb/inspector.rb#38
IRB::Inspector::KERNEL_INSPECT = T.let(T.unsafe(nil), UnboundMethod)

# source://irb//lib/irb.rb#899
class IRB::Irb
  # Creates a new irb session
  #
  # @return [Irb] a new instance of Irb
  #
  # source://irb//lib/irb.rb#915
  def initialize(workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # source://irb//lib/irb.rb#1086
  def build_statement(code); end

  # source://irb//lib/irb.rb#1107
  def configure_io; end

  # Returns the current context of this irb session
  #
  # source://irb//lib/irb.rb#910
  def context; end

  # source://irb//lib/irb.rb#1159
  def convert_invalid_byte_sequence(str, enc); end

  # A hook point for `debug` command's breakpoint after :IRB_EXIT as well as its clean-up
  #
  # source://irb//lib/irb.rb#924
  def debug_break; end

  # source://irb//lib/irb.rb#934
  def debug_readline(binding); end

  # source://irb//lib/irb.rb#1073
  def each_top_level_statement; end

  # source://irb//lib/irb.rb#1166
  def encode_with_invalid_byte_sequence(str, enc); end

  # Evaluates input for this session.
  #
  # source://irb//lib/irb.rb#993
  def eval_input; end

  # source://irb//lib/irb.rb#1188
  def handle_exception(exc); end

  # Outputs the local variables to this current session, including
  # #signal_status and #context, using IRB::Locale.
  #
  # source://irb//lib/irb.rb#1361
  def inspect; end

  # source://irb//lib/irb.rb#1322
  def output_value(omit = T.unsafe(nil)); end

  # source://irb//lib/irb.rb#1025
  def read_input(prompt); end

  # source://irb//lib/irb.rb#1044
  def readmultiline; end

  # source://irb//lib/irb.rb#966
  def run(conf = T.unsafe(nil)); end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#912
  def scanner; end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#912
  def scanner=(_arg0); end

  # Handler for the signal SIGINT, see Kernel#trap for more information.
  #
  # source://irb//lib/irb.rb#1288
  def signal_handle; end

  # Evaluates the given block using the given +status+.
  #
  # source://irb//lib/irb.rb#1310
  def signal_status(status); end

  # @return [Boolean]
  #
  # source://irb//lib/irb.rb#1102
  def single_line_command?(code); end

  # Evaluates the given block using the given +input_method+ as the
  # Context#io.
  #
  # Used by the irb commands +source+ and +irb_load+, see IRB@IRB+Sessions
  # for more information.
  #
  # source://irb//lib/irb.rb#1277
  def suspend_input_method(input_method); end

  # Evaluates the given block using the given +path+ as the Context#irb_path
  # and +name+ as the Context#irb_name.
  #
  # Used by the irb command +source+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#1247
  def suspend_name(path = T.unsafe(nil), name = T.unsafe(nil)); end

  # Evaluates the given block using the given +workspace+ as the
  # Context#workspace.
  #
  # Used by the irb command +irb_load+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#1263
  def suspend_workspace(workspace); end

  private

  # source://irb//lib/irb.rb#1417
  def format_prompt(format, ltype, indent, line_no); end

  # source://irb//lib/irb.rb#1378
  def generate_prompt(opens, continue, line_offset); end

  # source://irb//lib/irb.rb#1408
  def truncate_prompt_main(str); end
end

# source://irb//lib/irb.rb#907
IRB::Irb::CONTROL_CHARACTERS_PATTERN = T.let(T.unsafe(nil), String)

# Note: instance and index assignment expressions could also be written like:
# "foo.bar=(1)" and "foo.[]=(1, bar)", when expressed that way, the former
# be parsed as :assign and echo will be suppressed, but the latter is
# parsed as a :method_add_arg and the output won't be suppressed
#
# source://irb//lib/irb.rb#905
IRB::Irb::PROMPT_MAIN_TRUNCATE_LENGTH = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb.rb#906
IRB::Irb::PROMPT_MAIN_TRUNCATE_OMISSION = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/locale.rb#8
class IRB::Locale
  # @return [Locale] a new instance of Locale
  #
  # source://irb//lib/irb/locale.rb#25
  def initialize(locale = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#49
  def String(mes); end

  # source://irb//lib/irb/locale.rb#126
  def each_localized_path(dir, file); end

  # @yield [nil]
  #
  # source://irb//lib/irb/locale.rb#133
  def each_sublocale; end

  # source://irb//lib/irb/locale.rb#45
  def encoding; end

  # source://irb//lib/irb/locale.rb#97
  def find(file, paths = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#58
  def format(*opts); end

  # source://irb//lib/irb/locale.rb#62
  def gets(*rs); end

  # Returns the value of attribute lang.
  #
  # source://irb//lib/irb/locale.rb#43
  def lang; end

  # source://irb//lib/irb/locale.rb#85
  def load(file); end

  # Returns the value of attribute modifier.
  #
  # source://irb//lib/irb/locale.rb#43
  def modifier; end

  # source://irb//lib/irb/locale.rb#70
  def print(*opts); end

  # source://irb//lib/irb/locale.rb#75
  def printf(*opts); end

  # source://irb//lib/irb/locale.rb#80
  def puts(*opts); end

  # source://irb//lib/irb/locale.rb#66
  def readline(*rs); end

  # typically, for the parameters and a <path> in paths, it searches
  #   <path>/<dir>/<locale>/<file>
  #
  # @param paths load paths in which IRB find a localized file.
  # @param dir directory
  # @param file basename to be localized
  #
  # source://irb//lib/irb/locale.rb#115
  def search_file(lib_paths, dir, file); end

  # Returns the value of attribute territory.
  #
  # source://irb//lib/irb/locale.rb#43
  def territory; end
end

# source://irb//lib/irb/locale.rb#18
IRB::Locale::LEGACY_ENCODING_ALIAS_MAP = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/locale.rb#16
IRB::Locale::LOCALE_DIR = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/locale.rb#10
IRB::Locale::LOCALE_NAME_RE = T.let(T.unsafe(nil), Regexp)

# source://irb//lib/irb/nesting_parser.rb#3
module IRB::NestingParser
  class << self
    # source://irb//lib/irb/nesting_parser.rb#192
    def open_tokens(tokens); end

    # Calculates token information [line_tokens, prev_opens, next_opens, min_depth] for each line.
    # Example code
    #   ["hello
    #   world"+(
    # First line
    #   line_tokens: [[lbracket, '['], [tstring_beg, '"'], [tstring_content("hello\nworld"), "hello\n"]]
    #   prev_opens:  []
    #   next_tokens: [lbracket, tstring_beg]
    #   min_depth:   0 (minimum at beginning of line)
    # Second line
    #   line_tokens: [[tstring_content("hello\nworld"), "world"], [tstring_end, '"'], [op, '+'], [lparen, '(']]
    #   prev_opens:  [lbracket, tstring_beg]
    #   next_tokens: [lbracket, lparen]
    #   min_depth:   1 (minimum just after tstring_end)
    #
    # source://irb//lib/irb/nesting_parser.rb#211
    def parse_by_line(tokens); end

    # Scan each token and call the given block with array of token and other information for parsing
    #
    # source://irb//lib/irb/nesting_parser.rb#7
    def scan_opens(tokens); end
  end
end

# source://irb//lib/irb/nesting_parser.rb#4
IRB::NestingParser::IGNORE_TOKENS = T.let(T.unsafe(nil), Array)

# An output formatter used internally by the lexer.
#
# source://irb//lib/irb/notifier.rb#11
module IRB::Notifier
  private

  # Define a new Notifier output source, returning a new CompositeNotifier
  # with the given +prefix+ and +output_method+.
  #
  # The optional +prefix+ will be appended to all objects being inspected
  # during output, using the given +output_method+ as the output source. If
  # no +output_method+ is given, StdioOutputMethod will be used, and all
  # expressions will be sent directly to STDOUT without any additional
  # formatting.
  #
  # source://irb//lib/irb/notifier.rb#31
  def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end

  class << self
    # Define a new Notifier output source, returning a new CompositeNotifier
    # with the given +prefix+ and +output_method+.
    #
    # The optional +prefix+ will be appended to all objects being inspected
    # during output, using the given +output_method+ as the output source. If
    # no +output_method+ is given, StdioOutputMethod will be used, and all
    # expressions will be sent directly to STDOUT without any additional
    # formatting.
    #
    # source://irb//lib/irb/notifier.rb#31
    def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end
  end
end

# An abstract class, or superclass, for CompositeNotifier and
# LeveledNotifier to inherit. It provides several wrapper methods for the
# OutputMethod object used by the Notifier.
#
# source://irb//lib/irb/notifier.rb#39
class IRB::Notifier::AbstractNotifier
  # Creates a new Notifier object
  #
  # @return [AbstractNotifier] a new instance of AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#41
  def initialize(prefix, base_notifier); end

  # Execute the given block if notifications are enabled.
  #
  # @yield [@base_notifier]
  #
  # source://irb//lib/irb/notifier.rb#99
  def exec_if; end

  # A wrapper method used to determine whether notifications are enabled.
  #
  # Defaults to +true+.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#53
  def notify?; end

  # Same as #ppx, except it uses the #prefix given during object
  # initialization.
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#82
  def pp(*objs); end

  # Same as #pp, except it concatenates the given +prefix+ with the #prefix
  # given during object initialization.
  #
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#92
  def ppx(prefix, *objs); end

  # The +prefix+ for this Notifier, which is appended to all objects being
  # inspected during output.
  #
  # source://irb//lib/irb/notifier.rb#48
  def prefix; end

  # See OutputMethod#print for more detail.
  #
  # source://irb//lib/irb/notifier.rb#58
  def print(*opts); end

  # See OutputMethod#printf for more detail.
  #
  # source://irb//lib/irb/notifier.rb#68
  def printf(format, *opts); end

  # See OutputMethod#printn for more detail.
  #
  # source://irb//lib/irb/notifier.rb#63
  def printn(*opts); end

  # See OutputMethod#puts for more detail.
  #
  # source://irb//lib/irb/notifier.rb#73
  def puts(*objs); end
end

# A class that can be used to create a group of notifier objects with the
# intent of representing a leveled notification system for irb.
#
# This class will allow you to generate other notifiers, and assign them
# the appropriate level for output.
#
# The Notifier class provides a class-method Notifier.def_notifier to
# create a new composite notifier. Using the first composite notifier
# object you create, sibling notifiers can be initialized with
# #def_notifier.
#
# source://irb//lib/irb/notifier.rb#114
class IRB::Notifier::CompositeNotifier < ::IRB::Notifier::AbstractNotifier
  # Create a new composite notifier object with the given +prefix+, and
  # +base_notifier+ to use for output.
  #
  # @return [CompositeNotifier] a new instance of CompositeNotifier
  #
  # source://irb//lib/irb/notifier.rb#117
  def initialize(prefix, base_notifier); end

  # Creates a new LeveledNotifier in the composite #notifiers group.
  #
  # The given +prefix+ will be assigned to the notifier, and +level+ will
  # be used as the index of the #notifiers Array.
  #
  # This method returns the newly created instance.
  #
  # source://irb//lib/irb/notifier.rb#133
  def def_notifier(level, prefix = T.unsafe(nil)); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#140
  def level; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#157
  def level=(value); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#140
  def level_notifier; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#157
  def level_notifier=(value); end

  # List of notifiers in the group
  #
  # source://irb//lib/irb/notifier.rb#125
  def notifiers; end
end

# source://irb//lib/irb/notifier.rb#12
class IRB::Notifier::ErrUndefinedNotifier < ::StandardError
  # @return [ErrUndefinedNotifier] a new instance of ErrUndefinedNotifier
  #
  # source://irb//lib/irb/notifier.rb#13
  def initialize(val); end
end

# source://irb//lib/irb/notifier.rb#17
class IRB::Notifier::ErrUnrecognizedLevel < ::StandardError
  # @return [ErrUnrecognizedLevel] a new instance of ErrUnrecognizedLevel
  #
  # source://irb//lib/irb/notifier.rb#18
  def initialize(val); end
end

# A leveled notifier is comparable to the composite group from
# CompositeNotifier#notifiers.
#
# source://irb//lib/irb/notifier.rb#175
class IRB::Notifier::LeveledNotifier < ::IRB::Notifier::AbstractNotifier
  include ::Comparable

  # Create a new leveled notifier with the given +base+, and +prefix+ to
  # send to AbstractNotifier.new
  #
  # The given +level+ is used to compare other leveled notifiers in the
  # CompositeNotifier group to determine whether or not to output
  # notifications.
  #
  # @return [LeveledNotifier] a new instance of LeveledNotifier
  #
  # source://irb//lib/irb/notifier.rb#184
  def initialize(base, level, prefix); end

  # Compares the level of this notifier object with the given +other+
  # notifier.
  #
  # See the Comparable module for more information.
  #
  # source://irb//lib/irb/notifier.rb#197
  def <=>(other); end

  # The current level of this notifier object
  #
  # source://irb//lib/irb/notifier.rb#191
  def level; end

  # Whether to output messages to the output method, depending on the level
  # of this notifier object.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#203
  def notify?; end
end

# NoMsgNotifier is a LeveledNotifier that's used as the default notifier
# when creating a new CompositeNotifier.
#
# This notifier is used as the +zero+ index, or level +0+, for
# CompositeNotifier#notifiers, and will not output messages of any sort.
#
# source://irb//lib/irb/notifier.rb#213
class IRB::Notifier::NoMsgNotifier < ::IRB::Notifier::LeveledNotifier
  # Creates a new notifier that should not be used to output messages.
  #
  # @return [NoMsgNotifier] a new instance of NoMsgNotifier
  #
  # source://irb//lib/irb/notifier.rb#215
  def initialize; end

  # Ensures notifications are ignored, see AbstractNotifier#notify? for
  # more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#223
  def notify?; end
end

# An abstract output class for IO in irb. This is mainly used internally by
# IRB::Notifier. You can define your own output method to use with Irb.new,
# or Context.new
#
# source://irb//lib/irb/output-method.rb#11
class IRB::OutputMethod
  # Returns an array of the given +format+ and +opts+ to be used by
  # Kernel#sprintf, if there was a successful Regexp match in the given
  # +format+ from #printf
  #
  #     %
  #     <flag>  [#0- +]
  #     <minimum field width> (\*|\*[1-9][0-9]*\$|[1-9][0-9]*)
  #     <precision>.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)?
  #     #<length modifier>(hh|h|l|ll|L|q|j|z|t)
  #     <conversion specifier>[diouxXeEfgGcsb%]
  #
  # source://irb//lib/irb/output-method.rb#48
  def parse_printf_format(format, opts); end

  # Prints the given +objs+ calling Object#inspect on each.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#64
  def pp(*objs); end

  # Prints the given +objs+ calling Object#inspect on each and appending the
  # given +prefix+.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#72
  def ppx(prefix, *objs); end

  # Open this method to implement your own output method, raises a
  # NotImplementedError if you don't define #print in your own class.
  #
  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/output-method.rb#20
  def print(*opts); end

  # Extends IO#printf to format the given +opts+ for Kernel#sprintf using
  # #parse_printf_format
  #
  # source://irb//lib/irb/output-method.rb#31
  def printf(format, *opts); end

  # Prints the given +opts+, with a newline delimiter.
  #
  # source://irb//lib/irb/output-method.rb#25
  def printn(*opts); end

  # Calls #print on each element in the given +objs+, followed by a newline
  # character.
  #
  # source://irb//lib/irb/output-method.rb#54
  def puts(*objs); end
end

# source://irb//lib/irb/output-method.rb#12
class IRB::OutputMethod::NotImplementedError < ::StandardError
  # @return [NotImplementedError] a new instance of NotImplementedError
  #
  # source://irb//lib/irb/output-method.rb#13
  def initialize(val); end
end

# The implementation of this class is borrowed from RDoc's lib/rdoc/ri/driver.rb.
# Please do NOT use this class directly outside of IRB.
#
# source://irb//lib/irb/pager.rb#6
class IRB::Pager
  class << self
    # source://irb//lib/irb/pager.rb#20
    def page(retain_content: T.unsafe(nil)); end

    # source://irb//lib/irb/pager.rb#10
    def page_content(content, **options); end

    private

    # @return [Boolean]
    #
    # source://irb//lib/irb/pager.rb#47
    def content_exceeds_screen_height?(content); end

    # source://irb//lib/irb/pager.rb#62
    def setup_pager(retain_content:); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/pager.rb#43
    def should_page?; end
  end
end

# source://irb//lib/irb/pager.rb#7
IRB::Pager::PAGE_COMMANDS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/input-method.rb#164
class IRB::ReadlineInputMethod < ::IRB::StdioInputMethod
  include ::IRB::HistorySavingAbility

  # Creates a new input method object using Readline
  #
  # @return [ReadlineInputMethod] a new instance of ReadlineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#175
  def initialize; end

  # source://irb//lib/irb/input-method.rb#196
  def completion_info; end

  # Whether the end of this input method has been reached, returns +true+
  # if there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#219
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#203
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#224
  def inspect; end

  class << self
    # source://irb//lib/irb/input-method.rb#165
    def initialize_readline; end
  end
end

# source://irb//lib/irb/completion.rb#117
class IRB::RegexpCompletor < ::IRB::BaseCompletor
  # source://irb//lib/irb/completion.rb#146
  def complete_require_path(target, preposing, postposing); end

  # source://irb//lib/irb/completion.rb#179
  def completion_candidates(preposing, target, postposing, bind:); end

  # source://irb//lib/irb/completion.rb#187
  def doc_namespace(_preposing, matched, _postposing, bind:); end

  # source://irb//lib/irb/completion.rb#142
  def inspect; end

  # source://irb//lib/irb/completion.rb#191
  def retrieve_completion_data(input, bind:, doc_namespace:); end

  # source://irb//lib/irb/completion.rb#438
  def select_message(receiver, message, candidates, sep = T.unsafe(nil)); end
end

# Set of available operators in Ruby
#
# source://irb//lib/irb/completion.rb#436
IRB::RegexpCompletor::Operators = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/input-method.rb#480
class IRB::ReidlineInputMethod < ::IRB::RelineInputMethod
  # @return [ReidlineInputMethod] a new instance of ReidlineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#481
  def initialize; end
end

# source://irb//lib/irb/input-method.rb#233
class IRB::RelineInputMethod < ::IRB::StdioInputMethod
  include ::IRB::HistorySavingAbility

  # Creates a new input method object using Reline
  #
  # @return [RelineInputMethod] a new instance of RelineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#237
  def initialize(completor); end

  # source://irb//lib/irb/input-method.rb#290
  def auto_indent(&block); end

  # source://irb//lib/irb/input-method.rb#282
  def check_termination(&block); end

  # source://irb//lib/irb/input-method.rb#277
  def completion_info; end

  # source://irb//lib/irb/input-method.rb#412
  def display_document(matched, driver: T.unsafe(nil)); end

  # source://irb//lib/irb/input-method.rb#286
  def dynamic_prompt(&block); end

  # Whether the end of this input method has been reached, returns +true+
  # if there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#466
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#448
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#471
  def inspect; end

  # source://irb//lib/irb/input-method.rb#294
  def retrieve_doc_namespace(matched); end

  # source://irb//lib/irb/input-method.rb#299
  def show_doc_dialog_proc; end
end

# source://irb//lib/irb/input-method.rb#234
IRB::RelineInputMethod::HISTORY = T.let(T.unsafe(nil), Reline::History)

# :stopdoc:
#
# source://irb//lib/irb/ruby-lex.rb#13
class IRB::RubyLex
  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#156
  def assignment_expression?(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#274
  def calc_indent_level(opens); end

  # source://irb//lib/irb/ruby-lex.rb#137
  def check_code_state(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#198
  def check_code_syntax(code, local_variables:); end

  # source://irb//lib/irb/ruby-lex.rb#431
  def check_termination_in_prev_line(code, local_variables:); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#143
  def code_terminated?(code, tokens, opens, local_variables:); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#301
  def free_indent_token?(token); end

  # Calculates the difference of pasted code's indent and indent calculated from tokens
  #
  # source://irb//lib/irb/ruby-lex.rb#306
  def indent_difference(lines, line_results, line_index); end

  # source://irb//lib/irb/ruby-lex.rb#401
  def ltype_from_open_tokens(opens); end

  # source://irb//lib/irb/ruby-lex.rb#325
  def process_indent_level(tokens, lines, line_index, is_newline); end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#174
  def should_continue?(tokens); end

  class << self
    # source://irb//lib/irb/ruby-lex.rb#45
    def compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

    # source://irb//lib/irb/ruby-lex.rb#71
    def generate_local_variables_assign_code(local_variables); end

    # Some part of the code is not included in Ripper's token.
    # Example: DATA part, token after heredoc_beg when heredoc has unclosed embexpr.
    # With interpolated tokens, tokens.map(&:tok).join will be equal to code.
    #
    # source://irb//lib/irb/ruby-lex.rb#78
    def interpolate_ripper_ignored_tokens(code, tokens); end

    # source://irb//lib/irb/ruby-lex.rb#107
    def ripper_lex_without_warning(code, local_variables: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/ruby-lex.rb#14
IRB::RubyLex::ASSIGNMENT_NODE_TYPES = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#62
IRB::RubyLex::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#299
IRB::RubyLex::FREE_INDENT_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#394
IRB::RubyLex::LTYPE_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#39
class IRB::RubyLex::TerminateLineInput < ::StandardError
  # @return [TerminateLineInput] a new instance of TerminateLineInput
  #
  # source://irb//lib/irb/ruby-lex.rb#40
  def initialize; end
end

# source://irb//lib/irb/statement.rb#4
class IRB::Statement
  # Returns the value of attribute code.
  #
  # source://irb//lib/irb/statement.rb#5
  def code; end

  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/statement.rb#19
  def evaluable_code; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#7
  def is_assignment?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#15
  def should_be_handled_by_debugger?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#11
  def suppresses_echo?; end
end

# source://irb//lib/irb/statement.rb#46
class IRB::Statement::Command < ::IRB::Statement
  # @return [Command] a new instance of Command
  #
  # source://irb//lib/irb/statement.rb#47
  def initialize(code, command, arg, command_class); end

  # source://irb//lib/irb/statement.rb#68
  def evaluable_code; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#54
  def is_assignment?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#62
  def should_be_handled_by_debugger?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#58
  def suppresses_echo?; end
end

# source://irb//lib/irb/statement.rb#23
class IRB::Statement::Expression < ::IRB::Statement
  # @return [Expression] a new instance of Expression
  #
  # source://irb//lib/irb/statement.rb#24
  def initialize(code, is_assignment); end

  # source://irb//lib/irb/statement.rb#41
  def evaluable_code; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#37
  def is_assignment?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#33
  def should_be_handled_by_debugger?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/statement.rb#29
  def suppresses_echo?; end
end

# source://irb//lib/irb/input-method.rb#53
class IRB::StdioInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [StdioInputMethod] a new instance of StdioInputMethod
  #
  # source://irb//lib/irb/input-method.rb#55
  def initialize; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#104
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#75
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#65
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#109
  def inspect; end

  # Returns the current line number for #io.
  #
  # #line counts the number of times #gets is called.
  #
  # See IO#lineno for more information.
  #
  # source://irb//lib/irb/input-method.rb#99
  def line(line_no); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#90
  def readable_after_eof?; end
end

# A standard output printer
#
# source://irb//lib/irb/output-method.rb#79
class IRB::StdioOutputMethod < ::IRB::OutputMethod
  # Prints the given +opts+ to standard output, see IO#print for more
  # information.
  #
  # source://irb//lib/irb/output-method.rb#82
  def print(*opts); end
end

# source://irb//lib/irb/workspace.rb#9
IRB::TOPLEVEL_BINDING = T.let(T.unsafe(nil), Binding)

# source://irb//lib/irb/completion.rb#96
class IRB::TypeCompletor < ::IRB::BaseCompletor
  # @return [TypeCompletor] a new instance of TypeCompletor
  #
  # source://irb//lib/irb/completion.rb#97
  def initialize(context); end

  # source://irb//lib/irb/completion.rb#105
  def completion_candidates(preposing, target, _postposing, bind:); end

  # source://irb//lib/irb/completion.rb#111
  def doc_namespace(preposing, matched, _postposing, bind:); end

  # source://irb//lib/irb/completion.rb#101
  def inspect; end
end

# source://irb//lib/irb/version.rb#8
IRB::VERSION = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/workspace.rb#11
class IRB::WorkSpace
  # Creates a new workspace.
  #
  # set self to main if specified, otherwise
  # inherit main from TOPLEVEL_BINDING.
  #
  # @return [WorkSpace] a new instance of WorkSpace
  #
  # source://irb//lib/irb/workspace.rb#16
  def initialize(*main); end

  # The Binding of this workspace
  #
  # source://irb//lib/irb/workspace.rb#106
  def binding; end

  # source://irb//lib/irb/workspace.rb#144
  def code_around_binding; end

  # Evaluate the given +statements+ within the  context of this workspace.
  #
  # source://irb//lib/irb/workspace.rb#116
  def evaluate(statements, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # error message manipulator
  # WARN: Rails patches this method to filter its own backtrace. Be cautious when changing it.
  # See: https://github.com/rails/rails/blob/main/railties/lib/rails/commands/console/console_command.rb#L8:~:text=def,filter_backtrace
  #
  # source://irb//lib/irb/workspace.rb#131
  def filter_backtrace(bt); end

  # source://irb//lib/irb/workspace.rb#111
  def load_commands_to_main; end

  # source://irb//lib/irb/workspace.rb#124
  def local_variable_get(name); end

  # source://irb//lib/irb/workspace.rb#120
  def local_variable_set(name, value); end

  # The top-level workspace of this context, also available as
  # <code>IRB.conf[:__MAIN__]</code>
  #
  # source://irb//lib/irb/workspace.rb#109
  def main; end
end

# source://irb//lib/irb/ruby-lex.rb#473
RubyLex = IRB::RubyLex
