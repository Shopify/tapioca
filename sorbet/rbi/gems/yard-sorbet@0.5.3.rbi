# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yard-sorbet` gem.
# Please instead update this file by running `bin/tapioca gem yard-sorbet`.

# typed: true

# Types are documentation
module YARDSorbet; end

# Extract & re-add directives to a docstring
module YARDSorbet::Directives
  class << self
    sig { params(docstring: String, directives: T::Array[String]).void }
    def add_directives(docstring, directives); end

    sig { params(docstring: T.nilable(String)).returns([YARD::Docstring, T::Array[String]]) }
    def extract_directives(docstring); end
  end
end

# Custom YARD Handlers
module YARDSorbet::Handlers; end

# Apllies an `@abstract` tag to `abstract!`/`interface!` modules (if not alerady present).
class YARDSorbet::Handlers::AbstractDSLHandler < ::YARD::Handlers::Ruby::Base
  sig { void }
  def process; end
end

# Extra text for class namespaces
YARDSorbet::Handlers::AbstractDSLHandler::CLASS_TAG_TEXT = T.let(T.unsafe(nil), String)

# The text accompanying the `@abstract` tag.
YARDSorbet::Handlers::AbstractDSLHandler::TAG_TEXT = T.let(T.unsafe(nil), String)

# Handle `enums` calls, registering enum values as constants
class YARDSorbet::Handlers::EnumsHandler < ::YARD::Handlers::Ruby::Base
  sig { void }
  def process; end

  private

  sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Boolean) }
  def const_assign_node?(node); end
end

# A YARD Handler for Sorbet type declarations
class YARDSorbet::Handlers::SigHandler < ::YARD::Handlers::Ruby::Base
  # Swap the method definition docstring and the sig docstring.
  # Parse relevant parts of the `sig` and include them as well.
  sig { void }
  def process; end

  private

  sig { params(method_node: YARD::Parser::Ruby::AstNode, node: YARD::Parser::Ruby::AstNode, docstring: YARD::Docstring).void }
  def parse_params(method_node, node, docstring); end

  sig { params(node: YARD::Parser::Ruby::AstNode, docstring: YARD::Docstring).void }
  def parse_return(node, docstring); end

  sig { params(method_node: YARD::Parser::Ruby::AstNode, docstring: YARD::Docstring).void }
  def parse_sig(method_node, docstring); end
end

# These node types attached to sigs represent attr_* declarations
YARDSorbet::Handlers::SigHandler::ATTR_NODE_TYPES = T.let(T.unsafe(nil), Array)

# Class-level handler that folds all `const` and `prop` declarations into the constructor documentation
# this needs to be injected as a module otherwise the default Class handler will overwrite documentation
module YARDSorbet::Handlers::StructClassHandler
  sig { void }
  def process; end

  private

  sig { params(object: YARD::CodeObjects::MethodObject, props: T::Array[YARDSorbet::TStructProp], docstring: YARD::Docstring, directives: T::Array[String]).void }
  def decorate_t_struct_init(object, props, docstring, directives); end

  # Create a virtual `initialize` method with all the `prop`/`const` arguments
  sig { params(props: T::Array[YARDSorbet::TStructProp], class_ns: YARD::CodeObjects::ClassObject).void }
  def process_t_struct_props(props, class_ns); end

  sig { params(props: T::Array[YARDSorbet::TStructProp]).returns(T::Array[[String, T.nilable(String)]]) }
  def to_object_parameters(props); end
end

# Handles all `const`/`prop` calls, creating accessor methods, and compiles them for later usage at the class level
# in creating a constructor
class YARDSorbet::Handlers::StructPropHandler < ::YARD::Handlers::Ruby::Base
  sig { void }
  def process; end

  private

  # Add the source and docstring to the method object
  sig { params(object: YARD::CodeObjects::MethodObject, prop: YARDSorbet::TStructProp).void }
  def decorate_object(object, prop); end

  # Get the default prop value
  sig { returns(T.nilable(String)) }
  def default_value; end

  sig { params(name: String).returns(YARDSorbet::TStructProp) }
  def make_prop(name); end

  # Register the field explicitly as an attribute.
  # While `const` attributes are immutable, `prop` attributes may be reassigned.
  sig { params(object: YARD::CodeObjects::MethodObject, name: String).void }
  def register_attrs(object, name); end

  # Store the prop for use in the constructor definition
  sig { params(prop: YARDSorbet::TStructProp).void }
  def update_state(prop); end
end

# Helper methods for working with `YARD` AST Nodes
module YARDSorbet::NodeUtils
  class << self
    # Traverese AST nodes in breadth-first order
    sig { params(node: YARD::Parser::Ruby::AstNode, _blk: T.proc.params(n: YARD::Parser::Ruby::AstNode).void).void }
    def bfs_traverse(node, &_blk); end

    # Gets the node that a sorbet `sig` can be attached do, bypassing visisbility modifiers and the like
    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T.any(YARD::Parser::Ruby::MethodCallNode, YARD::Parser::Ruby::MethodDefinitionNode)) }
    def get_method_node(node); end

    # Find and return the adjacent node (ascending)
    sig { params(node: YARD::Parser::Ruby::AstNode).returns(YARD::Parser::Ruby::AstNode) }
    def sibling_node(node); end
  end
end

# Command node types that can have type signatures
YARDSorbet::NodeUtils::ATTRIBUTE_METHODS = T.let(T.unsafe(nil), Array)

# Node types that can have type signatures
YARDSorbet::NodeUtils::SIGABLE_NODE = T.type_alias { T.any(YARD::Parser::Ruby::MethodCallNode, YARD::Parser::Ruby::MethodDefinitionNode) }

# Skip these method contents during BFS node traversal, they can have their own nested types via `T.Proc`
YARDSorbet::NodeUtils::SKIP_METHOD_CONTENTS = T.let(T.unsafe(nil), Array)

# Translate `sig` type syntax to `YARD` type syntax.
module YARDSorbet::SigToYARD
  class << self
    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert(node); end

    private

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(String) }
    def build_generic_type(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_aref(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_array(node); end

    sig { params(node: YARD::Parser::Ruby::MethodCallNode).returns(T::Array[String]) }
    def convert_call(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_collection(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_hash(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_list(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_node(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_node_type(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_ref(node); end

    sig { params(node: YARD::Parser::Ruby::MethodCallNode).returns(T::Array[String]) }
    def convert_t_method(node); end

    sig { params(node: YARD::Parser::Ruby::AstNode).returns(T::Array[String]) }
    def convert_unknown(node); end
  end
end

# Used to store the details of a `T::Struct` `prop` definition
class YARDSorbet::TStructProp < ::T::Struct
  const :default, T.nilable(String)
  const :doc, String
  const :prop_name, String
  const :source, String
  const :types, T::Array[String]

  class << self
    def inherited(s); end
  end
end

# Helper methods for working with `YARD` tags
module YARDSorbet::TagUtils
  class << self
    sig { params(docstring: YARD::Docstring, tag_name: String, name: T.nilable(String)).returns(T.nilable(YARD::Tags::Tag)) }
    def find_tag(docstring, tag_name, name); end

    # Create or update a `YARD` tag with type information
    sig { params(docstring: YARD::Docstring, tag_name: String, types: T.nilable(T::Array[String]), name: T.nilable(String), text: String).void }
    def upsert_tag(docstring, tag_name, types = T.unsafe(nil), name = T.unsafe(nil), text = T.unsafe(nil)); end
  end
end

# {https://rubygems.org/gems/yard-sorbet Version history}
YARDSorbet::VERSION = T.let(T.unsafe(nil), String)
