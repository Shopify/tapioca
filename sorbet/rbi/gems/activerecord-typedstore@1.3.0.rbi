# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   tapioca sync

# typed: true

module ActiveRecord
  extend(::ActiveSupport::Autoload)

  def self.eager_load!; end
  def self.gem_version; end
  def self.version; end
end

class ActiveRecord::MigrationProxy < ::Struct
  def initialize(name, version, filename, scope); end

  def announce(*args, &block); end
  def basename; end
  def disable_ddl_transaction(*args, &block); end
  def filename; end
  def filename=(_); end
  def migrate(*args, &block); end
  def mtime; end
  def name; end
  def name=(_); end
  def scope; end
  def scope=(_); end
  def version; end
  def version=(_); end
  def write(*args, &block); end

  private

  def load_migration; end
  def migration; end

  def self.[](*_); end
  def self.inspect; end
  def self.members; end
  def self.new(*_); end
end

module ActiveRecord::TypedStore
end

module ActiveRecord::TypedStore::Behavior
  extend(::ActiveSupport::Concern)

  mixes_in_class_methods(::ActiveRecord::TypedStore::Behavior::ClassMethods)

  def changes; end
  def clear_attribute_change(attr_name); end
  def query_attribute(attr_name); end
  def read_attribute(attr_name); end
end

module ActiveRecord::TypedStore::Behavior::ClassMethods
  def define_attribute_methods; end
  def define_typed_store_attribute_methods; end
  def undefine_attribute_methods; end
  def undefine_before_type_cast_method(attribute); end
end

class ActiveRecord::TypedStore::DSL
  def initialize(attribute_name, options); end

  def accessors; end
  def any(name, **options); end
  def boolean(name, **options); end
  def coder; end
  def date(name, **options); end
  def date_time(name, **options); end
  def datetime(name, **options); end
  def decimal(name, **options); end
  def default_coder(attribute_name); end
  def fields; end
  def float(name, **options); end
  def integer(name, **options); end
  def keys(*args, &block); end
  def string(name, **options); end
  def text(name, **options); end
  def time(name, **options); end
end

ActiveRecord::TypedStore::DSL::NO_DEFAULT_GIVEN = T.let(T.unsafe(nil), Object)

module ActiveRecord::TypedStore::Extension
  def typed_store(store_attribute, options = _, &block); end
end

class ActiveRecord::TypedStore::Field
  def initialize(name, type, options = _); end

  def accessor; end
  def array; end
  def blank; end
  def cast(value); end
  def default; end
  def has_default?; end
  def name; end
  def null; end
  def type; end
  def type_sym; end

  private

  def extract_default(value); end
  def lookup_type(type, options); end
  def type_cast(value, arrayize: _); end
end

ActiveRecord::TypedStore::Field::TYPES = T.let(T.unsafe(nil), Hash)

module ActiveRecord::TypedStore::IdentityCoder
  extend(::ActiveRecord::TypedStore::IdentityCoder)

  def dump(data); end
  def load(data); end
end

class ActiveRecord::TypedStore::Type < ::ActiveRecord::Type::Serialized
  def initialize(typed_hash_klass, coder, subtype); end

  def changed_in_place?(raw_old_value, value); end
  def default_value?(value); end
  def defaults; end
  def deserialize(value); end
  def serialize(value); end
  def type_cast_for_database(value); end
  def type_cast_from_database(value); end
  def type_cast_from_user(value); end
end

class ActiveRecord::TypedStore::TypedHash < ::ActiveSupport::HashWithIndifferentAccess
  def initialize(constructor = _); end

  def []=(key, value); end
  def defaults_hash(*args, &block); end
  def except(*args, &block); end
  def fields(*args, &block); end
  def merge!(other_hash); end
  def slice(*args, &block); end
  def store(key, value); end
  def update(other_hash); end
  def with_indifferent_access(*args, &block); end
  def without(*args, &block); end

  private

  def cast_value(key, value); end

  def self.create(fields); end
  def self.defaults_hash; end
  def self.fields; end
end

ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError
