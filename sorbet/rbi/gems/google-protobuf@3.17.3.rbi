# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `google-protobuf` gem.
# Please instead update this file by running `bin/tapioca gem google-protobuf`.

# typed: true

# We define these before requiring the platform-specific modules.
# That way the module init can grab references to these.
module Google; end

module Google::Protobuf
  class << self
    def decode(klass, proto); end
    def decode_json(klass, json, options = T.unsafe(nil)); end
    def deep_copy(_arg0); end
    def discard_unknown(_arg0); end
    def encode(msg); end
    def encode_json(msg, options = T.unsafe(nil)); end
  end
end

class Google::Protobuf::Builder
  def initialize(_arg0); end

  def add_enum(_arg0); end
  def add_file(*_arg0); end
  def add_message(_arg0); end
end

class Google::Protobuf::Descriptor
  include ::Enumerable

  def initialize(_arg0, _arg1, _arg2); end

  def each; end
  def each_oneof; end
  def file_descriptor; end
  def lookup(_arg0); end
  def lookup_oneof(_arg0); end
  def msgclass; end
  def name; end
end

class Google::Protobuf::DescriptorPool
  def build(*_arg0); end
  def lookup(_arg0); end

  class << self
    def generated_pool; end
  end
end

class Google::Protobuf::EnumBuilderContext
  def initialize(_arg0, _arg1); end

  def value(_arg0, _arg1); end
end

class Google::Protobuf::EnumDescriptor
  include ::Enumerable

  def initialize(_arg0, _arg1, _arg2); end

  def each; end
  def enummodule; end
  def file_descriptor; end
  def lookup_name(_arg0); end
  def lookup_value(_arg0); end
  def name; end
end

class Google::Protobuf::Error < ::StandardError; end

class Google::Protobuf::FieldDescriptor
  def initialize(_arg0, _arg1, _arg2); end

  def clear(_arg0); end
  def default; end
  def get(_arg0); end
  def has?(_arg0); end
  def json_name; end
  def label; end
  def name; end
  def number; end
  def set(_arg0, _arg1); end
  def submsg_name; end
  def subtype; end
  def type; end
end

class Google::Protobuf::FileBuilderContext
  def initialize(_arg0, _arg1, _arg2); end

  def add_enum(_arg0); end
  def add_message(_arg0); end
end

class Google::Protobuf::FileDescriptor
  def initialize(_arg0, _arg1, _arg2); end

  def name; end
  def syntax; end
end

module Google::Protobuf::Internal
  class << self
    def fixup_descriptor(package, msg_names, enum_names); end
    def infer_package(names); end
  end
end

class Google::Protobuf::Internal::Arena; end

class Google::Protobuf::Internal::NestingBuilder
  def initialize(msg_names, enum_names); end

  def build(package); end

  private

  def build_msg(msg); end
  def parent(name); end
end

class Google::Protobuf::Map
  include ::Enumerable

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clear; end
  def delete(_arg0); end
  def dup; end
  def each; end
  def freeze; end
  def has_key?(_arg0); end
  def hash; end
  def inspect; end
  def keys; end
  def length; end
  def merge(_arg0); end
  def to_h; end
  def values; end
end

class Google::Protobuf::MessageBuilderContext
  def initialize(_arg0, _arg1); end

  def map(*_arg0); end
  def oneof(_arg0); end
  def optional(*_arg0); end
  def proto3_optional(*_arg0); end
  def repeated(*_arg0); end
  def required(*_arg0); end
end

module Google::Protobuf::MessageExts
  mixes_in_class_methods ::Google::Protobuf::MessageExts::ClassMethods

  def to_json(options = T.unsafe(nil)); end
  def to_proto; end

  class << self
    # this is only called in jruby; mri loades the ClassMethods differently
    def included(klass); end
  end
end

module Google::Protobuf::MessageExts::ClassMethods; end

class Google::Protobuf::OneofBuilderContext
  def initialize(_arg0, _arg1); end

  def optional(*_arg0); end
end

class Google::Protobuf::OneofDescriptor
  include ::Enumerable

  def initialize(_arg0, _arg1, _arg2); end

  def each; end
  def name; end
end

class Google::Protobuf::ParseError < ::Google::Protobuf::Error; end

class Google::Protobuf::RepeatedField
  include ::Enumerable
  extend ::Forwardable

  def initialize(*_arg0); end

  def &(*args, &block); end
  def *(*args, &block); end
  def +(_arg0); end
  def -(*args, &block); end
  def <<(_arg0); end
  def <=>(*args, &block); end
  def ==(_arg0); end
  def [](*_arg0); end
  def []=(_arg0, _arg1); end
  def assoc(*args, &block); end
  def at(*_arg0); end
  def bsearch(*args, &block); end
  def bsearch_index(*args, &block); end
  def clear; end
  def clone; end
  def collect!(*args, &block); end
  def combination(*args, &block); end
  def compact(*args, &block); end
  def compact!(*args, &block); end
  def concat(_arg0); end
  def count(*args, &block); end
  def cycle(*args, &block); end
  def delete(*args, &block); end
  def delete_at(*args, &block); end
  def delete_if(*args, &block); end
  def dig(*args, &block); end
  def drop(*args, &block); end
  def drop_while(*args, &block); end
  def dup; end
  def each; end

  # array aliases into enumerable
  def each_index(*_arg0); end

  def empty?; end
  def eql?(*args, &block); end
  def fetch(*args, &block); end
  def fill(*args, &block); end
  def find_index(*args, &block); end
  def first(n = T.unsafe(nil)); end
  def flatten(*args, &block); end
  def flatten!(*args, &block); end
  def freeze; end
  def hash; end
  def include?(*args, &block); end
  def index(*args, &block); end
  def insert(*args, &block); end
  def inspect(*args, &block); end
  def join(*args, &block); end
  def keep_if(*args, &block); end
  def last(n = T.unsafe(nil)); end
  def length; end
  def map; end
  def map!(*args, &block); end
  def pack(*args, &block); end
  def permutation(*args, &block); end
  def pop(n = T.unsafe(nil)); end
  def pretty_print(*args, &block); end
  def pretty_print_cycle(*args, &block); end
  def product(*args, &block); end
  def push(*_arg0); end
  def rassoc(*args, &block); end
  def reject!(*args, &block); end
  def repeated_combination(*args, &block); end
  def repeated_permutation(*args, &block); end
  def replace(_arg0); end
  def reverse(*args, &block); end
  def reverse!(*args, &block); end
  def rindex(*args, &block); end
  def rotate(*args, &block); end
  def rotate!(*args, &block); end
  def sample(*args, &block); end
  def select!(*args, &block); end
  def shelljoin(*args, &block); end
  def shift(*args, &block); end
  def shuffle(*args, &block); end
  def shuffle!(*args, &block); end
  def size; end
  def slice(*_arg0); end
  def slice!(*args, &block); end
  def sort!(*args, &block); end
  def sort_by!(*args, &block); end
  def to_ary; end
  def to_s(*args, &block); end
  def transpose(*args, &block); end
  def uniq(*args, &block); end
  def uniq!(*args, &block); end
  def unshift(*args, &block); end
  def values_at; end
  def |(*args, &block); end

  private

  def pop_one; end

  class << self
    private

    def define_array_wrapper_method(method_name); end
    def define_array_wrapper_with_result_method(method_name); end
  end
end

# propagates changes made by user of enumerator back to the original repeated field.
# This only applies in cases where the calling function which created the enumerator,
# such as #sort!, modifies itself rather than a new array, such as #sort
class Google::Protobuf::RepeatedField::ProxyingEnumerator < ::Struct
  def each(*args, &block); end
end

class Google::Protobuf::TypeError < ::TypeError; end
