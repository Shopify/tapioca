# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `connection_pool` gem.
# Please instead update this file by running `bin/tapioca gem connection_pool`.


# Generic connection pool class for sharing a limited number of objects or network connections
# among many threads.  Note: pool elements are lazily created.
#
# Example usage with block (faster):
#
#    @pool = ConnectionPool.new { Redis.new }
#    @pool.with do |redis|
#      redis.lpop('my-list') if redis.llen('my-list') > 0
#    end
#
# Using optional timeout override (for that single invocation)
#
#    @pool.with(timeout: 2.0) do |redis|
#      redis.lpop('my-list') if redis.llen('my-list') > 0
#    end
#
# Example usage replacing an existing connection (slower):
#
#    $redis = ConnectionPool.wrap { Redis.new }
#
#    def do_work
#      $redis.lpop('my-list') if $redis.llen('my-list') > 0
#    end
#
# Accepts the following options:
# - :size - number of connections to pool, defaults to 5
# - :timeout - amount of time to wait for a connection if none currently available, defaults to 5 seconds
# - :auto_reload_after_fork - automatically drop all connections after fork, defaults to true
#
# source://connection_pool//lib/connection_pool/version.rb#1
class ConnectionPool
  # @raise [ArgumentError]
  # @return [ConnectionPool] a new instance of ConnectionPool
  #
  # source://connection_pool//lib/connection_pool.rb#90
  def initialize(options = T.unsafe(nil), &block); end

  # Automatically drop all connections after fork
  #
  # source://connection_pool//lib/connection_pool.rb#216
  def auto_reload_after_fork; end

  # Number of pool entries available for checkout at this instant.
  #
  # source://connection_pool//lib/connection_pool.rb#219
  def available; end

  # source://connection_pool//lib/connection_pool.rb#164
  def checkin(force: T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#154
  def checkout(options = T.unsafe(nil)); end

  # Marks the current thread's checked-out connection for discard.
  #
  # When a connection is marked for discard, it will not be returned to the pool
  # when checked in. Instead, the connection will be discarded.
  # This is useful when a connection has become invalid or corrupted
  # and should not be reused.
  #
  # Takes an optional block that will be called with the connection to be discarded.
  # The block should perform any necessary clean-up on the connection.
  #
  # Note: This only affects the connection currently checked out by the calling thread.
  # The connection will be discarded when +checkin+ is called.
  #
  # @example
  #   pool.with do |conn|
  #   begin
  #   conn.execute("SELECT 1")
  #   rescue SomeConnectionError
  #   pool.discard_current_connection  # Mark connection as bad
  #   raise
  #   end
  #   end
  # @return [void]
  # @yield [conn]
  # @yieldparam conn [Object] The connection to be discarded.
  # @yieldreturn [void]
  #
  # source://connection_pool//lib/connection_pool.rb#150
  def discard_current_connection(&block); end

  # Number of pool entries created and idle in the pool.
  #
  # source://connection_pool//lib/connection_pool.rb#224
  def idle; end

  # Reaps idle connections that have been idle for over +idle_seconds+.
  # +idle_seconds+ defaults to 60.
  #
  # source://connection_pool//lib/connection_pool.rb#209
  def reap(idle_seconds = T.unsafe(nil), &block); end

  # Reloads the ConnectionPool by passing each connection to +block+ and then
  # removing it the pool. Subsequent checkouts will create new connections as
  # needed.
  #
  # source://connection_pool//lib/connection_pool.rb#203
  def reload(&block); end

  # Shuts down the ConnectionPool by passing each connection to +block+ and
  # then removing it from the pool. Attempting to checkout a connection after
  # shutdown will raise +ConnectionPool::PoolShuttingDownError+.
  #
  # source://connection_pool//lib/connection_pool.rb#195
  def shutdown(&block); end

  # Size of this connection pool
  #
  # source://connection_pool//lib/connection_pool.rb#214
  def size; end

  # source://connection_pool//lib/connection_pool.rb#118
  def then(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool.rb#106
  def with(options = T.unsafe(nil)); end

  class << self
    # source://connection_pool//lib/connection_pool.rb#52
    def after_fork; end

    # source://connection_pool//lib/connection_pool.rb#44
    def wrap(options, &block); end
  end
end

# source://connection_pool//lib/connection_pool.rb#42
ConnectionPool::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://connection_pool//lib/connection_pool.rb#5
class ConnectionPool::Error < ::RuntimeError; end

# source://connection_pool//lib/connection_pool.rb#70
module ConnectionPool::ForkTracker
  # source://connection_pool//lib/connection_pool.rb#71
  def _fork; end
end

# source://connection_pool//lib/connection_pool.rb#49
ConnectionPool::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap)

# source://connection_pool//lib/connection_pool.rb#7
class ConnectionPool::PoolShuttingDownError < ::ConnectionPool::Error; end

# The TimedStack manages a pool of homogeneous connections (or any resource
# you wish to manage). Connections are created lazily up to a given maximum
# number.
#
# Examples:
#
#    ts = TimedStack.new(1) { MyConnection.new }
#
#    # fetch a connection
#    conn = ts.pop
#
#    # return a connection
#    ts.push conn
#
#    conn = ts.pop
#    ts.pop timeout: 5
#    #=> raises ConnectionPool::TimeoutError after 5 seconds
#
# source://connection_pool//lib/connection_pool/timed_stack.rb#19
class ConnectionPool::TimedStack
  # Creates a new pool with +size+ connections that are created from the given
  # +block+.
  #
  # @return [TimedStack] a new instance of TimedStack
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#25
  def initialize(size = T.unsafe(nil), &block); end

  # Returns +obj+ to the stack. +options+ is ignored in TimedStack but may be
  # used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#50
  def <<(obj, options = T.unsafe(nil)); end

  # Reduce the created count
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#139
  def decrement_created; end

  # Returns +true+ if there are no available connections.
  #
  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#121
  def empty?; end

  # The number of connections created and available on the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#133
  def idle; end

  # The number of connections available on the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#127
  def length; end

  # Returns the value of attribute max.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#20
  def max; end

  # Retrieves a connection from the stack. If a connection is available it is
  # immediately returned. If no connection is available within the given
  # timeout a ConnectionPool::TimeoutError is raised.
  #
  # +:timeout+ is the only checked entry in +options+ and is preferred over
  # the +timeout+ argument (which will be removed in a future release). Other
  # options may be used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#60
  def pop(timeout = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns +obj+ to the stack. +options+ is ignored in TimedStack but may be
  # used by subclasses that extend TimedStack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#38
  def push(obj, options = T.unsafe(nil)); end

  # Reaps connections that were checked in more than +idle_seconds+ ago.
  #
  # @raise [ArgumentError]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#101
  def reap(idle_seconds, &block); end

  # Shuts down the TimedStack by passing each connection to +block+ and then
  # removing it from the pool. Attempting to checkout a connection after
  # shutdown will raise +ConnectionPool::PoolShuttingDownError+ unless
  # +:reload+ is +true+.
  #
  # @raise [ArgumentError]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#87
  def shutdown(reload: T.unsafe(nil), &block); end

  private

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must returns true if a connection is available on the stack.
  #
  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#163
  def connection_stored?(options = T.unsafe(nil)); end

  # source://connection_pool//lib/connection_pool/timed_stack.rb#145
  def current_time; end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must return a connection from the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#171
  def fetch_connection(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # Returns true if the first connection in the stack has been idle for more than idle_seconds
  #
  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#203
  def idle_connections?(idle_seconds); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method returns the oldest idle connection if it has been idle for more than idle_seconds.
  # This requires that the stack is kept in order of checked in time (oldest first).
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#191
  def reserve_idle_connection(idle_seconds); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must shut down all connections on the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#179
  def shutdown_connections(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must return +obj+ to the stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#211
  def store_connection(obj, options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must create a connection if and only if the total number of
  # connections allowed has not been met.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#220
  def try_create(options = T.unsafe(nil)); end

  # This is an extension point for TimedStack and is called with a mutex.
  #
  # This method must returns a connection from the stack if one exists. Allows
  # subclasses with expensive match/search algorithms to avoid double-handling
  # their stack.
  #
  # source://connection_pool//lib/connection_pool/timed_stack.rb#155
  def try_fetch_connection(options = T.unsafe(nil)); end
end

# source://connection_pool//lib/connection_pool.rb#9
class ConnectionPool::TimeoutError < ::Timeout::Error; end

# source://connection_pool//lib/connection_pool/version.rb#2
ConnectionPool::VERSION = T.let(T.unsafe(nil), String)

# source://connection_pool//lib/connection_pool/wrapper.rb#2
class ConnectionPool::Wrapper < ::BasicObject
  # @return [Wrapper] a new instance of Wrapper
  #
  # source://connection_pool//lib/connection_pool/wrapper.rb#5
  def initialize(options = T.unsafe(nil), &block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#35
  def method_missing(name, *args, **kwargs, &block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#25
  def pool_available; end

  # source://connection_pool//lib/connection_pool/wrapper.rb#17
  def pool_shutdown(&block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#21
  def pool_size; end

  # @return [Boolean]
  #
  # source://connection_pool//lib/connection_pool/wrapper.rb#29
  def respond_to?(id, *args); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#13
  def with(&block); end

  # source://connection_pool//lib/connection_pool/wrapper.rb#9
  def wrapped_pool; end
end

# source://connection_pool//lib/connection_pool/wrapper.rb#3
ConnectionPool::Wrapper::METHODS = T.let(T.unsafe(nil), Array)

module Process
  extend ::SQLite3::ForkSafety::CoreExt
  extend ::ConnectionPool::ForkTracker
  extend ::RedisClient::PIDCache::CoreExt
  extend ::ActiveSupport::ForkTracker::CoreExt
end
