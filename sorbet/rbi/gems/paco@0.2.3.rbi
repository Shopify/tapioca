# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `paco` gem.
# Please instead update this file by running `bin/tapioca gem paco`.


# source://paco//lib/paco/version.rb#3
module Paco
  include ::Paco::Combinators

  class << self
    # @private
    #
    # source://paco//lib/paco.rb#13
    def extended(base); end

    # @private
    #
    # source://paco//lib/paco.rb#17
    def included(base); end
  end
end

# source://paco//lib/paco/callstack.rb#4
class Paco::Callstack
  # @return [Callstack] a new instance of Callstack
  #
  # source://paco//lib/paco/callstack.rb#7
  def initialize; end

  # source://paco//lib/paco/callstack.rb#12
  def failure(**params); end

  # Returns the value of attribute stack.
  #
  # source://paco//lib/paco/callstack.rb#5
  def stack; end

  # source://paco//lib/paco/callstack.rb#17
  def start(**params); end

  # source://paco//lib/paco/callstack.rb#22
  def success(**params); end
end

# source://paco//lib/paco/combinators/char.rb#4
module Paco::Combinators
  include ::Paco::Combinators::Char
  extend ::Paco::Combinators::Char

  private

  # Accepts any number of parsers, and returns a parser that returns the value of the first parser that succeeds, backtracking in between.
  #
  # @param parsers [Array<Paco::Parser>]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#61
  def alt(*parsers); end

  # Returns a parser that doesn't consume any input and always fails with passed `message`.
  #
  # @param message [String]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#41
  def failed(message); end

  # Returns parser that returns `Paco::Index` representing
  # the current offset into the parse without consuming the input.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#165
  def index; end

  # Accepts a block that returns a parser, which is evaluated the first time the parser is used.
  # This is useful for referencing parsers that haven't yet been defined, and for implementing recursive parsers.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#106
  def lazy(desc = T.unsafe(nil), &block); end

  # Returns a parser that runs the passed `parser` without consuming the input,
  # and returns empty string.
  #
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#49
  def lookahead(parser); end

  # Expects `parser` zero or more times, and returns an array of the results.
  #
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#143
  def many(parser); end

  # Helper used for memoization
  #
  # source://paco//lib/paco/combinators.rb#170
  def memoize(&block); end

  # Returns a parser that runs the passed `parser` without consuming the input, and
  # returns `null` if the passed `parser` _does not match_ the input. Fails otherwise.
  #
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#17
  def not_followed_by(parser); end

  # Returns parser that returns result of the passed `parser` or nil if `parser` fails.
  #
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#158
  def optional(parser); end

  # Returns a parser that expects zero or more matches for `parser`,
  # separated by the parser `separator`. Returns an array of `parser` results.
  #
  # @param parser [Paco::Parser]
  # @param separator [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#115
  def sep_by(parser, separator); end

  # Returns a parser that expects one or more matches for `parser`,
  # separated by the parser `separator`. Returns an array of `parser` results.
  #
  # @param parser [Paco::Parser]
  # @param separator [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#125
  def sep_by!(parser, separator); end

  # source://paco//lib/paco/combinators.rb#125
  def sep_by_1(parser, separator); end

  # Accepts one or more parsers, and returns a parser that expects them
  # to match in order, returns an array of all their results.
  # If `block` specified, passes results of the `parses` as an arguments
  # to a `block`, and at the end returns its result.
  #
  # @param parsers [Array<Paco::Parser>]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#86
  def seq(*parsers); end

  # Returns a parser that doesn't consume any input and always returns `result`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#34
  def succeed(result); end

  # Expects the parser `before` before `parser` and `after` after `parser. Returns the result of the parser.
  #
  # @param before [Paco::Parser]
  # @param after [Paco::Parser]
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators.rb#136
  def wrap(before, after, parser); end

  class << self
    # Accepts any number of parsers, and returns a parser that returns the value of the first parser that succeeds, backtracking in between.
    #
    # @param parsers [Array<Paco::Parser>]
    # @raise [ArgumentError]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#61
    def alt(*parsers); end

    # Returns a parser that doesn't consume any input and always fails with passed `message`.
    #
    # @param message [String]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#41
    def failed(message); end

    # Returns parser that returns `Paco::Index` representing
    # the current offset into the parse without consuming the input.
    #
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#165
    def index; end

    # Accepts a block that returns a parser, which is evaluated the first time the parser is used.
    # This is useful for referencing parsers that haven't yet been defined, and for implementing recursive parsers.
    #
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#106
    def lazy(desc = T.unsafe(nil), &block); end

    # Returns a parser that runs the passed `parser` without consuming the input,
    # and returns empty string.
    #
    # @param parser [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#49
    def lookahead(parser); end

    # Expects `parser` zero or more times, and returns an array of the results.
    #
    # @param parser [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#143
    def many(parser); end

    # Helper used for memoization
    #
    # source://paco//lib/paco/combinators.rb#170
    def memoize(&block); end

    # Returns a parser that runs the passed `parser` without consuming the input, and
    # returns `null` if the passed `parser` _does not match_ the input. Fails otherwise.
    #
    # @param parser [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#17
    def not_followed_by(parser); end

    # Returns parser that returns result of the passed `parser` or nil if `parser` fails.
    #
    # @param parser [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#158
    def optional(parser); end

    # Returns a parser that expects zero or more matches for `parser`,
    # separated by the parser `separator`. Returns an array of `parser` results.
    #
    # @param parser [Paco::Parser]
    # @param separator [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#115
    def sep_by(parser, separator); end

    # Returns a parser that expects one or more matches for `parser`,
    # separated by the parser `separator`. Returns an array of `parser` results.
    #
    # @param parser [Paco::Parser]
    # @param separator [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#125
    def sep_by!(parser, separator); end

    # Accepts one or more parsers, and returns a parser that expects them
    # to match in order, returns an array of all their results.
    # If `block` specified, passes results of the `parses` as an arguments
    # to a `block`, and at the end returns its result.
    #
    # @param parsers [Array<Paco::Parser>]
    # @raise [ArgumentError]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#86
    def seq(*parsers); end

    # Returns a parser that doesn't consume any input and always returns `result`.
    #
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#34
    def succeed(result); end

    # Expects the parser `before` before `parser` and `after` after `parser. Returns the result of the parser.
    #
    # @param before [Paco::Parser]
    # @param after [Paco::Parser]
    # @param parser [Paco::Parser]
    # @return [Paco::Parser]
    #
    # source://paco//lib/paco/combinators.rb#136
    def wrap(before, after, parser); end
  end
end

# source://paco//lib/paco/combinators/char.rb#5
module Paco::Combinators::Char
  # Returns a parser that consumes and returns the next character of the input.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#86
  def any_char; end

  # Returns a parser that checks for the "carriage return" (`\r`) character.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#123
  def cr; end

  # Returns a parser that checks for the "carriage return" character followed by the "line feed" character (`\r\n`).
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#135
  def crlf; end

  # Alias for `Paco::Combinators.regexp_char(/[0-9]/)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#171
  def digit; end

  # Alias for `Paco::Combinators.regexp(/[0-9]+/)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#177
  def digits; end

  # Returns a parser that will match any kind of line ending *including* end of file.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#147
  def end_of_line; end

  # Returns a parser that matches end of file and returns nil.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#112
  def eof; end

  # Alias for `Paco::Combinators.regexp_char(/[a-z]/i)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#153
  def letter; end

  # Alias for `Paco::Combinators.regexp(/[a-z]+/i)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#159
  def letters; end

  # Returns a parser that checks for the "line feed" (`\n`) character.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#129
  def lf; end

  # Returns a parser that will match any kind of line ending.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#141
  def newline; end

  # Returns a parser that looks for exactly one character _NOT_ from passed
  # `matcher`, and returns its value on success.
  #
  # @param matcher [String, Array<String>]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#80
  def none_of(matcher); end

  # Returns a parser that looks for exactly one character from passed
  # `matcher`, and returns its value on success.
  #
  # @param matcher [String, Array<String>]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#72
  def one_of(matcher); end

  # Alias for `Paco::Combinators.regexp(/[0-9]*/)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#183
  def opt_digits; end

  # Alias for `Paco::Combinators.regexp(/[a-z]*/i)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#165
  def opt_letters; end

  # Alias for `Paco::Combinators.regexp(/\s*/)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#195
  def opt_ws; end

  # Returns a parser that looks for a match to the regexp and returns the entire text matched.
  # The regexp will always match starting at the current parse location.
  # When `group` is specified, it returns only the text in the specific regexp match group.
  #
  # @param regexp [Regexp]
  # @param group [Integer]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#50
  def regexp(regexp, group: T.unsafe(nil)); end

  # Returns a parser that checks current character against the passed `regexp`
  #
  # @param regexp [Regexp]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#64
  def regexp_char(regexp); end

  # Returns a parser that consumes and returns the entire remainder of the input.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#92
  def remainder; end

  # Returns a parser that returns a single character if passed block result is truthy:
  #
  # lower = Combinators.satisfy do |char|
  #   char == char.downcase
  # end
  #
  # lower.parse("a") #=> "a"
  # lower.parse("P") #=> ParseError
  #
  # @param desc [String] optional description for the parser
  # @param block [Proc] proc with one argument – a next char of the input
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#19
  def satisfy(desc = T.unsafe(nil), &block); end

  # Alias for `parser.trim(Paco::Combinators.opt_ws)`.
  #
  # @param parser [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#202
  def spaced(parser); end

  # Returns a parser that looks for a passed `matcher` string and returns its value on success.
  #
  # @param matcher [String]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#34
  def string(matcher); end

  # Returns a parser that returns a string containing all the next
  # characters that are truthy for the passed block.
  #
  # @param block [Proc] proc with one argument – a next char of the input
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#106
  def take_while(&block); end

  # Alias for `Paco::Combinators.regexp(/\s+/)`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/combinators/char.rb#189
  def ws; end
end

# source://paco//lib/paco/context.rb#7
class Paco::Context
  # @return [Context] a new instance of Context
  #
  # source://paco//lib/paco/context.rb#11
  def initialize(input, pos: T.unsafe(nil), with_callstack: T.unsafe(nil)); end

  # Returns the value of attribute callstack.
  #
  # source://paco//lib/paco/context.rb#8
  def callstack; end

  # @return [Boolean]
  #
  # source://paco//lib/paco/context.rb#25
  def eof?; end

  # @param parser [Paco::Parser]
  #
  # source://paco//lib/paco/context.rb#36
  def failure_parse(parser); end

  # @param from [Integer]
  # @return [Paco::Index]
  #
  # source://paco//lib/paco/context.rb#31
  def index(from = T.unsafe(nil)); end

  # Returns the value of attribute input.
  #
  # source://paco//lib/paco/context.rb#8
  def input; end

  # Returns the value of attribute last_pos.
  #
  # source://paco//lib/paco/context.rb#8
  def last_pos; end

  # Returns the value of attribute pos.
  #
  # source://paco//lib/paco/context.rb#9
  def pos; end

  # Sets the attribute pos
  #
  # @param value the value to set the attribute pos to.
  #
  # source://paco//lib/paco/context.rb#9
  def pos=(_arg0); end

  # source://paco//lib/paco/context.rb#17
  def read(n); end

  # source://paco//lib/paco/context.rb#21
  def read_all; end

  # @param parser [Paco::Parser]
  #
  # source://paco//lib/paco/context.rb#41
  def start_parse(parser); end

  # @param result [Object]
  # @param parser [Paco::Parser]
  #
  # source://paco//lib/paco/context.rb#47
  def success_parse(result, parser); end
end

# source://paco//lib/paco/parse_error.rb#4
class Paco::Error < ::StandardError; end

# source://paco//lib/paco/index.rb#2
class Paco::Index < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  # Returns the value of attribute pos
  #
  # @return [Object] the current value of pos
  def pos; end

  # Sets the attribute pos
  #
  # @param value [Object] the value to set the attribute pos to.
  # @return [Object] the newly set value
  def pos=(_); end

  class << self
    def [](*_arg0); end

    # @param input [String]
    # @param pos [Integer]
    # @raise [ArgumentError]
    #
    # source://paco//lib/paco/index.rb#5
    def calculate(input:, pos:); end

    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://paco//lib/paco/memoizer.rb#6
module Paco::Memoizer
  extend ::MonitorMixin

  class << self
    # source://paco//lib/paco/memoizer.rb#10
    def memoize(key, &block); end
  end
end

# source://paco//lib/paco/parse_error.rb#6
class Paco::ParseError < ::Paco::Error
  # @param ctx [Paco::Context]
  # @return [ParseError] a new instance of ParseError
  #
  # source://paco//lib/paco/parse_error.rb#10
  def initialize(ctx, expected); end

  # source://paco//lib/paco/parse_error.rb#16
  def callstack; end

  # Returns the value of attribute ctx.
  #
  # source://paco//lib/paco/parse_error.rb#7
  def ctx; end

  # Returns the value of attribute expected.
  #
  # source://paco//lib/paco/parse_error.rb#7
  def expected; end

  # source://paco//lib/paco/parse_error.rb#20
  def message; end

  # Returns the value of attribute pos.
  #
  # source://paco//lib/paco/parse_error.rb#7
  def pos; end
end

# source://paco//lib/paco/parser.rb#6
class Paco::Parser
  # @param desc [String]
  # @return [Parser] a new instance of Parser
  #
  # source://paco//lib/paco/parser.rb#10
  def initialize(desc = T.unsafe(nil), &block); end

  # Expects `other` parser to follow `parser`, but returns only the value of `parser`.
  #
  # @param other [Poco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#60
  def <(other); end

  # Expects `other` parser to follow `parser`, but returns only the value of `other` parser.
  #
  # @param other [Poco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#68
  def >(other); end

  # @param ctx [Paco::Context]
  #
  # source://paco//lib/paco/parser.rb#30
  def _parse(ctx); end

  # Returns a parser that runs `parser` at least `num` times,
  # and returns an array of the results.
  #
  # source://paco//lib/paco/parser.rb#168
  def at_least(num); end

  # Returns a parser that runs `parser` at most `num` times,
  # and returns an array of the results.
  #
  # source://paco//lib/paco/parser.rb#176
  def at_most(num); end

  # Returns a new parser which tries `parser`, and on success
  # calls the `block` with the result of the parse, which is expected
  # to return another parser, which will be tried next. This allows you
  # to dynamically decide how to continue the parse, which is impossible
  # with the other Paco::Combinators.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#88
  def bind(&block); end

  # Returns a new parser which tries `parser`, and on success
  # calls the `block` with the result of the parse, which is expected
  # to return another parser, which will be tried next. This allows you
  # to dynamically decide how to continue the parse, which is impossible
  # with the other Paco::Combinators.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#88
  def chain(&block); end

  # Returns the value of attribute desc.
  #
  # source://paco//lib/paco/parser.rb#7
  def desc; end

  # Raises ParseError
  #
  # @param ctx [Paco::Context]
  # @raise [Paco::ParseError]
  #
  # source://paco//lib/paco/parser.rb#40
  def failure(ctx); end

  # Returns a new parser which tries `parser` and, if it fails, returns `value` without consuming any input.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#109
  def fallback(value); end

  # Transforms the output of `parser` with the given block.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#76
  def fmap(&block); end

  # Returns a parser that runs `parser` and concatenate it results with the `separator`.
  #
  # @param separator [String]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#139
  def join(separator = T.unsafe(nil)); end

  # Expects `parser` zero or more times, and returns an array of the results.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#97
  def many; end

  # Expects `other` parser to follow `parser`, but returns only the value of `other` parser.
  #
  # @param other [Poco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#68
  def next(other); end

  # Returns a parser that runs passed `other` parser without consuming the input, and
  # returns result of the `parser` if the passed one _does not match_ the input. Fails otherwise.
  #
  # @param other [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#132
  def not_followed_by(other); end

  # Returns a new parser which tries `parser`, and if it fails uses `other`.
  #
  # @param other [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#48
  def or(other); end

  # @param input [String, Paco::Context]
  # @param with_callstack [true, false]
  #
  # source://paco//lib/paco/parser.rb#24
  def parse(input, with_callstack: T.unsafe(nil)); end

  # Returns a new parser with the same behavior, but which returns passed `value`.
  #
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#103
  def result(value); end

  # Expects `other` parser to follow `parser`, but returns only the value of `parser`.
  #
  # @param other [Poco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#60
  def skip(other); end

  # Returns a parser that runs `parser` between `min` and `max` times,
  # and returns an array of the results. When `max` is not specified, `max` = `min`.
  #
  # @param min [Integer]
  # @param max [Integer]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#148
  def times(min, max = T.unsafe(nil)); end

  # Expects `other` parser before and after `parser`, and returns the result of the parser.
  #
  # @param other [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#116
  def trim(other); end

  # @param desc [String]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#17
  def with_desc(desc); end

  # Expects the parser `before` before `parser` and `after` after `parser. Returns the result of the parser.
  #
  # @param before [Paco::Parser]
  # @param after [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#124
  def wrap(before, after); end

  # Returns a new parser which tries `parser`, and if it fails uses `other`.
  #
  # @param other [Paco::Parser]
  # @return [Paco::Parser]
  #
  # source://paco//lib/paco/parser.rb#48
  def |(other); end
end

# source://paco//lib/paco/version.rb#4
Paco::VERSION = T.let(T.unsafe(nil), String)
