# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mail` gem.
# Please instead update this file by running `bin/tapioca gem mail`.

# typed: true

module Mail
  class << self
    def all(*args, &block); end
    def connection(&block); end
    def defaults(&block); end
    def delete_all(*args, &block); end
    def deliver(*args, &block); end
    def delivery_method; end
    def eager_autoload!; end
    def find(*args, &block); end
    def find_and_delete(*args, &block); end
    def first(*args, &block); end
    def from_source(source); end
    def inform_interceptors(mail); end
    def inform_observers(mail); end
    def last(*args, &block); end
    def new(*args, &block); end
    def random_tag; end
    def read(filename); end
    def read_from_string(mail_as_string); end
    def register_autoload(name, path); end
    def register_interceptor(interceptor); end
    def register_observer(observer); end
    def retriever_method; end
    def something_random; end
    def uniq; end
    def unregister_interceptor(interceptor); end
    def unregister_observer(observer); end
  end
end

class Mail::Address
  include ::Mail::Constants
  include ::Mail::Utilities

  def initialize(value = T.unsafe(nil)); end

  def ==(other_address); end
  def address(output_type = T.unsafe(nil)); end
  def address=(value); end
  def comments; end
  def decoded; end
  def display_name(output_type = T.unsafe(nil)); end
  def display_name=(str); end
  def domain(output_type = T.unsafe(nil)); end
  def encoded; end
  def format(output_type = T.unsafe(nil)); end
  def group; end
  def inspect; end
  def local(output_type = T.unsafe(nil)); end
  def name; end
  def raw; end
  def to_s; end

  private

  def format_comments; end
  def get_comments; end
  def get_display_name; end
  def get_domain; end
  def get_local; end
  def get_name; end
  def parse(value = T.unsafe(nil)); end
  def strip_all_comments(string); end
  def strip_domain_comments(value); end

  class << self
    def wrap(address); end
  end
end

class Mail::AddressContainer < ::Array
  def initialize(field, list = T.unsafe(nil)); end

  def <<(address); end
end

class Mail::AddressList
  def initialize(string); end

  def addresses; end
  def addresses_grouped_by_group; end
  def group_names; end
end

class Mail::AttachmentsList < ::Array
  def initialize(parts_list); end

  def [](index_value); end
  def []=(name, value); end
  def guess_encoding; end
  def inline; end
  def set_mime_type(filename); end
end

class Mail::BccField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
  def include_in_headers; end
  def include_in_headers=(include_in_headers); end
end

Mail::BccField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::BccField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::Body
  def initialize(string = T.unsafe(nil)); end

  def <<(val); end
  def ==(other); end
  def =~(regexp); end
  def ascii_only?; end
  def boundary; end
  def boundary=(val); end
  def charset; end
  def charset=(val); end
  def decoded; end
  def default_encoding; end
  def empty?; end
  def encoded(transfer_encoding = T.unsafe(nil)); end
  def encoding(val = T.unsafe(nil)); end
  def encoding=(val); end
  def epilogue; end
  def epilogue=(val); end
  def include?(other); end
  def match(regexp); end
  def multipart?; end
  def negotiate_best_encoding(message_encoding, allowed_encodings = T.unsafe(nil)); end
  def parts; end
  def preamble; end
  def preamble=(val); end
  def raw_source; end
  def set_sort_order(order); end
  def sort_parts!; end
  def split!(boundary); end
  def to_s; end

  private

  def crlf_boundary; end
  def end_boundary; end
  def extract_parts; end
  def set_charset; end
end

class Mail::CcField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::CcField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::CcField::FIELD_NAME = T.let(T.unsafe(nil), String)

module Mail::CheckDeliveryParams
  class << self
    def check(mail); end
    def check_addr(addr_name, addr); end
    def check_from(addr); end
    def check_message(message); end
    def check_to(addrs); end
    def validate_smtp_addr(addr); end
  end
end

class Mail::CommentsField < ::Mail::UnstructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end
end

Mail::CommentsField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::CommentsField::FIELD_NAME = T.let(T.unsafe(nil), String)

module Mail::CommonAddress
  def <<(val); end
  def addresses; end
  def addrs; end
  def charset; end
  def decoded_group_addresses; end
  def default; end
  def display_names; end
  def each; end
  def encode_if_needed(val); end
  def encoded_group_addresses; end
  def formatted; end
  def group_addresses; end
  def group_names; end
  def groups; end
  def parse(val = T.unsafe(nil)); end
  def value=(val); end

  private

  def address_list; end
  def do_decode; end
  def do_encode(field_name); end
  def get_group_addresses(group_list); end
  def utf8_if_needed(val); end
end

module Mail::CommonDate
  def date_time; end
  def default; end
  def parse(val = T.unsafe(nil)); end

  private

  def do_decode; end
  def do_encode(field_name); end
  def element; end
end

module Mail::CommonField
  include ::Mail::Constants

  def default; end
  def field_length; end
  def name; end
  def name=(value); end
  def responsible_for?(val); end
  def to_s; end
  def value; end
  def value=(value); end

  private

  def ensure_filename_quoted(value); end
end

Mail::CommonField::FILENAME_RE = T.let(T.unsafe(nil), Regexp)

module Mail::CommonMessageId
  def default; end
  def element; end
  def message_id; end
  def message_ids; end
  def parse(val = T.unsafe(nil)); end

  private

  def do_decode; end
  def do_encode(field_name); end
  def formated_message_ids(join); end
end

class Mail::Configuration
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def initialize; end

  def delivery_method(method = T.unsafe(nil), settings = T.unsafe(nil)); end
  def lookup_delivery_method(method); end
  def lookup_retriever_method(method); end
  def param_encode_language(value = T.unsafe(nil)); end
  def retriever_method(method = T.unsafe(nil), settings = T.unsafe(nil)); end
end

module Mail::Constants; end
Mail::Constants::ASTERISK = T.let(T.unsafe(nil), String)
Mail::Constants::ATOM_UNSAFE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::B_VALUES = T.let(T.unsafe(nil), Array)
Mail::Constants::CAPITAL_M = T.let(T.unsafe(nil), String)
Mail::Constants::COLON = T.let(T.unsafe(nil), String)
Mail::Constants::CONTROL_CHAR = T.let(T.unsafe(nil), Regexp)
Mail::Constants::CR = T.let(T.unsafe(nil), String)
Mail::Constants::CRLF = T.let(T.unsafe(nil), Regexp)
Mail::Constants::CR_ENCODED = T.let(T.unsafe(nil), String)
Mail::Constants::EMPTY = T.let(T.unsafe(nil), String)
Mail::Constants::ENCODED_VALUE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::EQUAL_LF = T.let(T.unsafe(nil), String)
Mail::Constants::FIELD_BODY = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FIELD_LINE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FIELD_NAME = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FIELD_PREFIX = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FIELD_SPLIT = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FULL_ENCODED_VALUE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::FWS = T.let(T.unsafe(nil), Regexp)
Mail::Constants::HEADER_LINE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::HEADER_SPLIT = T.let(T.unsafe(nil), Regexp)
Mail::Constants::HYPHEN = T.let(T.unsafe(nil), String)
Mail::Constants::LF = T.let(T.unsafe(nil), String)
Mail::Constants::LF_ENCODED = T.let(T.unsafe(nil), String)
Mail::Constants::NULL_SENDER = T.let(T.unsafe(nil), String)
Mail::Constants::PHRASE_UNSAFE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::QP_SAFE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::QP_UNSAFE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::Q_VALUES = T.let(T.unsafe(nil), Array)
Mail::Constants::SPACE = T.let(T.unsafe(nil), String)
Mail::Constants::TEXT = T.let(T.unsafe(nil), Regexp)
Mail::Constants::TOKEN_UNSAFE = T.let(T.unsafe(nil), Regexp)
Mail::Constants::UNDERSCORE = T.let(T.unsafe(nil), String)
Mail::Constants::WSP = T.let(T.unsafe(nil), Regexp)

class Mail::ContentDescriptionField < ::Mail::UnstructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end
end

Mail::ContentDescriptionField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentDescriptionField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ContentDispositionElement
  def initialize(string); end

  def disposition_type; end
  def parameters; end

  private

  def cleaned(string); end
end

class Mail::ContentDispositionField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def disposition_type; end
  def element; end
  def encoded; end
  def filename; end
  def parameters; end
  def parse(val = T.unsafe(nil)); end
end

Mail::ContentDispositionField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentDispositionField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ContentIdField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def content_id; end
  def decoded; end
  def element; end
  def encoded; end
  def name; end
  def parse(val = T.unsafe(nil)); end
  def to_s; end

  private

  def generate_content_id; end
end

Mail::ContentIdField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentIdField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ContentLocationElement
  def initialize(string); end

  def location; end
  def to_s(*args); end
end

class Mail::ContentLocationField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def element; end
  def encoded; end
  def location; end
  def parse(val = T.unsafe(nil)); end
end

Mail::ContentLocationField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentLocationField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ContentTransferEncodingElement
  def initialize(string); end

  def encoding; end
end

class Mail::ContentTransferEncodingField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def element; end
  def encoded; end
  def encoding; end
  def parse(val = T.unsafe(nil)); end
end

Mail::ContentTransferEncodingField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentTransferEncodingField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type; end
  def parameters; end
  def sub_type; end

  private

  def cleaned(string); end
end

class Mail::ContentTypeField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def attempt_to_clean; end
  def content_type; end
  def decoded; end
  def default; end
  def element; end
  def encoded; end
  def filename; end
  def main_type; end
  def parameters; end
  def parse(val = T.unsafe(nil)); end
  def string; end
  def stringify(params); end
  def sub_type; end
  def value; end

  private

  def get_mime_type(val); end
  def method_missing(name, *args, &block); end
  def sanatize(val); end

  class << self
    def generate_boundary; end
    def with_boundary(type); end
  end
end

Mail::ContentTypeField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ContentTypeField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::DateField < ::Mail::StructuredField
  include ::Mail::CommonDate

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::DateField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::DateField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::DateTimeElement
  def initialize(string); end

  def date_string; end
  def time_string; end
end

module Mail::Encodings
  include ::Mail::Constants
  extend ::Mail::Constants
  extend ::Mail::Utilities

  class << self
    def address_encode(address, charset = T.unsafe(nil)); end
    def b_value_decode(str); end
    def b_value_encode(string, encoding = T.unsafe(nil)); end
    def collapse_adjacent_encodings(str); end
    def decode_encode(str, output_type); end
    def defined?(name); end
    def each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end
    def each_chunk_byterange(str, max_bytesize_per_chunk); end
    def encode_non_usascii(address, charset); end
    def find_encoding(str); end
    def get_all; end
    def get_encoding(name); end
    def get_name(name); end
    def param_decode(str, encoding); end
    def param_encode(str); end
    def q_value_decode(str); end
    def q_value_encode(encoded_str, encoding = T.unsafe(nil)); end
    def register(name, cls); end
    def transcode_charset(str, from_charset, to_charset = T.unsafe(nil)); end
    def unquote_and_convert_to(str, to_encoding); end
    def value_decode(str); end
    def value_encoding_from_string(str); end
    def with_ascii_kcode; end
  end
end

class Mail::Encodings::Base64 < ::Mail::Encodings::SevenBit
  class << self
    def can_encode?(enc); end
    def compatible_input?(str); end
    def cost(str); end
    def decode(str); end
    def encode(str); end
  end
end

Mail::Encodings::Base64::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::Base64::PRIORITY = T.let(T.unsafe(nil), Integer)
class Mail::Encodings::Binary < ::Mail::Encodings::Identity; end
Mail::Encodings::Binary::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::Binary::PRIORITY = T.let(T.unsafe(nil), Integer)

class Mail::Encodings::EightBit < ::Mail::Encodings::Binary
  class << self
    def compatible_input?(str); end
  end
end

Mail::Encodings::EightBit::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::EightBit::PRIORITY = T.let(T.unsafe(nil), Integer)

class Mail::Encodings::Identity < ::Mail::Encodings::TransferEncoding
  class << self
    def cost(str); end
    def decode(str); end
    def encode(str); end
  end
end

class Mail::Encodings::QuotedPrintable < ::Mail::Encodings::SevenBit
  class << self
    def can_encode?(enc); end
    def compatible_input?(str); end
    def cost(str); end
    def decode(str); end
    def encode(str); end
  end
end

Mail::Encodings::QuotedPrintable::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::QuotedPrintable::PRIORITY = T.let(T.unsafe(nil), Integer)

class Mail::Encodings::SevenBit < ::Mail::Encodings::EightBit
  class << self
    def decode(str); end
    def encode(str); end
  end
end

Mail::Encodings::SevenBit::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::SevenBit::PRIORITY = T.let(T.unsafe(nil), Integer)

class Mail::Encodings::TransferEncoding
  class << self
    def can_encode?(enc); end
    def can_transport?(enc); end
    def compatible_input?(str); end
    def cost(str); end
    def lowest_cost(str, encodings); end
    def negotiate(message_encoding, source_encoding, str, allowed_encodings = T.unsafe(nil)); end
    def renegotiate(message_encoding, source_encoding, str, allowed_encodings = T.unsafe(nil)); end
    def to_s; end
  end
end

Mail::Encodings::TransferEncoding::NAME = T.let(T.unsafe(nil), String)
Mail::Encodings::TransferEncoding::PRIORITY = T.let(T.unsafe(nil), Integer)

class Mail::Encodings::UnixToUnix < ::Mail::Encodings::TransferEncoding
  class << self
    def decode(str); end
    def encode(str); end
  end
end

Mail::Encodings::UnixToUnix::NAME = T.let(T.unsafe(nil), String)

class Mail::Envelope < ::Mail::StructuredField
  def initialize(*args); end

  def date; end
  def element; end
  def from; end
end

class Mail::EnvelopeFromElement
  def initialize(string); end

  def address; end
  def date_time; end
  def formatted_date_time; end
  def to_s; end
end

class Mail::Exim < ::Mail::Sendmail
  class << self
    def call(path, arguments, destinations, encoded_message); end
  end
end

Mail::Exim::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Mail::Field
  include ::Mail::Constants
  include ::Mail::Utilities
  include ::Comparable

  def initialize(name, value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def field; end
  def field=(value); end
  def field_order_id; end
  def inspect; end
  def method_missing(name, *args, &block); end
  def name; end
  def responsible_for?(val); end
  def same(other); end
  def to_s; end
  def unparsed_value; end
  def update(name, value); end
  def value; end
  def value=(val); end

  private

  def create_field(name, value, charset); end
  def field_class_for(name); end
  def new_field(name, value, charset); end
  def respond_to_missing?(method_name, include_private); end
  def unfold(string); end

  class << self
    def parse(field, charset = T.unsafe(nil)); end
    def split(raw_field); end
  end
end

Mail::Field::FIELDS_MAP = T.let(T.unsafe(nil), Hash)
Mail::Field::FIELD_NAME_MAP = T.let(T.unsafe(nil), Hash)
Mail::Field::FIELD_ORDER = T.let(T.unsafe(nil), Array)
Mail::Field::FIELD_ORDER_LOOKUP = T.let(T.unsafe(nil), Hash)
class Mail::Field::FieldError < ::StandardError; end

class Mail::Field::IncompleteParseError < ::Mail::Field::ParseError
  def initialize(element, original_text, unparsed_index); end
end

Mail::Field::KNOWN_FIELDS = T.let(T.unsafe(nil), Array)

class Mail::Field::NilParseError < ::Mail::Field::ParseError
  def initialize(element); end
end

class Mail::Field::ParseError < ::Mail::Field::FieldError
  def initialize(element, value, reason); end

  def element; end
  def element=(_arg0); end
  def reason; end
  def reason=(_arg0); end
  def value; end
  def value=(_arg0); end

  private

  def to_utf8(text); end
end

Mail::Field::STRUCTURED_FIELDS = T.let(T.unsafe(nil), Array)
class Mail::Field::SyntaxError < ::Mail::Field::FieldError; end

class Mail::FieldList < ::Array
  def <<(new_field); end
end

class Mail::FileDelivery
  def initialize(values); end

  def deliver!(mail); end
  def settings; end
  def settings=(_arg0); end
end

class Mail::FromField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::FromField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::FromField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::Header
  include ::Mail::Constants
  include ::Mail::Utilities
  include ::Enumerable

  def initialize(header_text = T.unsafe(nil), charset = T.unsafe(nil)); end

  def [](name); end
  def []=(name, value); end
  def charset; end
  def charset=(val); end
  def decoded; end
  def encoded; end
  def errors; end
  def field_summary; end
  def fields; end
  def fields=(unfolded_fields); end
  def has_content_id?; end
  def has_date?; end
  def has_message_id?; end
  def has_mime_version?; end
  def raw_source; end
  def to_s; end

  private

  def each(&block); end
  def initialize_copy(original); end
  def limited_field?(name); end
  def raw_source=(val); end
  def select_field_for(name); end
  def split_header; end

  class << self
    def maximum_amount; end
    def maximum_amount=(value); end
  end
end

Mail::Header::LIMITED_FIELDS = T.let(T.unsafe(nil), Array)

class Mail::IMAP < ::Mail::Retriever
  def initialize(values); end

  def connection(&block); end
  def delete_all(mailbox = T.unsafe(nil)); end
  def find(options = T.unsafe(nil), &block); end
  def settings; end
  def settings=(_arg0); end

  private

  def start(config = T.unsafe(nil), &block); end
  def validate_options(options); end
end

class Mail::InReplyToField < ::Mail::StructuredField
  include ::Mail::CommonMessageId

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::InReplyToField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::InReplyToField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::IndifferentHash < ::Hash
  def initialize(constructor = T.unsafe(nil)); end

  def []=(key, value); end
  def default(key = T.unsafe(nil)); end
  def delete(key); end
  def dup; end
  def fetch(key, *extras); end
  def has_key?(key); end
  def include?(key); end
  def key?(key); end
  def member?(key); end
  def merge(hash); end
  def merge!(other_hash); end
  def regular_update(*_arg0); end
  def regular_writer(_arg0, _arg1); end
  def reverse_merge(other_hash); end
  def reverse_merge!(other_hash); end
  def store(key, value); end
  def stringify_keys; end
  def stringify_keys!; end
  def symbolize_keys; end
  def to_hash; end
  def to_options!; end
  def update(other_hash); end
  def values_at(*indices); end

  protected

  def convert_key(key); end
  def convert_value(value); end

  class << self
    def new_from_hash_copying_default(hash); end
  end
end

class Mail::KeywordsField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def default; end
  def encoded; end
  def keywords; end
  def parse(val = T.unsafe(nil)); end
  def phrase_list; end
end

Mail::KeywordsField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::KeywordsField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams

  def initialize(settings); end

  def deliver!(mail); end
  def logger; end
  def settings; end
  def severity; end

  private

  def default_logger; end
  def derive_severity(severity); end
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end
  def any_attachment; end
  def have_sent_email; end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AttachmentFilenameMatcher
  def initialize(filename); end

  def ===(other); end
  def filename; end
end

class Mail::Matchers::HasSentEmailMatcher
  def initialize(_context); end

  def bcc(recipient_or_list); end
  def cc(recipient_or_list); end
  def description; end
  def failure_message; end
  def failure_message_when_negated; end
  def from(sender); end
  def matches?(subject); end
  def matching_body(body_matcher); end
  def matching_subject(subject_matcher); end
  def to(recipient_or_list); end
  def with_any_attachments; end
  def with_attachments(attachments); end
  def with_body(body); end
  def with_html(body); end
  def with_no_attachments; end
  def with_subject(subject); end
  def with_text(body); end

  protected

  def dump_deliveries; end
  def explain_expectations; end
  def filter_matched_deliveries(deliveries); end
  def matches_on_attachments?(delivery); end
  def matches_on_blind_copy_recipients?(delivery); end
  def matches_on_body?(delivery); end
  def matches_on_body_matcher?(delivery); end
  def matches_on_copy_recipients?(delivery); end
  def matches_on_having_attachments?(delivery); end
  def matches_on_html_part_body?(delivery); end
  def matches_on_recipients?(delivery); end
  def matches_on_sender?(delivery); end
  def matches_on_subject?(delivery); end
  def matches_on_subject_matcher?(delivery); end
  def matches_on_text_part_body?(delivery); end
end

class Mail::Message
  include ::Mail::Constants
  include ::Mail::Utilities

  def initialize(*args, &block); end

  def <=>(other); end
  def ==(other); end
  def [](name); end
  def []=(name, value); end
  def action; end
  def add_charset; end
  def add_content_transfer_encoding; end
  def add_content_type; end
  def add_date(date_val = T.unsafe(nil)); end
  def add_file(values); end
  def add_message_id(msg_id_val = T.unsafe(nil)); end
  def add_mime_version(ver_val = T.unsafe(nil)); end
  def add_part(part); end
  def add_transfer_encoding; end
  def all_parts; end
  def attachment; end
  def attachment?; end
  def attachments; end
  def bcc(val = T.unsafe(nil)); end
  def bcc=(val); end
  def bcc_addresses; end
  def bcc_addrs; end
  def body(value = T.unsafe(nil)); end
  def body=(value); end
  def body_encoding(value = T.unsafe(nil)); end
  def body_encoding=(value); end
  def bounced?; end
  def boundary; end
  def cc(val = T.unsafe(nil)); end
  def cc=(val); end
  def cc_addresses; end
  def cc_addrs; end
  def charset; end
  def charset=(value); end
  def comments(val = T.unsafe(nil)); end
  def comments=(val); end
  def content_description(val = T.unsafe(nil)); end
  def content_description=(val); end
  def content_disposition(val = T.unsafe(nil)); end
  def content_disposition=(val); end
  def content_id(val = T.unsafe(nil)); end
  def content_id=(val); end
  def content_location(val = T.unsafe(nil)); end
  def content_location=(val); end
  def content_transfer_encoding(val = T.unsafe(nil)); end
  def content_transfer_encoding=(val); end
  def content_type(val = T.unsafe(nil)); end
  def content_type=(val); end
  def content_type_parameters; end
  def convert_to_multipart; end
  def date(val = T.unsafe(nil)); end
  def date=(val); end
  def decode_body; end
  def decoded; end
  def default(sym, val = T.unsafe(nil)); end
  def deliver; end
  def deliver!; end
  def delivery_handler; end
  def delivery_handler=(_arg0); end
  def delivery_method(method = T.unsafe(nil), settings = T.unsafe(nil)); end
  def delivery_status_part; end
  def delivery_status_report?; end
  def destinations; end
  def diagnostic_code; end
  def encode!; end
  def encoded; end
  def envelope_date; end
  def envelope_from; end
  def error_status; end
  def errors; end
  def filename; end
  def final_recipient; end
  def find_first_mime_type(mt); end
  def from(val = T.unsafe(nil)); end
  def from=(val); end
  def from_address; end
  def from_addrs; end
  def has_attachments?; end
  def has_charset?; end
  def has_content_transfer_encoding?; end
  def has_content_type?; end
  def has_date?; end
  def has_message_id?; end
  def has_mime_version?; end
  def has_transfer_encoding?; end
  def header(value = T.unsafe(nil)); end
  def header=(value); end
  def header_fields; end
  def headers(hash = T.unsafe(nil)); end
  def html_part(&block); end
  def html_part=(msg); end
  def in_reply_to(val = T.unsafe(nil)); end
  def in_reply_to=(val); end
  def inform_interceptors; end
  def inform_observers; end
  def inspect; end
  def is_marked_for_delete?; end
  def keywords(val = T.unsafe(nil)); end
  def keywords=(val); end
  def main_type; end
  def mark_for_delete=(value = T.unsafe(nil)); end
  def message_content_type; end
  def message_id(val = T.unsafe(nil)); end
  def message_id=(val); end
  def method_missing(name, *args, &block); end
  def mime_parameters; end
  def mime_type; end
  def mime_version(val = T.unsafe(nil)); end
  def mime_version=(val); end
  def multipart?; end
  def multipart_report?; end
  def part(params = T.unsafe(nil)); end
  def parts; end
  def perform_deliveries; end
  def perform_deliveries=(_arg0); end
  def raise_delivery_errors; end
  def raise_delivery_errors=(_arg0); end
  def raw_envelope; end
  def raw_source; end
  def read; end
  def ready_to_send!; end
  def received(val = T.unsafe(nil)); end
  def received=(val); end
  def recipients; end
  def recipients_addresses; end
  def references(val = T.unsafe(nil)); end
  def references=(val); end
  def register_for_delivery_notification(observer); end
  def remote_mta; end
  def reply(*args, &block); end
  def reply_to(val = T.unsafe(nil)); end
  def reply_to=(val); end
  def resent_bcc(val = T.unsafe(nil)); end
  def resent_bcc=(val); end
  def resent_cc(val = T.unsafe(nil)); end
  def resent_cc=(val); end
  def resent_date(val = T.unsafe(nil)); end
  def resent_date=(val); end
  def resent_from(val = T.unsafe(nil)); end
  def resent_from=(val); end
  def resent_message_id(val = T.unsafe(nil)); end
  def resent_message_id=(val); end
  def resent_sender(val = T.unsafe(nil)); end
  def resent_sender=(val); end
  def resent_to(val = T.unsafe(nil)); end
  def resent_to=(val); end
  def retryable?; end
  def return_path(val = T.unsafe(nil)); end
  def return_path=(val); end
  def sender(val = T.unsafe(nil)); end
  def sender=(val); end
  def set_envelope(val); end
  def skip_deletion; end
  def smtp_envelope_from(val = T.unsafe(nil)); end
  def smtp_envelope_from=(val); end
  def smtp_envelope_to(val = T.unsafe(nil)); end
  def smtp_envelope_to=(val); end
  def sub_type; end
  def subject(val = T.unsafe(nil)); end
  def subject=(val); end
  def text?; end
  def text_part(&block); end
  def text_part=(msg); end
  def to(val = T.unsafe(nil)); end
  def to=(val); end
  def to_addresses; end
  def to_addrs; end
  def to_s; end
  def to_yaml(opts = T.unsafe(nil)); end
  def transfer_encoding; end
  def transport_encoding(val = T.unsafe(nil)); end
  def transport_encoding=(val); end
  def without_attachments!; end
  def x_original_to_addresses; end

  private

  def add_boundary; end
  def add_encoding_to_body; end
  def add_multipart_alternate_header; end
  def add_multipart_mixed_header; end
  def add_required_fields; end
  def add_required_message_fields; end
  def allowed_encodings; end
  def body_lazy(value); end
  def decode_body_as_text; end
  def do_delivery; end
  def find_attachment; end
  def identify_and_set_transfer_encoding; end
  def init_with_hash(hash); end
  def init_with_string(string); end
  def initialize_copy(original); end
  def parse_message; end
  def process_body_raw; end
  def raw_source=(value); end
  def separate_parts; end
  def set_envelope_header; end

  class << self
    def default_charset; end
    def default_charset=(charset); end
    def from_hash(hash); end
    def from_yaml(str); end
  end
end

Mail::Message::HEADER_SEPARATOR = T.let(T.unsafe(nil), Regexp)

class Mail::MessageIdField < ::Mail::StructuredField
  include ::Mail::CommonMessageId

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
  def message_ids; end
  def name; end
  def to_s; end

  private

  def generate_message_id; end
end

Mail::MessageIdField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::MessageIdField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id; end
  def message_ids; end

  private

  def clean_msg_id(val); end
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major; end
  def minor; end
end

class Mail::MimeVersionField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def element; end
  def encoded; end
  def major; end
  def minor; end
  def parse(val = T.unsafe(nil)); end
  def version; end
end

Mail::MimeVersionField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::MimeVersionField::FIELD_NAME = T.let(T.unsafe(nil), String)

module Mail::Multibyte
  class << self
    def clean(string); end
    def mb_chars(str); end
    def proxy_class; end
    def proxy_class=(_arg0); end
    def valid_character; end
    def verify(string); end
    def verify!(string); end
  end
end

class Mail::Multibyte::Chars
  include ::Comparable

  def initialize(string); end

  def <=>(other); end
  def =~(other); end
  def [](*args); end
  def []=(*args); end
  def acts_like_string?; end
  def capitalize; end
  def capitalize!(*args); end
  def compose; end
  def decompose; end
  def downcase; end
  def downcase!(*args); end
  def g_length; end
  def limit(limit); end
  def method_missing(method, *args, &block); end
  def normalize(form = T.unsafe(nil)); end
  def respond_to?(method, include_private = T.unsafe(nil)); end
  def reverse; end
  def reverse!(*args); end
  def slice(*args); end
  def slice!(*args); end
  def split(*args); end
  def tidy_bytes(force = T.unsafe(nil)); end
  def tidy_bytes!(*args); end
  def titlecase; end
  def titleize; end
  def to_s; end
  def to_str; end
  def upcase; end
  def upcase!(*args); end
  def wrapped_string; end

  protected

  def chars(string); end
  def justify(integer, way, padstr = T.unsafe(nil)); end
  def padding(padsize, padstr = T.unsafe(nil)); end
  def translate_offset(byte_offset); end

  class << self
    def consumes?(string); end
  end
end

class Mail::Multibyte::EncodingError < ::StandardError; end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode

  def apply_mapping(string, mapping); end
  def compose_codepoints(codepoints); end
  def decompose_codepoints(type, codepoints); end
  def default_normalization_form; end
  def default_normalization_form=(_arg0); end
  def g_pack(unpacked); end
  def g_unpack(string); end
  def in_char_class?(codepoint, classes); end
  def normalize(string, form = T.unsafe(nil)); end
  def reorder_characters(codepoints); end
  def tidy_bytes(string, force = T.unsafe(nil)); end
  def u_unpack(string); end

  private

  def database; end
  def tidy_byte(byte); end

  class << self
    def codepoints_to_pattern(array_of_codepoints); end
  end
end

class Mail::Multibyte::Unicode::Codepoint
  def initialize; end

  def code; end
  def code=(_arg0); end
  def combining_class; end
  def combining_class=(_arg0); end
  def decomp_mapping; end
  def decomp_mapping=(_arg0); end
  def decomp_type; end
  def decomp_type=(_arg0); end
  def lowercase_mapping; end
  def lowercase_mapping=(_arg0); end
  def swapcase_mapping; end
  def uppercase_mapping; end
  def uppercase_mapping=(_arg0); end
end

Mail::Multibyte::Unicode::HANGUL_JAMO_FIRST = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_JAMO_LAST = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_LBASE = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_LCOUNT = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_NCOUNT = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_SBASE = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_SCOUNT = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_SLAST = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_TBASE = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_TCOUNT = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_VBASE = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::HANGUL_VCOUNT = T.let(T.unsafe(nil), Integer)
Mail::Multibyte::Unicode::LEADERS_AND_TRAILERS = T.let(T.unsafe(nil), Array)
Mail::Multibyte::Unicode::LEADERS_PAT = T.let(T.unsafe(nil), Regexp)
Mail::Multibyte::Unicode::NORMALIZATION_FORMS = T.let(T.unsafe(nil), Array)
Mail::Multibyte::Unicode::TRAILERS_PAT = T.let(T.unsafe(nil), Regexp)
Mail::Multibyte::Unicode::UNICODE_VERSION = T.let(T.unsafe(nil), String)

class Mail::Multibyte::Unicode::UnicodeDatabase
  def initialize; end

  def boundary; end
  def boundary=(_arg0); end
  def codepoints; end
  def codepoints=(_arg0); end
  def composition_exclusion; end
  def composition_exclusion=(_arg0); end
  def composition_map; end
  def composition_map=(_arg0); end
  def cp1252; end
  def cp1252=(_arg0); end
  def load; end

  class << self
    def dirname; end
    def filename; end
  end
end

Mail::Multibyte::Unicode::UnicodeDatabase::ATTRIBUTES = T.let(T.unsafe(nil), Array)
Mail::Multibyte::Unicode::WHITESPACE = T.let(T.unsafe(nil), Array)
Mail::Multibyte::VALID_CHARACTER = T.let(T.unsafe(nil), Hash)

class Mail::OptionalField < ::Mail::UnstructuredField
  private

  def do_encode; end
end

class Mail::POP3 < ::Mail::Retriever
  def initialize(values); end

  def connection(&block); end
  def delete_all; end
  def find(options = T.unsafe(nil), &block); end
  def settings; end
  def settings=(_arg0); end

  private

  def start(config = T.unsafe(nil), &block); end
  def validate_options(options); end
end

class Mail::ParameterHash < ::Mail::IndifferentHash
  include ::Mail::Constants
  include ::Mail::Utilities

  def [](key_name); end
  def decoded; end
  def encoded; end
end

module Mail::ParserTools
  def chars(data, from_bytes, to_bytes); end
end

module Mail::Parsers; end

module Mail::Parsers::AddressListsParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::AddressListsParser::AddressListStruct < ::Struct
  def addresses; end
  def addresses=(_); end
  def error; end
  def error=(_); end
  def group_names; end
  def group_names=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Mail::Parsers::AddressListsParser::AddressStruct < ::Struct
  def comments; end
  def comments=(_); end
  def display_name; end
  def display_name=(_); end
  def domain; end
  def domain=(_); end
  def error; end
  def error=(_); end
  def group; end
  def group=(_); end
  def local; end
  def local=(_); end
  def obs_domain_list; end
  def obs_domain_list=(_); end
  def raw; end
  def raw=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::ContentDispositionParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct < ::Struct
  def disposition_type; end
  def disposition_type=(_); end
  def error; end
  def error=(_); end
  def parameters; end
  def parameters=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::ContentLocationParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct < ::Struct
  def error; end
  def error=(_); end
  def location; end
  def location=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct < ::Struct
  def encoding; end
  def encoding=(_); end
  def error; end
  def error=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::ContentTypeParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct < ::Struct
  def error; end
  def error=(_); end
  def main_type; end
  def main_type=(_); end
  def parameters; end
  def parameters=(_); end
  def sub_type; end
  def sub_type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::DateTimeParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct < ::Struct
  def date_string; end
  def date_string=(_); end
  def error; end
  def error=(_); end
  def time_string; end
  def time_string=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct < ::Struct
  def address; end
  def address=(_); end
  def ctime_date; end
  def ctime_date=(_); end
  def error; end
  def error=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::MessageIdsParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct < ::Struct
  def error; end
  def error=(_); end
  def message_ids; end
  def message_ids=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::MimeVersionParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct < ::Struct
  def error; end
  def error=(_); end
  def major; end
  def major=(_); end
  def minor; end
  def minor=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Mail::Parsers::PhraseListsParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct < ::Struct
  def error; end
  def error=(_); end
  def phrases; end
  def phrases=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Mail::Parsers::ReceivedParser
  extend ::Mail::ParserTools

  class << self
    def en_comment_tail; end
    def en_comment_tail=(_arg0); end
    def en_main; end
    def en_main=(_arg0); end
    def error; end
    def error=(_arg0); end
    def first_final; end
    def first_final=(_arg0); end
    def parse(data); end
    def start; end
    def start=(_arg0); end

    private

    def _eof_actions; end
    def _eof_actions=(_arg0); end
    def _index_offsets; end
    def _index_offsets=(_arg0); end
    def _indicies; end
    def _indicies=(_arg0); end
    def _key_spans; end
    def _key_spans=(_arg0); end
    def _trans_actions; end
    def _trans_actions=(_arg0); end
    def _trans_keys; end
    def _trans_keys=(_arg0); end
    def _trans_targs; end
    def _trans_targs=(_arg0); end
  end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct < ::Struct
  def date; end
  def date=(_); end
  def error; end
  def error=(_); end
  def info; end
  def info=(_); end
  def time; end
  def time=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class Mail::Part < ::Mail::Message
  def action; end
  def add_content_id(content_id_val = T.unsafe(nil)); end
  def add_required_fields; end
  def add_required_message_fields; end
  def bounced?; end
  def cid; end
  def delivery_status_data; end
  def delivery_status_report_part?; end
  def diagnostic_code; end
  def error_status; end
  def final_recipient; end
  def has_content_id?; end
  def inline?; end
  def inline_content_id; end
  def remote_mta; end
  def retryable?; end
  def url; end

  private

  def get_return_values(key); end
  def parse_delivery_status_report; end
  def parse_message; end
end

class Mail::PartsList
  def initialize(*args); end

  def attachments; end
  def collect; end
  def collect!; end
  def encode_with(coder); end
  def map; end
  def map!; end
  def parts; end
  def sort; end
  def sort!(order); end
  def to_yaml(options = T.unsafe(nil)); end

  private

  def get_order_value(part, order); end
end

class Mail::PhraseList
  def initialize(string); end

  def phrases; end
end

Mail::RANDOM_TAG = T.let(T.unsafe(nil), String)

class Mail::ReceivedElement
  include ::Mail::Constants
  include ::Mail::Utilities

  def initialize(string); end

  def date_time; end
  def info; end
  def to_s(*args); end
end

class Mail::ReceivedField < ::Mail::StructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def date_time; end
  def decoded; end
  def element; end
  def encoded; end
  def formatted_date; end
  def info; end
  def parse(val = T.unsafe(nil)); end
end

Mail::ReceivedField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ReceivedField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ReferencesField < ::Mail::StructuredField
  include ::Mail::CommonMessageId

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ReferencesField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ReferencesField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ReplyToField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ReplyToField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ReplyToField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentBccField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ResentBccField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentBccField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentCcField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ResentCcField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentCcField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentDateField < ::Mail::StructuredField
  include ::Mail::CommonDate

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ResentDateField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentDateField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentFromField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ResentFromField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentFromField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentMessageIdField < ::Mail::StructuredField
  include ::Mail::CommonMessageId

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
  def name; end
end

Mail::ResentMessageIdField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentMessageIdField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentSenderField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def address; end
  def addresses; end
  def decoded; end
  def encoded; end
end

Mail::ResentSenderField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentSenderField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::ResentToField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ResentToField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ResentToField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::Retriever
  def all(options = T.unsafe(nil), &block); end
  def find_and_delete(options = T.unsafe(nil), &block); end
  def first(options = T.unsafe(nil), &block); end
  def last(options = T.unsafe(nil), &block); end
end

class Mail::ReturnPathField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def address; end
  def decoded; end
  def default; end
  def encoded; end
end

Mail::ReturnPathField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ReturnPathField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::Ruby19
  class << self
    def b_value_decode(str); end
    def b_value_encode(str, encoding = T.unsafe(nil)); end
    def bracket(str); end
    def charset_encoder; end
    def charset_encoder=(_arg0); end
    def decode_base64(str); end
    def decode_utf7(utf7); end
    def encode_base64(str); end
    def encode_utf7(string); end
    def escape_bracket(str); end
    def escape_paren(str); end
    def get_constant(klass, string); end
    def has_constant?(klass, string); end
    def param_decode(str, encoding); end
    def param_encode(str); end
    def paren(str); end
    def pick_encoding(charset); end
    def q_value_decode(str); end
    def q_value_encode(str, encoding = T.unsafe(nil)); end
    def string_byteslice(str, *args); end
    def transcode_charset(str, from_encoding, to_encoding = T.unsafe(nil)); end
    def uri_parser; end

    private

    def convert_to_encoding(encoding); end
    def transcode_to_scrubbed_utf8(str); end
  end
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end

  private

  def pick_encoding(charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def initialize(values); end

  def deliver!(mail); end
  def settings; end
  def settings=(_arg0); end

  private

  def build_smtp_session; end
  def ssl_context; end
  def start_smtp_session(&block); end
end

Mail::SMTP::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Mail::SMTPConnection
  def initialize(values); end

  def deliver!(mail); end
  def settings; end
  def settings=(_arg0); end
  def smtp; end
  def smtp=(_arg0); end

  private

  def dot_stuff(message); end
end

class Mail::SenderField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def address; end
  def addresses; end
  def decoded; end
  def default; end
  def encoded; end
end

Mail::SenderField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::SenderField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::Sendmail
  def initialize(values); end

  def deliver!(mail); end
  def settings; end
  def settings=(_arg0); end

  class << self
    def call(path, arguments, destinations, encoded_message); end
    def popen(command, &block); end
    def shellquote(address); end
  end
end

Mail::Sendmail::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Mail::StructuredField
  include ::Mail::Constants
  include ::Mail::CommonField
  include ::Mail::Utilities

  def initialize(name = T.unsafe(nil), value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def charset; end
  def charset=(val); end
  def default; end
  def errors; end
end

class Mail::SubjectField < ::Mail::UnstructuredField
  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end
end

Mail::SubjectField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::SubjectField::FIELD_NAME = T.let(T.unsafe(nil), String)

class Mail::TestMailer
  def initialize(values); end

  def deliver!(mail); end
  def settings; end
  def settings=(_arg0); end

  class << self
    def deliveries; end
    def deliveries=(val); end
  end
end

class Mail::TestRetriever < ::Mail::Retriever
  def initialize(values); end

  def find(options = T.unsafe(nil), &block); end

  class << self
    def emails; end
    def emails=(val); end
  end
end

class Mail::ToField < ::Mail::StructuredField
  include ::Mail::CommonAddress

  def initialize(value = T.unsafe(nil), charset = T.unsafe(nil)); end

  def decoded; end
  def encoded; end
end

Mail::ToField::CAPITALIZED_FIELD = T.let(T.unsafe(nil), String)
Mail::ToField::FIELD_NAME = T.let(T.unsafe(nil), String)
class Mail::UnknownEncodingType < ::StandardError; end

class Mail::UnstructuredField
  include ::Mail::Constants
  include ::Mail::CommonField
  include ::Mail::Utilities

  def initialize(name, value, charset = T.unsafe(nil)); end

  def charset; end
  def charset=(_arg0); end
  def decoded; end
  def default; end
  def encoded; end
  def errors; end
  def parse; end

  private

  def do_decode; end
  def do_encode; end
  def encode(value); end
  def encode_crlf(value); end
  def fold(prepend = T.unsafe(nil)); end
  def normalized_encoding; end
  def wrap_lines(name, folded_lines); end
  def wrapped_value; end
end

module Mail::Utilities
  include ::Mail::Constants

  def atom_safe?(str); end
  def bracket(str); end
  def capitalize_field(str); end
  def constantize(str); end
  def dasherize(str); end
  def dquote(str); end
  def escape_paren(str); end
  def map_lines(str, &block); end
  def map_with_index(enum, &block); end
  def match_to_s(obj1, obj2); end
  def paren(str); end
  def quote_atom(str); end
  def quote_phrase(str); end
  def quote_token(str); end
  def token_safe?(str); end
  def unbracket(str); end
  def underscoreize(str); end
  def unparen(str); end
  def uri_escape(str); end
  def uri_parser; end
  def uri_unescape(str); end

  private

  def unescape(str); end
  def unquote(str); end

  class << self
    def binary_unsafe_to_crlf(string); end
    def binary_unsafe_to_lf(string); end
    def blank?(value); end
    def safe_for_line_ending_conversion?(string); end
    def to_crlf(string); end
    def to_lf(string); end
    def unescape(str); end
    def unquote(str); end
  end
end

Mail::Utilities::CRLF = T.let(T.unsafe(nil), String)
Mail::Utilities::LF = T.let(T.unsafe(nil), String)
Mail::Utilities::TO_CRLF_REGEX = T.let(T.unsafe(nil), Regexp)

module Mail::VERSION
  class << self
    def version; end
  end
end

Mail::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)
Mail::VERSION::MINOR = T.let(T.unsafe(nil), Integer)
Mail::VERSION::PATCH = T.let(T.unsafe(nil), Integer)
Mail::VERSION::STRING = T.let(T.unsafe(nil), String)

class String
  include ::Comparable
  include ::Colorize::InstanceMethods
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::Colorize::ClassMethods
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
