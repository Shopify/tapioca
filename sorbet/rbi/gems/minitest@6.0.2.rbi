# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `minitest` gem.
# Please instead update this file by running `bin/tapioca gem minitest`.


# Kernel extensions for minitest
#
# pkg:gem/minitest#lib/minitest/spec.rb:38
module Kernel
  private

  # Describe a series of expectations for a given target +desc+.
  #
  # Defines a test class subclassing from either Minitest::Spec or
  # from the surrounding describe's class. The surrounding class may
  # subclass Minitest::Spec manually in order to easily share code:
  #
  #     class MySpec < Minitest::Spec
  #       # ... shared code ...
  #     end
  #
  #     class TestStuff < MySpec
  #       it "does stuff" do
  #         # shared code available here
  #       end
  #       describe "inner stuff" do
  #         it "still does stuff" do
  #           # ...and here
  #         end
  #       end
  #     end
  #
  # For more information on getting started with writing specs, see:
  #
  # http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html
  #
  # For some suggestions on how to improve your specs, try:
  #
  # https://betterspecs.org
  #
  # but do note that several items there are debatable or specific to
  # rspec.
  #
  # For more information about expectations, see Minitest::Expectations.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:74
  def describe(desc, *additional_desc, &block); end
end

# The top-level namespace for Minitest. Also the location of the main
# runtime. See +Minitest.run+ for more information.
#
# pkg:gem/minitest#lib/minitest/parallel.rb:3
module Minitest
  class << self
    # A simple hook allowing you to run a block of code after everything
    # is done running. Eg:
    #
    #   Minitest.after_run { p $debugging_info }
    #
    # pkg:gem/minitest#lib/minitest.rb:95
    def after_run(&block); end

    # pkg:gem/minitest#lib/minitest.rb:20
    def allow_fork; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def allow_fork=(_arg0); end

    # Registers Minitest to run at process exit
    #
    # pkg:gem/minitest#lib/minitest.rb:69
    def autorun; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def backtrace_filter; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def backtrace_filter=(_arg0); end

    # pkg:gem/minitest#lib/minitest.rb:19
    def cattr_accessor(name); end

    # pkg:gem/minitest#lib/minitest.rb:1209
    def clock_time; end

    # pkg:gem/minitest#lib/minitest.rb:332
    def empty_run!(options); end

    # pkg:gem/minitest#lib/minitest.rb:20
    def extensions; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def extensions=(_arg0); end

    # pkg:gem/minitest#lib/minitest.rb:365
    def filter_backtrace(bt); end

    # pkg:gem/minitest#lib/minitest.rb:20
    def info_signal; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def info_signal=(_arg0); end

    # pkg:gem/minitest#lib/minitest.rb:134
    def init_plugins(options); end

    # Manually load plugins by name.
    #
    # pkg:gem/minitest#lib/minitest.rb:102
    def load(*names); end

    # pkg:gem/minitest#lib/minitest.rb:118
    def load_plugins; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def parallel_executor; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def parallel_executor=(_arg0); end

    # pkg:gem/minitest#lib/minitest.rb:152
    def process_args(args = T.unsafe(nil)); end

    # Register a plugin to be used. Does NOT require / load it.
    #
    # pkg:gem/minitest#lib/minitest.rb:113
    def register_plugin(name_or_mod); end

    # pkg:gem/minitest#lib/minitest.rb:20
    def reporter; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def reporter=(_arg0); end

    # This is the top-level run method. Everything starts from here. It
    # tells each Runnable sub-class to run, and each of those are
    # responsible for doing whatever they do.
    #
    # The overall structure of a run looks like this:
    #
    #   [Minitest.load_plugins] optional, called by user, or require what you want
    #   Minitest.autorun
    #     Minitest.run(args)
    #       Minitest.process_args
    #       Minitest.init_plugins
    #       Minitest.run_all_suites(reporter, options)
    #         Runnable.runnables.each |runnable_klass|
    #           runnable_klass.run_suite(reporter, options)
    #             filtered_methods = runnable_klass.filter_runnable_methods options
    #             filtered_methods.each |runnable_method|
    #               runnable_klass.run(self, runnable_method, reporter)
    #                 runnable_klass.new(runnable_method).run
    #
    # pkg:gem/minitest#lib/minitest.rb:299
    def run(args = T.unsafe(nil)); end

    # Internal run method. Responsible for telling all Runnable
    # sub-classes to run.
    #
    # pkg:gem/minitest#lib/minitest.rb:352
    def run_all_suites(reporter, options); end

    # pkg:gem/minitest#lib/minitest.rb:20
    def seed; end

    # pkg:gem/minitest#lib/minitest.rb:20
    def seed=(_arg0); end
  end
end

# Defines the API for Reporters. Subclass this and override whatever
# you want. Go nuts.
#
# pkg:gem/minitest#lib/minitest.rb:707
class Minitest::AbstractReporter
  # @return [AbstractReporter] a new instance of AbstractReporter
  #
  # pkg:gem/minitest#lib/minitest.rb:709
  def initialize; end

  # Did this run pass?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:744
  def passed?; end

  # About to start running a test. This allows a reporter to show
  # that it is starting or that we are in the middle of a test run.
  #
  # pkg:gem/minitest#lib/minitest.rb:723
  def prerecord(klass, name); end

  # Output and record the result of the test. Call
  # {result#result_code}[rdoc-ref:Runnable#result_code] to get the
  # result character string. Stores the result of the run if the run
  # did not pass.
  #
  # pkg:gem/minitest#lib/minitest.rb:732
  def record(result); end

  # Outputs the summary of the run.
  #
  # pkg:gem/minitest#lib/minitest.rb:738
  def report; end

  # Starts reporting on the run.
  #
  # pkg:gem/minitest#lib/minitest.rb:716
  def start; end

  # pkg:gem/minitest#lib/minitest.rb:748
  def synchronize(&block); end
end

# Represents run failures.
#
# pkg:gem/minitest#lib/minitest.rb:1039
class Minitest::Assertion < ::Exception
  # pkg:gem/minitest#lib/minitest.rb:1042
  def error; end

  # Where was this run before an assertion was raised?
  #
  # pkg:gem/minitest#lib/minitest.rb:1049
  def location; end

  # pkg:gem/minitest#lib/minitest.rb:1057
  def result_code; end

  # pkg:gem/minitest#lib/minitest.rb:1061
  def result_label; end
end

# pkg:gem/minitest#lib/minitest.rb:1040
Minitest::Assertion::RE = T.let(T.unsafe(nil), Regexp)

# Minitest Assertions.  All assertion methods accept a +msg+ which is
# printed if the assertion fails.
#
# Protocol: Nearly everything here boils up to +assert+, which
# expects to be able to increment an instance accessor named
# +assertions+. This is not provided by Assertions and must be
# provided by the thing including Assertions. See Minitest::Runnable
# for an example.
#
# pkg:gem/minitest#lib/minitest/assertions.rb:16
module Minitest::Assertions
  # pkg:gem/minitest#lib/minitest/assertions.rb:181
  def _synchronize; end

  # pkg:gem/minitest#lib/minitest/assertions.rb:193
  def _where; end

  # Fails unless +test+ is truthy.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:171
  def assert(test, msg = T.unsafe(nil)); end

  # Fails unless +obj+ is empty.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:188
  def assert_empty(obj, msg = T.unsafe(nil)); end

  # Fails unless <tt>exp == act</tt> printing the difference between
  # the two, if possible.
  #
  # If there is no visible difference but the assertion fails, you
  # should suspect that your #== is buggy, or your inspect output is
  # missing crucial details.  For nicer structural diffing, set
  # Minitest::Test.make_my_diffs_pretty!
  #
  # For floats use assert_in_delta.
  #
  # See also: Minitest::Assertions.diff
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:211
  def assert_equal(exp, act, msg = T.unsafe(nil)); end

  # For comparing Floats.  Fails unless +exp+ and +act+ are within +delta+
  # of each other.
  #
  #   assert_in_delta Math::PI, (22.0 / 7.0), 0.01
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:225
  def assert_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end

  # For comparing Floats.  Fails unless +exp+ and +act+ have a relative
  # error less than +epsilon+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:237
  def assert_in_epsilon(exp, act, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end

  # Fails unless +collection+ includes +obj+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:244
  def assert_includes(collection, obj, msg = T.unsafe(nil)); end

  # Fails unless +obj+ is an instance of +cls+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:254
  def assert_instance_of(cls, obj, msg = T.unsafe(nil)); end

  # Fails unless +obj+ is a kind of +cls+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:265
  def assert_kind_of(cls, obj, msg = T.unsafe(nil)); end

  # Fails unless +matcher+ <tt>=~</tt> +obj+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:276
  def assert_match(matcher, obj, msg = T.unsafe(nil)); end

  # Fails unless +obj+ is nil
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:288
  def assert_nil(obj, msg = T.unsafe(nil)); end

  # For testing with binary operators. Eg:
  #
  #   assert_operator 5, :<=, 4
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:298
  def assert_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end

  # Fails if stdout or stderr do not output the expected results.
  # Pass in nil if you don't care about that streams output. Pass in
  # "" if you require it to be silent. Pass in a regexp if you want
  # to pattern match.
  #
  #   assert_output(/hey/) { method_with_output }
  #
  # NOTE: this uses #capture_io, not #capture_subprocess_io.
  #
  # See also: #assert_silent
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:317
  def assert_output(stdout = T.unsafe(nil), stderr = T.unsafe(nil)); end

  # Fails unless +path+ exists.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:341
  def assert_path_exists(path, msg = T.unsafe(nil)); end

  # For testing with pattern matching (only supported with Ruby 3.0 and later)
  #
  #   # pass
  #   assert_pattern { [1,2,3] => [Integer, Integer, Integer] }
  #
  #   # fail "length mismatch (given 3, expected 1)"
  #   assert_pattern { [1,2,3] => [Integer] }
  #
  # The bare <tt>=></tt> pattern will raise a NoMatchingPatternError on failure, which would
  # normally be counted as a test error. This assertion rescues NoMatchingPatternError and
  # generates a test failure. Any other exception will be raised as normal and generate a test
  # error.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:360
  def assert_pattern; end

  # For testing with predicates. Eg:
  #
  #   assert_predicate str, :empty?
  #
  # This is really meant for specs and is front-ended by assert_operator:
  #
  #   str.must_be :empty?
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:378
  def assert_predicate(o1, op, msg = T.unsafe(nil)); end

  # Fails unless the block raises one of +exp+. Returns the
  # exception matched so you can check the message, attributes, etc.
  #
  # +exp+ takes an optional message on the end to help explain
  # failures and defaults to StandardError if no exception class is
  # passed. Eg:
  #
  #   assert_raises(CustomError) { method_with_custom_error }
  #
  # With custom error message:
  #
  #   assert_raises(CustomError, 'This should have raised CustomError') { method_with_custom_error }
  #
  # Using the returned object:
  #
  #   error = assert_raises(CustomError) do
  #     raise CustomError, 'This is really bad'
  #   end
  #
  #   assert_equal 'This is really bad', error.message
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:406
  def assert_raises(*exp); end

  # Fails unless +obj+ responds to +meth+.
  # include_all defaults to false to match Object#respond_to?
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:438
  def assert_respond_to(obj, meth, msg = T.unsafe(nil), include_all: T.unsafe(nil)); end

  # Fails unless +exp+ and +act+ are #equal?
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:446
  def assert_same(exp, act, msg = T.unsafe(nil)); end

  # Fails if the block outputs anything to stderr or stdout.
  #
  # See also: #assert_output
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:459
  def assert_silent; end

  # Fails unless the block throws +sym+
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:468
  def assert_throws(sym, msg = T.unsafe(nil)); end

  # Captures $stdout and $stderr into strings:
  #
  #   out, err = capture_io do
  #     puts "Some info"
  #     warn "You did a bad thing"
  #   end
  #
  #   assert_match %r%info%, out
  #   assert_match %r%bad%, err
  #
  # NOTE: For efficiency, this method uses StringIO and does not
  # capture IO for subprocesses. Use #capture_subprocess_io for
  # that.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:504
  def capture_io; end

  # Captures $stdout and $stderr into strings, using Tempfile to
  # ensure that subprocess IO is captured as well.
  #
  #   out, err = capture_subprocess_io do
  #     system "echo Some info"
  #     system "echo You did a bad thing 1>&2"
  #   end
  #
  #   assert_match %r%info%, out
  #   assert_match %r%bad%, err
  #
  # NOTE: This method is approximately 10x slower than #capture_io so
  # only use it when you need to test the output of a subprocess.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:537
  def capture_subprocess_io; end

  # Returns a diff between +exp+ and +act+. If there is no known
  # diff command or if it doesn't make sense to diff the output
  # (single line, short output), then it simply returns a basic
  # comparison between the two.
  #
  # See +things_to_diff+ for more info.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:57
  def diff(exp, act); end

  # Returns details for exception +e+
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:569
  def exception_details(e, msg); end

  # Fails after a given date (in the local time zone). This allows
  # you to put time-bombs in your tests if you need to keep
  # something around until a later date lest you forget about it.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:585
  def fail_after(y, m, d, msg); end

  # Fails with +msg+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:592
  def flunk(msg = T.unsafe(nil)); end

  # Returns a proc that delays generation of an output message. If
  # +msg+ is a proc (eg, from another +message+ call) return +msg+
  # as-is. Otherwise, return a proc that will output +msg+ along
  # with the value of the result of the block passed to +message+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:603
  def message(msg = T.unsafe(nil), ending = T.unsafe(nil), &default); end

  # This returns a human-readable version of +obj+. By default
  # #inspect is called. You can override this to use #pretty_inspect
  # if you want.
  #
  # See Minitest::Test.make_my_diffs_pretty!
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:127
  def mu_pp(obj); end

  # This returns a diff-able more human-readable version of +obj+.
  # This differs from the regular mu_pp because it expands escaped
  # newlines and makes hex-values (like object_ids) generic. This
  # uses mu_pp to do the first pass and then cleans it up.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:145
  def mu_pp_for_diff(obj); end

  # used for counting assertions
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:614
  def pass(_msg = T.unsafe(nil)); end

  # Fails if +test+ is truthy.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:621
  def refute(test, msg = T.unsafe(nil)); end

  # Fails if +obj+ is empty.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:629
  def refute_empty(obj, msg = T.unsafe(nil)); end

  # Fails if <tt>exp == act</tt>.
  #
  # For floats use refute_in_delta.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:639
  def refute_equal(exp, act, msg = T.unsafe(nil)); end

  # For comparing Floats.  Fails if +exp+ is within +delta+ of +act+.
  #
  #   refute_in_delta Math::PI, (22.0 / 7.0)
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:651
  def refute_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end

  # For comparing Floats.  Fails if +exp+ and +act+ have a relative error
  # less than +epsilon+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:663
  def refute_in_epsilon(exp, act, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end

  # Fails if +obj+ includes +sub+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:670
  def refute_includes(obj, sub, msg = T.unsafe(nil)); end

  # Fails if +obj+ is an instance of +cls+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:678
  def refute_instance_of(cls, obj, msg = T.unsafe(nil)); end

  # Fails if +obj+ is a kind of +cls+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:688
  def refute_kind_of(cls, obj, msg = T.unsafe(nil)); end

  # Fails if +matcher+ <tt>=~</tt> +obj+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:696
  def refute_match(matcher, obj, msg = T.unsafe(nil)); end

  # Fails if +obj+ is nil.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:705
  def refute_nil(obj, msg = T.unsafe(nil)); end

  # Fails if +o1+ is not +op+ +o2+. Eg:
  #
  #   refute_operator 1, :>, 2 #=> pass
  #   refute_operator 1, :<, 2 #=> fail
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:737
  def refute_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end

  # Fails if +path+ exists.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:747
  def refute_path_exists(path, msg = T.unsafe(nil)); end

  # For testing with pattern matching (only supported with Ruby 3.0 and later)
  #
  #   # pass
  #   refute_pattern { [1,2,3] => [String] }
  #
  #   # fail "NoMatchingPatternError expected, but nothing was raised."
  #   refute_pattern { [1,2,3] => [Integer, Integer, Integer] }
  #
  # This assertion expects a NoMatchingPatternError exception, and will fail if none is raised. Any
  # other exceptions will be raised as normal and generate a test error.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:722
  def refute_pattern; end

  # For testing with predicates.
  #
  #   refute_predicate str, :empty?
  #
  # This is really meant for specs and is front-ended by refute_operator:
  #
  #   str.wont_be :empty?
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:761
  def refute_predicate(o1, op, msg = T.unsafe(nil)); end

  # Fails if +obj+ responds to the message +meth+.
  # include_all defaults to false to match Object#respond_to?
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:771
  def refute_respond_to(obj, meth, msg = T.unsafe(nil), include_all: T.unsafe(nil)); end

  # Fails if +exp+ is the same (by object identity) as +act+.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:780
  def refute_same(exp, act, msg = T.unsafe(nil)); end

  # Skips the current run. If run in verbose-mode, the skipped run
  # gets listed at the end of the run but doesn't cause a failure
  # exit code.
  #
  # @raise [Minitest::Skip]
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:793
  def skip(msg = T.unsafe(nil), _ignored = T.unsafe(nil)); end

  # Skips the current run until a given date (in the local time
  # zone). This allows you to put some fixes on hold until a later
  # date, but still holds you accountable and prevents you from
  # forgetting it.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:805
  def skip_until(y, m, d, msg); end

  # Was this testcase skipped? Meant for #teardown.
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:814
  def skipped?; end

  # Returns things to diff [expect, butwas], or [nil, nil] if nothing to diff.
  #
  # Criterion:
  #
  # 1. Strings include newlines or escaped newlines, but not both.
  # 2. or:  String lengths are > 30 characters.
  # 3. or:  Strings are equal to each other (but maybe different encodings?).
  # 4. and: we found a diff executable.
  #
  # pkg:gem/minitest#lib/minitest/assertions.rb:102
  def things_to_diff(exp, act); end

  class << self
    # Returns the diff command to use in #diff. Tries to intelligently
    # figure out what diff to use.
    #
    # pkg:gem/minitest#lib/minitest/assertions.rb:27
    def diff; end

    # Set the diff command to use in #diff.
    #
    # pkg:gem/minitest#lib/minitest/assertions.rb:45
    def diff=(o); end
  end
end

# pkg:gem/minitest#lib/minitest/assertions.rb:17
Minitest::Assertions::UNDEFINED = T.let(T.unsafe(nil), Object)

# The standard backtrace filter for minitest.
#
# See Minitest.backtrace_filter=.
#
# pkg:gem/minitest#lib/minitest.rb:1174
class Minitest::BacktraceFilter
  # @return [BacktraceFilter] a new instance of BacktraceFilter
  #
  # pkg:gem/minitest#lib/minitest.rb:1183
  def initialize(regexp = T.unsafe(nil)); end

  # Filter +bt+ to something useful. Returns the whole thing if
  # $DEBUG (ruby) or $MT_DEBUG (env).
  #
  # pkg:gem/minitest#lib/minitest.rb:1191
  def filter(bt); end

  # The regular expression to use to filter backtraces. Defaults to +MT_RE+.
  #
  # pkg:gem/minitest#lib/minitest.rb:1181
  def regexp; end

  # The regular expression to use to filter backtraces. Defaults to +MT_RE+.
  #
  # pkg:gem/minitest#lib/minitest.rb:1181
  def regexp=(_arg0); end
end

# pkg:gem/minitest#lib/minitest.rb:1176
Minitest::BacktraceFilter::MT_RE = T.let(T.unsafe(nil), Regexp)

# Dispatch to multiple reporters as one.
#
# pkg:gem/minitest#lib/minitest.rb:989
class Minitest::CompositeReporter < ::Minitest::AbstractReporter
  # @return [CompositeReporter] a new instance of CompositeReporter
  #
  # pkg:gem/minitest#lib/minitest.rb:995
  def initialize(*reporters); end

  # Add another reporter to the mix.
  #
  # pkg:gem/minitest#lib/minitest.rb:1007
  def <<(reporter); end

  # pkg:gem/minitest#lib/minitest.rb:1000
  def io; end

  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:1011
  def passed?; end

  # pkg:gem/minitest#lib/minitest.rb:1019
  def prerecord(klass, name); end

  # pkg:gem/minitest#lib/minitest.rb:1025
  def record(result); end

  # pkg:gem/minitest#lib/minitest.rb:1031
  def report; end

  # The list of reporters to dispatch to.
  #
  # pkg:gem/minitest#lib/minitest.rb:993
  def reporters; end

  # The list of reporters to dispatch to.
  #
  # pkg:gem/minitest#lib/minitest.rb:993
  def reporters=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:1015
  def start; end
end

# Compresses backtraces.
#
# pkg:gem/minitest#lib/minitest/compress.rb:5
module Minitest::Compress
  # Takes a backtrace (array of strings) and compresses repeating
  # cycles in it to make it more readable.
  #
  # pkg:gem/minitest#lib/minitest/compress.rb:11
  def compress(orig); end
end

# fucking hell rdoc...
#
# pkg:gem/minitest#lib/minitest/spec.rb:31
class Minitest::Expectation < ::Struct
  include ::Minitest::Expectations

  # Returns the value of attribute ctx
  #
  # @return [Object] the current value of ctx
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:31
  def ctx; end

  # Sets the attribute ctx
  #
  # @param value [Object] the value to set the attribute ctx to.
  # @return [Object] the newly set value
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:31
  def ctx=(_); end

  # Returns the value of attribute target
  #
  # @return [Object] the current value of target
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:31
  def target; end

  # Sets the attribute target
  #
  # @param value [Object] the value to set the attribute target to.
  # @return [Object] the newly set value
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:31
  def target=(_); end

  class << self
    # pkg:gem/minitest#lib/minitest/spec.rb:31
    def [](*_arg0); end

    # pkg:gem/minitest#lib/minitest/spec.rb:31
    def inspect; end

    # pkg:gem/minitest#lib/minitest/spec.rb:31
    def keyword_init?; end

    # pkg:gem/minitest#lib/minitest/spec.rb:31
    def members; end

    # pkg:gem/minitest#lib/minitest/spec.rb:31
    def new(*_arg0); end
  end
end

# It's where you hide your "assertions".
#
# Please note, because of the way that expectations are implemented,
# all expectations (eg must_equal) are dependent upon a thread local
# variable +:current_spec+. If your specs rely on mixing threads into
# the specs themselves, you're better off using assertions or the new
# _(value) wrapper. For example:
#
#     it "should still work in threads" do
#       my_threaded_thingy do
#         (1+1).must_equal 2                  # bad
#         assert_equal 2, 1+1                 # good
#         _(1 + 1).must_equal 2               # good
#         value(1 + 1).must_equal 2           # good, also #expect
#         _ { 1 + "1" }.must_raise TypeError  # good
#       end
#     end
#
# pkg:gem/minitest#lib/minitest/expectations.rb:20
module Minitest::Expectations
  # pkg:gem/minitest#lib/minitest/expectations.rb:116
  def must_be(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:47
  def must_be_close_to(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:29
  def must_be_empty(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:76
  def must_be_instance_of(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:85
  def must_be_kind_of(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:103
  def must_be_nil(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:161
  def must_be_same_as(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:170
  def must_be_silent(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:49
  def must_be_within_delta(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:58
  def must_be_within_epsilon(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:38
  def must_equal(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:67
  def must_include(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:94
  def must_match(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:125
  def must_output(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:134
  def must_pattern_match(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:143
  def must_raise(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:152
  def must_respond_to(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:179
  def must_throw(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:188
  def path_must_exist(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:197
  def path_wont_exist(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:293
  def wont_be(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:224
  def wont_be_close_to(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:206
  def wont_be_empty(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:253
  def wont_be_instance_of(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:262
  def wont_be_kind_of(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:280
  def wont_be_nil(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:320
  def wont_be_same_as(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:226
  def wont_be_within_delta(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:235
  def wont_be_within_epsilon(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:215
  def wont_equal(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:244
  def wont_include(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:271
  def wont_match(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:302
  def wont_pattern_match(*args, **_arg1); end

  # pkg:gem/minitest#lib/minitest/expectations.rb:311
  def wont_respond_to(*args, **_arg1); end
end

# Provides a simple set of guards that you can use in your tests
# to skip execution if it is not applicable. These methods are
# mixed into Test as both instance and class methods so you
# can use them inside or outside of the test methods.
#
#   def test_something_for_mri
#     skip "bug 1234"  if jruby?
#     # ...
#   end
#
#   if windows? then
#     # ... lots of test methods ...
#   end
#
# pkg:gem/minitest#lib/minitest.rb:1138
module Minitest::Guard
  # Is this running on jruby?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:1143
  def jruby?(platform = T.unsafe(nil)); end

  # Is this running on mri?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:1150
  def mri?(platform = T.unsafe(nil)); end

  # Is this running on macOS?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:1157
  def osx?(platform = T.unsafe(nil)); end

  # Is this running on windows?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:1164
  def windows?(platform = T.unsafe(nil)); end
end

# pkg:gem/minitest#lib/minitest/parallel.rb:4
module Minitest::Parallel; end

# The engine used to run multiple tests in parallel.
#
# pkg:gem/minitest#lib/minitest/parallel.rb:9
class Minitest::Parallel::Executor
  # Create a parallel test executor of with +size+ workers.
  #
  # @return [Executor] a new instance of Executor
  #
  # pkg:gem/minitest#lib/minitest/parallel.rb:19
  def initialize(size); end

  # Add a job to the queue
  #
  # pkg:gem/minitest#lib/minitest/parallel.rb:45
  def <<(work); end

  # Shuts down the pool of workers by signalling them to quit and
  # waiting for them all to finish what they're currently working
  # on.
  #
  # pkg:gem/minitest#lib/minitest/parallel.rb:52
  def shutdown; end

  # The size of the pool of workers.
  #
  # pkg:gem/minitest#lib/minitest/parallel.rb:14
  def size; end

  # Start the executor
  #
  # pkg:gem/minitest#lib/minitest/parallel.rb:28
  def start; end
end

# pkg:gem/minitest#lib/minitest/parallel.rb:58
module Minitest::Parallel::Test
  # pkg:gem/minitest#lib/minitest/parallel.rb:59
  def _synchronize; end
end

# pkg:gem/minitest#lib/minitest/parallel.rb:61
module Minitest::Parallel::Test::ClassMethods
  # pkg:gem/minitest#lib/minitest/parallel.rb:62
  def run(klass, method_name, reporter); end

  # pkg:gem/minitest#lib/minitest/parallel.rb:66
  def run_order; end
end

# A very simple reporter that prints the "dots" during the run.
#
# This is added to the top-level CompositeReporter at the start of
# the run. If you want to change the output of minitest via a
# plugin, pull this out of the composite and replace it with your
# own.
#
# pkg:gem/minitest#lib/minitest.rb:779
class Minitest::ProgressReporter < ::Minitest::Reporter
  # pkg:gem/minitest#lib/minitest.rb:780
  def prerecord(klass, name); end

  # pkg:gem/minitest#lib/minitest.rb:787
  def record(result); end
end

# Shared code for anything that can get passed to a Reporter. See
# Minitest::Test & Minitest::Result.
#
# pkg:gem/minitest#lib/minitest.rb:604
module Minitest::Reportable
  # @raise [NotImplementedError]
  #
  # pkg:gem/minitest#lib/minitest.rb:626
  def class_name; end

  # Did this run error?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:647
  def error?; end

  # The location identifier of this test. Depends on a method
  # existing called class_name.
  #
  # pkg:gem/minitest#lib/minitest.rb:621
  def location; end

  # Did this run pass?
  #
  # Note: skipped runs are not considered passing, but they don't
  # cause the process to exit non-zero.
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:611
  def passed?; end

  # Returns ".", "F", or "E" based on the result of the run.
  #
  # pkg:gem/minitest#lib/minitest.rb:633
  def result_code; end

  # Was this run skipped?
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:640
  def skipped?; end
end

# pkg:gem/minitest#lib/minitest.rb:615
Minitest::Reportable::BASE_DIR = T.let(T.unsafe(nil), String)

# AbstractReportera
#
# pkg:gem/minitest#lib/minitest.rb:755
class Minitest::Reporter < ::Minitest::AbstractReporter
  # @return [Reporter] a new instance of Reporter
  #
  # pkg:gem/minitest#lib/minitest.rb:764
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  # The IO used to report.
  #
  # pkg:gem/minitest#lib/minitest.rb:757
  def io; end

  # The IO used to report.
  #
  # pkg:gem/minitest#lib/minitest.rb:757
  def io=(_arg0); end

  # Command-line options for this run.
  #
  # pkg:gem/minitest#lib/minitest.rb:762
  def options; end

  # Command-line options for this run.
  #
  # pkg:gem/minitest#lib/minitest.rb:762
  def options=(_arg0); end
end

# This represents a test result in a clean way that can be
# marshalled over a wire. Tests can do anything they want to the
# test instance and can create conditions that cause Marshal.dump to
# blow up. By using Result.from(a_test) you can be reasonably sure
# that the test result can be marshalled.
#
# pkg:gem/minitest#lib/minitest.rb:659
class Minitest::Result < ::Minitest::Runnable
  include ::Minitest::Reportable

  # pkg:gem/minitest#lib/minitest.rb:690
  def class_name; end

  # The class name of the test result.
  #
  # pkg:gem/minitest#lib/minitest.rb:665
  def klass; end

  # The class name of the test result.
  #
  # pkg:gem/minitest#lib/minitest.rb:665
  def klass=(_arg0); end

  # The location of the test method.
  #
  # pkg:gem/minitest#lib/minitest.rb:670
  def source_location; end

  # The location of the test method.
  #
  # pkg:gem/minitest#lib/minitest.rb:670
  def source_location=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:694
  def to_s; end

  class << self
    # Create a new test result from a Runnable instance.
    #
    # pkg:gem/minitest#lib/minitest.rb:675
    def from(runnable); end
  end
end

# re-open
#
# pkg:gem/minitest#lib/minitest.rb:378
class Minitest::Runnable
  # @return [Runnable] a new instance of Runnable
  #
  # pkg:gem/minitest#lib/minitest.rb:535
  def initialize(name); end

  # Number of assertions executed in this run.
  #
  # pkg:gem/minitest#lib/minitest.rb:382
  def assertions; end

  # Number of assertions executed in this run.
  #
  # pkg:gem/minitest#lib/minitest.rb:382
  def assertions=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:531
  def failure; end

  # An assertion raised during the run, if any.
  #
  # pkg:gem/minitest#lib/minitest.rb:387
  def failures; end

  # An assertion raised during the run, if any.
  #
  # pkg:gem/minitest#lib/minitest.rb:387
  def failures=(_arg0); end

  # Metadata you attach to the test results that get sent to the reporter.
  #
  # Lazily initializes to a hash, to keep memory down.
  #
  # NOTE: this data *must* be plain (read: marshal-able) data!
  # Hashes! Arrays! Strings!
  #
  # pkg:gem/minitest#lib/minitest.rb:550
  def metadata; end

  # Sets metadata, mainly used for +Result.from+.
  #
  # pkg:gem/minitest#lib/minitest.rb:557
  def metadata=(_arg0); end

  # Returns true if metadata exists.
  #
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:562
  def metadata?; end

  # Name of the run.
  #
  # pkg:gem/minitest#lib/minitest.rb:405
  def name; end

  # Set the name of the run.
  #
  # pkg:gem/minitest#lib/minitest.rb:412
  def name=(o); end

  # Did this run pass?
  #
  # Note: skipped runs are not considered passing, but they don't
  # cause the process to exit non-zero.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:579
  def passed?; end

  # Returns a single character string to print based on the result
  # of the run. One of <tt>"."</tt>, <tt>"F"</tt>,
  # <tt>"E"</tt> or <tt>"S"</tt>.
  #
  # @raise [NotImplementedError]
  #
  # pkg:gem/minitest#lib/minitest.rb:588
  def result_code; end

  # Runs a single method. Needs to return self.
  #
  # @raise [NotImplementedError]
  #
  # pkg:gem/minitest#lib/minitest.rb:569
  def run; end

  # Was this run skipped? See #passed? for more information.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:595
  def skipped?; end

  # The time it took to run.
  #
  # pkg:gem/minitest#lib/minitest.rb:392
  def time; end

  # The time it took to run.
  #
  # pkg:gem/minitest#lib/minitest.rb:392
  def time=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:394
  def time_it; end

  class << self
    # Returns an array of filtered +runnable_methods+. Uses
    # options[:include] (--include arguments) and options[:exclude]
    # (--exclude arguments) values to filter.
    #
    # pkg:gem/minitest#lib/minitest.rb:434
    def filter_runnable_methods(options = T.unsafe(nil)); end

    # pkg:gem/minitest#lib/minitest.rb:1219
    def inherited(klass); end

    # Returns all instance methods matching the pattern +re+.
    #
    # pkg:gem/minitest#lib/minitest.rb:419
    def methods_matching(re); end

    # pkg:gem/minitest#lib/minitest.rb:503
    def on_signal(name, action); end

    # pkg:gem/minitest#lib/minitest.rb:423
    def reset; end

    # Runs a single method and has the reporter record the result.
    # This was considered internal API but is factored out of run so
    # that subclasses can specialize the running of an individual
    # test. See Minitest::ParallelTest::ClassMethods for an example.
    #
    # pkg:gem/minitest#lib/minitest.rb:484
    def run(klass, method_name, reporter); end

    # Defines the order to run tests (:random by default). Override
    # this or use a convenience method to change it for your tests.
    #
    # pkg:gem/minitest#lib/minitest.rb:493
    def run_order; end

    # Responsible for running all runnable methods in a given class,
    # each in its own instance. Each instance is passed to the
    # reporter to record.
    #
    # pkg:gem/minitest#lib/minitest.rb:452
    def run_suite(reporter, options = T.unsafe(nil)); end

    # Each subclass of Runnable is responsible for overriding this
    # method to return all runnable methods. See #methods_matching.
    #
    # @raise [NotImplementedError]
    #
    # pkg:gem/minitest#lib/minitest.rb:520
    def runnable_methods; end

    # Returns all subclasses of Runnable.
    #
    # pkg:gem/minitest#lib/minitest.rb:527
    def runnables; end

    # pkg:gem/minitest#lib/minitest.rb:497
    def with_info_handler(_reporter = T.unsafe(nil), &block); end
  end
end

# pkg:gem/minitest#lib/minitest.rb:501
Minitest::Runnable::SIGNALS = T.let(T.unsafe(nil), Hash)

# Assertion raised when skipping a run.
#
# pkg:gem/minitest#lib/minitest.rb:1069
class Minitest::Skip < ::Minitest::Assertion
  # pkg:gem/minitest#lib/minitest.rb:1070
  def result_label; end
end

# Minitest::Spec -- The faster, better, less-magical spec framework!
#
# For a list of expectations, see Minitest::Expectations.
#
# pkg:gem/minitest#lib/minitest/spec.rb:99
class Minitest::Spec < ::Minitest::Test
  include ::Minitest::Spec::DSL::InstanceMethods
  extend ::Minitest::Spec::DSL
end

# Oh look! A Minitest::Spec::DSL module! Eat your heart out DHH.
#
# pkg:gem/minitest#lib/minitest/spec.rb:104
module Minitest::Spec::DSL
  # Define an 'after' action. Inherits the way normal methods should.
  #
  # NOTE: +type+ is ignored and is only there to make porting easier.
  #
  # Equivalent to Minitest::Test#teardown.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:189
  def after(_type = T.unsafe(nil), &block); end

  # Define a 'before' action. Inherits the way normal methods should.
  #
  # NOTE: +type+ is ignored and is only there to make porting easier.
  #
  # Equivalent to Minitest::Test#setup.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:175
  def before(_type = T.unsafe(nil), &block); end

  # pkg:gem/minitest#lib/minitest/spec.rb:158
  def children; end

  # pkg:gem/minitest#lib/minitest/spec.rb:254
  def create(name, desc); end

  # pkg:gem/minitest#lib/minitest/spec.rb:274
  def desc; end

  # pkg:gem/minitest#lib/minitest/spec.rb:154
  def describe_stack; end

  # pkg:gem/minitest#lib/minitest/spec.rb:272
  def inspect; end

  # Define an expectation with name +desc+. Name gets morphed to a
  # proper test method name. For some freakish reason, people who
  # write specs don't like class inheritance, so this goes way out of
  # its way to make sure that expectations aren't inherited.
  #
  # This is also aliased to #specify and doesn't require a +desc+ arg.
  #
  # Hint: If you _do_ want inheritance, use minitest/test. You can mix
  # and match between assertions and expectations as much as you want.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:207
  def it(desc = T.unsafe(nil), &block); end

  # Essentially, define an accessor for +name+ with +block+.
  #
  # Why use let instead of def? I honestly don't know.
  #
  # @raise [ArgumentError]
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:231
  def let(name, &block); end

  # pkg:gem/minitest#lib/minitest/spec.rb:267
  def name; end

  # pkg:gem/minitest#lib/minitest/spec.rb:162
  def nuke_test_methods!; end

  # Register a new type of spec that matches the spec's description.
  # This method can take either a Regexp and a spec class or a spec
  # class and a block that takes the description and returns true if
  # it matches.
  #
  # Eg:
  #
  #     register_spec_type(/Controller$/, Minitest::Spec::Rails)
  #
  # or:
  #
  #     register_spec_type(Minitest::Spec::RailsModel) do |desc|
  #       desc.superclass == ActiveRecord::Base
  #     end
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:130
  def register_spec_type(*args, &block); end

  # Figure out the spec class to use based on a spec's description. Eg:
  #
  #     spec_type("BlahController") # => Minitest::Spec::Rails
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:144
  def spec_type(desc, *additional); end

  # Define an expectation with name +desc+. Name gets morphed to a
  # proper test method name. For some freakish reason, people who
  # write specs don't like class inheritance, so this goes way out of
  # its way to make sure that expectations aren't inherited.
  #
  # This is also aliased to #specify and doesn't require a +desc+ arg.
  #
  # Hint: If you _do_ want inheritance, use minitest/test. You can mix
  # and match between assertions and expectations as much as you want.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:275
  def specify(desc = T.unsafe(nil), &block); end

  # Another lazy man's accessor generator. Made even more lazy by
  # setting the name for you to +subject+.
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:250
  def subject(&block); end

  # pkg:gem/minitest#lib/minitest/spec.rb:271
  def to_s; end

  class << self
    # pkg:gem/minitest#lib/minitest/spec.rb:310
    def extended(obj); end
  end
end

# Rdoc... why are you so dumb?
#
# pkg:gem/minitest#lib/minitest/spec.rb:280
module Minitest::Spec::DSL::InstanceMethods
  # Takes a value or a block and returns a value monad that has
  # all of Expectations methods available to it.
  #
  #   _(1 + 1).must_equal 2
  #
  # And for blocks:
  #
  #   _ { 1 + "1" }.must_raise TypeError
  #
  # This method of expectation-based testing is preferable to
  # straight-expectation methods (on Object) because it stores its
  # test context, bypassing our hacky use of thread-local variables.
  #
  # It is also aliased to #value and #expect for your aesthetic
  # pleasure:
  #
  #         _(1 + 1).must_equal 2
  #     value(1 + 1).must_equal 2
  #    expect(1 + 1).must_equal 2
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:302
  def _(value = T.unsafe(nil), &block); end

  # Takes a value or a block and returns a value monad that has
  # all of Expectations methods available to it.
  #
  #   _(1 + 1).must_equal 2
  #
  # And for blocks:
  #
  #   _ { 1 + "1" }.must_raise TypeError
  #
  # This method of expectation-based testing is preferable to
  # straight-expectation methods (on Object) because it stores its
  # test context, bypassing our hacky use of thread-local variables.
  #
  # It is also aliased to #value and #expect for your aesthetic
  # pleasure:
  #
  #         _(1 + 1).must_equal 2
  #     value(1 + 1).must_equal 2
  #    expect(1 + 1).must_equal 2
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:307
  def expect(value = T.unsafe(nil), &block); end

  # Takes a value or a block and returns a value monad that has
  # all of Expectations methods available to it.
  #
  #   _(1 + 1).must_equal 2
  #
  # And for blocks:
  #
  #   _ { 1 + "1" }.must_raise TypeError
  #
  # This method of expectation-based testing is preferable to
  # straight-expectation methods (on Object) because it stores its
  # test context, bypassing our hacky use of thread-local variables.
  #
  # It is also aliased to #value and #expect for your aesthetic
  # pleasure:
  #
  #         _(1 + 1).must_equal 2
  #     value(1 + 1).must_equal 2
  #    expect(1 + 1).must_equal 2
  #
  # pkg:gem/minitest#lib/minitest/spec.rb:306
  def value(value = T.unsafe(nil), &block); end
end

# Contains pairs of matchers and Spec classes to be used to
# calculate the superclass of a top-level describe. This allows for
# automatically customizable spec types.
#
# See: register_spec_type and spec_type
#
# pkg:gem/minitest#lib/minitest/spec.rb:112
Minitest::Spec::DSL::TYPES = T.let(T.unsafe(nil), Array)

# pkg:gem/minitest#lib/minitest/spec.rb:317
Minitest::Spec::TYPES = T.let(T.unsafe(nil), Array)

# A reporter that gathers statistics about a test run. Does not do
# any IO because meant to be used as a parent class for a reporter
# that does.
#
# If you want to create an entirely different type of output (eg,
# CI, HTML, etc), this is the place to start.
#
# Example:
#
#   class JenkinsCIReporter < StatisticsReporter
#     def report
#       super  # Needed to calculate some statistics
#
#       print "<testsuite "
#       print "tests='#{count}' "
#       print "failures='#{failures}' "
#       # Remaining XML...
#     end
#   end
#
# pkg:gem/minitest#lib/minitest.rb:815
class Minitest::StatisticsReporter < ::Minitest::Reporter
  # @return [StatisticsReporter] a new instance of StatisticsReporter
  #
  # pkg:gem/minitest#lib/minitest.rb:864
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  # Total number of assertions.
  #
  # pkg:gem/minitest#lib/minitest.rb:819
  def assertions; end

  # Total number of assertions.
  #
  # pkg:gem/minitest#lib/minitest.rb:819
  def assertions=(_arg0); end

  # Total number of test cases.
  #
  # pkg:gem/minitest#lib/minitest.rb:824
  def count; end

  # Total number of test cases.
  #
  # pkg:gem/minitest#lib/minitest.rb:824
  def count=(_arg0); end

  # Total number of tests that erred.
  #
  # pkg:gem/minitest#lib/minitest.rb:852
  def errors; end

  # Total number of tests that erred.
  #
  # pkg:gem/minitest#lib/minitest.rb:852
  def errors=(_arg0); end

  # Total number of tests that failed.
  #
  # pkg:gem/minitest#lib/minitest.rb:847
  def failures; end

  # Total number of tests that failed.
  #
  # pkg:gem/minitest#lib/minitest.rb:847
  def failures=(_arg0); end

  # @return [Boolean]
  #
  # pkg:gem/minitest#lib/minitest.rb:878
  def passed?; end

  # pkg:gem/minitest#lib/minitest.rb:886
  def record(result); end

  # Report on the tracked statistics.
  #
  # pkg:gem/minitest#lib/minitest.rb:896
  def report; end

  # An +Array+ of test cases that failed or were skipped.
  #
  # pkg:gem/minitest#lib/minitest.rb:829
  def results; end

  # An +Array+ of test cases that failed or were skipped.
  #
  # pkg:gem/minitest#lib/minitest.rb:829
  def results=(_arg0); end

  # Total number of tests that where skipped.
  #
  # pkg:gem/minitest#lib/minitest.rb:862
  def skips; end

  # Total number of tests that where skipped.
  #
  # pkg:gem/minitest#lib/minitest.rb:862
  def skips=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:882
  def start; end

  # Time the test run started. If available, the monotonic clock is
  # used and this is a +Float+, otherwise it's an instance of
  # +Time+.
  #
  # pkg:gem/minitest#lib/minitest.rb:836
  def start_time; end

  # Time the test run started. If available, the monotonic clock is
  # used and this is a +Float+, otherwise it's an instance of
  # +Time+.
  #
  # pkg:gem/minitest#lib/minitest.rb:836
  def start_time=(_arg0); end

  # Test run time. If available, the monotonic clock is used and
  # this is a +Float+, otherwise it's an instance of +Time+.
  #
  # pkg:gem/minitest#lib/minitest.rb:842
  def total_time; end

  # Test run time. If available, the monotonic clock is used and
  # this is a +Float+, otherwise it's an instance of +Time+.
  #
  # pkg:gem/minitest#lib/minitest.rb:842
  def total_time=(_arg0); end

  # Total number of tests that warned.
  #
  # pkg:gem/minitest#lib/minitest.rb:857
  def warnings; end

  # Total number of tests that warned.
  #
  # pkg:gem/minitest#lib/minitest.rb:857
  def warnings=(_arg0); end
end

# A reporter that prints the header, summary, and failure details at
# the end of the run.
#
# This is added to the top-level CompositeReporter at the start of
# the run. If you want to change the output of minitest via a
# plugin, pull this out of the composite and replace it with your
# own.
#
# pkg:gem/minitest#lib/minitest.rb:917
class Minitest::SummaryReporter < ::Minitest::StatisticsReporter
  # pkg:gem/minitest#lib/minitest.rb:950
  def aggregated_results(io); end

  # pkg:gem/minitest#lib/minitest.rb:919
  def old_sync; end

  # pkg:gem/minitest#lib/minitest.rb:919
  def old_sync=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:933
  def report; end

  # pkg:gem/minitest#lib/minitest.rb:921
  def start; end

  # pkg:gem/minitest#lib/minitest.rb:945
  def statistics; end

  # pkg:gem/minitest#lib/minitest.rb:970
  def summary; end

  # pkg:gem/minitest#lib/minitest.rb:918
  def sync; end

  # pkg:gem/minitest#lib/minitest.rb:918
  def sync=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:966
  def to_s; end
end

# Subclass Test to create your own tests. Typically you'll want a
# Test subclass per implementation class.
#
# See Minitest::Assertions
#
# pkg:gem/minitest#lib/minitest/test.rb:10
class Minitest::Test < ::Minitest::Runnable
  include ::Minitest::Reportable
  include ::Minitest::Assertions
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  extend ::Minitest::Guard

  # LifecycleHooks
  #
  # pkg:gem/minitest#lib/minitest/test.rb:186
  def capture_exceptions; end

  # pkg:gem/minitest#lib/minitest/test.rb:203
  def neuter_exception(e); end

  # pkg:gem/minitest#lib/minitest/test.rb:214
  def new_exception(klass, msg, bt, kill = T.unsafe(nil)); end

  # Runs a single test with setup/teardown hooks.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:84
  def run; end

  # pkg:gem/minitest#lib/minitest/test.rb:196
  def sanitize_exception(e); end

  class << self
    # Call this at the top of your tests when you absolutely
    # positively need to have ordered tests. In doing so, you're
    # admitting that you suck and your tests are weak.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:31
    def i_suck_and_my_tests_are_order_dependent!; end

    # Returns the value of attribute io_lock.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:22
    def io_lock; end

    # Sets the attribute io_lock
    #
    # @param value the value to set the attribute io_lock to.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:22
    def io_lock=(_arg0); end

    # Make diffs for this Test use #pretty_inspect so that diff
    # in assert_equal can have more details. NOTE: this is much slower
    # than the regular inspect but much more usable for complex
    # objects.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:44
    def make_my_diffs_pretty!; end

    # Call this at the top of your tests (inside the +Minitest::Test+
    # subclass or +describe+ block) when you want to run your tests in
    # parallel. In doing so, you're admitting that you rule and your
    # tests are awesome.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:56
    def parallelize_me!; end

    # Returns all instance methods starting with "test_". Based on
    # #run_order, the methods are either sorted, randomized
    # (default), or run in parallel.
    #
    # pkg:gem/minitest#lib/minitest/test.rb:67
    def runnable_methods; end
  end
end

# Provides before/after hooks for setup and teardown. These are
# meant for library writers, NOT for regular test authors. See
# #before_setup for an example.
#
# pkg:gem/minitest#lib/minitest/test.rb:109
module Minitest::Test::LifecycleHooks
  # Runs before every test, after setup. This hook is meant for
  # libraries to extend minitest. It is not meant to be used by
  # test developers.
  #
  # See #before_setup for an example.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:159
  def after_setup; end

  # Runs after every test, after teardown. This hook is meant for
  # libraries to extend minitest. It is not meant to be used by
  # test developers.
  #
  # See #before_setup for an example.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:183
  def after_teardown; end

  # Runs before every test, before setup. This hook is meant for
  # libraries to extend minitest. It is not meant to be used by
  # test developers.
  #
  # As a simplistic example:
  #
  #   module MyMinitestPlugin
  #     def before_setup
  #       super
  #       # ... stuff to do before setup is run
  #     end
  #
  #     def after_setup
  #       # ... stuff to do after setup is run
  #       super
  #     end
  #
  #     def before_teardown
  #       super
  #       # ... stuff to do before teardown is run
  #     end
  #
  #     def after_teardown
  #       # ... stuff to do after teardown is run
  #       super
  #     end
  #   end
  #
  #   class Minitest::Test
  #     include MyMinitestPlugin
  #   end
  #
  # pkg:gem/minitest#lib/minitest/test.rb:144
  def before_setup; end

  # Runs after every test, before teardown. This hook is meant for
  # libraries to extend minitest. It is not meant to be used by
  # test developers.
  #
  # See #before_setup for an example.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:168
  def before_teardown; end

  # Runs before every test. Use this to set up before each test
  # run.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:150
  def setup; end

  # Runs after every test. Use this to clean up after each test
  # run.
  #
  # pkg:gem/minitest#lib/minitest/test.rb:174
  def teardown; end
end

# pkg:gem/minitest#lib/minitest/test.rb:15
Minitest::Test::PASSTHROUGH_EXCEPTIONS = T.let(T.unsafe(nil), Array)

# pkg:gem/minitest#lib/minitest/test.rb:17
Minitest::Test::SETUP_METHODS = T.let(T.unsafe(nil), Array)

# pkg:gem/minitest#lib/minitest/test.rb:19
Minitest::Test::TEARDOWN_METHODS = T.let(T.unsafe(nil), Array)

# Assertion wrapping an unexpected error that was raised during a run.
#
# pkg:gem/minitest#lib/minitest.rb:1078
class Minitest::UnexpectedError < ::Minitest::Assertion
  include ::Minitest::Compress

  # @return [UnexpectedError] a new instance of UnexpectedError
  #
  # pkg:gem/minitest#lib/minitest.rb:1084
  def initialize(error); end

  # pkg:gem/minitest#lib/minitest.rb:1097
  def backtrace; end

  # TODO: figure out how to use `cause` instead
  #
  # pkg:gem/minitest#lib/minitest.rb:1082
  def error; end

  # TODO: figure out how to use `cause` instead
  #
  # pkg:gem/minitest#lib/minitest.rb:1082
  def error=(_arg0); end

  # pkg:gem/minitest#lib/minitest.rb:1103
  def message; end

  # pkg:gem/minitest#lib/minitest.rb:1109
  def result_label; end
end

# pkg:gem/minitest#lib/minitest.rb:1101
Minitest::UnexpectedError::BASE_RE = T.let(T.unsafe(nil), Regexp)

# Assertion raised on warning when running in -Werror mode.
#
# pkg:gem/minitest#lib/minitest.rb:1117
class Minitest::UnexpectedWarning < ::Minitest::Assertion
  # pkg:gem/minitest#lib/minitest.rb:1118
  def result_label; end
end

# pkg:gem/minitest#lib/minitest.rb:13
Minitest::VERSION = T.let(T.unsafe(nil), String)

# pkg:gem/minitest#lib/minitest/spec.rb:3
class Module
  # pkg:gem/minitest#lib/minitest/spec.rb:4
  def infect_an_assertion(meth, new_name, dont_flip = T.unsafe(nil)); end
end
