# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `measured` gem.
# Please instead update this file by running `bin/tapioca gem measured`.

module Measured
  class << self
    def build(&block); end
    def method_missing(method, *args); end
  end
end

module Measured::Arithmetic
  extend ::Forwardable

  def +(other); end
  def -(other); end
  def -@; end
  def coerce(other); end
  def finite?(*args, &block); end
  def infinite?(*args, &block); end
  def negative?(*args, &block); end

  # @return [Boolean]
  def nonzero?; end

  def positive?(*args, &block); end
  def scale(other); end

  # @raise [TypeError]
  def to_i; end

  def zero?(*args, &block); end

  private

  def arithmetic_operation(other, operator); end
end

module Measured::Cache; end

class Measured::Cache::Json
  # @return [Json] a new instance of Json
  def initialize(filename); end

  # @return [Boolean]
  def exist?; end

  # Returns the value of attribute filename.
  def filename; end

  # Returns the value of attribute path.
  def path; end

  def read; end

  # @raise [ArgumentError]
  def write(table); end

  private

  def decode(table); end

  # JSON dump and load of Rational objects exists, but it changes the behaviour of JSON globally if required.
  # Instead, the same marshalling technique is rewritten here to prevent changing this behaviour project wide.
  # https://github.com/ruby/ruby/blob/trunk/ext/json/lib/json/add/rational.rb
  def encode(table); end
end

module Measured::Cache::JsonWriter
  def write(table); end
end

class Measured::Cache::Null
  # @return [Boolean]
  def exist?; end

  def read; end
  def write(table); end
end

class Measured::ConversionTableBuilder
  # @return [ConversionTableBuilder] a new instance of ConversionTableBuilder
  def initialize(units, cache: T.unsafe(nil)); end

  # @return [Boolean]
  def cached?; end

  def to_h; end

  # Returns the value of attribute units.
  def units; end

  def update_cache; end

  private

  # @raise [Measured::MissingConversionPath]
  def find_conversion(to:, from:); end

  def find_direct_conversion(to:, from:); end
  def find_direct_conversion_cached(to:, from:); end
  def find_tree_traversal_conversion(to:, from:); end
  def generate_table; end
  def traverse(from:, to:, units_remaining:, amount:); end

  # This uses a depth-first search algorithm: https://en.wikipedia.org/wiki/Depth-first_search
  def validate_acyclic_graph(graph, from:, visited: T.unsafe(nil)); end

  def validate_no_cycles; end
end

class Measured::CycleDetected < ::Measured::UnitError
  # @return [CycleDetected] a new instance of CycleDetected
  def initialize(unit); end

  # Returns the value of attribute unit.
  def unit; end
end

class Measured::Length < ::Measured::Measurable
  class << self
    def unit_system; end
  end
end

class Measured::Measurable < ::Numeric
  include ::Measured::Arithmetic

  # @raise [Measured::UnitError]
  # @return [Measurable] a new instance of Measurable
  def initialize(value, unit); end

  def <=>(other); end
  def convert_to(new_unit); end
  def format(format_string = T.unsafe(nil), with_conversion_string: T.unsafe(nil)); end
  def humanize; end
  def inspect; end
  def to_s; end

  # Returns the value of attribute unit.
  def unit; end

  # Returns the value of attribute value.
  def value; end

  private

  def unit_from_unit_or_name!(value); end

  class << self
    def name; end
    def parse(string); end
    def unit_names(*args, &block); end
    def unit_names_with_aliases(*args, &block); end
    def unit_or_alias?(*args, &block); end
    def unit_system; end
  end
end

Measured::Measurable::DEFAULT_FORMAT_STRING = T.let(T.unsafe(nil), String)

class Measured::MissingConversionPath < ::Measured::UnitError
  # @return [MissingConversionPath] a new instance of MissingConversionPath
  def initialize(from, to); end

  # Returns the value of attribute from.
  def from; end

  # Returns the value of attribute to.
  def to; end
end

module Measured::Parser
  extend ::Measured::Parser

  # @raise [Measured::UnitError]
  def parse_string(string); end
end

Measured::Parser::PARSE_REGEX = T.let(T.unsafe(nil), Regexp)

class Measured::Unit
  include ::Comparable

  # @return [Unit] a new instance of Unit
  def initialize(name, aliases: T.unsafe(nil), value: T.unsafe(nil), unit_system: T.unsafe(nil)); end

  def <=>(other); end

  # Returns the value of attribute aliases.
  def aliases; end

  # Returns the value of attribute conversion_amount.
  def conversion_amount; end

  # Returns the value of attribute conversion_unit.
  def conversion_unit; end

  def inspect; end

  # Returns the value of attribute inverse_conversion_amount.
  def inverse_conversion_amount; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute names.
  def names; end

  def to_s(with_conversion_string: T.unsafe(nil)); end

  # Returns the value of attribute unit_system.
  def unit_system; end

  def with(name: T.unsafe(nil), unit_system: T.unsafe(nil), aliases: T.unsafe(nil), value: T.unsafe(nil)); end

  private

  def parse_value(tokens); end
end

class Measured::UnitAlreadyAdded < ::Measured::UnitError
  # @return [UnitAlreadyAdded] a new instance of UnitAlreadyAdded
  def initialize(unit_name); end

  # Returns the value of attribute unit_name.
  def unit_name; end
end

class Measured::UnitError < ::StandardError; end

class Measured::UnitSystem
  # @return [UnitSystem] a new instance of UnitSystem
  def initialize(units, cache: T.unsafe(nil)); end

  # @return [Boolean]
  def cached?; end

  # @raise [Measured::UnitError]
  def convert(value, from:, to:); end

  # @return [Boolean]
  def unit?(name); end

  def unit_for(name); end

  # @raise [Measured::UnitError]
  def unit_for!(name); end

  # Returns the value of attribute unit_names.
  def unit_names; end

  # Returns the value of attribute unit_names_with_aliases.
  def unit_names_with_aliases; end

  # @return [Boolean]
  def unit_or_alias?(name); end

  # Returns the value of attribute units.
  def units; end

  def update_cache; end

  protected

  # Returns the value of attribute conversion_table.
  def conversion_table; end

  # Returns the value of attribute unit_name_to_unit.
  def unit_name_to_unit; end
end

class Measured::UnitSystemBuilder
  # @return [UnitSystemBuilder] a new instance of UnitSystemBuilder
  def initialize; end

  def build; end
  def cache(cache_class, *args); end
  def si_unit(unit_name, aliases: T.unsafe(nil), value: T.unsafe(nil)); end
  def unit(unit_name, aliases: T.unsafe(nil), value: T.unsafe(nil)); end

  private

  def build_si_units(name, aliases: T.unsafe(nil), value: T.unsafe(nil)); end
  def build_unit(name, aliases: T.unsafe(nil), value: T.unsafe(nil)); end
  def check_for_duplicate_unit_names!(unit); end
end

Measured::UnitSystemBuilder::SI_PREFIXES = T.let(T.unsafe(nil), Array)
Measured::VERSION = T.let(T.unsafe(nil), String)

class Measured::Volume < ::Measured::Measurable
  class << self
    def unit_system; end
  end
end

class Measured::Weight < ::Measured::Measurable
  class << self
    def unit_system; end
  end
end
