# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `bin/tapioca gem identity_cache`.

# typed: true

module IdentityCache
  extend ::ActiveSupport::Concern
  extend ::IdentityCache::CacheHash
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex
  include ::IdentityCache::WithPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  def cache_namespace; end
  def cache_namespace=(val); end
  def fetch_read_only_records; end
  def fetch_read_only_records=(val); end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  class << self
    def append_features(base); end
    def cache; end
    def cache_backend=(cache_adaptor); end
    def cache_namespace; end
    def cache_namespace=(val); end
    def eager_load!; end
    def fetch(key); end
    def fetch_multi(*keys); end
    def fetch_read_only_records; end
    def fetch_read_only_records=(val); end
    def logger; end
    def logger=(_arg0); end
    def map_cached_nil_for(value); end
    def readonly; end
    def readonly=(_arg0); end
    def should_fill_cache?; end
    def should_use_cache?; end
    def unmap_cached_nil_for(value); end
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    def fetch_in_batches(keys); end
  end
end

class IdentityCache::AlreadyIncludedError < ::StandardError; end
class IdentityCache::AssociationError < ::StandardError; end
IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

module IdentityCache::BelongsToCaching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods

  module GeneratedClassMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end

  module GeneratedInstanceMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end
end

module IdentityCache::BelongsToCaching::ClassMethods
  def cache_belongs_to(association); end
end

IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)
IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

class IdentityCache::CacheFetcher
  def initialize(cache_backend); end

  def cache_backend; end
  def cache_backend=(_arg0); end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys, &block); end
  def write(key, value); end

  private

  def add(key, value); end
  def add_multi(keys); end
  def cas_multi(keys); end
end

module IdentityCache::CacheHash
  def memcache_hash(key); end
end

module IdentityCache::CacheInvalidation
  def reload(*_arg0); end

  private

  def clear_cached_associations; end
end

IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

module IdentityCache::CacheKeyGeneration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods

  class << self
    def denormalized_schema_hash(klass); end
    def denormalized_schema_string(klass); end
    def schema_to_string(columns); end
  end
end

module IdentityCache::CacheKeyGeneration::ClassMethods
  def rails_cache_key_namespace; end
end

IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

module IdentityCache::CacheKeyLoader
  class << self
    def load(cache_fetcher, db_key); end
    def load_batch(cache_fetcher_to_db_keys_hash); end
    def load_multi(cache_fetcher, db_keys); end

    private

    def cache_fetch_multi(cache_keys); end
    def resolve_multi_on_miss(cache_fetcher, unresolved_cache_keys, cache_key_to_db_key_hash, resolve_miss_result, db_keys_buffer: T.unsafe(nil)); end
  end
end

module IdentityCache::Cached; end

class IdentityCache::Cached::Association
  include ::IdentityCache::Cached::EmbeddedFetching

  def initialize(name, reflection:); end

  def build; end
  def cached_accessor_name; end
  def clear(_record); end
  def embedded?; end
  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(_records); end
  def fetch_async(_load_strategy, _records); end
  def inverse_name; end
  def name; end
  def read(_record); end
  def records_variable_name; end
  def reflection; end
  def validate; end
  def write(_record, _value); end
end

class IdentityCache::Cached::Attribute
  def initialize(model, attribute_or_proc, alias_name, key_fields, unique); end

  def alias_name; end
  def attribute; end
  def cache_key(index_key); end
  def expire(record); end
  def fetch(db_key); end
  def key_fields; end
  def load_one_from_db(key); end
  def model; end
  def unique; end

  private

  def cache_key_from_key_values(_key_values); end
  def cache_key_prefix; end
  def cast_db_key(_index_key); end
  def fetch_method_suffix; end
  def field_types; end
  def load_from_db_where_conditions(_index_key_or_keys); end
  def new_cache_key(record); end
  def old_cache_key(record); end
  def unhashed_values_cache_key_string(_index_key); end
end

class IdentityCache::Cached::AttributeByMulti < ::IdentityCache::Cached::Attribute
  def build; end
  def cache_key_from_key_values(index_key); end

  private

  def cast_db_key(key_values); end
  def load_from_db_where_conditions(key_values); end
  def unhashed_values_cache_key_string(key_values); end
end

class IdentityCache::Cached::AttributeByOne < ::IdentityCache::Cached::Attribute
  def initialize(*_arg0); end

  def build; end
  def cache_decode(db_value); end
  def cache_encode(db_value); end
  def fetch_multi(keys); end
  def key_field; end
  def load_multi_from_db(keys); end

  private

  def cache_key_from_key_values(key_values); end
  def cast_db_key(key); end
  def load_from_db_where_conditions(key_values); end
  def unhashed_values_cache_key_string(key); end
end

class IdentityCache::Cached::BelongsTo < ::IdentityCache::Cached::Association
  def build; end
  def clear(record); end
  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(records); end
  def fetch_async(load_strategy, records); end
  def records_variable_name; end
  def write(owner_record, associated_record); end
end

module IdentityCache::Cached::EmbeddedFetching
  private

  def embedded_fetched?(records); end
  def fetch_embedded(records); end
  def fetch_embedded_async(load_strategy, records); end
end

module IdentityCache::Cached::Prefetcher
  class << self
    def prefetch(klass, associations, records, load_strategy: T.unsafe(nil)); end

    private

    def fetch_association(load_strategy, klass, association, records, &block); end
    def preload_records(records, association); end
  end
end

IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

class IdentityCache::Cached::PrimaryIndex
  def initialize(model); end

  def cache_decode(cache_value); end
  def cache_encode(record); end
  def cache_key(id); end
  def expire(id); end
  def fetch(id); end
  def fetch_multi(ids); end
  def load_multi_from_db(ids); end
  def load_one_from_db(id); end
  def model; end

  private

  def build_query(id_or_ids); end
  def cache_key_prefix; end
  def cast_id(id); end
  def id_column; end
end

module IdentityCache::Cached::Recursive; end

class IdentityCache::Cached::Recursive::Association < ::IdentityCache::Cached::Association
  def initialize(name, reflection:); end

  def build; end
  def clear(record); end
  def dehydrated_variable_name; end
  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(records); end
  def fetch_async(load_strategy, records); end
  def read(record); end
  def set_with_inverse(record, association_target); end
  def write(record, association_target); end

  private

  def embedded_fetched?(records); end
  def hydrate_association_target(associated_class, dehydrated_value); end
  def set_inverse(record, association_target); end
end

class IdentityCache::Cached::Recursive::HasMany < ::IdentityCache::Cached::Recursive::Association; end
class IdentityCache::Cached::Recursive::HasOne < ::IdentityCache::Cached::Recursive::Association; end
module IdentityCache::Cached::Reference; end

class IdentityCache::Cached::Reference::Association < ::IdentityCache::Cached::Association
  def embedded_by_reference?; end
  def embedded_recursively?; end
end

class IdentityCache::Cached::Reference::HasMany < ::IdentityCache::Cached::Reference::Association
  def initialize(name, reflection:); end

  def build; end
  def cached_ids_name; end
  def clear(record); end
  def fetch(records); end
  def fetch_async(load_strategy, records); end
  def ids_variable_name; end
  def read(record); end
  def write(record, ids); end

  private

  def embedded_fetched?(records); end
  def ids_cached_reader_name; end
  def ids_name; end
  def singular_name; end
end

class IdentityCache::Cached::Reference::HasOne < ::IdentityCache::Cached::Reference::Association
  def initialize(name, reflection:); end

  def build; end
  def cached_id_name; end
  def clear(record); end
  def fetch(records); end
  def fetch_async(load_strategy, records); end
  def id_variable_name; end
  def read(record); end
  def write(record, id); end

  private

  def embedded_fetched?(records); end
  def id_cached_reader_name; end
  def id_name; end
end

module IdentityCache::ConfigurationDSL
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end
end

module IdentityCache::ConfigurationDSL::ClassMethods
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end
  def cache_has_many(association, embed: T.unsafe(nil)); end
  def cache_has_one(association, embed:); end

  private

  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end
  def check_association_for_caching(association); end
  def ensure_base_model; end
end

IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)
IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)
class IdentityCache::DerivedModelError < ::StandardError; end

module IdentityCache::Encoder
  class << self
    def decode(coder, klass); end
    def encode(record); end

    private

    def coder_from_record(record, klass); end
    def embedded_coder(record, _association, cached_association); end
    def record_from_coder(coder, klass); end
  end
end

IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)
IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)

class IdentityCache::ExpiryHook
  def initialize(cached_association); end

  def install; end

  private

  def cached_association; end
  def child_class; end
  def inverse_name; end
  def only_on_foreign_key_change?; end
  def parent_class; end
end

class IdentityCache::FallbackFetcher
  def initialize(cache_backend); end

  def cache_backend; end
  def cache_backend=(_arg0); end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys); end
  def write(key, value); end
end

class IdentityCache::InverseAssociationError < ::StandardError; end
module IdentityCache::LoadStrategy; end

module IdentityCache::LoadStrategy::Eager
  extend ::IdentityCache::LoadStrategy::Eager

  def lazy_load; end
  def load(cache_fetcher, db_key); end
  def load_batch(db_keys_by_cache_fetcher); end
  def load_multi(cache_fetcher, db_keys); end
end

class IdentityCache::LoadStrategy::Lazy
  def initialize; end

  def lazy_load; end
  def load(cache_fetcher, db_key); end
  def load_batch(db_keys_by_cache_fetcher); end
  def load_multi(cache_fetcher, db_keys, &callback); end
  def load_now; end

  private

  def load_pending(pending_loads); end
end

class IdentityCache::LoadStrategy::LoadRequest
  def initialize(db_keys, callback); end

  def after_load(results); end
  def db_keys; end
end

class IdentityCache::LoadStrategy::MultiLoadRequest
  def initialize(load_requests); end

  def after_load(all_results); end
  def db_keys; end
end

class IdentityCache::MemoizedCacheProxy
  def initialize(cache_adaptor = T.unsafe(nil)); end

  def cache_backend=(cache_adaptor); end
  def cache_fetcher; end
  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(*keys); end
  def memoized_key_values; end
  def with_memoization; end
  def write(key, value); end

  private

  def clear_memoization; end
  def fetch_memoized(key); end
  def fetch_multi_memoized(keys); end
  def instrument_duration(payload, key); end
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end
  def memoizing?; end
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

IdentityCache::MemoizedCacheProxy::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

module IdentityCache::ParentModelExpiration
  include ::ArTransactionChanges
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  def add_parents_to_cache_expiry_set(parents_to_expire); end
  def add_record_to_cache_expiry_set(parents_to_expire, record); end
  def expire_parent_caches; end
  def parents_to_expire_on_changes(parents_to_expire, association_name, cached_associations); end
  def should_expire_identity_cache_parent?(foreign_key, only_on_foreign_key_change); end

  module GeneratedClassMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  class << self
    def add_parent_expiry_hook(cached_association); end
    def install_all_pending_parent_expiry_hooks; end
    def install_pending_parent_expiry_hooks(model); end

    private

    def lazy_hooks; end
  end
end

module IdentityCache::QueryAPI
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods

  def _run_commit_callbacks; end
  def expire_cache; end
  def was_new_record?; end

  private

  def expire_attribute_indexes; end
end

module IdentityCache::QueryAPI::ClassMethods
  def all_cached_associations; end
  def cached_association(name); end
  def prefetch_associations(includes, records); end

  private

  def cache_fetch_includes; end
  def check_association_scope(association_name); end
  def each_id_embedded_association; end
  def embedded_associations; end
  def preload_id_embedded_association(records, cached_association); end
  def raise_if_scoped; end
  def readonly_copy(record_or_records); end
  def readonly_record_copy(record); end
  def recursively_embedded_associations; end
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

class IdentityCache::Railtie < ::Rails::Railtie; end
class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound; end

module IdentityCache::ShouldUseCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
end

module IdentityCache::ShouldUseCache::ClassMethods
  def should_use_cache?; end
end

class IdentityCache::UnsupportedAssociationError < ::StandardError; end
class IdentityCache::UnsupportedScopeError < ::StandardError; end
IdentityCache::VERSION = T.let(T.unsafe(nil), String)

module IdentityCache::WithPrimaryIndex
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  def expire_cache; end
  def expire_primary_index; end
  def primary_cache_index_key; end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

module IdentityCache::WithPrimaryIndex::ClassMethods
  def cache_index(*fields, unique: T.unsafe(nil)); end
  def cached_primary_index; end
  def exists_with_identity_cache?(id); end
  def expire_primary_key_cache_index(id); end
  def fetch(id, includes: T.unsafe(nil)); end
  def fetch_by_id(id, includes: T.unsafe(nil)); end
  def fetch_multi(*ids, includes: T.unsafe(nil)); end
  def primary_cache_index_enabled; end
end

module IdentityCache::WithoutPrimaryIndex
  include ::ArTransactionChanges
  include ::IdentityCache::CacheInvalidation
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  class << self
    def append_features(base); end
  end
end

module IdentityCache::WithoutPrimaryIndex::ClassMethods
  def primary_cache_index_enabled; end
end
