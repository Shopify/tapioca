# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `bin/tapioca gem identity_cache`.

# source://identity_cache-1.1.0/lib/identity_cache/version.rb:2
module IdentityCache
  extend ::ActiveSupport::Concern
  extend ::IdentityCache::CacheHash
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex
  include ::IdentityCache::WithPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # source://identity_cache-1.1.0/lib/identity_cache.rb:68
  def cache_namespace; end

  # source://identity_cache-1.1.0/lib/identity_cache.rb:68
  def cache_namespace=(val); end

  # source://identity_cache-1.1.0/lib/identity_cache.rb:74
  def fetch_read_only_records; end

  # source://identity_cache-1.1.0/lib/identity_cache.rb:74
  def fetch_read_only_records=(val); end

  class << self
    # @raise [AlreadyIncludedError]
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:83
    def append_features(base); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:102
    def cache; end

    # Sets the cache adaptor IdentityCache will be using
    #
    # == Parameters
    #
    # +cache_adaptor+ - A ActiveSupport::Cache::Store
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:94
    def cache_backend=(cache_adaptor); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:68
    def cache_namespace; end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:68
    def cache_namespace=(val); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:195
    def eager_load!; end

    # Cache retrieval and miss resolver primitive; given a key it will try to
    # retrieve the associated value from the cache otherwise it will return the
    # value of the execution of the block.
    #
    # == Parameters
    # +key+ A cache key string
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:145
    def fetch(key); end

    # Same as +fetch+, except that it will try a collection of keys, using the
    # multiget operation of the cache adaptor.
    #
    # == Parameters
    # +keys+ A collection or array of key strings
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:166
    def fetch_multi(*keys); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:74
    def fetch_read_only_records; end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:74
    def fetch_read_only_records=(val); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:106
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:81
    def logger=(_arg0); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:153
    def map_cached_nil_for(value); end

    # Returns the value of attribute readonly.
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:80
    def readonly; end

    # Sets the attribute readonly
    #
    # @param value the value to set the attribute readonly to.
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:80
    def readonly=(_arg0); end

    # @return [Boolean]
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:110
    def should_fill_cache?; end

    # @return [Boolean]
    #
    # source://identity_cache-1.1.0/lib/identity_cache.rb:114
    def should_use_cache?; end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:157
    def unmap_cached_nil_for(value); end

    # source://identity_cache-1.1.0/lib/identity_cache.rb:187
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    # source://identity_cache-1.1.0/lib/identity_cache.rb:201
    def fetch_in_batches(keys); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache.rb:56
class IdentityCache::AlreadyIncludedError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache.rb:58
class IdentityCache::AssociationError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache.rb:52
IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://identity_cache-1.1.0/lib/identity_cache/belongs_to_caching.rb:3
module IdentityCache::BelongsToCaching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods

  module GeneratedClassMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end

  module GeneratedInstanceMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/belongs_to_caching.rb:11
module IdentityCache::BelongsToCaching::ClassMethods
  # source://identity_cache-1.1.0/lib/identity_cache/belongs_to_caching.rb:12
  def cache_belongs_to(association); end
end

# source://identity_cache-1.1.0/lib/identity_cache.rb:51
IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)

# source://identity_cache-1.1.0/lib/identity_cache/version.rb:4
IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

# source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:3
class IdentityCache::CacheFetcher
  # @return [CacheFetcher] a new instance of CacheFetcher
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:6
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:4
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:4
  def cache_backend=(_arg0); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:18
  def clear; end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:14
  def delete(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:28
  def fetch(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:22
  def fetch_multi(keys, &block); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:10
  def write(key, value); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:84
  def add(key, value); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:78
  def add_multi(keys); end

  # source://identity_cache-1.1.0/lib/identity_cache/cache_fetcher.rb:50
  def cas_multi(keys); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cache_hash.rb:22
module IdentityCache::CacheHash
  # source://identity_cache-1.1.0/lib/identity_cache/cache_hash.rb:25
  def memcache_hash(key); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cache_invalidation.rb:3
module IdentityCache::CacheInvalidation
  # source://identity_cache-1.1.0/lib/identity_cache/cache_invalidation.rb:6
  def reload(*_arg0); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/cache_invalidation.rb:13
  def clear_cached_associations; end
end

# source://identity_cache-1.1.0/lib/identity_cache/cache_invalidation.rb:4
IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

# source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:3
module IdentityCache::CacheKeyGeneration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods

  class << self
    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:28
    def denormalized_schema_hash(klass); end

    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:11
    def denormalized_schema_string(klass); end

    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:7
    def schema_to_string(columns); end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:33
module IdentityCache::CacheKeyGeneration::ClassMethods
  # source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:34
  def rails_cache_key_namespace; end
end

# source://identity_cache-1.1.0/lib/identity_cache/cache_key_generation.rb:5
IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

# A generic cache key loader that supports different types of
# cache fetchers, each of which can use their own cache key
# format and have their own cache miss resolvers.
#
# Here is the interface of a cache fetcher in the
# [ruby-signature](https://github.com/ruby/ruby-signature)'s
# format.
#
# ```
# interface _CacheFetcher[DbKey, DbValue, CacheableValue]
#   def cache_key: (DbKey) -> String
#   def cache_encode: (DbValue) -> CacheableValue
#   def cache_decode: (CacheableValue) -> DbValue
#   def load_one_from_db: (DbKey) -> DbValue
#   def load_multi_from_db: (Array[DbKey]) -> Hash[DbKey, DbValue]
# end
# ```
#
# source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:21
module IdentityCache::CacheKeyLoader
  class << self
    # Load a single key for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key Reference to what to load from the database.
    # @return The database value corresponding to the database key.
    #
    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:28
    def load(cache_fetcher, db_key); end

    # Load multiple keys for multiple cache fetchers
    #
    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:51
    def load_batch(cache_fetcher_to_db_keys_hash); end

    # Load multiple keys for a cache fetcher.
    #
    # @param cache_fetcher [_CacheFetcher]
    # @param db_key [Array] Reference to what to load from the database.
    # @return [Hash] A hash mapping each database key to its corresponding value
    #
    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:46
    def load_multi(cache_fetcher, db_keys); end

    private

    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:99
    def cache_fetch_multi(cache_keys); end

    # source://identity_cache-1.1.0/lib/identity_cache/cache_key_loader.rb:106
    def resolve_multi_on_miss(cache_fetcher, unresolved_cache_keys, cache_key_to_db_key_hash, resolve_miss_result, db_keys_buffer: T.unsafe(nil)); end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached.rb:3
module IdentityCache::Cached; end

# source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:4
class IdentityCache::Cached::Association
  include ::IdentityCache::Cached::EmbeddedFetching

  # @return [Association] a new instance of Association
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:7
  def initialize(name, reflection:); end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:16
  def build; end

  # Returns the value of attribute cached_accessor_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:14
  def cached_accessor_name; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:28
  def clear(_record); end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:40
  def embedded?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:44
  def embedded_by_reference?; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:48
  def embedded_recursively?; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:32
  def fetch(_records); end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:36
  def fetch_async(_load_strategy, _records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:52
  def inverse_name; end

  # Returns the value of attribute name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:14
  def name; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:20
  def read(_record); end

  # Returns the value of attribute records_variable_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:14
  def records_variable_name; end

  # Returns the value of attribute reflection.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:14
  def reflection; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:59
  def validate; end

  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/association.rb:24
  def write(_record, _value); end
end

# @abstract
#
# source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:6
class IdentityCache::Cached::Attribute
  # @return [Attribute] a new instance of Attribute
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:9
  def initialize(model, attribute_or_proc, alias_name, key_fields, unique); end

  # Returns the value of attribute alias_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:7
  def alias_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:21
  def attribute; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:50
  def cache_key(index_key); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:37
  def expire(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:25
  def fetch(db_key); end

  # Returns the value of attribute key_fields.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:7
  def key_fields; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:55
  def load_one_from_db(key); end

  # Returns the value of attribute model.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:7
  def model; end

  # Returns the value of attribute unique.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:7
  def unique; end

  private

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:80
  def cache_key_from_key_values(_key_values); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:88
  def cache_key_prefix; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:65
  def cast_db_key(_index_key); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:118
  def fetch_method_suffix; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:84
  def field_types; end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:75
  def load_from_db_where_conditions(_index_key_or_keys); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:98
  def new_cache_key(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:103
  def old_cache_key(record); end

  # @abstract
  # @raise [NotImplementedError]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:70
  def unhashed_values_cache_key_string(_index_key); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_multi.rb:5
class IdentityCache::Cached::AttributeByMulti < ::IdentityCache::Cached::Attribute
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_multi.rb:6
  def build; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute.rb:50
  def cache_key_from_key_values(index_key); end

  private

  # Attribute method overrides
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_multi.rb:19
  def cast_db_key(key_values); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_multi.rb:30
  def load_from_db_where_conditions(key_values); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_multi.rb:26
  def unhashed_values_cache_key_string(key_values); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:5
class IdentityCache::Cached::AttributeByOne < ::IdentityCache::Cached::Attribute
  # @return [AttributeByOne] a new instance of AttributeByOne
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:8
  def initialize(*_arg0); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:13
  def build; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:62
  def cache_decode(db_value); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:62
  def cache_encode(db_value); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:27
  def fetch_multi(keys); end

  # Returns the value of attribute key_field.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:6
  def key_field; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:43
  def load_multi_from_db(keys); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:83
  def cache_key_from_key_values(key_values); end

  # Attribute method overrides
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:71
  def cast_db_key(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:79
  def load_from_db_where_conditions(key_values); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/attribute_by_one.rb:75
  def unhashed_values_cache_key_string(key); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:4
class IdentityCache::Cached::BelongsTo < ::IdentityCache::Cached::Association
  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:7
  def build; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:24
  def clear(record); end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:95
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:91
  def embedded_recursively?; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:34
  def fetch(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:38
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute records_variable_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:5
  def records_variable_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/belongs_to.rb:30
  def write(owner_record, associated_record); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/embedded_fetching.rb:4
module IdentityCache::Cached::EmbeddedFetching
  private

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/embedded_fetching.rb:34
  def embedded_fetched?(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/embedded_fetching.rb:7
  def fetch_embedded(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/embedded_fetching.rb:11
  def fetch_embedded_async(load_strategy, records); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/prefetcher.rb:5
module IdentityCache::Cached::Prefetcher
  class << self
    # source://identity_cache-1.1.0/lib/identity_cache/cached/prefetcher.rb:9
    def prefetch(klass, associations, records, load_strategy: T.unsafe(nil)); end

    private

    # source://identity_cache-1.1.0/lib/identity_cache/cached/prefetcher.rb:39
    def fetch_association(load_strategy, klass, association, records, &block); end

    # source://identity_cache-1.1.0/lib/identity_cache/cached/prefetcher.rb:54
    def preload_records(records, association); end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/prefetcher.rb:6
IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:5
class IdentityCache::Cached::PrimaryIndex
  # @return [PrimaryIndex] a new instance of PrimaryIndex
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:8
  def initialize(model); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:72
  def cache_decode(cache_value); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:68
  def cache_encode(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:50
  def cache_key(id); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:45
  def expire(id); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:12
  def fetch(id); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:33
  def fetch_multi(ids); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:60
  def load_multi_from_db(ids); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:54
  def load_one_from_db(id); end

  # Returns the value of attribute model.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:6
  def model; end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:86
  def build_query(id_or_ids); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:90
  def cache_key_prefix; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:78
  def cast_id(id); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/primary_index.rb:82
  def id_column; end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:4
module IdentityCache::Cached::Recursive; end

# source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:5
class IdentityCache::Cached::Recursive::Association < ::IdentityCache::Cached::Association
  # @return [Association] a new instance of Association
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:6
  def initialize(name, reflection:); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:13
  def build; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:52
  def clear(record); end

  # Returns the value of attribute dehydrated_variable_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:11
  def dehydrated_variable_name; end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:68
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:72
  def embedded_recursively?; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:58
  def fetch(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:62
  def fetch_async(load_strategy, records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:24
  def read(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:47
  def set_with_inverse(record, association_target); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:43
  def write(record, association_target); end

  private

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:102
  def embedded_fetched?(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:93
  def hydrate_association_target(associated_class, dehydrated_value); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/association.rb:78
  def set_inverse(record, association_target); end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/has_many.rb:5
class IdentityCache::Cached::Recursive::HasMany < ::IdentityCache::Cached::Recursive::Association; end

# source://identity_cache-1.1.0/lib/identity_cache/cached/recursive/has_one.rb:5
class IdentityCache::Cached::Recursive::HasOne < ::IdentityCache::Cached::Recursive::Association; end

# source://identity_cache-1.1.0/lib/identity_cache/cached/reference/association.rb:4
module IdentityCache::Cached::Reference; end

# source://identity_cache-1.1.0/lib/identity_cache/cached/reference/association.rb:5
class IdentityCache::Cached::Reference::Association < ::IdentityCache::Cached::Association
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/association.rb:6
  def embedded_by_reference?; end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/association.rb:10
  def embedded_recursively?; end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:5
class IdentityCache::Cached::Reference::HasMany < ::IdentityCache::Cached::Reference::Association
  # @return [HasMany] a new instance of HasMany
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:6
  def initialize(name, reflection:); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:14
  def build; end

  # Returns the value of attribute cached_ids_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:12
  def cached_ids_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:43
  def clear(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:51
  def fetch(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:55
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute ids_variable_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:12
  def ids_variable_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:35
  def read(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:39
  def write(record, ids); end

  private

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:86
  def embedded_fetched?(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:99
  def ids_cached_reader_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:95
  def ids_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_many.rb:91
  def singular_name; end
end

# source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:5
class IdentityCache::Cached::Reference::HasOne < ::IdentityCache::Cached::Reference::Association
  # @return [HasOne] a new instance of HasOne
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:6
  def initialize(name, reflection:); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:14
  def build; end

  # Returns the value of attribute cached_id_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:12
  def cached_id_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:44
  def clear(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:52
  def fetch(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:56
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute id_variable_name.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:12
  def id_variable_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:36
  def read(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:40
  def write(record, id); end

  private

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:85
  def embedded_fetched?(records); end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:94
  def id_cached_reader_name; end

  # source://identity_cache-1.1.0/lib/identity_cache/cached/reference/has_one.rb:90
  def id_name; end
end

# source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:3
module IdentityCache::ConfigurationDSL
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:16
module IdentityCache::ConfigurationDSL::ClassMethods
  # Will cache a single attribute on its own blob, it will add a
  # fetch_attribute_by_id (or the value of the by option).
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     cache_attribute :quantity, by: :name
  #     cache_attribute :quantity, by: [:name, :vendor]
  #   end
  #
  # == Parameters
  # +attribute+ Symbol with the name of the attribute being cached
  #
  # == Options
  #
  # * by: Other attribute or attributes in the model to keep values indexed. Default is :id
  # * unique: if the index would only have unique values. Default is true
  #
  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:118
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # The embed option, if set, will make IdentityCache keep the association
  # values in the same cache entry as the parent.
  #
  # Embedded associations are more effective in offloading database work,
  # however they will increase the size of the cache entries and make the
  # whole entry expire when any of the embedded members change.
  #
  # == Example:
  #   class Product
  #     include IdentityCache
  #     has_many :options
  #     has_many :orders
  #     cache_has_many :options, embed: :ids
  #     cache_has_many :orders
  #   end
  #
  # == Parameters
  # +association+ Name of the association being cached as a symbol
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated records
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:ids` (the default), it will only embed the ids for the associated
  #   records.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:44
  def cache_has_many(association, embed: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # IdentityCache will keep the association values in the same cache entry
  # as the parent.
  #
  # == Example:
  #   class Product
  #     cache_has_one :store, embed: true
  #     cache_has_one :vendor, embed: :id
  #   end
  #
  # == Parameters
  # +association+ Symbol with the name of the association being cached
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated record
  #   in the cache entries for this model, as well as all the embedded
  #   associations for the associated record recursively.
  #   If `:id`, it will only embed the id for the associated record.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:82
  def cache_has_one(association, embed:); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:124
  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end

  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:143
  def check_association_for_caching(association); end

  # source://identity_cache-1.1.0/lib/identity_cache/configuration_dsl.rb:134
  def ensure_base_model; end
end

# source://identity_cache-1.1.0/lib/identity_cache.rb:53
IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)

# source://identity_cache-1.1.0/lib/identity_cache.rb:54
IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)

# source://identity_cache-1.1.0/lib/identity_cache.rb:66
class IdentityCache::DerivedModelError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:3
module IdentityCache::Encoder
  class << self
    # source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:16
    def decode(coder, klass); end

    # source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:8
    def encode(record); end

    private

    # source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:26
    def coder_from_record(record, klass); end

    # source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:57
    def embedded_coder(record, _association, cached_association); end

    # source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:69
    def record_from_coder(coder, klass); end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:4
IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache-1.1.0/lib/identity_cache/encoder.rb:5
IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)

# source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:3
class IdentityCache::ExpiryHook
  # @return [ExpiryHook] a new instance of ExpiryHook
  #
  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:4
  def initialize(cached_association); end

  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:8
  def install; end

  private

  # Returns the value of attribute cached_association.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:16
  def cached_association; end

  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:30
  def child_class; end

  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:22
  def inverse_name; end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:18
  def only_on_foreign_key_change?; end

  # source://identity_cache-1.1.0/lib/identity_cache/expiry_hook.rb:26
  def parent_class; end
end

# source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:3
class IdentityCache::FallbackFetcher
  # @return [FallbackFetcher] a new instance of FallbackFetcher
  #
  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:6
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:4
  def cache_backend; end

  # Sets the attribute cache_backend
  #
  # @param value the value to set the attribute cache_backend to.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:4
  def cache_backend=(_arg0); end

  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:18
  def clear; end

  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:14
  def delete(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:35
  def fetch(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:22
  def fetch_multi(keys); end

  # source://identity_cache-1.1.0/lib/identity_cache/fallback_fetcher.rb:10
  def write(key, value); end
end

# source://identity_cache-1.1.0/lib/identity_cache.rb:60
class IdentityCache::InverseAssociationError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache/load_strategy/load_request.rb:4
module IdentityCache::LoadStrategy; end

# source://identity_cache-1.1.0/lib/identity_cache/load_strategy/eager.rb:5
module IdentityCache::LoadStrategy::Eager
  extend ::IdentityCache::LoadStrategy::Eager

  # @yield [lazy_loader]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/eager.rb:20
  def lazy_load; end

  # @yield [CacheKeyLoader.load(cache_fetcher, db_key)]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/eager.rb:8
  def load(cache_fetcher, db_key); end

  # @yield [CacheKeyLoader.load_batch(db_keys_by_cache_fetcher)]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/eager.rb:16
  def load_batch(db_keys_by_cache_fetcher); end

  # @yield [CacheKeyLoader.load_multi(cache_fetcher, db_keys)]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/eager.rb:12
  def load_multi(cache_fetcher, db_keys); end
end

# source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:5
class IdentityCache::LoadStrategy::Lazy
  # @return [Lazy] a new instance of Lazy
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:6
  def initialize; end

  # @yield [_self]
  # @yieldparam _self [IdentityCache::LoadStrategy::Lazy] the object that the method was called on
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:45
  def lazy_load; end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:10
  def load(cache_fetcher, db_key); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:32
  def load_batch(db_keys_by_cache_fetcher); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:17
  def load_multi(cache_fetcher, db_keys, &callback); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:50
  def load_now; end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/lazy.rb:60
  def load_pending(pending_loads); end
end

# source://identity_cache-1.1.0/lib/identity_cache/load_strategy/load_request.rb:5
class IdentityCache::LoadStrategy::LoadRequest
  # @return [LoadRequest] a new instance of LoadRequest
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/load_request.rb:8
  def initialize(db_keys, callback); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/load_request.rb:13
  def after_load(results); end

  # Returns the value of attribute db_keys.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/load_request.rb:6
  def db_keys; end
end

# source://identity_cache-1.1.0/lib/identity_cache/load_strategy/multi_load_request.rb:5
class IdentityCache::LoadStrategy::MultiLoadRequest
  # @return [MultiLoadRequest] a new instance of MultiLoadRequest
  #
  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/multi_load_request.rb:6
  def initialize(load_requests); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/multi_load_request.rb:14
  def after_load(all_results); end

  # source://identity_cache-1.1.0/lib/identity_cache/load_strategy/multi_load_request.rb:10
  def db_keys; end
end

# source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:6
class IdentityCache::MemoizedCacheProxy
  # @return [MemoizedCacheProxy] a new instance of MemoizedCacheProxy
  #
  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:9
  def initialize(cache_adaptor = T.unsafe(nil)); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:14
  def cache_backend=(cache_adaptor); end

  # Returns the value of attribute cache_fetcher.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:7
  def cache_fetcher; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:134
  def clear; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:59
  def delete(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:72
  def fetch(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:103
  def fetch_multi(*keys); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:39
  def memoized_key_values; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:43
  def with_memoization; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:51
  def write(key, value); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:189
  def clear_memoization; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:153
  def fetch_memoized(key); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:161
  def fetch_multi_memoized(keys); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:181
  def instrument_duration(payload, key); end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:197
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:193
  def memoizing?; end

  # source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:146
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

# source://identity_cache-1.1.0/lib/identity_cache/memoized_cache_proxy.rb:143
IdentityCache::MemoizedCacheProxy::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:3
module IdentityCache::ParentModelExpiration
  include ::ArTransactionChanges
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:51
  def add_parents_to_cache_expiry_set(parents_to_expire); end

  # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:58
  def add_record_to_cache_expiry_set(parents_to_expire, record); end

  # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:43
  def expire_parent_caches; end

  # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:64
  def parents_to_expire_on_changes(parents_to_expire, association_name, cached_associations); end

  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:98
  def should_expire_identity_cache_parent?(foreign_key, only_on_foreign_key_change); end

  class << self
    # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:8
    def add_parent_expiry_hook(cached_association); end

    # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:13
    def install_all_pending_parent_expiry_hooks; end

    # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:23
    def install_pending_parent_expiry_hooks(model); end

    private

    # source://identity_cache-1.1.0/lib/identity_cache/parent_model_expiration.rb:33
    def lazy_hooks; end
  end

  module GeneratedClassMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:3
module IdentityCache::QueryAPI
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods

  # Override the method that is used to call after_commit callbacks so that we can
  # expire the caches before other after_commit callbacks. This way we can avoid stale
  # cache reads that happen from the ordering of callbacks. For example, if an after_commit
  # callback enqueues a background job, then we don't want it to be possible for the
  # background job to run and load data from the cache before it is invalidated.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:163
  def _run_commit_callbacks; end

  # Invalidate the cache data associated with the record.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:172
  def expire_cache; end

  # @api private
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:178
  def was_new_record?; end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:185
  def expire_attribute_indexes; end
end

# source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:6
module IdentityCache::QueryAPI::ClassMethods
  # @api private
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:18
  def all_cached_associations; end

  # @api private
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:13
  def cached_association(name); end

  # Prefetches cached associations on a collection of records
  #
  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:8
  def prefetch_associations(includes, records); end

  private

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:134
  def cache_fetch_includes; end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:31
  def check_association_scope(association_name); end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:117
  def each_id_embedded_association; end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:130
  def embedded_associations; end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:42
  def preload_id_embedded_association(records, cached_association); end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:24
  def raise_if_scoped; end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:109
  def readonly_copy(record_or_records); end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:103
  def readonly_record_copy(record); end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:126
  def recursively_embedded_associations; end

  # source://identity_cache-1.1.0/lib/identity_cache/query_api.rb:68
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

# source://identity_cache-1.1.0/lib/identity_cache/railtie.rb:3
class IdentityCache::Railtie < ::Rails::Railtie; end

# source://identity_cache-1.1.0/lib/identity_cache/record_not_found.rb:4
class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound; end

# source://identity_cache-1.1.0/lib/identity_cache/should_use_cache.rb:3
module IdentityCache::ShouldUseCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
end

# source://identity_cache-1.1.0/lib/identity_cache/should_use_cache.rb:6
module IdentityCache::ShouldUseCache::ClassMethods
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/should_use_cache.rb:7
  def should_use_cache?; end
end

# source://identity_cache-1.1.0/lib/identity_cache.rb:64
class IdentityCache::UnsupportedAssociationError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache.rb:62
class IdentityCache::UnsupportedScopeError < ::StandardError; end

# source://identity_cache-1.1.0/lib/identity_cache/version.rb:3
IdentityCache::VERSION = T.let(T.unsafe(nil), String)

# source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:3
module IdentityCache::WithPrimaryIndex
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:8
  def expire_cache; end

  # @api private
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:14
  def expire_primary_index; end

  # @api private
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:19
  def primary_cache_index_key; end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:23
module IdentityCache::WithPrimaryIndex::ClassMethods
  # Declares a new index in the cache for the class where IdentityCache was
  # included.
  #
  # IdentityCache will add a fetch_by_field1_and_field2_and_...field for every
  # index.
  #
  # == Example:
  #
  #  class Product
  #    include IdentityCache
  #    cache_index :name, :vendor
  #  end
  #
  # Will add Product.fetch_by_name_and_vendor
  #
  # == Parameters
  #
  # +fields+ Array of symbols or strings representing the fields in the index
  #
  # == Options
  # * unique: if the index would only have unique values. Default is false
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:55
  def cache_index(*fields, unique: T.unsafe(nil)); end

  # @api private
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:25
  def cached_primary_index; end

  # Similar to ActiveRecord::Base#exists? will return true if the id can be
  # found in the cache or in the DB.
  #
  # @return [Boolean]
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:96
  def exists_with_identity_cache?(id); end

  # Invalidates the primary cache index for the associated record. Will not invalidate cached attributes.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:131
  def expire_primary_key_cache_index(id); end

  # Default fetcher added to the model on inclusion, it behaves like
  # ActiveRecord::Base.find, but will raise IdentityCache::RecordNotFound
  # if the id is not in the cache.
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:113
  def fetch(id, includes: T.unsafe(nil)); end

  # Default fetcher added to the model on inclusion, it behaves like
  # ActiveRecord::Base.where(id: id).first
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:102
  def fetch_by_id(id, includes: T.unsafe(nil)); end

  # Default fetcher added to the model on inclusion, if behaves like
  # ActiveRecord::Base.find_all_by_id
  #
  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:121
  def fetch_multi(*ids, includes: T.unsafe(nil)); end

  # source://identity_cache-1.1.0/lib/identity_cache/with_primary_index.rb:29
  def primary_cache_index_enabled; end
end

# source://identity_cache-1.1.0/lib/identity_cache/without_primary_index.rb:3
module IdentityCache::WithoutPrimaryIndex
  include ::ArTransactionChanges
  include ::IdentityCache::CacheInvalidation
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods

  class << self
    # @raise [AlreadyIncludedError]
    #
    # source://identity_cache-1.1.0/lib/identity_cache/without_primary_index.rb:15
    def append_features(base); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

# source://identity_cache-1.1.0/lib/identity_cache/without_primary_index.rb:25
module IdentityCache::WithoutPrimaryIndex::ClassMethods
  # source://identity_cache-1.1.0/lib/identity_cache/without_primary_index.rb:26
  def primary_cache_index_enabled; end
end
