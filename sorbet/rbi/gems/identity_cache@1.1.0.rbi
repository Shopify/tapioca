# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `identity_cache` gem.
# Please instead update this file by running `bin/tapioca gem identity_cache`.

module IdentityCache
  extend ::ActiveSupport::Concern
  extend ::IdentityCache::CacheHash
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex
  include ::IdentityCache::WithPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  def cache_namespace; end
  def cache_namespace=(val); end
  def fetch_read_only_records; end
  def fetch_read_only_records=(val); end

  class << self
    def append_features(base); end
    def cache; end

    # Sets the cache adaptor IdentityCache will be using
    #
    # == Parameters
    #
    # +cache_adaptor+ - A ActiveSupport::Cache::Store
    def cache_backend=(cache_adaptor); end

    def cache_namespace; end
    def cache_namespace=(val); end
    def eager_load!; end

    # Cache retrieval and miss resolver primitive; given a key it will try to
    # retrieve the associated value from the cache otherwise it will return the
    # value of the execution of the block.
    #
    # == Parameters
    # +key+ A cache key string
    def fetch(key); end

    # Same as +fetch+, except that it will try a collection of keys, using the
    # multiget operation of the cache adaptor.
    #
    # == Parameters
    # +keys+ A collection or array of key strings
    def fetch_multi(*keys); end

    def fetch_read_only_records; end
    def fetch_read_only_records=(val); end
    def logger; end

    # Sets the attribute logger
    def logger=(_arg0); end

    def map_cached_nil_for(value); end

    # Returns the value of attribute readonly.
    def readonly; end

    # Sets the attribute readonly
    def readonly=(_arg0); end

    def should_fill_cache?; end
    def should_use_cache?; end
    def unmap_cached_nil_for(value); end
    def with_fetch_read_only_records(value = T.unsafe(nil)); end

    private

    def fetch_in_batches(keys); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

class IdentityCache::AlreadyIncludedError < ::StandardError; end
class IdentityCache::AssociationError < ::StandardError; end
IdentityCache::BATCH_SIZE = T.let(T.unsafe(nil), Integer)

module IdentityCache::BelongsToCaching
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods

  module GeneratedClassMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end

  module GeneratedInstanceMethods
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
  end
end

module IdentityCache::BelongsToCaching::ClassMethods
  def cache_belongs_to(association); end
end

IdentityCache::CACHED_NIL = T.let(T.unsafe(nil), Symbol)
IdentityCache::CACHE_VERSION = T.let(T.unsafe(nil), Integer)

class IdentityCache::CacheFetcher
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  def cache_backend; end

  # Sets the attribute cache_backend
  def cache_backend=(_arg0); end

  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys, &block); end
  def write(key, value); end

  private

  def add(key, value); end
  def add_multi(keys); end
  def cas_multi(keys); end
end

module IdentityCache::CacheHash
  def memcache_hash(key); end
end

module IdentityCache::CacheInvalidation
  def reload(*_arg0); end

  private

  def clear_cached_associations; end
end

IdentityCache::CacheInvalidation::CACHE_KEY_NAMES = T.let(T.unsafe(nil), Array)

module IdentityCache::CacheKeyGeneration
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods

  class << self
    def denormalized_schema_hash(klass); end
    def denormalized_schema_string(klass); end
    def schema_to_string(columns); end
  end
end

module IdentityCache::CacheKeyGeneration::ClassMethods
  def rails_cache_key_namespace; end
end

IdentityCache::CacheKeyGeneration::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

# A generic cache key loader that supports different types of
# cache fetchers, each of which can use their own cache key
# format and have their own cache miss resolvers.
#
# Here is the interface of a cache fetcher in the
# [ruby-signature](https://github.com/ruby/ruby-signature)'s
# format.
#
# ```
# interface _CacheFetcher[DbKey, DbValue, CacheableValue]
# def cache_key: (DbKey) -> String
# def cache_encode: (DbValue) -> CacheableValue
# def cache_decode: (CacheableValue) -> DbValue
# def load_one_from_db: (DbKey) -> DbValue
# def load_multi_from_db: (Array[DbKey]) -> Hash[DbKey, DbValue]
# end
# ```
module IdentityCache::CacheKeyLoader
  class << self
    # Load a single key for a cache fetcher.
    def load(cache_fetcher, db_key); end

    # Load multiple keys for multiple cache fetchers
    def load_batch(cache_fetcher_to_db_keys_hash); end

    # Load multiple keys for a cache fetcher.
    def load_multi(cache_fetcher, db_keys); end

    private

    def cache_fetch_multi(cache_keys); end
    def resolve_multi_on_miss(cache_fetcher, unresolved_cache_keys, cache_key_to_db_key_hash, resolve_miss_result, db_keys_buffer: T.unsafe(nil)); end
  end
end

module IdentityCache::Cached; end

class IdentityCache::Cached::Association
  include ::IdentityCache::Cached::EmbeddedFetching

  def initialize(name, reflection:); end

  def build; end

  # Returns the value of attribute cached_accessor_name.
  def cached_accessor_name; end

  def clear(_record); end
  def embedded?; end
  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(_records); end
  def fetch_async(_load_strategy, _records); end
  def inverse_name; end

  # Returns the value of attribute name.
  def name; end

  def read(_record); end

  # Returns the value of attribute records_variable_name.
  def records_variable_name; end

  # Returns the value of attribute reflection.
  def reflection; end

  def validate; end
  def write(_record, _value); end
end

class IdentityCache::Cached::Attribute
  def initialize(model, attribute_or_proc, alias_name, key_fields, unique); end

  # Returns the value of attribute alias_name.
  def alias_name; end

  def attribute; end
  def cache_key(index_key); end
  def expire(record); end
  def fetch(db_key); end

  # Returns the value of attribute key_fields.
  def key_fields; end

  def load_one_from_db(key); end

  # Returns the value of attribute model.
  def model; end

  # Returns the value of attribute unique.
  def unique; end

  private

  def cache_key_from_key_values(_key_values); end
  def cache_key_prefix; end
  def cast_db_key(_index_key); end
  def fetch_method_suffix; end
  def field_types; end
  def load_from_db_where_conditions(_index_key_or_keys); end
  def new_cache_key(record); end
  def old_cache_key(record); end
  def unhashed_values_cache_key_string(_index_key); end
end

class IdentityCache::Cached::AttributeByMulti < ::IdentityCache::Cached::Attribute
  def build; end
  def cache_key_from_key_values(index_key); end

  private

  # Attribute method overrides
  def cast_db_key(key_values); end

  def load_from_db_where_conditions(key_values); end
  def unhashed_values_cache_key_string(key_values); end
end

class IdentityCache::Cached::AttributeByOne < ::IdentityCache::Cached::Attribute
  def initialize(*_arg0); end

  def build; end
  def cache_decode(db_value); end
  def cache_encode(db_value); end
  def fetch_multi(keys); end

  # Returns the value of attribute key_field.
  def key_field; end

  def load_multi_from_db(keys); end

  private

  def cache_key_from_key_values(key_values); end

  # Attribute method overrides
  def cast_db_key(key); end

  def load_from_db_where_conditions(key_values); end
  def unhashed_values_cache_key_string(key); end
end

class IdentityCache::Cached::BelongsTo < ::IdentityCache::Cached::Association
  def build; end
  def clear(record); end
  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(records); end
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute records_variable_name.
  def records_variable_name; end

  def write(owner_record, associated_record); end
end

module IdentityCache::Cached::EmbeddedFetching
  private

  def embedded_fetched?(records); end
  def fetch_embedded(records); end
  def fetch_embedded_async(load_strategy, records); end
end

module IdentityCache::Cached::Prefetcher
  class << self
    def prefetch(klass, associations, records, load_strategy: T.unsafe(nil)); end

    private

    def fetch_association(load_strategy, klass, association, records, &block); end
    def preload_records(records, association); end
  end
end

IdentityCache::Cached::Prefetcher::ASSOCIATION_FETCH_EVENT = T.let(T.unsafe(nil), String)

class IdentityCache::Cached::PrimaryIndex
  def initialize(model); end

  def cache_decode(cache_value); end
  def cache_encode(record); end
  def cache_key(id); end
  def expire(id); end
  def fetch(id); end
  def fetch_multi(ids); end
  def load_multi_from_db(ids); end
  def load_one_from_db(id); end

  # Returns the value of attribute model.
  def model; end

  private

  def build_query(id_or_ids); end
  def cache_key_prefix; end
  def cast_id(id); end
  def id_column; end
end

module IdentityCache::Cached::Recursive; end

class IdentityCache::Cached::Recursive::Association < ::IdentityCache::Cached::Association
  def initialize(name, reflection:); end

  def build; end
  def clear(record); end

  # Returns the value of attribute dehydrated_variable_name.
  def dehydrated_variable_name; end

  def embedded_by_reference?; end
  def embedded_recursively?; end
  def fetch(records); end
  def fetch_async(load_strategy, records); end
  def read(record); end
  def set_with_inverse(record, association_target); end
  def write(record, association_target); end

  private

  def embedded_fetched?(records); end
  def hydrate_association_target(associated_class, dehydrated_value); end
  def set_inverse(record, association_target); end
end

class IdentityCache::Cached::Recursive::HasMany < ::IdentityCache::Cached::Recursive::Association; end
class IdentityCache::Cached::Recursive::HasOne < ::IdentityCache::Cached::Recursive::Association; end
module IdentityCache::Cached::Reference; end

class IdentityCache::Cached::Reference::Association < ::IdentityCache::Cached::Association
  def embedded_by_reference?; end
  def embedded_recursively?; end
end

class IdentityCache::Cached::Reference::HasMany < ::IdentityCache::Cached::Reference::Association
  def initialize(name, reflection:); end

  def build; end

  # Returns the value of attribute cached_ids_name.
  def cached_ids_name; end

  def clear(record); end
  def fetch(records); end
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute ids_variable_name.
  def ids_variable_name; end

  def read(record); end
  def write(record, ids); end

  private

  def embedded_fetched?(records); end
  def ids_cached_reader_name; end
  def ids_name; end
  def singular_name; end
end

class IdentityCache::Cached::Reference::HasOne < ::IdentityCache::Cached::Reference::Association
  def initialize(name, reflection:); end

  def build; end

  # Returns the value of attribute cached_id_name.
  def cached_id_name; end

  def clear(record); end
  def fetch(records); end
  def fetch_async(load_strategy, records); end

  # Returns the value of attribute id_variable_name.
  def id_variable_name; end

  def read(record); end
  def write(record, id); end

  private

  def embedded_fetched?(records); end
  def id_cached_reader_name; end
  def id_name; end
end

module IdentityCache::ConfigurationDSL
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
  end
end

module IdentityCache::ConfigurationDSL::ClassMethods
  # Will cache a single attribute on its own blob, it will add a
  # fetch_attribute_by_id (or the value of the by option).
  #
  # == Example:
  # class Product
  # include IdentityCache
  # cache_attribute :quantity, by: :name
  # cache_attribute :quantity, by: [:name, :vendor]
  # end
  #
  # == Parameters
  # +attribute+ Symbol with the name of the attribute being cached
  #
  # == Options
  #
  # * by: Other attribute or attributes in the model to keep values indexed. Default is :id
  # * unique: if the index would only have unique values. Default is true
  def cache_attribute(attribute, by: T.unsafe(nil), unique: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # The embed option, if set, will make IdentityCache keep the association
  # values in the same cache entry as the parent.
  #
  # Embedded associations are more effective in offloading database work,
  # however they will increase the size of the cache entries and make the
  # whole entry expire when any of the embedded members change.
  #
  # == Example:
  # class Product
  # include IdentityCache
  # has_many :options
  # has_many :orders
  # cache_has_many :options, embed: :ids
  # cache_has_many :orders
  # end
  #
  # == Parameters
  # +association+ Name of the association being cached as a symbol
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated records
  # in the cache entries for this model, as well as all the embedded
  # associations for the associated record recursively.
  # If `:ids` (the default), it will only embed the ids for the associated
  # records.
  def cache_has_many(association, embed: T.unsafe(nil)); end

  # Will cache an association to the class including IdentityCache.
  # IdentityCache will keep the association values in the same cache entry
  # as the parent.
  #
  # == Example:
  # class Product
  # cache_has_one :store, embed: true
  # cache_has_one :vendor, embed: :id
  # end
  #
  # == Parameters
  # +association+ Symbol with the name of the association being cached
  #
  # == Options
  #
  # * embed: If `true`, IdentityCache will embed the associated record
  # in the cache entries for this model, as well as all the embedded
  # associations for the associated record recursively.
  # If `:id`, it will only embed the id for the associated record.
  def cache_has_one(association, embed:); end

  private

  def cache_attribute_by_alias(attribute_or_proc, alias_name:, by:, unique:); end
  def check_association_for_caching(association); end
  def ensure_base_model; end
end

IdentityCache::DELETED = T.let(T.unsafe(nil), Symbol)
IdentityCache::DELETED_TTL = T.let(T.unsafe(nil), Integer)
class IdentityCache::DerivedModelError < ::StandardError; end

module IdentityCache::Encoder
  class << self
    def decode(coder, klass); end
    def encode(record); end

    private

    def coder_from_record(record, klass); end
    def embedded_coder(record, _association, cached_association); end
    def record_from_coder(coder, klass); end
  end
end

IdentityCache::Encoder::DEHYDRATE_EVENT = T.let(T.unsafe(nil), String)
IdentityCache::Encoder::HYDRATE_EVENT = T.let(T.unsafe(nil), String)

class IdentityCache::ExpiryHook
  def initialize(cached_association); end

  def install; end

  private

  # Returns the value of attribute cached_association.
  def cached_association; end

  def child_class; end
  def inverse_name; end
  def only_on_foreign_key_change?; end
  def parent_class; end
end

class IdentityCache::FallbackFetcher
  def initialize(cache_backend); end

  # Returns the value of attribute cache_backend.
  def cache_backend; end

  # Sets the attribute cache_backend
  def cache_backend=(_arg0); end

  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(keys); end
  def write(key, value); end
end

class IdentityCache::InverseAssociationError < ::StandardError; end
module IdentityCache::LoadStrategy; end

module IdentityCache::LoadStrategy::Eager
  extend ::IdentityCache::LoadStrategy::Eager

  def lazy_load; end
  def load(cache_fetcher, db_key); end
  def load_batch(db_keys_by_cache_fetcher); end
  def load_multi(cache_fetcher, db_keys); end
end

class IdentityCache::LoadStrategy::Lazy
  def initialize; end

  def lazy_load; end
  def load(cache_fetcher, db_key); end
  def load_batch(db_keys_by_cache_fetcher); end
  def load_multi(cache_fetcher, db_keys, &callback); end
  def load_now; end

  private

  def load_pending(pending_loads); end
end

class IdentityCache::LoadStrategy::LoadRequest
  def initialize(db_keys, callback); end

  def after_load(results); end

  # Returns the value of attribute db_keys.
  def db_keys; end
end

class IdentityCache::LoadStrategy::MultiLoadRequest
  def initialize(load_requests); end

  def after_load(all_results); end
  def db_keys; end
end

class IdentityCache::MemoizedCacheProxy
  def initialize(cache_adaptor = T.unsafe(nil)); end

  def cache_backend=(cache_adaptor); end

  # Returns the value of attribute cache_fetcher.
  def cache_fetcher; end

  def clear; end
  def delete(key); end
  def fetch(key); end
  def fetch_multi(*keys); end
  def memoized_key_values; end
  def with_memoization; end
  def write(key, value); end

  private

  def clear_memoization; end
  def fetch_memoized(key); end
  def fetch_multi_memoized(keys); end
  def instrument_duration(payload, key); end
  def log_multi_result(keys, memo_miss_keys, cache_miss_keys); end
  def memoizing?; end
  def set_instrumentation_payload(payload, num_keys:, memo_misses:, cache_misses:); end
end

IdentityCache::MemoizedCacheProxy::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

module IdentityCache::ParentModelExpiration
  include ::ArTransactionChanges
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  def add_parents_to_cache_expiry_set(parents_to_expire); end
  def add_record_to_cache_expiry_set(parents_to_expire, record); end
  def expire_parent_caches; end
  def parents_to_expire_on_changes(parents_to_expire, association_name, cached_associations); end
  def should_expire_identity_cache_parent?(foreign_key, only_on_foreign_key_change); end

  class << self
    def add_parent_expiry_hook(cached_association); end
    def install_all_pending_parent_expiry_hooks; end
    def install_pending_parent_expiry_hooks(model); end

    private

    def lazy_hooks; end
  end

  module GeneratedClassMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

module IdentityCache::QueryAPI
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods

  # Override the method that is used to call after_commit callbacks so that we can
  # expire the caches before other after_commit callbacks. This way we can avoid stale
  # cache reads that happen from the ordering of callbacks. For example, if an after_commit
  # callback enqueues a background job, then we don't want it to be possible for the
  # background job to run and load data from the cache before it is invalidated.
  def _run_commit_callbacks; end

  # Invalidate the cache data associated with the record.
  def expire_cache; end

  def was_new_record?; end

  private

  def expire_attribute_indexes; end
end

module IdentityCache::QueryAPI::ClassMethods
  def all_cached_associations; end
  def cached_association(name); end

  # Prefetches cached associations on a collection of records
  def prefetch_associations(includes, records); end

  private

  def cache_fetch_includes; end
  def check_association_scope(association_name); end
  def each_id_embedded_association; end
  def embedded_associations; end
  def preload_id_embedded_association(records, cached_association); end
  def raise_if_scoped; end
  def readonly_copy(record_or_records); end
  def readonly_record_copy(record); end
  def recursively_embedded_associations; end
  def setup_embedded_associations_on_miss(records, readonly: T.unsafe(nil)); end
end

class IdentityCache::Railtie < ::Rails::Railtie; end
class IdentityCache::RecordNotFound < ::ActiveRecord::RecordNotFound; end

module IdentityCache::ShouldUseCache
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
end

module IdentityCache::ShouldUseCache::ClassMethods
  def should_use_cache?; end
end

class IdentityCache::UnsupportedAssociationError < ::StandardError; end
class IdentityCache::UnsupportedScopeError < ::StandardError; end
IdentityCache::VERSION = T.let(T.unsafe(nil), String)

module IdentityCache::WithPrimaryIndex
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration
  include ::IdentityCache::WithoutPrimaryIndex

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithPrimaryIndex::ClassMethods

  def expire_cache; end
  def expire_primary_index; end
  def primary_cache_index_key; end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

module IdentityCache::WithPrimaryIndex::ClassMethods
  # Declares a new index in the cache for the class where IdentityCache was
  # included.
  #
  # IdentityCache will add a fetch_by_field1_and_field2_and_...field for every
  # index.
  #
  # == Example:
  #
  # class Product
  # include IdentityCache
  # cache_index :name, :vendor
  # end
  #
  # Will add Product.fetch_by_name_and_vendor
  #
  # == Parameters
  #
  # +fields+ Array of symbols or strings representing the fields in the index
  #
  # == Options
  # * unique: if the index would only have unique values. Default is false
  def cache_index(*fields, unique: T.unsafe(nil)); end

  def cached_primary_index; end

  # Similar to ActiveRecord::Base#exists? will return true if the id can be
  # found in the cache or in the DB.
  def exists_with_identity_cache?(id); end

  # Invalidates the primary cache index for the associated record. Will not invalidate cached attributes.
  def expire_primary_key_cache_index(id); end

  # Default fetcher added to the model on inclusion, it behaves like
  # ActiveRecord::Base.find, but will raise IdentityCache::RecordNotFound
  # if the id is not in the cache.
  def fetch(id, includes: T.unsafe(nil)); end

  # Default fetcher added to the model on inclusion, it behaves like
  # ActiveRecord::Base.where(id: id).first
  def fetch_by_id(id, includes: T.unsafe(nil)); end

  # Default fetcher added to the model on inclusion, if behaves like
  # ActiveRecord::Base.find_all_by_id
  def fetch_multi(*ids, includes: T.unsafe(nil)); end

  def primary_cache_index_enabled; end
end

module IdentityCache::WithoutPrimaryIndex
  include ::ArTransactionChanges
  include ::IdentityCache::CacheInvalidation
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::IdentityCache::BelongsToCaching
  include ::IdentityCache::CacheKeyGeneration
  include ::IdentityCache::ConfigurationDSL
  include ::IdentityCache::QueryAPI
  include ::IdentityCache::ShouldUseCache
  include ::IdentityCache::ParentModelExpiration

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::IdentityCache::BelongsToCaching::ClassMethods
  mixes_in_class_methods ::IdentityCache::CacheKeyGeneration::ClassMethods
  mixes_in_class_methods ::IdentityCache::ConfigurationDSL::ClassMethods
  mixes_in_class_methods ::IdentityCache::QueryAPI::ClassMethods
  mixes_in_class_methods ::IdentityCache::ShouldUseCache::ClassMethods
  mixes_in_class_methods ::IdentityCache::WithoutPrimaryIndex::ClassMethods

  class << self
    def append_features(base); end
  end

  module GeneratedClassMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end

  module GeneratedInstanceMethods
    def cache_indexes; end
    def cache_indexes=(value); end
    def cache_indexes?; end
    def cached_belongs_tos; end
    def cached_belongs_tos=(value); end
    def cached_belongs_tos?; end
    def cached_has_manys; end
    def cached_has_manys=(value); end
    def cached_has_manys?; end
    def cached_has_ones; end
    def cached_has_ones=(value); end
    def cached_has_ones?; end
    def cached_model; end
    def cached_model=(value); end
    def cached_model?; end
    def parent_expiration_entries; end
    def parent_expiration_entries=(value); end
    def parent_expiration_entries?; end
  end
end

module IdentityCache::WithoutPrimaryIndex::ClassMethods
  def primary_cache_index_enabled; end
end
