# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activeresource` gem.
# Please instead update this file by running `bin/tapioca gem activeresource`.

# source://activeresource//lib/active_resource/exceptions.rb#3
module ActiveResource
  extend ::ActiveSupport::Autoload
end

# source://activeresource//lib/active_resource/associations.rb#3
module ActiveResource::Associations
  # Specifies a one-to-one association with another class. This class should only be used
  # if this class contains the foreign key.
  #
  # Methods will be added for retrieval and query for a single associated object, for which
  # this object holds an id:
  #
  # [association(force_reload = false)]
  #   Returns the associated object. +nil+ is returned if the foreign key is +nil+.
  #   Throws a ActiveResource::ResourceNotFound exception if the foreign key is not +nil+
  #   and the resource is not found.
  #
  # (+association+ is replaced with the symbol passed as the first argument, so
  # <tt>belongs_to :post</tt> would add among others <tt>post.nil?</tt>.
  #
  # === Example
  #
  # A Comment class declares <tt>belongs_to :post</tt>, which will add:
  # * <tt>Comment#post</tt> (similar to <tt>Post.find(post_id)</tt>)
  # The declaration can also include an options hash to specialize the behavior of the association.
  #
  # === Options
  # [:class_name]
  #   Specify the class name for the association. Use it only if that name can't be inferred from association name.
  #   So <tt>belongs_to :post</tt> will by default be linked to the Post class, but if the real class name is Article,
  #   you'll have to specify it with this option.
  # [:foreign_key]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :post</tt>
  #   association will use "post_id" as the default <tt>:foreign_key</tt>. Similarly,
  #   <tt>belongs_to :article, :class_name => "Post"</tt> will use a foreign key
  #   of "article_id".
  #
  # Option examples:
  # <tt>belongs_to :customer, :class_name => 'User'</tt>
  # Creates a belongs_to association called customer which is represented through the <tt>User</tt> class.
  #
  # <tt>belongs_to :customer, :foreign_key => 'user_id'</tt>
  # Creates a belongs_to association called customer which would be resolved by the foreign_key <tt>user_id</tt> instead of <tt>customer_id</tt>
  #
  # source://activeresource//lib/active_resource/associations.rb#116
  def belongs_to(name, options = T.unsafe(nil)); end

  # Defines the belongs_to association finder method
  #
  # source://activeresource//lib/active_resource/associations.rb#121
  def defines_belongs_to_finder_method(reflection); end

  # source://activeresource//lib/active_resource/associations.rb#141
  def defines_has_many_finder_method(reflection); end

  # Defines the has_one association
  #
  # source://activeresource//lib/active_resource/associations.rb#159
  def defines_has_one_finder_method(reflection); end

  # Specifies a one-to-many association.
  #
  # === Options
  # [:class_name]
  #   Specify the class name of the association. This class name would
  #   be used for resolving the association class.
  #
  # ==== Example for [:class_name] - option
  # GET /posts/123.json delivers following response body:
  #   {
  #     title: "ActiveResource now has associations",
  #     body: "Lorem Ipsum"
  #     comments: [
  #       {
  #         content: "..."
  #       },
  #       {
  #         content: "..."
  #       }
  #     ]
  #   }
  # ====
  #
  # <tt>has_many :comments, :class_name => 'myblog/comment'</tt>
  # Would resolve those comments into the <tt>Myblog::Comment</tt> class.
  #
  # If the response body does not contain an attribute matching the association name
  # a request sent to the index action under the current resource.
  # For the example above, if the comments are not present the requested path would be:
  # GET /posts/123/comments.xml
  #
  # source://activeresource//lib/active_resource/associations.rb#43
  def has_many(name, options = T.unsafe(nil)); end

  # Specifies a one-to-one association.
  #
  # === Options
  # [:class_name]
  #   Specify the class name of the association. This class name would
  #   be used for resolving the association class.
  #
  # ==== Example for [:class_name] - option
  # GET /posts/1.json delivers following response body:
  #   {
  #     title: "ActiveResource now has associations",
  #     body: "Lorem Ipsum",
  #     author: {
  #       name: "Gabby Blogger",
  #     }
  #   }
  # ====
  #
  # <tt>has_one :author, :class_name => 'myblog/author'</tt>
  # Would resolve this author into the <tt>Myblog::Author</tt> class.
  #
  # If the response body does not contain an attribute matching the association name
  # a request is sent to a singleton path under the current resource.
  # For example, if a Product class <tt>has_one :inventory</tt> calling <tt>Product#inventory</tt>
  # will generate a request on /products/:product_id/inventory.json.
  #
  # source://activeresource//lib/active_resource/associations.rb#73
  def has_one(name, options = T.unsafe(nil)); end
end

# source://activeresource//lib/active_resource/associations.rb#4
module ActiveResource::Associations::Builder; end

# source://activeresource//lib/active_resource/associations/builder/association.rb#4
class ActiveResource::Associations::Builder::Association
  # @return [Association] a new instance of Association
  #
  # source://activeresource//lib/active_resource/associations/builder/association.rb#18
  def initialize(model, name, options); end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#22
  def build; end

  # Returns the value of attribute klass.
  #
  # source://activeresource//lib/active_resource/associations/builder/association.rb#12
  def klass; end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#10
  def macro; end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#10
  def macro=(_arg0); end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#10
  def macro?; end

  # Returns the value of attribute model.
  #
  # source://activeresource//lib/active_resource/associations/builder/association.rb#12
  def model; end

  # Returns the value of attribute name.
  #
  # source://activeresource//lib/active_resource/associations/builder/association.rb#12
  def name; end

  # Returns the value of attribute options.
  #
  # source://activeresource//lib/active_resource/associations/builder/association.rb#12
  def options; end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#6
  def valid_options; end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#6
  def valid_options=(_arg0); end

  # source://activeresource//lib/active_resource/associations/builder/association.rb#6
  def valid_options?; end

  private

  # source://activeresource//lib/active_resource/associations/builder/association.rb#28
  def validate_options; end

  class << self
    # source://activeresource//lib/active_resource/associations/builder/association.rb#14
    def build(model, name, options); end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro; end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro=(value); end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro?; end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#6
    def valid_options; end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#6
    def valid_options=(value); end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#6
    def valid_options?; end
  end
end

# source://activeresource//lib/active_resource/associations/builder/belongs_to.rb#4
class ActiveResource::Associations::Builder::BelongsTo < ::ActiveResource::Associations::Builder::Association
  # source://activeresource//lib/active_resource/associations/builder/belongs_to.rb#9
  def build; end

  class << self
    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro; end

    # source://activeresource//lib/active_resource/associations/builder/association.rb#6
    def valid_options; end
  end
end

# source://activeresource//lib/active_resource/associations/builder/has_many.rb#4
class ActiveResource::Associations::Builder::HasMany < ::ActiveResource::Associations::Builder::Association
  # source://activeresource//lib/active_resource/associations/builder/has_many.rb#7
  def build; end

  class << self
    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro; end
  end
end

# source://activeresource//lib/active_resource/associations/builder/has_one.rb#4
class ActiveResource::Associations::Builder::HasOne < ::ActiveResource::Associations::Builder::Association
  # source://activeresource//lib/active_resource/associations/builder/has_one.rb#7
  def build; end

  class << self
    # source://activeresource//lib/active_resource/associations/builder/association.rb#10
    def macro; end
  end
end

# 400 Bad Request
#
# source://activeresource//lib/active_resource/exceptions.rb#53
class ActiveResource::BadRequest < ::ActiveResource::ClientError; end

# ActiveResource::Base is the main class for mapping RESTful resources as models in a Rails application.
#
# For an outline of what Active Resource is capable of, see its {README}[link:files/activeresource/README_rdoc.html].
#
# == Automated mapping
#
# Active Resource objects represent your RESTful resources as manipulatable Ruby objects. To map resources
# to Ruby objects, Active Resource only needs a class name that corresponds to the resource name (e.g., the class
# Person maps to the resources people, very similarly to Active Record) and a +site+ value, which holds the
# URI of the resources.
#
#   class Person < ActiveResource::Base
#     self.site = "https://api.people.com"
#   end
#
# Now the Person class is mapped to RESTful resources located at <tt>https://api.people.com/people/</tt>, and
# you can now use Active Resource's life cycle methods to manipulate resources. In the case where you already have
# an existing model with the same name as the desired RESTful resource you can set the +element_name+ value.
#
#   class PersonResource < ActiveResource::Base
#     self.site = "https://api.people.com"
#     self.element_name = "person"
#   end
#
# If your Active Resource object is required to use an HTTP proxy you can set the +proxy+ value which holds a URI.
#
#   class PersonResource < ActiveResource::Base
#     self.site = "https://api.people.com"
#     self.proxy = "https://user:password@proxy.people.com:8080"
#   end
#
#
# == Life cycle methods
#
# Active Resource exposes methods for creating, finding, updating, and deleting resources
# from REST web services.
#
#   ryan = Person.new(:first => 'Ryan', :last => 'Daigle')
#   ryan.save                # => true
#   ryan.id                  # => 2
#   Person.exists?(ryan.id)  # => true
#   ryan.exists?             # => true
#
#   ryan = Person.find(1)
#   # Resource holding our newly created Person object
#
#   ryan.first = 'Rizzle'
#   ryan.save                # => true
#
#   ryan.destroy             # => true
#
# As you can see, these are very similar to Active Record's life cycle methods for database records.
# You can read more about each of these methods in their respective documentation.
#
# === Custom REST methods
#
# Since simple CRUD/life cycle methods can't accomplish every task, Active Resource also supports
# defining your own custom REST methods. To invoke them, Active Resource provides the <tt>get</tt>,
# <tt>post</tt>, <tt>put</tt> and <tt>delete</tt> methods where you can specify a custom REST method
# name to invoke.
#
#   # POST to the custom 'register' REST method, i.e. POST /people/new/register.json.
#   Person.new(:name => 'Ryan').post(:register)
#   # => { :id => 1, :name => 'Ryan', :position => 'Clerk' }
#
#   # PUT an update by invoking the 'promote' REST method, i.e. PUT /people/1/promote.json?position=Manager.
#   Person.find(1).put(:promote, :position => 'Manager')
#   # => { :id => 1, :name => 'Ryan', :position => 'Manager' }
#
#   # GET all the positions available, i.e. GET /people/positions.json.
#   Person.get(:positions)
#   # => [{:name => 'Manager'}, {:name => 'Clerk'}]
#
#   # DELETE to 'fire' a person, i.e. DELETE /people/1/fire.json.
#   Person.find(1).delete(:fire)
#
# For more information on using custom REST methods, see the
# ActiveResource::CustomMethods documentation.
#
# == Validations
#
# You can validate resources client side by overriding validation methods in the base class.
#
#   class Person < ActiveResource::Base
#      self.site = "https://api.people.com"
#      protected
#        def validate
#          errors.add("last", "has invalid characters") unless last =~ /[a-zA-Z]*/
#        end
#   end
#
# See the ActiveResource::Validations documentation for more information.
#
# == Authentication
#
# Many REST APIs require authentication. The HTTP spec describes two ways to
# make requests with a username and password (see RFC 2617).
#
# Basic authentication simply sends a username and password along with HTTP
# requests. These sensitive credentials are sent unencrypted, visible to
# any onlooker, so this scheme should only be used with SSL.
#
# Digest authentication sends a cryptographic hash of the username, password,
# HTTP method, URI, and a single-use secret key provided by the server.
# Sensitive credentials aren't visible to onlookers, so digest authentication
# doesn't require SSL. However, this doesn't mean the connection is secure!
# Just the username and password.
#
# Another common way to authenticate requests is via bearer tokens, a scheme
# originally created as part of the OAuth 2.0 protocol (see RFC 6750).
#
# Bearer authentication sends a token, that can maybe only be a short string
# of hexadecimal characters or even a JWT Token. Similarly to the Basic
# authentication, this scheme should only be used with SSL.
#
# (You really, really want to use SSL. There's little reason not to.)
#
# === Picking an authentication scheme
#
# Basic authentication is the default. To switch to digest or bearer token authentication,
# set +auth_type+ to +:digest+ or +:bearer+:
#
#    class Person < ActiveResource::Base
#      self.auth_type = :digest
#    end
#
# === Setting the username and password
#
# Set +user+ and +password+ on the class, or include them in the +site+ URL.
#
#    class Person < ActiveResource::Base
#      # Set user and password directly:
#      self.user = "ryan"
#      self.password = "password"
#
#      # Or include them in the site:
#      self.site = "https://ryan:password@api.people.com"
#    end
#
# === Setting the bearer token
#
# Set +bearer_token+ on the class:
#
#    class Person < ActiveResource::Base
#      # Set bearer token directly:
#      self.auth_type = :bearer
#      self.bearer_token = "my-bearer-token"
#    end
#
# === Certificate Authentication
#
# You can also authenticate using an X509 certificate. <tt>See ssl_options=</tt> for all options.
#
#    class Person < ActiveResource::Base
#      self.site = "https://secure.api.people.com/"
#
#      File.open(pem_file_path, 'rb') do |pem_file|
#        self.ssl_options = {
#          cert:        OpenSSL::X509::Certificate.new(pem_file),
#          key:         OpenSSL::PKey::RSA.new(pem_file),
#          ca_path:     "/path/to/OpenSSL/formatted/CA_Certs",
#          verify_mode: OpenSSL::SSL::VERIFY_PEER }
#      end
#    end
#
#
# == Errors & Validation
#
# Error handling and validation is handled in much the same manner as you're used to seeing in
# Active Record. Both the response code in the HTTP response and the body of the response are used to
# indicate that an error occurred.
#
# === Resource errors
#
# When a GET is requested for a resource that does not exist, the HTTP <tt>404</tt> (Resource Not Found)
# response code will be returned from the server which will raise an ActiveResource::ResourceNotFound
# exception.
#
#   # GET https://api.people.com/people/999.json
#   ryan = Person.find(999) # 404, raises ActiveResource::ResourceNotFound
#
#
# <tt>404</tt> is just one of the HTTP error response codes that Active Resource will handle with its own exception. The
# following HTTP response codes will also result in these exceptions:
#
# * 200..399 - Valid response. No exceptions, other than these redirects:
# * 301, 302, 303, 307 - ActiveResource::Redirection
# * 400 - ActiveResource::BadRequest
# * 401 - ActiveResource::UnauthorizedAccess
# * 403 - ActiveResource::ForbiddenAccess
# * 404 - ActiveResource::ResourceNotFound
# * 405 - ActiveResource::MethodNotAllowed
# * 409 - ActiveResource::ResourceConflict
# * 410 - ActiveResource::ResourceGone
# * 412 - ActiveResource::PreconditionFailed
# * 422 - ActiveResource::ResourceInvalid (rescued by save as validation errors)
# * 429 - ActiveResource::TooManyRequests
# * 401..499 - ActiveResource::ClientError
# * 500..599 - ActiveResource::ServerError
# * Other - ActiveResource::ConnectionError
#
# These custom exceptions allow you to deal with resource errors more naturally and with more precision
# rather than returning a general HTTP error. For example:
#
#   begin
#     ryan = Person.find(my_id)
#   rescue ActiveResource::ResourceNotFound
#     redirect_to :action => 'not_found'
#   rescue ActiveResource::ResourceConflict, ActiveResource::ResourceInvalid
#     redirect_to :action => 'new'
#   end
#
# When a GET is requested for a nested resource and you don't provide the prefix_param
# an ActiveResource::MissingPrefixParam will be raised.
#
#  class Comment < ActiveResource::Base
#    self.site = "https://someip.com/posts/:post_id"
#  end
#
#  Comment.find(1)
#  # => ActiveResource::MissingPrefixParam: post_id prefix_option is missing
#
# === Validation errors
#
# Active Resource supports validations on resources and will return errors if any of these validations fail
# (e.g., "First name can not be blank" and so on). These types of errors are denoted in the response by
# a response code of <tt>422</tt> and an JSON or XML representation of the validation errors. The save operation will
# then fail (with a <tt>false</tt> return value) and the validation errors can be accessed on the resource in question.
#
#   ryan = Person.find(1)
#   ryan.first # => ''
#   ryan.save  # => false
#
#   # When
#   # PUT https://api.people.com/people/1.xml
#   # or
#   # PUT https://api.people.com/people/1.json
#   # is requested with invalid values, the response is:
#   #
#   # Response (422):
#   # <errors><error>First cannot be empty</error></errors>
#   # or
#   # {"errors":{"first":["cannot be empty"]}}
#   #
#
#   ryan.errors.invalid?(:first)  # => true
#   ryan.errors.full_messages     # => ['First cannot be empty']
#
# For backwards-compatibility with older endpoints, the following formats are also supported in JSON responses:
#
#   # {"errors":['First cannot be empty']}
#   #   This was the required format for previous versions of ActiveResource
#   # {"first":["cannot be empty"]}
#   #   This was the default format produced by respond_with in ActionController <3.2.1
#
# Parsing either of these formats will result in a deprecation warning.
#
# Learn more about Active Resource's validation features in the ActiveResource::Validations documentation.
#
# === Timeouts
#
# Active Resource relies on HTTP to access RESTful APIs and as such is inherently susceptible to slow or
# unresponsive servers. In such cases, your Active Resource method calls could \timeout. You can control the
# amount of time before Active Resource times out with the +timeout+ variable.
#
#   class Person < ActiveResource::Base
#     self.site = "https://api.people.com"
#     self.timeout = 5
#   end
#
# This sets the +timeout+ to 5 seconds. You can adjust the +timeout+ to a value suitable for the RESTful API
# you are accessing. It is recommended to set this to a reasonably low value to allow your Active Resource
# clients (especially if you are using Active Resource in a Rails application) to fail-fast (see
# http://en.wikipedia.org/wiki/Fail-fast) rather than cause cascading failures that could incapacitate your
# server.
#
# When a \timeout occurs, an ActiveResource::TimeoutError is raised. You should rescue from
# ActiveResource::TimeoutError in your Active Resource method calls.
#
# Internally, Active Resource relies on Ruby's Net::HTTP library to make HTTP requests. Setting +timeout+
# sets the <tt>read_timeout</tt> of the internal Net::HTTP instance to the same value. The default
# <tt>read_timeout</tt> is 60 seconds on most Ruby implementations.
#
# Active Resource also supports distinct +open_timeout+ (time to connect) and +read_timeout+ (how long to
# wait for an upstream response). This is inline with supported +Net::HTTP+ timeout configuration and allows
# for finer control of client timeouts depending on context.
#
#   class Person < ActiveResource::Base
#     self.site = "https://api.people.com"
#     self.open_timeout = 2
#     self.read_timeout = 10
#   end
#
# source://activeresource//lib/active_resource/base.rb#319
class ActiveResource::Base
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveResource::Validations
  include ::ActiveResource::CustomMethods
  include ::ActiveResource::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::Conversion
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serializers::Xml
  include ::ActiveResource::Reflection
  extend ::ThreadsafeAttributes
  extend ::ActiveModel::Naming
  extend ::ActiveResource::Associations
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveResource::CustomMethods::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveResource::Reflection::ClassMethods

  # Constructor method for \new resources; the optional +attributes+ parameter takes a \hash
  # of attributes for the \new resource.
  #
  # ==== Examples
  #   my_course = Course.new
  #   my_course.name = "Western Civilization"
  #   my_course.lecturer = "Don Trotter"
  #   my_course.save
  #
  #   my_other_course = Course.new(:name => "Philosophy: Reason and Being", :lecturer => "Ralph Cling")
  #   my_other_course.save
  #
  # @return [Base] a new instance of Base
  #
  # source://activeresource//lib/active_resource/base.rb#1213
  def initialize(attributes = T.unsafe(nil), persisted = T.unsafe(nil)); end

  # Test for equality. Resource are equal if and only if +other+ is the same object or
  # is an instance of the same class, is not <tt>new?</tt>, and has the same +id+.
  #
  # ==== Examples
  #   ryan = Person.create(:name => 'Ryan')
  #   jamie = Person.create(:name => 'Jamie')
  #
  #   ryan == jamie
  #   # => false (Different name attribute and id)
  #
  #   ryan_again = Person.new(:name => 'Ryan')
  #   ryan == ryan_again
  #   # => false (ryan_again is new?)
  #
  #   ryans_clone = Person.create(:name => 'Ryan')
  #   ryan == ryans_clone
  #   # => false (Different id attributes)
  #
  #   ryans_twin = Person.find(ryan.id)
  #   ryan == ryans_twin
  #   # => true
  #
  # source://activeresource//lib/active_resource/base.rb#1318
  def ==(other); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
  def __callbacks?; end

  # source://activeresource//lib/active_resource/base.rb#331
  def _collection_parser; end

  # source://activeresource//lib/active_resource/base.rb#331
  def _collection_parser=(_arg0); end

  # source://activeresource//lib/active_resource/base.rb#331
  def _collection_parser?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _create_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _destroy_callbacks; end

  # source://activeresource//lib/active_resource/base.rb#330
  def _format; end

  # source://activeresource//lib/active_resource/base.rb#330
  def _format=(_arg0); end

  # source://activeresource//lib/active_resource/base.rb#330
  def _format?; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_create_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_destroy_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_save_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_update_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_validate_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#928
  def _run_validation_callbacks(&block); end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _save_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _update_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _validate_callbacks; end

  # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#940
  def _validation_callbacks; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
  def _validators; end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
  def _validators?; end

  # source://activeresource//lib/active_resource/base.rb#1184
  def attributes; end

  # source://activeresource//lib/active_resource/base.rb#1184
  def attributes=(_arg0); end

  # Returns a \clone of the resource that hasn't been assigned an +id+ yet and
  # is treated as a \new resource.
  #
  #   ryan = Person.find(1)
  #   not_ryan = ryan.clone
  #   not_ryan.new?  # => true
  #
  # Any active resource member attributes will NOT be cloned, though all other
  # attributes are. This is to prevent the conflict between any +prefix_options+
  # that refer to the original parent resource and the newly cloned parent
  # resource that does not exist.
  #
  #   ryan = Person.find(1)
  #   ryan.address = StreetAddress.find(1, :person_id => ryan.id)
  #   ryan.hash = {:not => "an ARes instance"}
  #
  #   not_ryan = ryan.clone
  #   not_ryan.new?            # => true
  #   not_ryan.address         # => NoMethodError
  #   not_ryan.hash            # => {:not => "an ARes instance"}
  #
  # source://activeresource//lib/active_resource/base.rb#1240
  def clone; end

  # source://activeresource//lib/active_resource/base.rb#335
  def connection_class; end

  # source://activeresource//lib/active_resource/base.rb#335
  def connection_class=(_arg0); end

  # source://activeresource//lib/active_resource/base.rb#335
  def connection_class?; end

  # Deletes the resource from the remote service.
  #
  # ==== Examples
  #   my_id = 3
  #   my_person = Person.find(my_id)
  #   my_person.destroy
  #   Person.find(my_id) # 404 (Resource Not Found)
  #
  #   new_person = Person.create(:name => 'James')
  #   new_id = new_person.id # => 7
  #   new_person.destroy
  #   Person.find(new_id) # 404 (Resource Not Found)
  #
  # source://activeresource//lib/active_resource/base.rb#1400
  def destroy; end

  # Duplicates the current resource without saving it.
  #
  # ==== Examples
  #   my_invoice = Invoice.create(:customer => 'That Company')
  #   next_invoice = my_invoice.dup
  #   next_invoice.new? # => true
  #
  #   next_invoice.save
  #   next_invoice == my_invoice # => false (different id attributes)
  #
  #   my_invoice.customer   # => That Company
  #   next_invoice.customer # => That Company
  #
  # source://activeresource//lib/active_resource/base.rb#1345
  def dup; end

  # Returns the serialized string representation of the resource in the configured
  # serialization format specified in ActiveResource::Base.format. The options
  # applicable depend on the configured encoding format.
  #
  # source://activeresource//lib/active_resource/base.rb#1429
  def encode(options = T.unsafe(nil)); end

  # Tests for equality (delegates to ==).
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1323
  def eql?(other); end

  # Evaluates to <tt>true</tt> if this resource is not <tt>new?</tt> and is
  # found on the remote service. Using this method, you can check for
  # resources that may have been deleted between the object's instantiation
  # and actions on it.
  #
  # ==== Examples
  #   Person.create(:name => 'Theodore Roosevelt')
  #   that_guy = Person.find(:first)
  #   that_guy.exists? # => true
  #
  #   that_lady = Person.new(:name => 'Paul Bean')
  #   that_lady.exists? # => false
  #
  #   guys_id = that_guy.id
  #   Person.delete(guys_id)
  #   that_guy.exists? # => false
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1422
  def exists?; end

  # Delegates to id in order to allow two resources of the same type and \id to work with something like:
  #   [(a = Person.find 1), (b = Person.find 2)] & [(c = Person.find 1), (d = Person.find 4)] # => [a]
  #
  # source://activeresource//lib/active_resource/base.rb#1329
  def hash; end

  # Gets the <tt>\id</tt> attribute of the resource.
  #
  # source://activeresource//lib/active_resource/base.rb#1287
  def id; end

  # Sets the <tt>\id</tt> attribute of the resource.
  #
  # source://activeresource//lib/active_resource/base.rb#1292
  def id=(id); end

  # source://activeresource//lib/active_resource/base.rb#332
  def include_format_in_path; end

  # source://activeresource//lib/active_resource/base.rb#332
  def include_format_in_path=(_arg0); end

  # source://activeresource//lib/active_resource/base.rb#332
  def include_format_in_path?; end

  # source://activemodel/7.0.4.3/lib/active_model/serializers/json.rb#15
  def include_root_in_json; end

  # source://activemodel/7.0.4.3/lib/active_model/serializers/json.rb#15
  def include_root_in_json?; end

  # This is a list of known attributes for this resource. Either
  # gathered from the provided <tt>schema</tt>, or from the attributes
  # set on this instance after it has been fetched from the remote system.
  #
  # source://activeresource//lib/active_resource/base.rb#1197
  def known_attributes; end

  # A method to manually load attributes from a \hash. Recursively loads collections of
  # resources. This method is called in +initialize+ and +create+ when a \hash of attributes
  # is provided.
  #
  # ==== Examples
  #   my_attrs = {:name => 'J&J Textiles', :industry => 'Cloth and textiles'}
  #   my_attrs = {:name => 'Marty', :colors => ["red", "green", "blue"]}
  #
  #   the_supplier = Supplier.find(:first)
  #   the_supplier.name # => 'J&M Textiles'
  #   the_supplier.load(my_attrs)
  #   the_supplier.name('J&J Textiles')
  #
  #   # These two calls are the same as Supplier.new(my_attrs)
  #   my_supplier = Supplier.new
  #   my_supplier.load(my_attrs)
  #
  #   # These three calls are the same as Supplier.create(my_attrs)
  #   your_supplier = Supplier.new
  #   your_supplier.load(my_attrs)
  #   your_supplier.save
  #
  # source://activeresource//lib/active_resource/base.rb#1469
  def load(attributes, remove_root = T.unsafe(nil), persisted = T.unsafe(nil)); end

  # :singleton-method:
  # The logger for diagnosing and tracing Active Resource calls.
  #
  # source://activeresource//lib/active_resource/base.rb#323
  def logger; end

  # source://activemodel/7.0.4.3/lib/active_model/naming.rb#244
  def model_name(*_arg0, **_arg1, &_arg2); end

  # Returns +true+ if this object hasn't yet been saved, otherwise, returns +false+.
  #
  # ==== Examples
  #   not_new = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  #   not_new.new? # => false
  #
  #   is_new = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  #   is_new.new? # => true
  #
  #   is_new.save
  #   is_new.new? # => false
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1265
  def new?; end

  # Returns +true+ if this object hasn't yet been saved, otherwise, returns +false+.
  #
  # ==== Examples
  #   not_new = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  #   not_new.new? # => false
  #
  #   is_new = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  #   is_new.new? # => true
  #
  #   is_new.save
  #   is_new.new? # => false
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1265
  def new_record?; end

  # Returns +true+ if this object has been saved, otherwise returns +false+.
  #
  # ==== Examples
  #   persisted = Computer.create(:brand => 'Apple', :make => 'MacBook', :vendor => 'MacMall')
  #   persisted.persisted? # => true
  #
  #   not_persisted = Computer.new(:brand => 'IBM', :make => 'Thinkpad', :vendor => 'IBM')
  #   not_persisted.persisted? # => false
  #
  #   not_persisted.save
  #   not_persisted.persisted? # => true
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1282
  def persisted?; end

  # source://activeresource//lib/active_resource/base.rb#1185
  def prefix_options; end

  # source://activeresource//lib/active_resource/base.rb#1185
  def prefix_options=(_arg0); end

  # source://activeresource//lib/active_resource/base.rb#1565
  def read_attribute_for_serialization(n); end

  # source://activeresource//lib/active_resource/reflection.rb#16
  def reflections; end

  # source://activeresource//lib/active_resource/reflection.rb#16
  def reflections=(_arg0); end

  # source://activeresource//lib/active_resource/reflection.rb#16
  def reflections?; end

  # A method to \reload the attributes of this object from the remote web service.
  #
  # ==== Examples
  #   my_branch = Branch.find(:first)
  #   my_branch.name # => "Wislon Raod"
  #
  #   # Another client fixes the typo...
  #
  #   my_branch.name # => "Wislon Raod"
  #   my_branch.reload
  #   my_branch.name # => "Wilson Road"
  #
  # source://activeresource//lib/active_resource/base.rb#1444
  def reload; end

  # For checking <tt>respond_to?</tt> without searching the attributes (which is faster).
  def respond_to_without_attributes?(*_arg0); end

  # Saves (+POST+) or \updates (+PUT+) a resource. Delegates to +create+ if the object is \new,
  # +update+ if it exists. If the response to the \save includes a body, it will be assumed that this body
  # is Json for the final object as it looked after the \save (which would include attributes like +created_at+
  # that weren't part of the original submit).
  #
  # ==== Examples
  #   my_company = Company.new(:name => 'RoleModel Software', :owner => 'Ken Auer', :size => 2)
  #   my_company.new? # => true
  #   my_company.save # sends POST /companies/ (create)
  #
  #   my_company.new? # => false
  #   my_company.size = 10
  #   my_company.save # sends PUT /companies/1 (update)
  #
  # source://activeresource//lib/active_resource/validations.rb#111
  def save(options = T.unsafe(nil)); end

  # Saves the resource.
  #
  # If the resource is new, it is created via +POST+, otherwise the
  # existing resource is updated via +PUT+.
  #
  # With <tt>save!</tt> validations always run. If any of them fail
  # ActiveResource::ResourceInvalid gets raised, and nothing is POSTed to
  # the remote system.
  # See ActiveResource::Validations for more information.
  #
  # There's a series of callbacks associated with <tt>save!</tt>. If any
  # of the <tt>before_*</tt> callbacks return +false+ the action is
  # cancelled and <tt>save!</tt> raises ActiveResource::ResourceInvalid.
  #
  # source://activeresource//lib/active_resource/base.rb#1384
  def save!; end

  # source://activeresource//lib/active_resource/base.rb#1365
  def save_without_validation; end

  # If no schema has been defined for the class (see
  # <tt>ActiveResource::schema=</tt>), the default automatic schema is
  # generated from the current instance's attributes
  #
  # source://activeresource//lib/active_resource/base.rb#1190
  def schema; end

  # source://activeresource//lib/active_resource/base.rb#1557
  def to_json(options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/base.rb#1561
  def to_xml(options = T.unsafe(nil)); end

  # Updates a single attribute and then saves the object.
  #
  # Note: <tt>Unlike ActiveRecord::Base.update_attribute</tt>, this method <b>is</b>
  # subject to normal validation routines as an update sends the whole body
  # of the resource in the request. (See Validations).
  #
  # As such, this method is equivalent to calling update_attributes with a single attribute/value pair.
  #
  # If the saving fails because of a connection or remote service error, an
  # exception will be raised. If saving fails because the resource is
  # invalid then <tt>false</tt> will be returned.
  #
  # source://activeresource//lib/active_resource/base.rb#1517
  def update_attribute(name, value); end

  # Updates this resource with all the attributes from the passed-in Hash
  # and requests that the record be saved.
  #
  # If the saving fails because of a connection or remote service error, an
  # exception will be raised. If saving fails because the resource is
  # invalid then <tt>false</tt> will be returned.
  #
  # Note: Though this request can be made with a partial set of the
  # resource's attributes, the full body of the request will still be sent
  # in the save request to the remote service.
  #
  # source://activeresource//lib/active_resource/base.rb#1532
  def update_attributes(attributes); end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#48
  def validation_context; end

  protected

  # source://activeresource//lib/active_resource/base.rb#1623
  def collection_path(options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/base.rb#1574
  def connection(refresh = T.unsafe(nil)); end

  # Create (i.e., \save to the remote service) the \new resource.
  #
  # source://activeresource//lib/active_resource/base.rb#1588
  def create; end

  # source://activeresource//lib/active_resource/base.rb#1611
  def element_path(options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/base.rb#1615
  def element_url(options = T.unsafe(nil)); end

  # Takes a response from a typical create post and pulls the ID out
  #
  # source://activeresource//lib/active_resource/base.rb#1607
  def id_from_response(response); end

  # source://activeresource//lib/active_resource/base.rb#1597
  def load_attributes_from_response(response); end

  # source://activeresource//lib/active_resource/base.rb#1619
  def new_element_path; end

  # Update the resource on the remote service.
  #
  # source://activeresource//lib/active_resource/base.rb#1579
  def update; end

  private

  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1680
  def const_valid?(*const_args); end

  # Create and return a class definition for a resource inside the current resource
  #
  # source://activeresource//lib/active_resource/base.rb#1688
  def create_resource_for(resource_name); end

  # Tries to find a resource for a given name; if it fails, then the resource is created
  #
  # source://activeresource//lib/active_resource/base.rb#1655
  def find_or_create_resource_for(name); end

  # Tries to find a resource for a given collection name; if it fails, then the resource is created
  #
  # source://activeresource//lib/active_resource/base.rb#1634
  def find_or_create_resource_for_collection(name); end

  # Tries to find a resource in a non empty list of nested modules
  # if it fails, then the resource is created
  #
  # source://activeresource//lib/active_resource/base.rb#1641
  def find_or_create_resource_in_modules(resource_name, module_names); end

  # source://activeresource//lib/active_resource/base.rb#1701
  def method_missing(method_symbol, *arguments); end

  # A method to determine if an object responds to a message (e.g., a method call). In Active Resource, a Person object with a
  # +name+ attribute can answer <tt>true</tt> to <tt>my_person.respond_to?(:name)</tt>, <tt>my_person.respond_to?(:name=)</tt>, and
  # <tt>my_person.respond_to?(:name?)</tt>.
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1542
  def respond_to_missing?(method, include_priv = T.unsafe(nil)); end

  # Determine whether the response is allowed to have a body per HTTP 1.1 spec section 4.4.1
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/base.rb#1629
  def response_code_allows_body?(c); end

  # source://activeresource//lib/active_resource/base.rb#1697
  def split_options(options = T.unsafe(nil)); end

  # source://activemodel/7.0.4.3/lib/active_model/validations.rb#48
  def validation_context=(_arg0); end

  class << self
    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#68
    def __callbacks?; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _bearer_token; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _bearer_token=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _bearer_token_defined?; end

    # source://activeresource//lib/active_resource/base.rb#331
    def _collection_parser; end

    # source://activeresource//lib/active_resource/base.rb#331
    def _collection_parser=(value); end

    # source://activeresource//lib/active_resource/base.rb#331
    def _collection_parser?; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _connection; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _connection=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _connection_defined?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _create_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _create_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _destroy_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _destroy_callbacks=(value); end

    # source://activeresource//lib/active_resource/base.rb#330
    def _format; end

    # source://activeresource//lib/active_resource/base.rb#330
    def _format=(value); end

    # source://activeresource//lib/active_resource/base.rb#330
    def _format?; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _headers; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _headers=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _headers_defined?; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _password; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _password=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _password_defined?; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _proxy; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _proxy=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _proxy_defined?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _save_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _save_callbacks=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _site; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _site=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _site_defined?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _update_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _update_callbacks=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#15
    def _user; end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#19
    def _user=(value); end

    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#23
    def _user_defined?; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _validate_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _validate_callbacks=(value); end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#932
    def _validation_callbacks; end

    # source://activesupport/7.0.4.3/lib/active_support/callbacks.rb#936
    def _validation_callbacks=(value); end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators; end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators=(value); end

    # source://activemodel/7.0.4.3/lib/active_model/validations.rb#52
    def _validators?; end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_create(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_destroy(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_save(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#144
    def after_update(*args, **options, &block); end

    # This is an alias for find(:all). You can pass in all the same
    # arguments to this method as you can to <tt>find(:all)</tt>
    #
    # source://activeresource//lib/active_resource/base.rb#1039
    def all(*args); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#137
    def around_create(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#137
    def around_destroy(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#137
    def around_save(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#137
    def around_update(*args, **options, &block); end

    # source://activeresource//lib/active_resource/base.rb#562
    def auth_type; end

    # source://activeresource//lib/active_resource/base.rb#568
    def auth_type=(auth_type); end

    # Gets the \bearer_token for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#547
    def bearer_token; end

    # Sets the \bearer_token for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#557
    def bearer_token=(bearer_token); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#130
    def before_create(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#130
    def before_destroy(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#130
    def before_save(*args, **options, &block); end

    # source://activemodel/7.0.4.3/lib/active_model/callbacks.rb#130
    def before_update(*args, **options, &block); end

    # Builds a new, unsaved record using the default values from the remote server so
    # that it can be used with RESTful forms.
    #
    # ==== Options
    # * +attributes+ - A hash that overrides the default values from the server.
    #
    # Returns the new resource instance.
    #
    # source://activeresource//lib/active_resource/base.rb#899
    def build(attributes = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/base.rb#714
    def collection_name; end

    # Sets the attribute collection_name
    #
    # @param value the value to set the attribute collection_name to.
    #
    # source://activeresource//lib/active_resource/base.rb#712
    def collection_name=(_arg0); end

    # source://activeresource//lib/active_resource/base.rb#601
    def collection_parser; end

    # Sets the parser to use when a collection is returned.  The parser must be Enumerable.
    #
    # source://activeresource//lib/active_resource/base.rb#596
    def collection_parser=(parser_instance); end

    # Gets the collection path for the REST resources. If the +query_options+ parameter is omitted, Rails
    # will split from the +prefix_options+.
    #
    # ==== Options
    # * +prefix_options+ - A hash to add a prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    #   would yield a URL like <tt>/accounts/19/purchases.json</tt>).
    # * +query_options+ - A hash to add items to the query string for the request.
    #
    # ==== Examples
    #   Post.collection_path
    #   # => /posts.json
    #
    #   Comment.collection_path(:post_id => 5)
    #   # => /posts/5/comments.json
    #
    #   Comment.collection_path(:post_id => 5, :active => 1)
    #   # => /posts/5/comments.json?active=1
    #
    #   Comment.collection_path({:post_id => 5}, {:active => 1})
    #   # => /posts/5/comments.json?active=1
    #
    # source://activeresource//lib/active_resource/base.rb#883
    def collection_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # An instance of ActiveResource::Connection that is the base \connection to the remote service.
    # The +refresh+ parameter toggles whether or not the \connection is refreshed at every request
    # or not (defaults to <tt>false</tt>).
    #
    # source://activeresource//lib/active_resource/base.rb#678
    def connection(refresh = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/base.rb#335
    def connection_class; end

    # source://activeresource//lib/active_resource/base.rb#335
    def connection_class=(value); end

    # source://activeresource//lib/active_resource/base.rb#335
    def connection_class?; end

    # Creates a new resource instance and makes a request to the remote service
    # that it be saved, making it equivalent to the following simultaneous calls:
    #
    #   ryan = Person.new(:first => 'ryan')
    #   ryan.save
    #
    # Returns the newly created resource. If a failure has occurred an
    # exception will be raised (see <tt>save</tt>). If the resource is invalid and
    # has not been saved then <tt>valid?</tt> will return <tt>false</tt>,
    # while <tt>new?</tt> will still return <tt>true</tt>.
    #
    # ==== Examples
    #   Person.create(:name => 'Jeremy', :email => 'myname@nospam.com', :enabled => true)
    #   my_person = Person.find(:first)
    #   my_person.email # => myname@nospam.com
    #
    #   dhh = Person.create(:name => 'David', :email => 'dhh@nospam.com', :enabled => true)
    #   dhh.valid? # => true
    #   dhh.new?   # => false
    #
    #   # We'll assume that there's a validation that requires the name attribute
    #   that_guy = Person.create(:name => '', :email => 'thatguy@nospam.com', :enabled => true)
    #   that_guy.valid? # => false
    #   that_guy.new?   # => true
    #
    # source://activeresource//lib/active_resource/base.rb#928
    def create(attributes = T.unsafe(nil)); end

    # Creates a new resource (just like <tt>create</tt>) and makes a request to the
    # remote service that it be saved, but runs validations and raises
    # <tt>ActiveResource::ResourceInvalid</tt>, making it equivalent to the following
    # simultaneous calls:
    #
    #   ryan = Person.new(:first => 'ryan')
    #   ryan.save!
    #
    # source://activeresource//lib/active_resource/base.rb#939
    def create!(attributes = T.unsafe(nil)); end

    # Deletes the resources with the ID in the +id+ parameter.
    #
    # ==== Options
    # All options specify \prefix and query parameters.
    #
    # ==== Examples
    #   Event.delete(2) # sends DELETE /events/2
    #
    #   Event.create(:name => 'Free Concert', :location => 'Community Center')
    #   my_event = Event.find(:first) # let's assume this is event with ID 7
    #   Event.delete(my_event.id) # sends DELETE /events/7
    #
    #   # Let's assume a request to events/5/cancel.json
    #   Event.delete(params[:id]) # sends DELETE /events/5
    #
    # source://activeresource//lib/active_resource/custom_methods.rb#76
    def delete(custom_method_name, options = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/base.rb#708
    def element_name; end

    # Sets the attribute element_name
    #
    # @param value the value to set the attribute element_name to.
    #
    # source://activeresource//lib/active_resource/base.rb#706
    def element_name=(_arg0); end

    # Gets the element path for the given ID in +id+. If the +query_options+ parameter is omitted, Rails
    # will split from the \prefix options.
    #
    # ==== Options
    # +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>/accounts/19/purchases.json</tt>).
    #
    # +query_options+ - A \hash to add items to the query string for the request.
    #
    # ==== Examples
    #   Post.element_path(1)
    #   # => /posts/1.json
    #
    #   class Comment < ActiveResource::Base
    #     self.site = "https://37s.sunrise.com/posts/:post_id"
    #   end
    #
    #   Comment.element_path(1, :post_id => 5)
    #   # => /posts/5/comments/1.json
    #
    #   Comment.element_path(1, :post_id => 5, :active => 1)
    #   # => /posts/5/comments/1.json?active=1
    #
    #   Comment.element_path(1, {:post_id => 5}, {:active => 1})
    #   # => /posts/5/comments/1.json?active=1
    #
    # source://activeresource//lib/active_resource/base.rb#805
    def element_path(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # Gets the element url for the given ID in +id+. If the +query_options+ parameter is omitted, Rails
    # will split from the \prefix options.
    #
    # ==== Options
    # +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>https://37s.sunrise.com/accounts/19/purchases.json</tt>).
    #
    # +query_options+ - A \hash to add items to the query string for the request.
    #
    # ==== Examples
    #   Post.element_url(1)
    #   # => https://37s.sunrise.com/posts/1.json
    #
    #   class Comment < ActiveResource::Base
    #     self.site = "https://37s.sunrise.com/posts/:post_id"
    #   end
    #
    #   Comment.element_url(1, :post_id => 5)
    #   # => https://37s.sunrise.com/posts/5/comments/1.json
    #
    #   Comment.element_url(1, :post_id => 5, :active => 1)
    #   # => https://37s.sunrise.com/posts/5/comments/1.json?active=1
    #
    #   Comment.element_url(1, {:post_id => 5}, {:active => 1})
    #   # => https://37s.sunrise.com/posts/5/comments/1.json?active=1
    #
    # source://activeresource//lib/active_resource/base.rb#838
    def element_url(id, prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

    # Asserts the existence of a resource, returning <tt>true</tt> if the resource is found.
    #
    # ==== Examples
    #   Note.create(:title => 'Hello, world.', :body => 'Nothing more for now...')
    #   Note.exists?(1) # => true
    #
    #   Note.exists(1349) # => false
    #
    # @return [Boolean]
    #
    # source://activeresource//lib/active_resource/base.rb#1074
    def exists?(id, options = T.unsafe(nil)); end

    # Core method for finding resources. Used similarly to Active Record's +find+ method.
    #
    # ==== Arguments
    # The first argument is considered to be the scope of the query. That is, how many
    # resources are returned from the request. It can be one of the following.
    #
    # * <tt>:one</tt> - Returns a single resource.
    # * <tt>:first</tt> - Returns the first resource found.
    # * <tt>:last</tt> - Returns the last resource found.
    # * <tt>:all</tt> - Returns every resource that matches the request.
    #
    # ==== Options
    #
    # * <tt>:from</tt> - Sets the path or custom method that resources will be fetched from.
    # * <tt>:params</tt> - Sets query and \prefix (nested URL) parameters.
    #
    # ==== Examples
    #   Person.find(1)
    #   # => GET /people/1.json
    #
    #   Person.find(:all)
    #   # => GET /people.json
    #
    #   Person.find(:all, :params => { :title => "CEO" })
    #   # => GET /people.json?title=CEO
    #
    #   Person.find(:first, :from => :managers)
    #   # => GET /people/managers.json
    #
    #   Person.find(:last, :from => :managers)
    #   # => GET /people/managers.json
    #
    #   Person.find(:all, :from => "/companies/1/people.json")
    #   # => GET /companies/1/people.json
    #
    #   Person.find(:one, :from => :leader)
    #   # => GET /people/leader.json
    #
    #   Person.find(:all, :from => :developers, :params => { :language => 'ruby' })
    #   # => GET /people/developers.json?language=ruby
    #
    #   Person.find(:one, :from => "/companies/1/manager.json")
    #   # => GET /companies/1/manager.json
    #
    #   StreetAddress.find(1, :params => { :person_id => 1 })
    #   # => GET /people/1/street_addresses/1.json
    #
    # == Failure or missing data
    # A failure to find the requested object raises a ResourceNotFound
    # exception if the find was called with an id.
    # With any other scope, find returns nil when no data is returned.
    #
    #   Person.find(1)
    #   # => raises ResourceNotFound
    #
    #   Person.find(:all)
    #   Person.find(:first)
    #   Person.find(:last)
    #   # => nil
    #
    # source://activeresource//lib/active_resource/base.rb#1002
    def find(*arguments); end

    # A convenience wrapper for <tt>find(:first, *args)</tt>. You can pass
    # in all the same arguments to this method as you can to
    # <tt>find(:first)</tt>.
    #
    # source://activeresource//lib/active_resource/base.rb#1026
    def first(*args); end

    # Returns the current format, default is ActiveResource::Formats::JsonFormat.
    #
    # source://activeresource//lib/active_resource/base.rb#591
    def format; end

    # Sets the format that attributes are sent and received in from a mime type reference:
    #
    #   Person.format = :json
    #   Person.find(1) # => GET /people/1.json
    #
    #   Person.format = ActiveResource::Formats::XmlFormat
    #   Person.find(1) # => GET /people/1.xml
    #
    # Default format is <tt>:json</tt>.
    #
    # source://activeresource//lib/active_resource/base.rb#582
    def format=(mime_type_reference_or_format); end

    # source://activeresource//lib/active_resource/base.rb#775
    def format_extension; end

    # source://activeresource//lib/active_resource/custom_methods.rb#58
    def get(custom_method_name, options = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/base.rb#698
    def headers; end

    # source://activeresource//lib/active_resource/base.rb#332
    def include_format_in_path; end

    # source://activeresource//lib/active_resource/base.rb#332
    def include_format_in_path=(value); end

    # source://activeresource//lib/active_resource/base.rb#332
    def include_format_in_path?; end

    # source://activemodel/7.0.4.3/lib/active_model/serializers/json.rb#15
    def include_root_in_json; end

    # source://activemodel/7.0.4.3/lib/active_model/serializers/json.rb#15
    def include_root_in_json=(value); end

    # source://activemodel/7.0.4.3/lib/active_model/serializers/json.rb#15
    def include_root_in_json?; end

    # Returns the list of known attributes for this resource, gathered
    # from the provided <tt>schema</tt>
    # Attributes that are known will cause your resource to return 'true'
    # when <tt>respond_to?</tt> is called on them. A known attribute will
    # return nil if not set (rather than <tt>MethodNotFound</tt>); thus
    # known attributes can be used with <tt>validates_presence_of</tt>
    # without a getter-method.
    #
    # source://activeresource//lib/active_resource/base.rb#456
    def known_attributes; end

    # A convenience wrapper for <tt>find(:last, *args)</tt>. You can pass
    # in all the same arguments to this method as you can to
    # <tt>find(:last)</tt>.
    #
    # source://activeresource//lib/active_resource/base.rb#1033
    def last(*args); end

    # source://activeresource//lib/active_resource/base.rb#323
    def logger; end

    # source://activeresource//lib/active_resource/base.rb#325
    def logger=(logger); end

    # Gets the new element path for REST resources.
    #
    # ==== Options
    # * +prefix_options+ - A hash to add a prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
    # would yield a URL like <tt>/accounts/19/purchases/new.json</tt>).
    #
    # ==== Examples
    #   Post.new_element_path
    #   # => /posts/new.json
    #
    #   class Comment < ActiveResource::Base
    #     self.site = "https://37s.sunrise.com/posts/:post_id"
    #   end
    #
    #   Comment.collection_path(:post_id => 5)
    #   # => /posts/5/comments/new.json
    #
    # source://activeresource//lib/active_resource/base.rb#858
    def new_element_path(prefix_options = T.unsafe(nil)); end

    # Gets the number of seconds after which connection attempts to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#633
    def open_timeout; end

    # Sets the number of seconds after which connection attempts to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#612
    def open_timeout=(timeout); end

    # source://activeresource//lib/active_resource/base.rb#1063
    def orig_delete(id, options = T.unsafe(nil)); end

    # Gets the \password for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#531
    def password; end

    # Sets the \password for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#541
    def password=(password); end

    # source://activeresource//lib/active_resource/custom_methods.rb#68
    def patch(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/custom_methods.rb#64
    def post(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

    # Gets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>)
    # This method is regenerated at runtime based on what the \prefix is set to.
    #
    # source://activeresource//lib/active_resource/base.rb#734
    def prefix(options = T.unsafe(nil)); end

    # Sets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>).
    # Default value is <tt>site.path</tt>.
    #
    # source://activeresource//lib/active_resource/base.rb#751
    def prefix=(value = T.unsafe(nil)); end

    # An attribute reader for the source string for the resource path \prefix. This
    # method is regenerated at runtime based on what the \prefix is set to.
    #
    # source://activeresource//lib/active_resource/base.rb#744
    def prefix_source; end

    # source://activeresource//lib/active_resource/base.rb#720
    def primary_key; end

    # Sets the attribute primary_key
    #
    # @param value the value to set the attribute primary_key to.
    #
    # source://activeresource//lib/active_resource/base.rb#718
    def primary_key=(_arg0); end

    # Gets the \proxy variable if a proxy is required
    #
    # source://activeresource//lib/active_resource/base.rb#499
    def proxy; end

    # Sets the URI of the http proxy to the value in the +proxy+ argument.
    #
    # source://activeresource//lib/active_resource/base.rb#509
    def proxy=(proxy); end

    # source://activeresource//lib/active_resource/custom_methods.rb#72
    def put(custom_method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

    # Gets the number of seconds after which reads to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#642
    def read_timeout; end

    # Sets the number of seconds after which reads to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#618
    def read_timeout=(timeout); end

    # source://activeresource//lib/active_resource/reflection.rb#16
    def reflections; end

    # source://activeresource//lib/active_resource/reflection.rb#16
    def reflections=(value); end

    # source://activeresource//lib/active_resource/reflection.rb#16
    def reflections?; end

    # Creates a schema for this resource - setting the attributes that are
    # known prior to fetching an instance from the remote system.
    #
    # The schema helps define the set of <tt>known_attributes</tt> of the
    # current resource.
    #
    # There is no need to specify a schema for your Active Resource. If
    # you do not, the <tt>known_attributes</tt> will be guessed from the
    # instance attributes returned when an instance is fetched from the
    # remote system.
    #
    # example:
    #   class Person < ActiveResource::Base
    #     schema do
    #       # define each attribute separately
    #       attribute 'name', :string
    #
    #       # or use the convenience methods and pass >=1 attribute names
    #       string  'eye_color', 'hair_color'
    #       integer 'age'
    #       float   'height', 'weight'
    #
    #       # unsupported types should be left as strings
    #       # overload the accessor methods if you need to convert them
    #       attribute 'created_at', 'string'
    #     end
    #   end
    #
    #   p = Person.new
    #   p.respond_to? :name   # => true
    #   p.respond_to? :age    # => true
    #   p.name                # => nil
    #   p.age                 # => nil
    #
    #   j = Person.find_by_name('John')
    #   <person><name>John</name><age>34</age><num_children>3</num_children></person>
    #   j.respond_to? :name   # => true
    #   j.respond_to? :age    # => true
    #   j.name                # => 'John'
    #   j.age                 # => '34'  # note this is a string!
    #   j.num_children        # => '3'  # note this is a string!
    #
    #   p.num_children        # => NoMethodError
    #
    # Attribute-types must be one of: <tt>string, text, integer, float, decimal, datetime, timestamp, time, date, binary, boolean</tt>
    #
    # Note: at present the attribute-type doesn't do anything, but stay
    # tuned...
    # Shortly it will also *cast* the value of the returned attribute.
    # ie:
    # j.age                 # => 34   # cast to an integer
    # j.weight              # => '65' # still a string!
    #
    # source://activeresource//lib/active_resource/base.rb#395
    def schema(&block); end

    # Alternative, direct way to specify a <tt>schema</tt> for this
    # Resource. <tt>schema</tt> is more flexible, but this is quick
    # for a very simple schema.
    #
    # Pass the schema as a hash with the keys being the attribute-names
    # and the value being one of the accepted attribute types (as defined
    # in <tt>schema</tt>)
    #
    # example:
    #
    #   class Person < ActiveResource::Base
    #     self.schema = {'name' => :string, 'age' => :integer }
    #   end
    #
    # The keys/values can be strings or symbols. They will be converted to
    # strings.
    #
    # @raise [ArgumentError]
    #
    # source://activeresource//lib/active_resource/base.rb#434
    def schema=(the_schema); end

    # Sets the attribute collection_name
    #
    # @param value the value to set the attribute collection_name to.
    #
    # source://activeresource//lib/active_resource/base.rb#712
    def set_collection_name(_arg0); end

    # Sets the attribute element_name
    #
    # @param value the value to set the attribute element_name to.
    #
    # source://activeresource//lib/active_resource/base.rb#706
    def set_element_name(_arg0); end

    # Sets the \prefix for a resource's nested URL (e.g., <tt>prefix/collectionname/1.json</tt>).
    # Default value is <tt>site.path</tt>.
    #
    # source://activeresource//lib/active_resource/base.rb#751
    def set_prefix(value = T.unsafe(nil)); end

    # Sets the attribute primary_key
    #
    # @param value the value to set the attribute primary_key to.
    #
    # source://activeresource//lib/active_resource/base.rb#718
    def set_primary_key(_arg0); end

    # Gets the URI of the REST resources to map for this class. The site variable is required for
    # Active Resource's mapping to work.
    #
    # source://activeresource//lib/active_resource/base.rb#462
    def site; end

    # Sets the URI of the REST resources to map for this class to the value in the +site+ argument.
    # The site variable is required for Active Resource's mapping to work.
    #
    # source://activeresource//lib/active_resource/base.rb#487
    def site=(site); end

    # Returns the SSL options hash.
    #
    # source://activeresource//lib/active_resource/base.rb#667
    def ssl_options; end

    # Options that will get applied to an SSL connection.
    #
    # * <tt>:key</tt> - An OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
    # * <tt>:cert</tt> - An OpenSSL::X509::Certificate object as client certificate
    # * <tt>:ca_file</tt> - Path to a CA certification file in PEM format. The file can contain several CA certificates.
    # * <tt>:ca_path</tt> - Path of a CA certification directory containing certifications in PEM format.
    # * <tt>:verify_mode</tt> - Flags for server the certification verification at beginning of SSL/TLS session. (OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER is acceptable)
    # * <tt>:verify_callback</tt> - The verify callback for the server certification verification.
    # * <tt>:verify_depth</tt> - The maximum depth for the certificate chain verification.
    # * <tt>:cert_store</tt> - OpenSSL::X509::Store to verify peer certificate.
    # * <tt>:ssl_timeout</tt> -The SSL timeout in seconds.
    #
    # source://activeresource//lib/active_resource/base.rb#661
    def ssl_options=(options); end

    # Gets the number of seconds after which requests to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#624
    def timeout; end

    # Sets the number of seconds after which requests to the REST API should time out.
    #
    # source://activeresource//lib/active_resource/base.rb#606
    def timeout=(timeout); end

    # Gets the \user for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#515
    def user; end

    # Sets the \user for REST HTTP authentication.
    #
    # source://activeresource//lib/active_resource/base.rb#525
    def user=(user); end

    # @raise [ArgumentError]
    #
    # source://activeresource//lib/active_resource/base.rb#1043
    def where(clauses = T.unsafe(nil)); end

    private

    # source://activeresource//lib/active_resource/base.rb#1087
    def check_prefix_options(prefix_options); end

    # Accepts a URI and creates the proxy URI from that.
    #
    # source://activeresource//lib/active_resource/base.rb#1156
    def create_proxy_uri_from(proxy); end

    # Accepts a URI and creates the site URI from that.
    #
    # source://activeresource//lib/active_resource/base.rb#1151
    def create_site_uri_from(site); end

    # Find every resource
    #
    # source://activeresource//lib/active_resource/base.rb#1095
    def find_every(options); end

    # Find a single resource from a one-off URL
    #
    # source://activeresource//lib/active_resource/base.rb#1119
    def find_one(options); end

    # Find a single resource from the default URL
    #
    # source://activeresource//lib/active_resource/base.rb#1130
    def find_single(scope, options); end

    # source://activeresource//lib/active_resource/base.rb#1136
    def instantiate_collection(collection, original_params = T.unsafe(nil), prefix_options = T.unsafe(nil)); end

    # source://activeresource//lib/active_resource/base.rb#1143
    def instantiate_record(record, prefix_options = T.unsafe(nil)); end

    # contains a set of the current prefix parameters.
    #
    # source://activeresource//lib/active_resource/base.rb#1161
    def prefix_parameters; end

    # Builds the query string for the request.
    #
    # source://activeresource//lib/active_resource/base.rb#1166
    def query_string(options); end

    # split an option hash into two hashes, one containing the prefix options,
    # and the other containing the leftovers.
    #
    # source://activeresource//lib/active_resource/base.rb#1172
    def split_options(options = T.unsafe(nil)); end
  end
end

# source://activeresource//lib/active_resource/callbacks.rb#6
module ActiveResource::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://activeresource//lib/active_resource/callbacks.rb#9
ActiveResource::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

# 4xx Client Error
#
# source://activeresource//lib/active_resource/exceptions.rb#49
class ActiveResource::ClientError < ::ActiveResource::ConnectionError; end

# source://activeresource//lib/active_resource/collection.rb#7
class ActiveResource::Collection
  include ::Enumerable

  # ActiveResource::Collection is a wrapper to handle parsing index responses that
  # do not directly map to Rails conventions.
  #
  # You can define a custom class that inherits from ActiveResource::Collection
  # in order to to set the elements instance.
  #
  # GET /posts.json delivers following response body:
  #   {
  #     posts: [
  #       {
  #         title: "ActiveResource now has associations",
  #         body: "Lorem Ipsum"
  #       },
  #       {...}
  #     ],
  #     next_page: "/posts.json?page=2"
  #   }
  #
  # A Post class can be setup to handle it with:
  #
  #   class Post < ActiveResource::Base
  #     self.site = "http://example.com"
  #     self.collection_parser = PostCollection
  #   end
  #
  # And the collection parser:
  #
  #   class PostCollection < ActiveResource::Collection
  #     attr_accessor :next_page
  #     def initialize(parsed = {})
  #       @elements = parsed['posts']
  #       @next_page = parsed['next_page']
  #     end
  #   end
  #
  # The result from a find method that returns multiple entries will now be a
  # PostParser instance.  ActiveResource::Collection includes Enumerable and
  # instances can be iterated over just like an array.
  #    @posts = Post.find(:all) # => PostCollection:xxx
  #    @posts.next_page         # => "/posts.json?page=2"
  #    @posts.map(&:id)         # =>[1, 3, 5 ...]
  #
  # The initialize method will receive the ActiveResource::Formats parsed result
  # and should set @elements.
  #
  # @return [Collection] a new instance of Collection
  #
  # source://activeresource//lib/active_resource/collection.rb#59
  def initialize(elements = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def &(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def *(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def +(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def -(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def <<(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def <=>(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def ==(arg); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def [](*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def []=(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def all?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def any?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def append(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def as_json(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def assoc(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def at(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def blank?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def bsearch(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def bsearch_index(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def clear(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def collect(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#67
  def collect!; end

  # source://activeresource//lib/active_resource/collection.rb#10
  def combination(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def compact(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def compact!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def compact_blank!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def concat(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def count(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def cycle(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def deconstruct(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def deep_dup(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def delete(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def delete_at(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def delete_if(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def difference(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def dig(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def drop(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def drop_while(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def each(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def each_index(*_arg0, **_arg1, &_arg2); end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def elements; end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def elements=(_arg0); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def empty?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def eql?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def excluding(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def extract!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def extract_options!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def fetch(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def fifth(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def fill(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def filter(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def filter!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def find_index(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def first(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#76
  def first_or_create(attributes = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/collection.rb#82
  def first_or_initialize(attributes = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def flatten(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def flatten!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def forty_two(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def fourth(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def from(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def hash(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def in_groups(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def in_groups_of(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def include?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def including(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def index(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def inquiry(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def insert(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def inspect(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def intersect?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def intersection(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def join(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def keep_if(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def last(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def length(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def map(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#67
  def map!; end

  # source://activeresource//lib/active_resource/collection.rb#10
  def max(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def min(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def minmax(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def none?(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def one?(*_arg0, **_arg1, &_arg2); end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def original_params; end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def original_params=(_arg0); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def pack(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def permutation(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def place(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def pop(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def prepend(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def pretty_print(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def pretty_print_cycle(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def product(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def push(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def rassoc(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def reject(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def reject!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def repeated_combination(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def repeated_permutation(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def replace(*_arg0, **_arg1, &_arg2); end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def resource_class; end

  # The array of actual elements returned by index actions
  #
  # source://activeresource//lib/active_resource/collection.rb#13
  def resource_class=(_arg0); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def reverse(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def reverse!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def reverse_each(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def rindex(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def rotate(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def rotate!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def sample(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def second(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def second_to_last(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def select(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def select!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def shelljoin(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def shift(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def shuffle(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def shuffle!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def size(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def slice(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def slice!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def sort(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def sort!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def sort_by!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def split(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def sum(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def take(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def take_while(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def third(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def third_to_last(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#63
  def to_a; end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_ary(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_default_s(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_formatted_s(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_fs(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_h(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_param(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_query(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_s(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_sentence(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_xml(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def to_yaml(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def transpose(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def union(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def uniq(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def uniq!(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def unshift(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def values_at(*_arg0, **_arg1, &_arg2); end

  # @raise [ArgumentError]
  #
  # source://activeresource//lib/active_resource/collection.rb#88
  def where(clauses = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def without(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def zip(*_arg0, **_arg1, &_arg2); end

  # source://activeresource//lib/active_resource/collection.rb#10
  def |(*_arg0, **_arg1, &_arg2); end
end

# source://activeresource//lib/active_resource/collection.rb#8
ActiveResource::Collection::SELF_DEFINE_METHODS = T.let(T.unsafe(nil), Array)

# Class to handle connections to remote web services.
# This class is used by ActiveResource::Base to interface with REST
# services.
#
# source://activeresource//lib/active_resource/connection.rb#14
class ActiveResource::Connection
  # The +site+ parameter is required and will set the +site+
  # attribute to the URI for the remote resource service.
  #
  # @raise [ArgumentError]
  # @return [Connection] a new instance of Connection
  #
  # source://activeresource//lib/active_resource/connection.rb#34
  def initialize(site, format = T.unsafe(nil), logger: T.unsafe(nil)); end

  # Returns the value of attribute auth_type.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def auth_type; end

  # Sets the auth type for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#65
  def auth_type=(auth_type); end

  # Returns the value of attribute bearer_token.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def bearer_token; end

  # Sets the bearer token for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#62
  def bearer_token=(_arg0); end

  # Executes a DELETE request (see HTTP protocol documentation if unfamiliar).
  # Used to delete resources.
  #
  # source://activeresource//lib/active_resource/connection.rb#89
  def delete(path, headers = T.unsafe(nil)); end

  # Returns the value of attribute format.
  #
  # source://activeresource//lib/active_resource/connection.rb#24
  def format; end

  # Sets the attribute format
  #
  # @param value the value to set the attribute format to.
  #
  # source://activeresource//lib/active_resource/connection.rb#24
  def format=(_arg0); end

  # Executes a GET request.
  # Used to get (find) resources.
  #
  # source://activeresource//lib/active_resource/connection.rb#83
  def get(path, headers = T.unsafe(nil)); end

  # Executes a HEAD request.
  # Used to obtain meta-information about resources, such as whether they exist and their size (via response headers).
  #
  # source://activeresource//lib/active_resource/connection.rb#113
  def head(path, headers = T.unsafe(nil)); end

  # Returns the value of attribute logger.
  #
  # source://activeresource//lib/active_resource/connection.rb#24
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://activeresource//lib/active_resource/connection.rb#24
  def logger=(_arg0); end

  # Returns the value of attribute open_timeout.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def open_timeout; end

  # Sets the number of seconds after which HTTP connects to the remote service should time out.
  #
  # source://activeresource//lib/active_resource/connection.rb#73
  def open_timeout=(_arg0); end

  # Returns the value of attribute password.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def password; end

  # Sets the password for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#59
  def password=(_arg0); end

  # Executes a PATCH request (see HTTP protocol documentation if unfamiliar).
  # Used to update resources.
  #
  # source://activeresource//lib/active_resource/connection.rb#95
  def patch(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Executes a POST request.
  # Used to create new resources.
  #
  # source://activeresource//lib/active_resource/connection.rb#107
  def post(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns the value of attribute proxy.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def proxy; end

  # Set the proxy for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#51
  def proxy=(proxy); end

  # Executes a PUT request (see HTTP protocol documentation if unfamiliar).
  # Used to update resources.
  #
  # source://activeresource//lib/active_resource/connection.rb#101
  def put(path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns the value of attribute read_timeout.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def read_timeout; end

  # Sets the number of seconds after which HTTP read requests to the remote service should time out.
  #
  # source://activeresource//lib/active_resource/connection.rb#76
  def read_timeout=(_arg0); end

  # Returns the value of attribute site.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def site; end

  # Set URI for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#43
  def site=(site); end

  # Returns the value of attribute ssl_options.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def ssl_options; end

  # Hash of options applied to Net::HTTP instance when +site+ protocol is 'https'.
  #
  # source://activeresource//lib/active_resource/connection.rb#79
  def ssl_options=(_arg0); end

  # Returns the value of attribute timeout.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def timeout; end

  # Sets the number of seconds after which HTTP requests to the remote service should time out.
  #
  # source://activeresource//lib/active_resource/connection.rb#70
  def timeout=(_arg0); end

  # Returns the value of attribute user.
  #
  # source://activeresource//lib/active_resource/connection.rb#23
  def user; end

  # Sets the user for remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#56
  def user=(_arg0); end

  private

  # source://activeresource//lib/active_resource/connection.rb#196
  def apply_ssl_options(http); end

  # source://activeresource//lib/active_resource/connection.rb#271
  def auth_attributes_for(uri, request_digest, params); end

  # source://activeresource//lib/active_resource/connection.rb#231
  def authorization_header(http_method, uri); end

  # Builds headers for request to remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#213
  def build_request_headers(headers, http_method, uri); end

  # source://activeresource//lib/active_resource/connection.rb#259
  def client_nonce; end

  # source://activeresource//lib/active_resource/connection.rb#184
  def configure_http(http); end

  # source://activeresource//lib/active_resource/connection.rb#208
  def default_header; end

  # source://activeresource//lib/active_resource/connection.rb#245
  def digest_auth_header(http_method, uri); end

  # source://activeresource//lib/active_resource/connection.rb#263
  def extract_params_from_response; end

  # Handles response and error codes from the remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#133
  def handle_response(response); end

  # Creates new Net::HTTP instance for communication with the
  # remote service and resources.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#349
  def http; end

  # source://activeresource//lib/active_resource/connection.rb#287
  def http_format_header(http_method); end

  # source://activeresource//lib/active_resource/http_mock.rb#358
  def http_stub; end

  # source://activeresource//lib/active_resource/connection.rb#291
  def legitimize_auth_type(auth_type); end

  # source://activeresource//lib/active_resource/connection.rb#174
  def new_http; end

  # Makes a request to the remote service.
  #
  # source://activeresource//lib/active_resource/connection.rb#119
  def request(method, path, *arguments); end

  # source://activeresource//lib/active_resource/connection.rb#217
  def response_auth_header; end

  # source://activeresource//lib/active_resource/http_mock.rb#366
  def stub_http?; end

  # source://activeresource//lib/active_resource/http_mock.rb#362
  def unstub_http?; end

  # source://activeresource//lib/active_resource/connection.rb#221
  def with_auth; end

  class << self
    # source://activeresource//lib/active_resource/connection.rb#27
    def requests; end
  end
end

# source://activeresource//lib/active_resource/connection.rb#15
ActiveResource::Connection::HTTP_FORMAT_HEADER_NAMES = T.let(T.unsafe(nil), Hash)

# source://activeresource//lib/active_resource/exceptions.rb#4
class ActiveResource::ConnectionError < ::StandardError
  # @return [ConnectionError] a new instance of ConnectionError
  #
  # source://activeresource//lib/active_resource/exceptions.rb#7
  def initialize(response, message = T.unsafe(nil)); end

  # Returns the value of attribute response.
  #
  # source://activeresource//lib/active_resource/exceptions.rb#5
  def response; end

  # source://activeresource//lib/active_resource/exceptions.rb#12
  def to_s; end
end

# A module to support custom REST methods and sub-resources, allowing you to break out
# of the "default" REST methods with your own custom resource requests. For example,
# say you use Rails to expose a REST service and configure your routes with:
#
#    map.resources :people, :new => { :register => :post },
#                           :member => { :promote => :put, :deactivate => :delete }
#                           :collection => { :active => :get }
#
# This route set creates routes for the following HTTP requests:
#
#    POST      /people/new/register.json # PeopleController.register
#    PATCH/PUT /people/1/promote.json    # PeopleController.promote with :id => 1
#    DELETE    /people/1/deactivate.json # PeopleController.deactivate with :id => 1
#    GET       /people/active.json       # PeopleController.active
#
# Using this module, Active Resource can use these custom REST methods just like the
# standard methods.
#
#   class Person < ActiveResource::Base
#     self.site = "https://37s.sunrise.com"
#   end
#
#   Person.new(:name => 'Ryan').post(:register)  # POST /people/new/register.json
#   # => { :id => 1, :name => 'Ryan' }
#
#   Person.find(1).put(:promote, :position => 'Manager') # PUT /people/1/promote.json
#   Person.find(1).delete(:deactivate) # DELETE /people/1/deactivate.json
#
#   Person.get(:active)  # GET /people/active.json
#   # => [{:id => 1, :name => 'Ryan'}, {:id => 2, :name => 'Joe'}]
#
# source://activeresource//lib/active_resource/custom_methods.rb#37
module ActiveResource::CustomMethods
  extend ::ActiveSupport::Concern

  # source://activeresource//lib/active_resource/custom_methods.rb#115
  def delete(method_name, options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/custom_methods.rb#94
  def get(method_name, options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/custom_methods.rb#107
  def patch(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/custom_methods.rb#98
  def post(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/custom_methods.rb#111
  def put(method_name, options = T.unsafe(nil), body = T.unsafe(nil)); end

  private

  # source://activeresource//lib/active_resource/custom_methods.rb#121
  def custom_method_element_url(method_name, options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/custom_methods.rb#125
  def custom_method_new_element_url(method_name, options = T.unsafe(nil)); end
end

# source://activeresource//lib/active_resource/custom_methods.rb#87
module ActiveResource::CustomMethods::ClassMethods
  # source://activeresource//lib/active_resource/custom_methods.rb#88
  def custom_method_collection_url(method_name, options = T.unsafe(nil)); end
end

# Active Resource validation is reported to and from this object, which is used by Base#save
# to determine whether the object in a valid state to be saved. See usage example in Validations.
#
# source://activeresource//lib/active_resource/validations.rb#12
class ActiveResource::Errors < ::ActiveModel::Errors
  # Grabs errors from an array of messages (like ActiveRecord::Validations).
  # The second parameter directs the errors cache to be cleared (default)
  # or not (by passing true).
  #
  # source://activeresource//lib/active_resource/validations.rb#16
  def from_array(messages, save_cache = T.unsafe(nil)); end

  # Grabs errors from a hash of attribute => array of errors elements
  # The second parameter directs the errors cache to be cleared (default)
  # or not (by passing true)
  #
  # Unrecognized attribute names will be humanized and added to the record's
  # base errors.
  #
  # source://activeresource//lib/active_resource/validations.rb#35
  def from_hash(messages, save_cache = T.unsafe(nil)); end

  # Grabs errors from a json response.
  #
  # source://activeresource//lib/active_resource/validations.rb#54
  def from_json(json, save_cache = T.unsafe(nil)); end

  # Grabs errors from an XML response.
  #
  # source://activeresource//lib/active_resource/validations.rb#74
  def from_xml(xml, save_cache = T.unsafe(nil)); end
end

# 403 Forbidden
#
# source://activeresource//lib/active_resource/exceptions.rb#61
class ActiveResource::ForbiddenAccess < ::ActiveResource::ClientError; end

# source://activeresource//lib/active_resource/formats.rb#4
module ActiveResource::Formats
  class << self
    # Lookup the format class from a mime type reference symbol. Example:
    #
    #   ActiveResource::Formats[:xml]  # => ActiveResource::Formats::XmlFormat
    #   ActiveResource::Formats[:json] # => ActiveResource::Formats::JsonFormat
    #
    # source://activeresource//lib/active_resource/formats.rb#12
    def [](mime_type_reference); end

    # source://activeresource//lib/active_resource/formats.rb#16
    def remove_root(data); end
  end
end

# source://activeresource//lib/active_resource/formats/json_format.rb#7
module ActiveResource::Formats::JsonFormat
  extend ::ActiveResource::Formats::JsonFormat

  # source://activeresource//lib/active_resource/formats/json_format.rb#22
  def decode(json); end

  # source://activeresource//lib/active_resource/formats/json_format.rb#18
  def encode(hash, options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/formats/json_format.rb#10
  def extension; end

  # source://activeresource//lib/active_resource/formats/json_format.rb#14
  def mime_type; end
end

# source://activeresource//lib/active_resource/formats/xml_format.rb#7
module ActiveResource::Formats::XmlFormat
  extend ::ActiveResource::Formats::XmlFormat

  # source://activeresource//lib/active_resource/formats/xml_format.rb#22
  def decode(xml); end

  # source://activeresource//lib/active_resource/formats/xml_format.rb#18
  def encode(hash, options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/formats/xml_format.rb#10
  def extension; end

  # source://activeresource//lib/active_resource/formats/xml_format.rb#14
  def mime_type; end
end

# One thing that has always been a pain with remote web services is testing. The HttpMock
# class makes it easy to test your Active Resource models by creating a set of mock responses to specific
# requests.
#
# To test your Active Resource model, you simply call the ActiveResource::HttpMock.respond_to
# method with an attached block. The block declares a set of URIs with expected input, and the output
# each request should return. The passed in block has any number of entries in the following generalized
# format:
#
#   mock.http_method(path, request_headers = {}, body = nil, status = 200, response_headers = {})
#
# * <tt>http_method</tt> - The HTTP method to listen for. This can be +get+, +post+, +patch+, +put+, +delete+ or
#   +head+.
# * <tt>path</tt> - A string, starting with a "/", defining the URI that is expected to be
#   called.
# * <tt>request_headers</tt> - Headers that are expected along with the request. This argument uses a
#   hash format, such as <tt>{ "Content-Type" => "application/json" }</tt>. This mock will only trigger
#   if your tests sends a request with identical headers.
# * <tt>body</tt> - The data to be returned. This should be a string of Active Resource parseable content,
#   such as Json.
# * <tt>status</tt> - The HTTP response code, as an integer, to return with the response.
# * <tt>response_headers</tt> - Headers to be returned with the response. Uses the same hash format as
#   <tt>request_headers</tt> listed above.
#
# In order for a mock to deliver its content, the incoming request must match by the <tt>http_method</tt>,
# +path+ and <tt>request_headers</tt>. If no match is found an +InvalidRequestError+ exception
# will be raised showing you what request it could not find a response for and also what requests and response
# pairs have been recorded so you can create a new mock for that request.
#
# ==== Example
#   def setup
#     @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
#     ActiveResource::HttpMock.respond_to do |mock|
#       mock.post   "/people.json",   {}, @matz, 201, "Location" => "/people/1.json"
#       mock.get    "/people/1.json", {}, @matz
#       mock.put    "/people/1.json", {}, nil, 204
#       mock.delete "/people/1.json", {}, nil, 200
#     end
#   end
#
#   def test_get_matz
#     person = Person.find(1)
#     assert_equal "Matz", person.name
#   end
#
# source://activeresource//lib/active_resource/http_mock.rb#54
class ActiveResource::HttpMock
  # @return [HttpMock] a new instance of HttpMock
  #
  # source://activeresource//lib/active_resource/http_mock.rb#270
  def initialize(site); end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def delete(path, headers); end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def get(path, headers); end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def head(path, headers); end

  # source://activeresource//lib/active_resource/http_mock.rb#274
  def inspect_responses; end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def patch(path, body, headers); end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def post(path, body, headers); end

  # source://activeresource//lib/active_resource/http_mock.rb#257
  def put(path, body, headers); end

  class << self
    # source://activeresource//lib/active_resource/http_mock.rb#205
    def delete_responses_to_replace(new_responses); end

    # Sets all ActiveResource::Connection to use HttpMock instances.
    #
    # source://activeresource//lib/active_resource/http_mock.rb#225
    def disable_net_connection!; end

    # Enables all ActiveResource::Connection instances to use real
    # Net::HTTP instance instead of a mock.
    #
    # source://activeresource//lib/active_resource/http_mock.rb#220
    def enable_net_connection!; end

    # @return [Boolean]
    #
    # source://activeresource//lib/active_resource/http_mock.rb#238
    def net_connection_disabled?; end

    # Checks if real requests can be used instead of the default mock used in tests.
    #
    # @return [Boolean]
    #
    # source://activeresource//lib/active_resource/http_mock.rb#230
    def net_connection_enabled?; end

    # Returns an array of all request objects that have been sent to the mock. You can use this to check
    # if your model actually sent an HTTP request.
    #
    # ==== Example
    #   def setup
    #     @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    #     ActiveResource::HttpMock.respond_to do |mock|
    #       mock.get "/people/1.json", {}, @matz
    #     end
    #   end
    #
    #   def test_should_request_remote_service
    #     person = Person.find(1)  # Call the remote service
    #
    #     # This request object has the same HTTP method and path as declared by the mock
    #     expected_request = ActiveResource::Request.new(:get, "/people/1.json")
    #
    #     # Assert that the mock received, and responded to, the expected request from the model
    #     assert ActiveResource::HttpMock.requests.include?(expected_request)
    #   end
    #
    # source://activeresource//lib/active_resource/http_mock.rb#103
    def requests; end

    # Deletes all logged requests and responses.
    #
    # source://activeresource//lib/active_resource/http_mock.rb#213
    def reset!; end

    # Accepts a block which declares a set of requests and responses for the HttpMock to respond to in
    # the following format:
    #
    #   mock.http_method(path, request_headers = {}, body = nil, status = 200, response_headers = {})
    #
    # === Example
    #
    #   @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    #   ActiveResource::HttpMock.respond_to do |mock|
    #     mock.post   "/people.json",   {}, @matz, 201, "Location" => "/people/1.json"
    #     mock.get    "/people/1.json", {}, @matz
    #     mock.put    "/people/1.json", {}, nil, 204
    #     mock.delete "/people/1.json", {}, nil, 200
    #   end
    #
    # Alternatively, accepts a hash of <tt>{Request => Response}</tt> pairs allowing you to generate
    # these the following format:
    #
    #   ActiveResource::Request.new(method, path, body, request_headers)
    #   ActiveResource::Response.new(body, status, response_headers)
    #
    # === Example
    #
    # Request.new(method, path, nil, request_headers)
    #
    #   @matz  = { :person => { :id => 1, :name => "Matz" } }.to_json
    #
    #   create_matz      = ActiveResource::Request.new(:post, '/people.json', @matz, {})
    #   created_response = ActiveResource::Response.new("", 201, {"Location" => "/people/1.json"})
    #   get_matz         = ActiveResource::Request.new(:get, '/people/1.json', nil)
    #   ok_response      = ActiveResource::Response.new("", 200, {})
    #
    #   pairs = {create_matz => created_response, get_matz => ok_response}
    #
    #   ActiveResource::HttpMock.respond_to(pairs)
    #
    # Note, by default, every time you call +respond_to+, any previous request and response pairs stored
    # in HttpMock will be deleted giving you a clean slate to work on.
    #
    # If you want to override this behavior, pass in +false+ as the last argument to +respond_to+
    #
    # === Example
    #
    #   ActiveResource::HttpMock.respond_to do |mock|
    #     mock.send(:get, "/people/1", {}, "JSON1")
    #   end
    #   ActiveResource::HttpMock.responses.length #=> 1
    #
    #   ActiveResource::HttpMock.respond_to(false) do |mock|
    #     mock.send(:get, "/people/2", {}, "JSON2")
    #   end
    #   ActiveResource::HttpMock.responses.length #=> 2
    #
    # This also works with passing in generated pairs of requests and responses, again, just pass in false
    # as the last argument:
    #
    # === Example
    #
    #   ActiveResource::HttpMock.respond_to do |mock|
    #     mock.send(:get, "/people/1", {}, "JSON1")
    #   end
    #   ActiveResource::HttpMock.responses.length #=> 1
    #
    #   get_matz         = ActiveResource::Request.new(:get, '/people/1.json', nil)
    #   ok_response      = ActiveResource::Response.new("", 200, {})
    #
    #   pairs = {get_matz => ok_response}
    #
    #   ActiveResource::HttpMock.respond_to(pairs, false)
    #   ActiveResource::HttpMock.responses.length #=> 2
    #
    #   # If you add a response with an existing request, it will be replaced
    #
    #   fail_response      = ActiveResource::Response.new("", 404, {})
    #   pairs = {get_matz => fail_response}
    #
    #   ActiveResource::HttpMock.respond_to(pairs, false)
    #   ActiveResource::HttpMock.responses.length #=> 2
    #
    # source://activeresource//lib/active_resource/http_mock.rb#192
    def respond_to(*args); end

    # Returns the list of requests and their mocked responses. Look up a
    # response for a request using <tt>responses.assoc(request)</tt>.
    #
    # source://activeresource//lib/active_resource/http_mock.rb#109
    def responses; end
  end
end

# source://activeresource//lib/active_resource/http_mock.rb#55
class ActiveResource::HttpMock::Responder
  # @return [Responder] a new instance of Responder
  #
  # source://activeresource//lib/active_resource/http_mock.rb#56
  def initialize(responses); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def delete(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def get(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def head(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def patch(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def post(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#65
  def put(path, request_headers = T.unsafe(nil), body = T.unsafe(nil), status = T.unsafe(nil), response_headers = T.unsafe(nil)); end

  private

  # source://activeresource//lib/active_resource/http_mock.rb#77
  def delete_duplicate_responses(request); end
end

# source://activeresource//lib/active_resource/inheriting_hash.rb#4
class ActiveResource::InheritingHash < ::Hash
  # @return [InheritingHash] a new instance of InheritingHash
  #
  # source://activeresource//lib/active_resource/inheriting_hash.rb#5
  def initialize(parent_hash = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/inheriting_hash.rb#11
  def [](key); end
end

# source://activeresource//lib/active_resource/http_mock.rb#7
class ActiveResource::InvalidRequestError < ::StandardError; end

# source://activeresource//lib/active_resource/log_subscriber.rb#4
class ActiveResource::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://activeresource//lib/active_resource/log_subscriber.rb#20
  def logger; end

  # source://activeresource//lib/active_resource/log_subscriber.rb#5
  def request(event); end
end

# 405 Method Not Allowed
#
# source://activeresource//lib/active_resource/exceptions.rb#89
class ActiveResource::MethodNotAllowed < ::ActiveResource::ClientError
  # source://activeresource//lib/active_resource/exceptions.rb#90
  def allowed_methods; end
end

# source://activeresource//lib/active_resource/exceptions.rb#45
class ActiveResource::MissingPrefixParam < ::ArgumentError; end

# 412 Precondition Failed
#
# source://activeresource//lib/active_resource/exceptions.rb#77
class ActiveResource::PreconditionFailed < ::ActiveResource::ClientError; end

# source://activeresource//lib/active_resource/railtie.rb#7
class ActiveResource::Railtie < ::Rails::Railtie; end

# 3xx Redirection
#
# source://activeresource//lib/active_resource/exceptions.rb#39
class ActiveResource::Redirection < ::ActiveResource::ConnectionError
  # source://activeresource//lib/active_resource/exceptions.rb#40
  def to_s; end
end

# = Active Resource reflection
#
# Associations in ActiveResource would be used to resolve nested attributes
# in a response with correct classes.
# Now they could be specified over Associations with the options :class_name
#
# source://activeresource//lib/active_resource/reflection.rb#12
module ActiveResource::Reflection
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveResource::Reflection::ClassMethods

  module GeneratedClassMethods
    def reflections; end
    def reflections=(value); end
    def reflections?; end
  end

  module GeneratedInstanceMethods
    def reflections; end
    def reflections=(value); end
    def reflections?; end
  end
end

# source://activeresource//lib/active_resource/reflection.rb#29
class ActiveResource::Reflection::AssociationReflection
  # @return [AssociationReflection] a new instance of AssociationReflection
  #
  # source://activeresource//lib/active_resource/reflection.rb#30
  def initialize(macro, name, options); end

  # Returns the class name for the macro.
  #
  # <tt>has_many :clients</tt> returns <tt>'Client'</tt>
  #
  # source://activeresource//lib/active_resource/reflection.rb#59
  def class_name; end

  # Returns the foreign_key for the macro.
  #
  # source://activeresource//lib/active_resource/reflection.rb#64
  def foreign_key; end

  # Returns the class for the macro.
  #
  # <tt>has_many :clients</tt> returns the Client class
  #
  # source://activeresource//lib/active_resource/reflection.rb#52
  def klass; end

  # Returns the macro type.
  #
  # <tt>has_many :clients</tt> returns <tt>:has_many</tt>
  #
  # source://activeresource//lib/active_resource/reflection.rb#42
  def macro; end

  # Returns the name of the macro.
  #
  # <tt>has_many :clients</tt> returns <tt>:clients</tt>
  #
  # source://activeresource//lib/active_resource/reflection.rb#37
  def name; end

  # Returns the hash of options used for the macro.
  #
  # <tt>has_many :clients</tt> returns +{}+
  #
  # source://activeresource//lib/active_resource/reflection.rb#47
  def options; end

  private

  # source://activeresource//lib/active_resource/reflection.rb#69
  def derive_class_name; end

  # source://activeresource//lib/active_resource/reflection.rb#73
  def derive_foreign_key; end
end

# source://activeresource//lib/active_resource/reflection.rb#20
module ActiveResource::Reflection::ClassMethods
  # source://activeresource//lib/active_resource/reflection.rb#21
  def create_reflection(macro, name, options); end
end

# source://activeresource//lib/active_resource/http_mock.rb#279
class ActiveResource::Request
  # @return [Request] a new instance of Request
  #
  # source://activeresource//lib/active_resource/http_mock.rb#282
  def initialize(method, path, body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/http_mock.rb#286
  def ==(req); end

  # Returns the value of attribute body.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def body=(_arg0); end

  # Returns the value of attribute headers.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def headers=(_arg0); end

  # Returns the value of attribute method.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def method=(_arg0); end

  # Returns the value of attribute path.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#280
  def path=(_arg0); end

  # source://activeresource//lib/active_resource/http_mock.rb#290
  def to_s; end

  private

  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/http_mock.rb#295
  def headers_match?(req); end
end

# 409 Conflict
#
# source://activeresource//lib/active_resource/exceptions.rb#69
class ActiveResource::ResourceConflict < ::ActiveResource::ClientError; end

# 410 Gone
#
# source://activeresource//lib/active_resource/exceptions.rb#73
class ActiveResource::ResourceGone < ::ActiveResource::ClientError; end

# source://activeresource//lib/active_resource/validations.rb#7
class ActiveResource::ResourceInvalid < ::ActiveResource::ClientError; end

# 404 Not Found
#
# source://activeresource//lib/active_resource/exceptions.rb#65
class ActiveResource::ResourceNotFound < ::ActiveResource::ClientError; end

# source://activeresource//lib/active_resource/http_mock.rb#306
class ActiveResource::Response
  # @return [Response] a new instance of Response
  #
  # source://activeresource//lib/active_resource/http_mock.rb#309
  def initialize(body, message = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns true if the other is a Response with an equal body, equal message
  # and equal headers. Otherwise it returns false.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#337
  def ==(other); end

  # source://activeresource//lib/active_resource/http_mock.rb#327
  def [](key); end

  # source://activeresource//lib/active_resource/http_mock.rb#331
  def []=(key, value); end

  # Returns the value of attribute body.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def body=(_arg0); end

  # Returns the value of attribute code.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def code; end

  # Sets the attribute code
  #
  # @param value the value to set the attribute code to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def code=(_arg0); end

  # Returns the value of attribute headers.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def headers=(_arg0); end

  # Returns the value of attribute message.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://activeresource//lib/active_resource/http_mock.rb#307
  def message=(_arg0); end

  # Returns true if code is 2xx,
  # false otherwise.
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/http_mock.rb#323
  def success?; end
end

# Raised when a OpenSSL::SSL::SSLError occurs.
#
# source://activeresource//lib/active_resource/exceptions.rb#31
class ActiveResource::SSLError < ::ActiveResource::ConnectionError
  # @return [SSLError] a new instance of SSLError
  #
  # source://activeresource//lib/active_resource/exceptions.rb#32
  def initialize(message); end

  # source://activeresource//lib/active_resource/exceptions.rb#35
  def to_s; end
end

# source://activeresource//lib/active_resource/schema.rb#4
class ActiveResource::Schema
  # The internals of an Active Resource Schema are very simple -
  # unlike an Active Record TableDefinition (on which it is based).
  # It provides a set of convenience methods for people to define their
  # schema using the syntax:
  #  schema do
  #    string :foo
  #    integer :bar
  #  end
  #
  #  The schema stores the name and type of each attribute. That is then
  #  read out by the schema method to populate the schema of the actual
  #  resource.
  #
  # @return [Schema] a new instance of Schema
  #
  # source://activeresource//lib/active_resource/schema.rb#25
  def initialize; end

  # @raise [ArgumentError]
  #
  # source://activeresource//lib/active_resource/schema.rb#29
  def attribute(name, type, options = T.unsafe(nil)); end

  # An array of attribute definitions, representing the attributes that
  # have been defined.
  #
  # source://activeresource//lib/active_resource/schema.rb#11
  def attrs; end

  # An array of attribute definitions, representing the attributes that
  # have been defined.
  #
  # source://activeresource//lib/active_resource/schema.rb#11
  def attrs=(_arg0); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def binary(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def boolean(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def date(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def datetime(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def decimal(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def float(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def integer(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def string(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def text(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def time(*args); end

  # source://activeresource//lib/active_resource/schema.rb#51
  def timestamp(*args); end
end

# attributes can be known to be one of these types. They are easy to
# cast to/from.
#
# source://activeresource//lib/active_resource/schema.rb#7
ActiveResource::Schema::KNOWN_ATTRIBUTE_TYPES = T.let(T.unsafe(nil), Array)

# 5xx Server Error
#
# source://activeresource//lib/active_resource/exceptions.rb#85
class ActiveResource::ServerError < ::ActiveResource::ConnectionError; end

# source://activeresource//lib/active_resource/singleton.rb#4
module ActiveResource::Singleton
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveResource::Singleton::ClassMethods

  # Deletes the resource from the remote service.
  #
  # ==== Examples
  #   weather = Weather.find
  #   weather.destroy
  #   Weather.find # 404 (Resource Not Found)
  #
  # source://activeresource//lib/active_resource/singleton.rb#85
  def destroy; end

  protected

  # Create (i.e. \save to the remote service) the \new resource.
  #
  # source://activeresource//lib/active_resource/singleton.rb#99
  def create; end

  # Update the resource on the remote service
  #
  # source://activeresource//lib/active_resource/singleton.rb#92
  def update; end

  private

  # source://activeresource//lib/active_resource/singleton.rb#107
  def singleton_path(options = T.unsafe(nil)); end
end

# source://activeresource//lib/active_resource/singleton.rb#7
module ActiveResource::Singleton::ClassMethods
  # Core method for finding singleton resources.
  #
  # ==== Arguments
  # Takes a single argument of options
  #
  # ==== Options
  # * <tt>:params</tt> - Sets the query and \prefix (nested URL) parameters.
  #
  # ==== Examples
  #   Weather.find
  #   # => GET /weather.json
  #
  #   Weather.find(:params => {:degrees => 'fahrenheit'})
  #   # => GET /weather.json?degrees=fahrenheit
  #
  # == Failure or missing data
  # A failure to find the requested object raises a ResourceNotFound exception.
  #
  #   Inventory.find
  #   # => raises ResourceNotFound
  #
  # source://activeresource//lib/active_resource/singleton.rb#65
  def find(options = T.unsafe(nil)); end

  # source://activeresource//lib/active_resource/singleton.rb#10
  def singleton_name; end

  # Sets the attribute singleton_name
  #
  # @param value the value to set the attribute singleton_name to.
  #
  # source://activeresource//lib/active_resource/singleton.rb#8
  def singleton_name=(_arg0); end

  # Gets the singleton path for the object.  If the +query_options+ parameter is omitted, Rails
  # will split from the \prefix options.
  #
  # ==== Options
  # * +prefix_options+ - A \hash to add a \prefix to the request for nested URLs (e.g., <tt>:account_id => 19</tt>
  # would yield a URL like <tt>/accounts/19/purchases.json</tt>).
  #
  # * +query_options+ - A \hash to add items to the query string for the request.
  #
  # ==== Examples
  #   Weather.singleton_path
  #   # => /weather.json
  #
  #   class Inventory < ActiveResource::Base
  #     self.site =   "https://37s.sunrise.com"
  #     self.prefix = "/products/:product_id/"
  #   end
  #
  #   Inventory.singleton_path(:product_id => 5)
  #   # => /products/5/inventory.json
  #
  #   Inventory.singleton_path({:product_id => 5}, {:sold => true})
  #   # => /products/5/inventory.json?sold=true
  #
  # source://activeresource//lib/active_resource/singleton.rb#38
  def singleton_path(prefix_options = T.unsafe(nil), query_options = T.unsafe(nil)); end

  private

  # Find singleton resource
  #
  # source://activeresource//lib/active_resource/singleton.rb#71
  def find_singleton(options); end
end

# Raised when a Timeout::Error occurs.
#
# source://activeresource//lib/active_resource/exceptions.rb#23
class ActiveResource::TimeoutError < ::ActiveResource::ConnectionError
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://activeresource//lib/active_resource/exceptions.rb#24
  def initialize(message); end

  # source://activeresource//lib/active_resource/exceptions.rb#27
  def to_s; end
end

# 429 Too Many Requests
#
# source://activeresource//lib/active_resource/exceptions.rb#81
class ActiveResource::TooManyRequests < ::ActiveResource::ClientError; end

# 401 Unauthorized
#
# source://activeresource//lib/active_resource/exceptions.rb#57
class ActiveResource::UnauthorizedAccess < ::ActiveResource::ClientError; end

# source://activeresource//lib/active_resource/version.rb#4
module ActiveResource::VERSION; end

# source://activeresource//lib/active_resource/version.rb#5
ActiveResource::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://activeresource//lib/active_resource/version.rb#6
ActiveResource::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://activeresource//lib/active_resource/version.rb#8
ActiveResource::VERSION::PRE = T.let(T.unsafe(nil), T.untyped)

# source://activeresource//lib/active_resource/version.rb#10
ActiveResource::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://activeresource//lib/active_resource/version.rb#7
ActiveResource::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# Module to support validation and errors with Active Resource objects. The module overrides
# Base#save to rescue ActiveResource::ResourceInvalid exceptions and parse the errors returned
# in the web service response. The module also adds an +errors+ collection that mimics the interface
# of the errors provided by ActiveModel::Errors.
#
# ==== Example
#
# Consider a Person resource on the server requiring both a +first_name+ and a +last_name+ with a
# <tt>validates_presence_of :first_name, :last_name</tt> declaration in the model:
#
#   person = Person.new(:first_name => "Jim", :last_name => "")
#   person.save                   # => false (server returns an HTTP 422 status code and errors)
#   person.valid?                 # => false
#   person.errors.empty?          # => false
#   person.errors.count           # => 1
#   person.errors.full_messages   # => ["Last name can't be empty"]
#   person.errors[:last_name]  # => ["can't be empty"]
#   person.last_name = "Halpert"
#   person.save                   # => true (and person is now saved to the remote service)
#
# source://activeresource//lib/active_resource/validations.rb#100
module ActiveResource::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations

  mixes_in_class_methods GeneratedClassMethods

  # Returns the Errors object that holds all information about attribute error messages.
  #
  # source://activeresource//lib/active_resource/validations.rb#172
  def errors; end

  # Loads the set of remote errors into the object's Errors based on the
  # content-type of the error-block received.
  #
  # source://activeresource//lib/active_resource/validations.rb#136
  def load_remote_errors(remote_errors, save_cache = T.unsafe(nil)); end

  # Validate a resource and save (POST) it to the remote web service.
  # If any local validations fail - the save (POST) will not be attempted.
  #
  # source://activeresource//lib/active_resource/validations.rb#111
  def save_with_validation(options = T.unsafe(nil)); end

  # Checks for errors on an object (i.e., is resource.errors empty?).
  #
  # Runs all the specified local validations and returns true if no errors
  # were added, otherwise false.
  # Runs local validations (eg those on your Active Resource model), and
  # also any errors returned from the remote system the last time we
  # saved.
  # Remote errors can only be cleared by trying to re-save the resource.
  #
  # ==== Examples
  #   my_person = Person.create(params[:person])
  #   my_person.valid?
  #   # => true
  #
  #   my_person.errors.add('login', 'can not be empty') if my_person.login == ''
  #   my_person.valid?
  #   # => false
  #
  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/validations.rb#163
  def valid?; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

# source://activeresource//lib/active_resource/threadsafe_attributes.rb#5
module ThreadsafeAttributes
  mixes_in_class_methods ::ThreadsafeAttributes::ClassMethods

  private

  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#31
  def get_threadsafe_attribute(name, main_thread); end

  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#53
  def get_threadsafe_attribute_by_thread(name, thread); end

  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#42
  def set_threadsafe_attribute(name, value, main_thread); end

  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#57
  def set_threadsafe_attribute_by_thread(name, value, thread); end

  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#49
  def threadsafe_attribute_defined?(name, main_thread); end

  # @return [Boolean]
  #
  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#62
  def threadsafe_attribute_defined_by_thread?(name, thread); end

  class << self
    # @private
    #
    # source://activeresource//lib/active_resource/threadsafe_attributes.rb#6
    def included(klass); end
  end
end

# source://activeresource//lib/active_resource/threadsafe_attributes.rb#10
module ThreadsafeAttributes::ClassMethods
  # source://activeresource//lib/active_resource/threadsafe_attributes.rb#11
  def threadsafe_attribute(*attrs); end
end
