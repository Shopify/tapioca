# typed: autogenerated

module Bundler
  FREEBSD = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  ORIGINAL_ENV = ::T.let(nil, ::T.untyped)
  SUDO_MUTEX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseMismatchError
  def status_code(); end
end

class Bundler::APIResponseMismatchError
end

module Bundler::BuildMetadata
end

module Bundler::BuildMetadata
  extend ::T::Sig
  def self.built_at(); end

  def self.git_commit_sha(); end

  def self.release?(); end

  def self.to_h(); end
end

class Bundler::BundlerError
end

class Bundler::BundlerError
  def self.all_errors(); end

  def self.status_code(code); end
end

class Bundler::CurrentRuby
  def jruby?(); end

  def jruby_18?(); end

  def jruby_19?(); end

  def jruby_1?(); end

  def jruby_20?(); end

  def jruby_21?(); end

  def jruby_22?(); end

  def jruby_23?(); end

  def jruby_24?(); end

  def jruby_25?(); end

  def jruby_26?(); end

  def jruby_2?(); end

  def maglev?(); end

  def maglev_18?(); end

  def maglev_19?(); end

  def maglev_1?(); end

  def maglev_20?(); end

  def maglev_21?(); end

  def maglev_22?(); end

  def maglev_23?(); end

  def maglev_24?(); end

  def maglev_25?(); end

  def maglev_26?(); end

  def maglev_2?(); end

  def mingw?(); end

  def mingw_18?(); end

  def mingw_19?(); end

  def mingw_1?(); end

  def mingw_20?(); end

  def mingw_21?(); end

  def mingw_22?(); end

  def mingw_23?(); end

  def mingw_24?(); end

  def mingw_25?(); end

  def mingw_26?(); end

  def mingw_2?(); end

  def mri?(); end

  def mri_18?(); end

  def mri_19?(); end

  def mri_1?(); end

  def mri_20?(); end

  def mri_21?(); end

  def mri_22?(); end

  def mri_23?(); end

  def mri_24?(); end

  def mri_25?(); end

  def mri_26?(); end

  def mri_2?(); end

  def mswin64?(); end

  def mswin64_18?(); end

  def mswin64_19?(); end

  def mswin64_1?(); end

  def mswin64_20?(); end

  def mswin64_21?(); end

  def mswin64_22?(); end

  def mswin64_23?(); end

  def mswin64_24?(); end

  def mswin64_25?(); end

  def mswin64_26?(); end

  def mswin64_2?(); end

  def mswin?(); end

  def mswin_18?(); end

  def mswin_19?(); end

  def mswin_1?(); end

  def mswin_20?(); end

  def mswin_21?(); end

  def mswin_22?(); end

  def mswin_23?(); end

  def mswin_24?(); end

  def mswin_25?(); end

  def mswin_26?(); end

  def mswin_2?(); end

  def on_18?(); end

  def on_19?(); end

  def on_1?(); end

  def on_20?(); end

  def on_21?(); end

  def on_22?(); end

  def on_23?(); end

  def on_24?(); end

  def on_25?(); end

  def on_26?(); end

  def on_2?(); end

  def rbx?(); end

  def rbx_18?(); end

  def rbx_19?(); end

  def rbx_1?(); end

  def rbx_20?(); end

  def rbx_21?(); end

  def rbx_22?(); end

  def rbx_23?(); end

  def rbx_24?(); end

  def rbx_25?(); end

  def rbx_26?(); end

  def rbx_2?(); end

  def ruby?(); end

  def ruby_18?(); end

  def ruby_19?(); end

  def ruby_1?(); end

  def ruby_20?(); end

  def ruby_21?(); end

  def ruby_22?(); end

  def ruby_23?(); end

  def ruby_24?(); end

  def ruby_25?(); end

  def ruby_26?(); end

  def ruby_2?(); end

  def truffleruby?(); end

  def truffleruby_18?(); end

  def truffleruby_19?(); end

  def truffleruby_1?(); end

  def truffleruby_20?(); end

  def truffleruby_21?(); end

  def truffleruby_22?(); end

  def truffleruby_23?(); end

  def truffleruby_24?(); end

  def truffleruby_25?(); end

  def truffleruby_26?(); end

  def truffleruby_2?(); end

  def x64_mingw?(); end

  def x64_mingw_18?(); end

  def x64_mingw_19?(); end

  def x64_mingw_1?(); end

  def x64_mingw_20?(); end

  def x64_mingw_21?(); end

  def x64_mingw_22?(); end

  def x64_mingw_23?(); end

  def x64_mingw_24?(); end

  def x64_mingw_25?(); end

  def x64_mingw_26?(); end

  def x64_mingw_2?(); end
  KNOWN_MAJOR_VERSIONS = ::T.let(nil, ::T.untyped)
  KNOWN_MINOR_VERSIONS = ::T.let(nil, ::T.untyped)
  KNOWN_PLATFORMS = ::T.let(nil, ::T.untyped)
end

class Bundler::CurrentRuby
end

class Bundler::CyclicDependencyError
  def status_code(); end
end

class Bundler::CyclicDependencyError
end

class Bundler::Definition
  include ::Bundler::GemHelpers
  def add_current_platform(); end

  def add_platform(platform); end

  def current_dependencies(); end

  def dependencies(); end

  def ensure_equivalent_gemfile_and_lockfile(explicit_flag=T.unsafe(nil)); end

  def find_indexed_specs(current_spec); end

  def find_resolved_spec(current_spec); end

  def gem_version_promoter(); end

  def gemfiles(); end

  def groups(); end

  def has_local_dependencies?(); end

  def has_rubygems_remotes?(); end

  def index(); end

  def initialize(lockfile, dependencies, sources, unlock, ruby_version=T.unsafe(nil), optional_groups=T.unsafe(nil), gemfiles=T.unsafe(nil)); end

  def lock(file, preserve_unknown_sections=T.unsafe(nil)); end

  def locked_bundler_version(); end

  def locked_deps(); end

  def locked_gems(); end

  def locked_ruby_version(); end

  def locked_ruby_version_object(); end

  def lockfile(); end

  def missing_specs(); end

  def missing_specs?(); end

  def new_platform?(); end

  def new_specs(); end

  def nothing_changed?(); end

  def platforms(); end

  def remove_platform(platform); end

  def removed_specs(); end

  def requested_specs(); end

  def requires(); end

  def resolve(); end

  def resolve_remotely!(); end

  def resolve_with_cache!(); end

  def ruby_version(); end

  def spec_git_paths(); end

  def specs(); end

  def specs_for(groups); end

  def to_lock(); end

  def unlocking?(); end

  def validate_platforms!(); end

  def validate_ruby!(); end

  def validate_runtime!(); end
end

class Bundler::Definition
  def self.build(gemfile, lockfile, unlock); end
end

class Bundler::DepProxy
  def ==(other); end

  def __platform(); end

  def dep(); end

  def eql?(other); end

  def initialize(dep, platform); end

  def name(); end

  def requirement(); end

  def type(); end
end

class Bundler::DepProxy
end

class Bundler::Dependency
  def autorequire(); end

  def current_env?(); end

  def current_platform?(); end

  def gem_platforms(valid_platforms); end

  def gemfile(); end

  def initialize(name, version, options=T.unsafe(nil), &blk); end

  def platforms(); end

  def should_include?(); end
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  REVERSE_PLATFORM_MAP = ::T.let(nil, ::T.untyped)
end

class Bundler::Dependency
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::DeprecatedError
  def status_code(); end
end

class Bundler::DeprecatedError
end

class Bundler::Dsl
  include ::Bundler::RubyDsl
  def dependencies(); end

  def dependencies=(dependencies); end

  def env(name); end

  def eval_gemfile(gemfile, contents=T.unsafe(nil)); end

  def gem(name, *args); end

  def gemspec(opts=T.unsafe(nil)); end

  def gemspecs(); end

  def git(uri, options=T.unsafe(nil), &blk); end

  def git_source(name, &block); end

  def github(repo, options=T.unsafe(nil)); end

  def group(*args, &blk); end

  def install_if(*args); end

  def method_missing(name, *args); end

  def path(path, options=T.unsafe(nil), &blk); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def plugin(*args); end

  def source(source, *args, &blk); end

  def to_definition(lockfile, unlock); end
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_PLATFORMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Dsl::DSLError
  def contents(); end

  def description(); end

  def dsl_path(); end

  def initialize(description, dsl_path, backtrace, contents=T.unsafe(nil)); end
end

class Bundler::Dsl::DSLError
end

class Bundler::Dsl
  def self.evaluate(gemfile, lockfile, unlock); end
end

class Bundler::EndpointSpecification
  def __swap__(spec); end

  def _local_specification(); end

  def checksum(); end

  def dependencies=(dependencies); end

  def fetch_platform(); end

  def initialize(name, version, platform, dependencies, metadata=T.unsafe(nil)); end
  ILLFORMED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def backup(); end

  def initialize(env, keys); end

  def restore(); end
  BUNDLER_KEYS = ::T.let(nil, ::T.untyped)
  BUNDLER_PREFIX = ::T.let(nil, ::T.untyped)
  INTENTIONALLY_NIL = ::T.let(nil, ::T.untyped)
end

class Bundler::EnvironmentPreserver
end

class Bundler::FeatureFlag
  def allow_bundler_dependency_conflicts?(); end

  def allow_offline_install?(); end

  def auto_clean_without_path?(); end

  def auto_config_jobs?(); end

  def bundler_10_mode?(); end

  def bundler_1_mode?(); end

  def bundler_2_mode?(); end

  def bundler_3_mode?(); end

  def bundler_4_mode?(); end

  def bundler_5_mode?(); end

  def bundler_6_mode?(); end

  def bundler_7_mode?(); end

  def bundler_8_mode?(); end

  def bundler_9_mode?(); end

  def cache_all?(); end

  def cache_command_is_package?(); end

  def console_command?(); end

  def default_cli_command(); end

  def default_install_uses_path?(); end

  def deployment_means_frozen?(); end

  def disable_multisource?(); end

  def error_on_stderr?(); end

  def forget_cli_options?(); end

  def github_https?(); end

  def global_gem_cache?(); end

  def global_path_appends_ruby_scope?(); end

  def init_gems_rb?(); end

  def initialize(bundler_version); end

  def list_command?(); end

  def lockfile_uses_separate_rubygems_sources?(); end

  def only_update_to_newer_versions?(); end

  def path_relative_to_cwd?(); end

  def plugins?(); end

  def prefer_gems_rb?(); end

  def print_only_version_number?(); end

  def setup_makes_kernel_gem_public?(); end

  def skip_default_git_sources?(); end

  def specific_platform?(); end

  def suppress_install_using_messages?(); end

  def unlock_source_unlocks_spec?(); end

  def update_requires_all_flag?(); end

  def use_gem_version_promoter_for_major_updates?(); end

  def viz_command?(); end
end

class Bundler::FeatureFlag
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  LOW_METHODS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPT_TABLE = ::T.let(nil, ::T.untyped)
end

module Bundler::FileUtils::DryRun
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  include ::Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::DryRun
  extend ::Bundler::FileUtils::DryRun
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

class Bundler::FileUtils::Entry_
  include ::Bundler::FileUtils::StreamUtils_
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
  DIRECTORY_TERM = ::T.let(nil, ::T.untyped)
  SYSCASE = ::T.let(nil, ::T.untyped)
  S_IF_DOOR = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
end

module Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::NoWrite
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  include ::Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::NoWrite
  extend ::Bundler::FileUtils::NoWrite
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils::Verbose
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils::Verbose
  extend ::Bundler::FileUtils::Verbose
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  GENERICS = ::T.let(nil, ::T.untyped)
  GENERIC_CACHE = ::T.let(nil, ::T.untyped)
end

class Bundler::GemHelpers::PlatformMatch
  def cpu_match(); end

  def cpu_match=(_); end

  def os_match(); end

  def os_match=(_); end

  def platform_version_match(); end

  def platform_version_match=(_); end
  EXACT_MATCH = ::T.let(nil, ::T.untyped)
  WORST_MATCH = ::T.let(nil, ::T.untyped)
end

class Bundler::GemHelpers::PlatformMatch
  def self.[](*_); end

  def self.cpu_match(spec_platform, user_platform); end

  def self.members(); end

  def self.os_match(spec_platform, user_platform); end

  def self.platform_version_match(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  extend ::T::Sig
  def self.generic(p); end

  def self.generic_local_platform(); end

  def self.platform_specificity_match(spec_platform, user_platform); end

  def self.select_best_platform_match(specs, platform); end
end

class Bundler::GemNotFound
  def status_code(); end
end

class Bundler::GemNotFound
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRequireError
  def initialize(orig_exception, msg); end

  def orig_exception(); end

  def status_code(); end
end

class Bundler::GemRequireError
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::GemfileError
  def status_code(); end
end

class Bundler::GemfileError
end

class Bundler::GemfileEvalError
end

class Bundler::GemfileEvalError
end

class Bundler::GemfileLockNotFound
  def status_code(); end
end

class Bundler::GemfileLockNotFound
end

class Bundler::GemfileNotFound
  def status_code(); end
end

class Bundler::GemfileNotFound
end

class Bundler::GemspecError
  def status_code(); end
end

class Bundler::GemspecError
end

class Bundler::GenericSystemCallError
  def initialize(underlying_error, message); end

  def status_code(); end

  def underlying_error(); end
end

class Bundler::GenericSystemCallError
end

class Bundler::GitError
  def status_code(); end
end

class Bundler::GitError
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::HTTPError
  def filter_uri(uri); end

  def status_code(); end
end

class Bundler::HTTPError
end

class Bundler::Index
  include ::Enumerable
  def <<(spec); end

  def ==(other); end

  def [](query, base=T.unsafe(nil)); end

  def add_source(index); end

  def all_specs(); end

  def dependencies_eql?(spec, other_spec); end

  def dependency_names(); end

  def each(&blk); end

  def empty?(); end

  def local_search(query, base=T.unsafe(nil)); end

  def search(query, base=T.unsafe(nil)); end

  def search_all(name); end

  def size(); end

  def sort_specs(specs); end

  def sources(); end

  def spec_names(); end

  def specs(); end

  def unmet_dependency_names(); end

  def unsorted_search(query, base); end

  def use(other, override_dupes=T.unsafe(nil)); end
  EMPTY_SEARCH = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

class Bundler::Index
  def self.build(); end

  def self.sort_specs(specs); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InstallError
  def status_code(); end
end

class Bundler::InstallError
end

class Bundler::InstallHookError
  def status_code(); end
end

class Bundler::InstallHookError
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::InvalidOption
  def status_code(); end
end

class Bundler::InvalidOption
end

class Bundler::LazySpecification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def __materialize__(); end

  def dependencies(); end

  def full_name(); end

  def git_version(); end

  def identifier(); end

  def initialize(name, version, platform, source=T.unsafe(nil)); end

  def name(); end

  def platform(); end

  def remote(); end

  def remote=(remote); end

  def respond_to?(*args); end

  def satisfies?(dependency); end

  def source(); end

  def source=(source); end

  def to_lock(); end

  def version(); end
end

class Bundler::LazySpecification::Identifier
  include ::Comparable
  def dependencies(); end

  def dependencies=(_); end

  def name(); end

  def name=(_); end

  def platform(); end

  def platform=(_); end

  def platform_string(); end

  def source(); end

  def source=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::LazySpecification::Identifier
  def self.[](*_); end

  def self.members(); end
end

class Bundler::LazySpecification
end

class Bundler::LockfileError
  def status_code(); end
end

class Bundler::LockfileError
end

class Bundler::LockfileParser
  def bundler_version(); end

  def dependencies(); end

  def initialize(lockfile); end

  def platforms(); end

  def ruby_version(); end

  def sources(); end

  def specs(); end

  def warn_for_outdated_bundler_version(); end
  BUNDLED = ::T.let(nil, ::T.untyped)
  DEPENDENCIES = ::T.let(nil, ::T.untyped)
  ENVIRONMENT_VERSION_SECTIONS = ::T.let(nil, ::T.untyped)
  GEM = ::T.let(nil, ::T.untyped)
  GIT = ::T.let(nil, ::T.untyped)
  KNOWN_SECTIONS = ::T.let(nil, ::T.untyped)
  NAME_VERSION = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PLATFORMS = ::T.let(nil, ::T.untyped)
  PLUGIN = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  SECTIONS_BY_VERSION_INTRODUCED = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SPECS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser
  def self.sections_in_lockfile(lockfile_contents); end

  def self.sections_to_ignore(base_version=T.unsafe(nil)); end

  def self.unknown_sections_in_lockfile(lockfile_contents); end
end

class Bundler::MarshalError
end

class Bundler::MarshalError
end

module Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def match_platform(p); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
  def self.platforms_match?(gemspec_platform, local_platform); end
end

module Bundler::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Bundler::Molinillo::CircularDependencyError
end

module Bundler::Molinillo::Compatibility
end

module Bundler::Molinillo::Compatibility
  extend ::T::Sig
  def self.flat_map(enum, &blk); end
end

module Bundler::Molinillo::Delegates
end

module Bundler::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Bundler::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates
  extend ::T::Sig
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Bundler::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Bundler::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Bundler::Molinillo::DependencyGraph::AddVertex
end

class Bundler::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Bundler::Molinillo::DependencyGraph::DeleteEdge
end

class Bundler::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Bundler::Molinillo::DependencyGraph::DetachVertexNamed
end

class Bundler::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Bundler::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Bundler::Molinillo::DependencyGraph::SetPayload
end

class Bundler::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Bundler::Molinillo::DependencyGraph::Tag
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Bundler::Molinillo::DependencyGraph::Vertex
end

class Bundler::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Bundler::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Bundler::Molinillo::DependencyState
end

class Bundler::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Bundler::Molinillo::NoSuchDependencyError
end

class Bundler::Molinillo::PossibilityState
end

class Bundler::Molinillo::PossibilityState
end

class Bundler::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Bundler::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Bundler::Molinillo::Resolver::Resolution
  include ::Bundler::Molinillo::Delegates::ResolutionState
  include ::Bundler::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Bundler::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Bundler::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Bundler::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Bundler::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution
end

class Bundler::Molinillo::Resolver
end

class Bundler::Molinillo::ResolverError
end

class Bundler::Molinillo::ResolverError
end

module Bundler::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Bundler::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Bundler::Molinillo::UI
  extend ::T::Sig
end

class Bundler::Molinillo::VersionConflict
  include ::Bundler::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Bundler::Molinillo::VersionConflict
end

module Bundler::Molinillo
  extend ::T::Sig
end

class Bundler::NoSpaceOnDeviceError
end

class Bundler::NoSpaceOnDeviceError
end

class Bundler::OperationNotSupportedError
end

class Bundler::OperationNotSupportedError
end

class Bundler::PathError
  def status_code(); end
end

class Bundler::PathError
end

class Bundler::PermissionError
  def action(); end

  def initialize(path, permission_type=T.unsafe(nil)); end

  def status_code(); end
end

class Bundler::PermissionError
end

module Bundler::Plugin
  PLUGIN_FILE_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::API
  def cache_dir(); end

  def method_missing(name, *args, &blk); end

  def tmp(*names); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::API
  def self.command(command, cls=T.unsafe(nil)); end

  def self.hook(event, &block); end

  def self.source(source, cls=T.unsafe(nil)); end
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  extend ::T::Sig
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::MalformattedPlugin
end

class Bundler::Plugin::MalformattedPlugin
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::UndefinedCommandError
end

class Bundler::Plugin::UndefinedCommandError
end

class Bundler::Plugin::UnknownSourceError
end

class Bundler::Plugin::UnknownSourceError
end

module Bundler::Plugin
  extend ::T::Sig
  def self.add_command(command, cls); end

  def self.add_hook(event, &block); end

  def self.add_source(source, cls); end

  def self.cache(); end

  def self.command?(command); end

  def self.exec_command(command, args); end

  def self.gemfile_install(gemfile=T.unsafe(nil), &inline); end

  def self.global_root(); end

  def self.hook(event, *args, &arg_blk); end

  def self.index(); end

  def self.install(names, options); end

  def self.installed?(plugin); end

  def self.local_root(); end

  def self.reset!(); end

  def self.root(); end

  def self.source(name); end

  def self.source?(name); end

  def self.source_from_lock(locked_opts); end
end

class Bundler::PluginError
  def status_code(); end
end

class Bundler::PluginError
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::ProductionError
  def status_code(); end
end

class Bundler::ProductionError
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Comparable
  def __swap__(spec); end

  def dependencies(); end

  def dependencies=(dependencies); end

  def fetch_platform(); end

  def full_name(); end

  def git_version(); end

  def initialize(name, version, platform, spec_fetcher); end

  def name(); end

  def platform(); end

  def remote(); end

  def remote=(remote); end

  def respond_to?(method, include_all=T.unsafe(nil)); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def version(); end
end

class Bundler::RemoteSpecification
end

class Bundler::Resolver
  include ::Bundler::Molinillo::UI
  include ::Bundler::Molinillo::SpecificationProvider
  def index_for(dependency); end

  def initialize(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms); end

  def relevant_sources_for_vertex(vertex); end

  def start(requirements); end
end

class Bundler::Resolver::SpecGroup
  include ::Bundler::GemHelpers
  def ==(other); end

  def activate_platform!(platform); end

  def dependencies_for_activated_platforms(); end

  def eql?(other); end

  def for?(platform); end

  def ignores_bundler_dependencies(); end

  def ignores_bundler_dependencies=(ignores_bundler_dependencies); end

  def initialize(all_specs); end

  def name(); end

  def name=(name); end

  def source(); end

  def source=(source); end

  def to_specs(); end

  def version(); end

  def version=(version); end
end

class Bundler::Resolver::SpecGroup
end

class Bundler::Resolver
  def self.platform_sort_key(platform); end

  def self.resolve(requirements, index, source_requirements=T.unsafe(nil), base=T.unsafe(nil), gem_version_promoter=T.unsafe(nil), additional_base_requirements=T.unsafe(nil), platforms=T.unsafe(nil)); end

  def self.sort_platforms(platforms); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def ruby(*ruby_version); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyVersion
  def ==(other); end

  def diff(other); end

  def engine(); end

  def engine_gem_version(); end

  def engine_versions(); end

  def exact?(); end

  def gem_version(); end

  def host(); end

  def initialize(versions, patchlevel, engine, engine_version); end

  def patchlevel(); end

  def single_version_string(); end

  def to_gem_version_with_patchlevel(); end

  def to_s(versions=T.unsafe(nil)); end

  def versions(); end

  def versions_string(versions); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Bundler::RubyVersion
  def self.from_string(string); end

  def self.system(); end
end

class Bundler::RubyVersionMismatch
  def status_code(); end
end

class Bundler::RubyVersionMismatch
end

class Bundler::RubygemsIntegration
  def backport_base_dir(); end

  def backport_cache_file(); end

  def backport_segment_generation(); end

  def backport_spec_file(); end

  def backport_yaml_initialize(); end

  def bin_path(gem, bin, ver); end

  def binstubs_call_gem?(); end

  def build(spec, skip_validation=T.unsafe(nil)); end

  def build_args(); end

  def build_args=(args); end

  def build_gem(gem_dir, spec); end

  def clear_paths(); end

  def config_map(); end

  def configuration(); end

  def download_gem(spec, uri, path); end

  def ext_lock(); end

  def fetch_all_remote_specs(remote); end

  def fetch_prerelease_specs(); end

  def fetch_specs(all, pre, &blk); end

  def gem_bindir(); end

  def gem_cache(); end

  def gem_dir(); end

  def gem_from_path(path, policy=T.unsafe(nil)); end

  def gem_path(); end

  def inflate(obj); end

  def install_with_build_args(args); end

  def load_path_insert_index(); end

  def load_plugin_files(files); end

  def load_plugins(); end

  def loaded_gem_paths(); end

  def loaded_specs(name); end

  def mark_loaded(spec); end

  def marshal_spec_dir(); end

  def method_visibility(klass, method); end

  def path(obj); end

  def path_separator(); end

  def platforms(); end

  def post_reset_hooks(); end

  def preserve_paths(); end

  def provides?(req_str); end

  def read_binary(path); end

  def redefine_method(klass, method, unbound_method=T.unsafe(nil), &block); end

  def replace_bin_path(specs, specs_by_name); end

  def replace_entrypoints(specs); end

  def replace_gem(specs, specs_by_name); end

  def replace_refresh(); end

  def repository_subdirectories(); end

  def reset(); end

  def reverse_rubygems_kernel_mixin(); end

  def ruby_engine(); end

  def security_policies(); end

  def security_policy_keys(); end

  def set_installed_by_version(spec, installed_by_version=T.unsafe(nil)); end

  def sources(); end

  def sources=(val); end

  def spec_cache_dirs(); end

  def spec_default_gem?(spec); end

  def spec_extension_dir(spec); end

  def spec_from_gem(path, policy=T.unsafe(nil)); end

  def spec_matches_for_glob(spec, glob); end

  def spec_missing_extensions?(spec, default=T.unsafe(nil)); end

  def stub_set_spec(stub, spec); end

  def stub_source_index(specs); end

  def stubs_provide_full_functionality?(); end

  def suffix_pattern(); end

  def ui=(obj); end

  def undo_replacements(); end

  def user_home(); end

  def validate(spec); end

  def version(); end

  def with_build_args(args); end
  EXT_LOCK = ::T.let(nil, ::T.untyped)
end

class Bundler::RubygemsIntegration::AlmostModern
end

class Bundler::RubygemsIntegration::AlmostModern
end

class Bundler::RubygemsIntegration::Ancient
end

class Bundler::RubygemsIntegration::Ancient
end

class Bundler::RubygemsIntegration::Future
  def all_specs(); end

  def fetch_specs(source, remote, name); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def stub_rubygems(specs); end
end

class Bundler::RubygemsIntegration::Future
end

class Bundler::RubygemsIntegration::Legacy
  def all_specs(); end

  def find_name(name); end

  def stub_rubygems(specs); end
end

class Bundler::RubygemsIntegration::Legacy
end

class Bundler::RubygemsIntegration::Modern
  def all_specs(); end

  def find_name(name); end

  def stub_rubygems(specs); end
end

class Bundler::RubygemsIntegration::Modern
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end

  def use_gemdeps(gemfile); end
end

class Bundler::RubygemsIntegration::MoreFuture
end

class Bundler::RubygemsIntegration::MoreModern
end

class Bundler::RubygemsIntegration::MoreModern
end

class Bundler::RubygemsIntegration::Transitional
end

class Bundler::RubygemsIntegration::Transitional
end

class Bundler::RubygemsIntegration
  def self.provides?(req_str); end

  def self.version(); end
end

class Bundler::Runtime
  include ::Bundler::SharedHelpers
  def cache(custom_path=T.unsafe(nil)); end

  def clean(dry_run=T.unsafe(nil)); end

  def current_dependencies(); end

  def dependencies(); end

  def gems(); end

  def initialize(root, definition); end

  def lock(opts=T.unsafe(nil)); end

  def prune_cache(cache_path); end

  def requested_specs(); end

  def require(*groups); end

  def requires(); end

  def setup(*groups); end

  def specs(); end
  REQUIRE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Runtime
end

class Bundler::SecurityError
  def status_code(); end
end

class Bundler::SecurityError
end

class Bundler::Settings
  def [](name); end

  def all(); end

  def allow_sudo?(); end

  def app_cache_path(); end

  def credentials_for(uri); end

  def gem_mirrors(); end

  def ignore_config?(); end

  def initialize(root=T.unsafe(nil)); end

  def key_for(key); end

  def local_overrides(); end

  def locations(key); end

  def mirror_for(uri); end

  def path(); end

  def pretty_values_for(exposed_key); end

  def set_command_option(key, value); end

  def set_command_option_if_given(key, value); end

  def set_global(key, value); end

  def set_local(key, value); end

  def temporary(update); end

  def validate!(); end
  ARRAY_KEYS = ::T.let(nil, ::T.untyped)
  BOOL_KEYS = ::T.let(nil, ::T.untyped)
  CONFIG_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  NORMALIZE_URI_OPTIONS_PATTERN = ::T.let(nil, ::T.untyped)
  NUMBER_KEYS = ::T.let(nil, ::T.untyped)
  PER_URI_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def append_ruby_scope(); end

  def append_ruby_scope=(_); end

  def base_path(); end

  def base_path_relative_to_pwd(); end

  def default_install_uses_path(); end

  def default_install_uses_path=(_); end

  def explicit_path(); end

  def explicit_path=(_); end

  def path(); end

  def system_path(); end

  def system_path=(_); end

  def use_system_gems?(); end

  def validate!(); end
end

class Bundler::Settings::Path
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.normalize_uri(uri); end
end

module Bundler::SharedHelpers
  def chdir(dir, &blk); end

  def const_get_safely(constant_name, namespace); end

  def default_bundle_dir(); end

  def default_gemfile(); end

  def default_lockfile(); end

  def digest(name); end

  def ensure_same_dependencies(spec, old_deps, new_deps); end

  def filesystem_access(path, action=T.unsafe(nil), &block); end

  def in_bundle?(); end

  def major_deprecation(major_version, message); end

  def md5_available?(); end

  def pretty_dependency(dep, print_source=T.unsafe(nil)); end

  def print_major_deprecations!(); end

  def pwd(); end

  def root(); end

  def set_bundle_environment(); end

  def set_env(key, value); end

  def trap(signal, override=T.unsafe(nil), &block); end

  def with_clean_git_env(&block); end

  def write_to_gemfile(gemfile_path, contents); end
end

module Bundler::SharedHelpers
  extend ::Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::Source
  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def dependency_names_to_double_check(); end

  def double_check_for(*_); end

  def extension_cache_path(spec); end

  def include?(other); end

  def path?(); end

  def unmet_deps(); end

  def version_message(spec); end
end

class Bundler::Source::Gemspec
  def as_path_source(); end

  def gemspec(); end
end

class Bundler::Source::Gemspec
end

class Bundler::Source::Git
  def allow_git_ops?(); end

  def branch(); end

  def cache_path(); end

  def extension_dir_name(); end

  def install_path(); end

  def local_override!(path); end

  def ref(); end

  def revision(); end

  def specs(*_); end

  def submodules(); end

  def unlock!(); end

  def uri(); end
end

class Bundler::Source::Git
end

class Bundler::Source::Metadata
  def ==(other); end

  def cached!(); end

  def eql?(other); end

  def install(spec, _opts=T.unsafe(nil)); end

  def options(); end

  def remote!(); end

  def specs(); end
end

class Bundler::Source::Metadata
end

class Bundler::Source::Path
  def ==(other); end

  def app_cache_dirname(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def eql?(other); end

  def expanded_original_path(); end

  def initialize(options); end

  def install(spec, options=T.unsafe(nil)); end

  def local_specs(*_); end

  def name(); end

  def name=(name); end

  def options(); end

  def original_path(); end

  def path(); end

  def remote!(); end

  def root(); end

  def root_path(); end

  def specs(); end

  def to_lock(); end

  def version(); end

  def version=(version); end
  DEFAULT_GLOB = ::T.let(nil, ::T.untyped)
end

class Bundler::Source::Path
  def self.from_lock(options); end
end

class Bundler::Source::Rubygems
  def ==(other); end

  def add_remote(source); end

  def api_fetchers(); end

  def builtin_gem?(spec); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cache_path(); end

  def cached!(); end

  def cached_built_in_gem(spec); end

  def cached_gem(spec); end

  def cached_path(spec); end

  def cached_specs(); end

  def caches(); end

  def credless_remotes(); end

  def double_check_for(unmet_dependency_names); end

  def eql?(other); end

  def equivalent_remotes?(other_remotes); end

  def fetch_gem(spec); end

  def fetch_names(fetchers, dependency_names, index, override_dupes); end

  def fetchers(); end

  def include?(o); end

  def initialize(options=T.unsafe(nil)); end

  def install(spec, opts=T.unsafe(nil)); end

  def installed?(spec); end

  def installed_specs(); end

  def loaded_from(spec); end

  def name(); end

  def normalize_uri(uri); end

  def options(); end

  def remote!(); end

  def remote_specs(); end

  def remotes(); end

  def remotes_for_spec(spec); end

  def remove_auth(remote); end

  def replace_remotes(other_remotes, allow_equivalent=T.unsafe(nil)); end

  def requires_sudo?(); end

  def rubygems_dir(); end

  def specs(); end

  def suppress_configured_credentials(remote); end

  def to_lock(); end
  API_REQUEST_LIMIT = ::T.let(nil, ::T.untyped)
  API_REQUEST_SIZE = ::T.let(nil, ::T.untyped)
end

class Bundler::Source::Rubygems
  def self.from_lock(options); end
end

class Bundler::Source
end

class Bundler::SourceList
  def add_git_source(options=T.unsafe(nil)); end

  def add_path_source(options=T.unsafe(nil)); end

  def add_plugin_source(source, options=T.unsafe(nil)); end

  def add_rubygems_remote(uri); end

  def add_rubygems_source(options=T.unsafe(nil)); end

  def all_sources(); end

  def cached!(); end

  def default_source(); end

  def get(source); end

  def git_sources(); end

  def global_rubygems_source(); end

  def global_rubygems_source=(uri); end

  def lock_sources(); end

  def metadata_source(); end

  def path_sources(); end

  def plugin_sources(); end

  def remote!(); end

  def replace_sources!(replacement_sources); end

  def rubygems_primary_remotes(); end

  def rubygems_remotes(); end

  def rubygems_sources(); end
end

class Bundler::SourceList
end

class Bundler::SpecSet
  include ::Enumerable
  include ::TSort
  def <<(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def add(*args, &block); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def find_by_name_and_platform(name, platform); end

  def for(dependencies, skip=T.unsafe(nil), check=T.unsafe(nil), match_current_platform=T.unsafe(nil), raise_on_missing=T.unsafe(nil)); end

  def initialize(specs); end

  def length(*args, &block); end

  def materialize(deps, missing_specs=T.unsafe(nil)); end

  def materialized_for_all_platforms(); end

  def merge(set); end

  def remove(*args, &block); end

  def size(*args, &block); end

  def sort!(); end

  def to_a(); end

  def to_hash(); end

  def valid_for?(deps); end

  def what_required(spec); end
end

class Bundler::SpecSet
  extend ::Forwardable
end

class Bundler::StubSpecification
  def activated(); end

  def activated=(activated); end

  def default_gem(); end

  def full_gem_path(); end

  def full_require_paths(); end

  def ignored(); end

  def ignored=(ignored); end

  def load_paths(); end

  def loaded_from(); end

  def matches_for_glob(glob); end

  def missing_extensions?(); end

  def raw_require_paths(); end

  def source=(source); end

  def stub(); end

  def stub=(stub); end

  def to_yaml(); end
end

class Bundler::StubSpecification
  def self.from_stub(stub); end
  def default_gem?; end
  def files; end
end

class Bundler::SudoNotPermittedError
  def status_code(); end
end

class Bundler::SudoNotPermittedError
end

class Bundler::TemporaryResourceError
end

class Bundler::TemporaryResourceError
end

class Bundler::ThreadCreationError
  def status_code(); end
end

class Bundler::ThreadCreationError
end

module Bundler::UI
end

class Bundler::UI::RGProxy
  def initialize(ui); end

  def say(message); end
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def add_color(string, color); end

  def ask(message); end

  def confirm(message, newline=T.unsafe(nil)); end

  def debug(message, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(message, newline=T.unsafe(nil)); end

  def info(message, newline=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(name); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(); end

  def trace(message, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(message, newline=T.unsafe(nil)); end

  def yes?(msg); end
end

class Bundler::UI::Silent
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
  def self.credential_filtered_string(str_to_filter, uri); end

  def self.credential_filtered_uri(uri_to_anonymize); end
end

class Bundler::VersionConflict
  def conflicts(); end

  def initialize(conflicts, msg=T.unsafe(nil)); end

  def status_code(); end
end

class Bundler::VersionConflict
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

class Bundler::VirtualProtocolError
  def status_code(); end
end

class Bundler::VirtualProtocolError
end

module Bundler::YAMLSerializer
  ARRAY_REGEX = ::T.let(nil, ::T.untyped)
  HASH_REGEX = ::T.let(nil, ::T.untyped)
end

module Bundler::YAMLSerializer
  extend ::T::Sig
  def self.dump(hash); end

  def self.load(str); end
end

class Bundler::YamlSyntaxError
  def initialize(orig_exception, msg); end

  def orig_exception(); end

  def status_code(); end
end

class Bundler::YamlSyntaxError
end

module Bundler
  extend ::T::Sig
  def self.app_cache(custom_path=T.unsafe(nil)); end

  def self.app_config_path(); end

  def self.bin_path(); end

  def self.bundle_path(); end

  def self.bundler_major_version(); end

  def self.clean_env(); end

  def self.clean_exec(*args); end

  def self.clean_system(*args); end

  def self.clear_gemspec_cache(); end

  def self.configure(); end

  def self.configured_bundle_path(); end

  def self.current_ruby(); end

  def self.default_bundle_dir(); end

  def self.default_gemfile(); end

  def self.default_lockfile(); end

  def self.definition(unlock=T.unsafe(nil)); end

  def self.environment(); end

  def self.feature_flag(); end

  def self.frozen_bundle?(); end

  def self.git_present?(); end

  def self.home(); end

  def self.install_path(); end

  def self.load_gemspec(file, validate=T.unsafe(nil)); end

  def self.load_gemspec_uncached(file, validate=T.unsafe(nil)); end

  def self.load_marshal(data); end

  def self.local_platform(); end

  def self.locked_gems(); end

  def self.mkdir_p(path, options=T.unsafe(nil)); end

  def self.original_env(); end

  def self.read_file(file); end

  def self.require(*groups); end

  def self.require_thor_actions(); end

  def self.requires_sudo?(); end

  def self.reset!(); end

  def self.reset_paths!(); end

  def self.reset_rubygems!(); end

  def self.rm_rf(path); end

  def self.root(); end

  def self.ruby_scope(); end

  def self.rubygems(); end

  def self.settings(); end

  def self.setup(*groups); end

  def self.specs_path(); end

  def self.sudo(str); end

  def self.system_bindir(); end

  def self.tmp(name=T.unsafe(nil)); end

  def self.tmp_home_path(login, warning); end

  def self.ui(); end

  def self.ui=(ui); end

  def self.use_system_gems?(); end

  def self.user_bundle_path(dir=T.unsafe(nil)); end

  def self.user_cache(); end

  def self.user_home(); end

  def self.which(executable); end

  def self.with_unbundled_env(); end

  def self.with_original_env(); end
end
